[
    {
        "question": "what would the 2012 shares outstanding in millions have been without the acquisition of smith international? Answer to the nearest integer.",
        "context": "schlumberger limited and subsidiaries shares of common stock ( stated in millions ) issued in treasury shares outstanding .\n\n|  | Issued | In Treasury | Shares Outstanding |\n| :--- | :--- | :--- | :--- |\n| Balance, January 1, 2010 | 1,334 | (139) | 1,195 |\n| Acquisition of Smith International, Inc. | 100 | 76 | 176 |\n| Shares sold to optionees less shares exchanged | \u2013 | 6 | 6 |\n| Shares issued under employee stock purchase plan | \u2013 | 3 | 3 |\n| Stock repurchase program | \u2013 | (27) | (27) |\n| Issued on conversions of debentures | \u2013 | 8 | 8 |\n| Balance, December 31, 2010 | 1,434 | (73) | 1,361 |\n| Shares sold to optionees less shares exchanged | \u2013 | 6 | 6 |\n| Vesting of restricted stock | \u2013 | 1 | 1 |\n| Shares issued under employee stock purchase plan | \u2013 | 3 | 3 |\n| Stock repurchase program | \u2013 | (37) | (37) |\n| Balance, December 31, 2011 | 1,434 | (100) | 1,334 |\n| Shares sold to optionees less shares exchanged | \u2013 | 4 | 4 |\n| Shares issued under employee stock purchase plan | \u2013 | 4 | 4 |\n| Stock repurchase program | \u2013 | (14) | (14) |\n| Balance, December 31, 2012 | 1,434 | (106) | 1,328 |\n\nsee the notes to consolidated financial statements .\n",
        "statistics": {
            "number_statistics": {
                "question_numbers": 0,
                "context_numbers": 41,
                "total_numbers": 41
            },
            "operator_statistics": {
                "operators": {
                    "+": 0,
                    "-": 7,
                    "*": 0,
                    "/": 0,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 7
            },
            "code_statistics": {
                "lines": 9,
                "parentheses": 0
            }
        },
        "difficulty": 4.143134726391533,
        "ground_truth": 1152,
        "source": "CodeFinQA-test-697",
        "python_solution": "shares_outstanding = 1328\nacquisition_cost = 176\nshares_sold = 0\noption_exchanged = 0\nemployee_plan = 0\nstock_repurchase = 0\nconversion_debentures = 0\nvesting_restricted_stock = 0\nanswer = shares_outstanding - acquisition_cost - shares_sold - option_exchanged - employee_plan - stock_repurchase - conversion_debentures - vesting_restricted_stock",
        "question_id": "test-2000",
        "level": "hard",
        "output": [
            "### Thinking Step-by-Step:\n\n#### Step 1: Understand the problem\nWe are tasked to determine the 2012 shares outstanding **without** the acquisition of Smith International. To do this:\n- The original shares outstanding for 2012 is 1,328.\n- The acquisition of Smith International in 2010 added 176 shares to \"Shares Outstanding\" (100 Issued + 76 from Treasury adjustment).\n\n#### Step 2: Adjust for the acquisition\nIf we are to calculate the shares outstanding **without Smith International**, we need to subtract the shares added due to this acquisition (176) from the 2012 shares outstanding (1,328).\n\n#### Step 3: Constraints\n1. Output should be rounded to the nearest integer since the question asks for \"Answer to the nearest integer.\"\n2. The calculation must respect chronological updates. Since shares outstanding are adjusted yearly, all flows that happened after 2010 should remain unaffected when removing the Smith International shares.\n\n#### Step 4: Formulate the solution\n- Starting with 2012 shares outstanding (1,328).\n- Subtract the shares directly attributable to Smith International (176).\n- Return the adjusted value.\n\nHere is the Python program:\n\n```python\ndef solution():\n    # Define variables name and value\n    shares_outstanding_2012 = 1328\n    smith_international_contribution = 176\n    \n    # Do math calculation to get the adjusted shares outstanding without Smith International\n    adjusted_shares_outstanding = shares_outstanding_2012 - smith_international_contribution\n    \n    # Return the answer rounded to the nearest integer\n    return round(adjusted_shares_outstanding)\n```\n\nThis solution adheres to all constraints and systematically adjusts for the acquisition's impact."
        ],
        "retrieval_query": "what would the 2012 shares outstanding in millions have been without the acquisition of smith international? Answer to the nearest integer.",
        "useful_functions": [],
        "usage": {
            "completion_tokens": 356,
            "prompt_tokens": 712,
            "total_tokens": 1068,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "what is the anualized return for cme group from 2012 to 2017? Answer to the nearest integer.",
        "context": "performance graph the following graph and table compares the cumulative five-year total return provided to shareholders on our class a common stock relative to the cumulative total returns of the s&p 500 index and our customized peer group . the peer group includes cboe holdings , inc. , intercontinentalexchange group , inc . and nasdaq , inc . an investment of $ 100 ( with reinvestment of all dividends ) is assumed to have been made in our class a common stock , in the peer group and the s&p 500 index on december 31 , 2012 , and its relative performance is tracked through december 31 , 2017 . comparison of 5 year cumulative total return* among cme group inc. , the s&p 500 index , and a peer group 12/12 12/13 12/14 12/15 12/16 cme group inc . s&p 500 peer group * $ 100 invested on 12/31/12 in stock or index , including reinvestment of dividends . fiscal year ending december 31 . copyright a9 2018 standard & poor 2019s , a division of s&p global . all rights reserved . the stock price performance included in this graph is not necessarily indicative of future stock price performance. .\n\n|  | 2013 | 2014 | 2015 | 2016 | 2017 |\n| :--- | :--- | :--- | :--- | :--- | :--- |\n| CME Group Inc. | $164.01 | $194.06 | $208.95 | $279.85 | $370.32 |\n| S&P 500 | 132.39 | 150.51 | 152.59 | 170.84 | 208.14 |\n| Peer Group | 176.61 | 187.48 | 219.99 | 249.31 | 323.23 |\n\nunregistered sales of equity securities during the past three years there have not been any unregistered sales by the company of equity securities. .\n",
        "statistics": {
            "number_statistics": {
                "question_numbers": 0,
                "context_numbers": 39,
                "total_numbers": 39
            },
            "operator_statistics": {
                "operators": {
                    "+": 0,
                    "-": 2,
                    "*": 1,
                    "/": 3,
                    "%": 0,
                    "**": 1
                },
                "total_operators": 7
            },
            "code_statistics": {
                "lines": 7,
                "parentheses": 4
            }
        },
        "difficulty": 4.143134726391533,
        "ground_truth": 22,
        "source": "CodeFinQA-test-718",
        "python_solution": "cme_group_return = 370.32\nsnp_return = 100\npeer_group_return = 100\ncme_group_to_snp_return_difference = cme_group_return / snp_return\npeer_group_to_snp_return_difference = peer_group_return / snp_return\nannualized_return = (cme_group_to_snp_return_difference - peer_group_to_snp_return_difference) ** (1/5) - 1\nanswer = annualized_return * 100",
        "question_id": "test-2001",
        "level": "hard",
        "output": [
            "To answer this question, we need to calculate the annualized return for CME Group from 2012 to 2017 based on the given cumulative returns table. \n\n**Key points to solve the problem:**\n1. **Initial Investment**: The initial investment is $100 at the end of 2012.\n2. **Final Value**: The final value at the end of 2017 is provided as $370.32.\n3. **Time Period**: The duration of the investment is 5 years (from 2012 to 2017).\n4. **Annualized Return Formula**: This return can be calculated using the compound annual growth rate (CAGR) formula:\n\n   \\[\n   \\text{CAGR} = \\left( \\frac{FV}{PV} \\right)^{\\frac{1}{t}} - 1\n   \\]\n\n   Where:\n   - \\(FV\\) = Final Value ($370.32)\n   - \\(PV\\) = Initial Value ($100)\n   - \\(t\\) = Time Period (5 years)\n\n5. **Constraints to Apply**:\n   - Answer should be rounded to the nearest integer.\n   - Ensure the formula adheres to the defined parameters.\n\nNow, let's generate the Python program to address the problem by implementing this formula:\n\n```python\ndef solution():\n    # Define variables: Initial Value, Final Value, and Time Period\n    initial_investment = 100  # PV\n    final_value = 370.32      # FV\n    time_period = 5           # t (years)\n    \n    # Calculate CAGR using the formula\n    cagr = ((final_value / initial_investment) ** (1 / time_period)) - 1\n    \n    # Convert CAGR to a percentage and round to the nearest integer\n    annualized_return = round(cagr * 100)\n    \n    # Return the answer\n    return annualized_return\n```\n\nThis program will compute the annualized return for CME Group from 2012 to 2017 using the provided data and constraints."
        ],
        "retrieval_query": "what is the anualized return for cme group from 2012 to 2017? Answer to the nearest integer.",
        "useful_functions": [
            "def calculate_bond_duration(cash_flows: list, discount_rate: float) -> float:\n    \"\"\"\n    Calculate the Macaulay Duration of a bond given its cash flows and discount rate.\n\n    This function computes the weighted average time for a bond to receive its cash flows,\n    providing a measure of interest rate sensitivity.\n\n    Args:\n        cash_flows (list): A list of cash flows from the bond, including coupon payments and the face value.\n                           Cash flows should be ordered by their respective time periods.\n        discount_rate (float): The discount rate (e.g., yield to maturity) used to discount cash flows. Must be positive.\n\n    Returns:\n        duration (float): The Macaulay Duration, representing the weighted average time to receive the bond's cash flows.\n\n    Notes:\n        - This function assumes that cash flows occur annually.\n        - The discount rate must be positive to ensure a valid result.\n        - Duration is typically used to assess a bond's sensitivity to interest rate changes.\n    \"\"\"\n    if discount_rate <= 0:\n        raise ValueError(\"Discount rate must be positive.\")\n\n    total_present_value = sum(cf / ((1 + discount_rate) ** t) for t, cf in enumerate(cash_flows, 1))\n    duration = sum(t * (cf / ((1 + discount_rate) ** t)) / total_present_value for t, cf in enumerate(cash_flows, 1))\n\n    return duration"
        ],
        "usage": {
            "completion_tokens": 426,
            "prompt_tokens": 1078,
            "total_tokens": 1504,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-561",
        "article_title": "Financing",
        "function": "def calculate_wacc(market_value_equity: float, market_value_debt: float, cost_of_equity: float, cost_of_debt: float, tax_rate: float) -> float:\n    \"\"\"\n    Calculate the Weighted Average Cost of Capital (WACC).\n\n    This function calculates the WACC, which represents a firm's average cost\n    of financing from all sources, weighted by their respective usage in the overall\n    capital structure. It gives an overall measure of the firm's cost of capital.\n\n    Args:\n        market_value_equity (float): Market value of the firm's equity.\n        market_value_debt (float): Market value of the firm's debt.\n        cost_of_equity (float): Cost of equity (Re) represented as a decimal (e.g., 0.08 for 8%).\n        cost_of_debt (float): Cost of debt (Rd) represented as a decimal (e.g., 0.04 for 4%).\n        tax_rate (float): Corporate tax rate (Tc) represented as a decimal (e.g., 0.30 for 30%).\n\n    Returns:\n        wacc (float): The Weighted Average Cost of Capital.\n\n    Notes:\n        - This function assumes that the market values of equity and debt and costs of capital\n          are provided in compatible units.\n        - The returned WACC is a decimal representation (e.g., 0.05 for 5%).\n        - The WACC calculation considers tax savings from interest expenses due to tax\n          deductibility.\n    \"\"\"\n    total_value = market_value_equity + market_value_debt\n    equity_weight = market_value_equity / total_value\n    debt_weight = market_value_debt / total_value\n    wacc = (equity_weight * cost_of_equity) + (debt_weight * cost_of_debt * (1 - tax_rate))\n    \n    return wacc",
        "statistics": {
            "number_statistics": {
                "args_numbers": 5,
                "question_numbers": 0,
                "context_numbers": 5,
                "total_numbers": 5
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 1,
                    "*": 3,
                    "/": 2,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 8
            },
            "code_statistics": {
                "lines": 5,
                "parentheses": 6
            }
        },
        "difficulty": 4.1588830833596715,
        "context": "A manufacturing company is evaluating its financing strategy and needs to calculate its Weighted Average Cost of Capital (WACC) to optimally structure its capital resources. The company's current market value of equity is 150 million, and the market value of its debt is 100 million. The cost of equity is estimated at 9%, while the cost of debt stands at 5%. Considering the corporate tax rate is 25%, the company wants to determine its WACC to make informed investment decisions.",
        "question": "What is the company's Weighted Average Cost of Capital (WACC)? Answer as a percentage to two decimal places.",
        "python_solution": "def solution():\n    # Define the financial parameters\n    market_value_equity = 150000000  # 150 million\n    market_value_debt = 100000000    # 100 million\n    cost_of_equity = 0.09            # 9%\n    cost_of_debt = 0.05              # 5%\n    tax_rate = 0.25                  # 25%\n\n    # Calculate total market value of the company's capital\n    total_value = market_value_equity + market_value_debt\n\n    # Calculate weights for equity and debt\n    equity_weight = market_value_equity / total_value\n    debt_weight = market_value_debt / total_value\n\n    # Calculate WACC using the formula\n    wacc = (equity_weight * cost_of_equity) + (debt_weight * cost_of_debt * (1 - tax_rate))\n\n    # Return the WACC as a percentage to two decimal places\n    return round(wacc * 100, 2)",
        "ground_truth": 6.9,
        "source": "FinanceReasoning-test-206",
        "question_id": "test-2002",
        "level": "hard",
        "output": [
            "To calculate the Weighted Average Cost of Capital (WACC), let's proceed step-by-step:\n\n### Step 1: Define the Variables\n1. **Market Value of Equity (`Equity`)**: $150 million.\n2. **Market Value of Debt (`Debt`)**: $100 million.\n3. **Cost of Equity (`Cost of Equity`)**: 9% or 0.09 in decimal form.\n4. **Cost of Debt (`Cost of Debt`)**: 5% or 0.05 in decimal form.\n5. **Corporate Tax Rate (`Tax Rate`)**: 25% or 0.25 in decimal form.\n\n### Step 2: Address Constraints (EC Technique)\n- All values (market values, costs, and tax rates) should be positive, and percentages should be converted into decimal form for calculations.\n- Ensure precision for the WACC percentage is retained up to two decimal places.\n- Adhere to the standard formula for WACC.\n\n### Step 3: Formula for WACC\nThe WACC formula is as follows:\n\\[ \\text{WACC} = \\left( \\frac{\\text{Equity}}{\\text{Total Value}} \\times \\text{Cost of Equity} \\right) + \\left( \\frac{\\text{Debt}}{\\text{Total Value}} \\times \\text{Cost of Debt After Tax} \\right) \\]\n\nWhere:\n- \\(\\text{Total Value} = \\text{Equity} + \\text{Debt}\\)\n- \\(\\text{Cost of Debt After Tax} = \\text{Cost of Debt} \\times (1 - \\text{Tax Rate})\\)\n\n### Step 4: Substitute Values and Solve\nUsing the given formula:\n- Compute the total market value of the company's capital structure (\\(\\text{Total Value}\\)).\n- Calculate the proportion of equity and debt.\n- Calculate the after-tax cost of debt.\n- Substitute these components into the WACC formula for the final result.\n\n### Step 5: Write the Python Program\n\nBelow is the Python program implementation:\n\n```python\ndef solution():\n    # Define variables name and value\n    equity_market_value = 150_000_000  # Market value of equity in dollars\n    debt_market_value = 100_000_000  # Market value of debt in dollars\n    cost_of_equity = 0.09  # 9% as decimal\n    cost_of_debt = 0.05  # 5% as decimal\n    tax_rate = 0.25  # 25% as decimal\n    \n    # Do math calculation to get the answer\n    total_value = equity_market_value + debt_market_value  # Total capital\n    equity_weight = equity_market_value / total_value  # Weight of equity\n    debt_weight = debt_market_value / total_value  # Weight of debt\n    after_tax_cost_of_debt = cost_of_debt * (1 - tax_rate)  # After-tax cost of debt\n    \n    wacc = (equity_weight * cost_of_equity) + (debt_weight * after_tax_cost_of_debt)  # Weighted Average Cost of Capital\n    answer = round(wacc * 100, 2)  # Convert to percentage and round to 2 decimal places\n    \n    # return answer\n    return answer\n```"
        ],
        "retrieval_query": "What is the company's Weighted Average Cost of Capital (WACC)? Answer as a percentage to two decimal places.",
        "useful_functions": [
            "def calculate_wacc(equity_market_value: float, debt_market_value: float, cost_of_equity: float, \n                   cost_of_debt: float, tax_rate: float) -> float:\n    \"\"\"\n    Calculate the Weighted Average Cost of Capital (WACC) for a company.\n\n    This function computes the WACC, which represents a company's average after-tax\n    cost of capital from all sources, including equity and debt. It combines the cost \n    of both equity and debt, weighted by their respective proportions in the total \n    capital used by the company.\n\n    Args:\n        equity_market_value (float): Market value of the firm's equity.\n        debt_market_value (float): Market value of the firm's debt.\n        cost_of_equity (float): Cost of equity, representing the required rate \n                                of return for equity investors.\n        cost_of_debt (float): Cost of debt, representing the effective rate paid \n                              on the company's issued debt.\n        tax_rate (float): Corporate tax rate, used to calculate the after-tax cost of debt.\n\n    Returns:\n        wacc (float): The calculated Weighted Average Cost of Capital (WACC).\n\n    Notes:\n        - Applicability: Useful for assessing the cost of capital for businesses \n          that use both equity and debt financing.\n        - Constraints: The equity and debt market values should be positive and \n          represent the total financing. The tax rate should be between 0 and 1.\n        - Considerations: It assumes taxes are constant and ignores complications \n          such as different classes of equity with different costs.\n    \"\"\"\n    total_value = equity_market_value + debt_market_value\n    equity_weight = equity_market_value / total_value\n    debt_weight = debt_market_value / total_value\n    after_tax_cost_of_debt = cost_of_debt * (1 - tax_rate)\n\n    wacc = (equity_weight * cost_of_equity) + (debt_weight * after_tax_cost_of_debt)\n    \n    return wacc",
            "def calculate_weighted_average_cost_of_capital(equity_cost: float, debt_cost: float, \n                                               equity_value: float, debt_value: float, \n                                               tax_rate: float) -> float:\n    \"\"\"\n    Calculate the Weighted Average Cost of Capital (WACC) for a company.\n\n    This function computes the WACC, which is a measure of a company's cost of \n    capital from all sources, including debt and equity. It is widely used in \n    corporate finance to evaluate investment opportunities and financial \n    strategies.\n\n    Args:\n        equity_cost (float): The cost of equity capital, often derived from \n                             models like CAPM.\n        debt_cost (float): The after-tax cost of debt.\n        equity_value (float): The market value of the company's equity.\n        debt_value (float): The market value of the company's debt.\n        tax_rate (float): The corporate tax rate applicable to the company.\n\n    Returns:\n        wacc (float): The weighted average cost of capital.\n\n    Notes:\n        - Applicability: Applies to companies with both debt and equity financing.\n        - Constraints: Assumes market values are available and tax rate is constant.\n        - Considerations: Accurate cost estimates and market values are critical.\n    \"\"\"\n    total_value = equity_value + debt_value\n    wacc = ((equity_value / total_value) * equity_cost) + \\\n           ((debt_value / total_value) * debt_cost * (1 - tax_rate))\n    return wacc",
            "def calculate_weighted_average_cost_of_capital(weight_equity: float, cost_equity: float, weight_debt: float, \n                                               pretax_cost_debt: float, tax_rate: float) -> float:\n    \"\"\"\n    Calculate the weighted average cost of capital (WACC) for a company.\n\n    This function computes the WACC by weighting the cost of equity and the after-tax cost of debt\n    according to their respective proportions in the company's capital structure.\n\n    Args:\n        weight_equity (float): The proportion of capital financed by common equity. Must be between 0 and 1.\n        cost_equity (float): The cost of common equity as a decimal. Must be between 0 and 1.\n        weight_debt (float): The proportion of capital financed by debt. Must be between 0 and 1.\n        pretax_cost_debt (float): The pretax cost of debt as a decimal. Must be between 0 and 1.\n        tax_rate (float): The corporate tax rate as a decimal. Must be between 0 and 1.\n\n    Returns:\n        wacc (float): The weighted average cost of capital as a decimal.\n\n    Notes:\n        - This function assumes the sum of `weight_equity` and `weight_debt` equals 1.\n        - The WACC is returned as a decimal and may be converted to a percentage by multiplying by 100.\n        - The function assumes all inputs are provided as decimals (e.g., 10% should be input as 0.10).\n    \"\"\"\n    cost_debt_after_tax = pretax_cost_debt * (1 - tax_rate)\n    wacc = (weight_equity * cost_equity) + (weight_debt * cost_debt_after_tax)\n    return wacc"
        ],
        "usage": {
            "completion_tokens": 690,
            "prompt_tokens": 1542,
            "total_tokens": 2232,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-2027",
        "article_title": "Unearned Interest",
        "function": "def calculate_unearned_interest(remaining_payments: int, original_payments: int, monthly_payment: float, original_loan_amount: float) -> float:\n    \"\"\"\n    Calculate the amount of unearned interest using the Rule of 78.\n\n    This function estimates the unearned portion of the interest on a precomputed loan \n    using the Rule of 78 method. It is used to determine the amount of interest that\n    should be rebated if the loan is repaid early.\n\n    Args:\n        remaining_payments (int): The number of payments remaining after the current payment.\n        original_payments (int): The original total number of monthly payments scheduled.\n        monthly_payment (float): The amount of the regular monthly loan payment.\n        original_loan_amount (float): The original amount of the loan.\n\n    Returns:\n        unearned_interest (float): The amount of unearned interest to be rebated.\n\n    Notes:\n        - Applicability: This function applies to loans with precomputed finance charges where \n          the Rule of 78 is used for rebates on early repayment.\n        - Constraints: The Rule of 78 is mainly applicable to consumer loans with precomputed \n          interest and may not be suitable for all types of loans or jurisdictions.\n        - Considerations: Ensure all parameters are in consistent units and consider impact \n          of any additional fees or penalties not covered by this function.\n    \"\"\"\n    total_finance_charge = (original_payments * monthly_payment) - original_loan_amount\n    unearned_interest = total_finance_charge * (remaining_payments * (remaining_payments + 1)) / (original_payments * (original_payments + 1))\n    \n    return unearned_interest",
        "statistics": {
            "number_statistics": {
                "args_numbers": 4,
                "question_numbers": 1,
                "context_numbers": 5,
                "total_numbers": 6
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 1,
                    "*": 4,
                    "/": 1,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 8
            },
            "code_statistics": {
                "lines": 3,
                "parentheses": 10
            }
        },
        "difficulty": 4.1588830833596715,
        "context": "Jane has taken out an auto loan for purchasing a car with an amount of $15,000. The loan is set up as a precomputed loan with a total of 24 monthly payments of $700 each. After making 10 payments, Jane plans to pay off the loan early. The financial institution uses the Rule of 78 method to calculate the rebate on unearned interest that Jane is entitled to receive due to her early repayment.",
        "question": "How much unearned interest should be rebated to Jane when she pays off her loan early after making 10 payments? Answer to the nearest dollar.",
        "python_solution": "def solution():\n    # Define variables and their values as per the context\n    original_loan_amount = 15000\n    original_payments = 24\n    monthly_payment = 700\n    remaining_payments = original_payments - 10  # Jane has made 10 payments\n\n    # Calculate total finance charges\n    total_finance_charge = (original_payments * monthly_payment) - original_loan_amount\n\n    # Calculate the unearned interest using Rule of 78\n    unearned_interest = total_finance_charge * (remaining_payments * (remaining_payments + 1)) / (original_payments * (original_payments + 1))\n    \n    # Return the final answer rounded to the nearest dollar\n    return round(unearned_interest)",
        "ground_truth": 630,
        "source": "FinanceReasoning-test-236",
        "question_id": "test-2003",
        "level": "hard",
        "output": [
            "To calculate the rebate on unearned interest using the Rule of 78 method, let's break this down step by step:\n\n### Step-by-Step Analysis:\n\n1. **Understand the Rule of 78**:\n   - The Rule of 78 is a method for calculating the unearned interest rebate on precomputed loans when they are paid off early.\n   - The sum of the months remaining in the loan's term is divided by the total sum of the numbers corresponding to the terms in months, which is the \"sum of the digits.\"\n\n2. **Find the Total Interest Paid Over the Loan's Term**:\n   - The loan has 24 months with monthly payments of \\$700. The total paid over 24 months would be \\( 24 \\times 700 = 16,800 \\).\n   - The loan amount is \\$15,000. The total interest over the life of the loan is:\n     \\[\n     \\text{Total Interest} = \\text{Total Payments to Lender} - \\text{Principal Loan Amount}\n     \\]\n\n3. **Calculate the \"Sum of the Digits\"**:\n   - The term is 24 months. The sum of the digits is \\( 1 + 2 + 3 + \\cdots + 24 = \\frac{n(n+1)}{2} \\), where \\( n = 24 \\).\n\n4. **Determine the Unearned Months**:\n   - After 10 months, Jane has 14 months remaining. The sum of the months remaining (unearned interest months) is \\( 14 + 13 + \\cdots + 1 \\).\n\n5. **Calculate the Unearned Interest Rebate**:\n   - The unearned interest is a portion of the total interest that Jane is entitled to get back, based on the ratio of unearned months to the total sum of the digits.\n   - Unearned Interest Rebate = \\( \\text{Total Interest} \\times \\frac{\\text{Sum of Unearned Months}}{\\text{Total Sum of Digits}} \\).\n\n6. **Constraints**:\n   - Final answer must be rounded to the nearest dollar.\n\n#### Translation of Steps into a Python Program:\n\n```python\ndef solution():\n    # Define variables name and value\n    principal = 15000\n    monthly_payment = 700\n    total_months = 24\n    months_paid = 10\n    remaining_months = total_months - months_paid\n    \n    # Calculate Total Payments and Total Interest\n    total_payments = monthly_payment * total_months\n    total_interest = total_payments - principal  # Interest = Total Payments - Loan Amount\n    \n    # Calculate the \"Sum of the Digits\" for 24 months\n    total_sum_of_digits = total_months * (total_months + 1) // 2\n    \n    # Calculate the sum of remaining (unearned months' digits)\n    unearned_digits = remaining_months * (remaining_months + 1) // 2  # Sum of digits for months left\n    \n    # Calculate unearned interest rebate\n    unearned_interest_rebate = total_interest * (unearned_digits / total_sum_of_digits)\n    \n    # Round to the nearest dollar\n    answer = round(unearned_interest_rebate)\n    \n    # Return the answer\n    return answer\n```"
        ],
        "retrieval_query": "How much unearned interest should be rebated to Jane when she pays off her loan early after making 10 payments? Answer to the nearest dollar.",
        "useful_functions": [],
        "usage": {
            "completion_tokens": 687,
            "prompt_tokens": 444,
            "total_tokens": 1131,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-2290",
        "article_title": "After-Tax Real Rate of Return",
        "function": "def calculate_after_tax_real_rate_of_return(nominal_return: float, tax_rate: float, inflation_rate: float) -> float:\n    \"\"\"\n    Calculate the after-tax real rate of return on an investment.\n\n    This function computes the true profit or loss of an investment after\n    accounting for taxes and inflation. It is used to evaluate the actual growth\n    of an investment by normalizing the nominal return with the applicable tax rate and\n    adjusting for inflation.\n\n    Args:\n        nominal_return (float): The nominal rate of return of the investment\n                                as a decimal (e.g., 0.17 for 17%).\n        tax_rate (float): The applicable tax rate as a decimal (e.g., 0.15 for 15%).\n        inflation_rate (float): The inflation rate during the period as a decimal (e.g., 0.025 for 2.5%).\n\n    Returns:\n        after_tax_real_rate_of_return (float): The after-tax real rate of return,\n                                               as a decimal, after accounting for taxes and inflation.\n\n    Notes:\n        - Applicability: Use this function to evaluate investment returns in real terms.\n        - Constraints: The nominal return, tax rate, and inflation rate should be provided as decimals.\n        - Considerations: Ensure accurate input values for reliable outputs. This function assumes a basic\n                          tax and inflation adjustment and does not consider other financial complexities.\n    \"\"\"\n    # Calculate after-tax return\n    after_tax_return = nominal_return * (1 - tax_rate)\n\n    # Calculate after-tax real rate of return by adjusting for inflation\n    after_tax_real_rate_of_return = (1 + after_tax_return) / (1 + inflation_rate) - 1\n\n    return after_tax_real_rate_of_return",
        "statistics": {
            "number_statistics": {
                "args_numbers": 3,
                "question_numbers": 0,
                "context_numbers": 3,
                "total_numbers": 3
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 4,
                    "*": 1,
                    "/": 1,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 8
            },
            "code_statistics": {
                "lines": 5,
                "parentheses": 6
            }
        },
        "difficulty": 4.1588830833596715,
        "context": "Lisa has invested in a bond with a nominal return rate of 8% per year. The country's current tax rate on investment income is 20%, and the inflation rate is running at 2.5% annually. She wants to calculate the actual growth of her investment by taking into account the tax and the inflation rate to understand her true gains over the year.",
        "question": "What is the after-tax real rate of return on Lisa's investment? Answer as a percentage to two decimal places.",
        "python_solution": "def solution():\n    # Define the input values\n    nominal_return = 0.08  # 8% nominal return\n    tax_rate = 0.20        # 20% tax rate\n    inflation_rate = 0.025 # 2.5% inflation rate\n\n    # Calculate the after-tax return\n    after_tax_return = nominal_return * (1 - tax_rate)\n\n    # Calculate the after-tax real rate of return by adjusting for inflation\n    after_tax_real_rate_of_return = (1 + after_tax_return) / (1 + inflation_rate) - 1\n\n    # Convert the result to a percentage and round to two decimal places\n    percentage_after_tax_real_rate_of_return = after_tax_real_rate_of_return * 100\n\n    # Return the final answer rounded to two decimal places\n    return round(percentage_after_tax_real_rate_of_return, 2)\n\n# The function call to test and print the solution\nprint(solution())",
        "ground_truth": 3.8,
        "source": "FinanceReasoning-test-267",
        "question_id": "test-2004",
        "level": "hard",
        "output": [
            "**Step-by-Step EC Reasoning:**\n\n1. **Constraints:**\n   - All calculations must consider taxes and inflation in order to derive an accurate real rate of return.\n   - The final result should be presented as a percentage and rounded to two decimal places.\n\n2. **Understanding the Problem:**\n   - The nominal return is provided as 8% per year.\n   - The tax rate on investment income is 20%.\n   - The inflation rate is 2.5%.\n   - We need to calculate the **after-tax real rate of return**.\n\n3. **Mathematical Steps:**\n   - Step 1: First, calculate the **after-tax nominal return** using the formula:\n     \\[\n     \\text{After-tax Nominal Return} = \\text{Nominal Return} \\times (1 - \\text{Tax Rate})\n     \\]\n   - Step 2: Use the **Fisher equation** for determining the real rate of return, approximated as:\n     \\[\n     \\text{Real Rate of Return} = \\text{After-tax Nominal Return} - \\text{Inflation Rate}\n     \\]\n     This approximation works when rates are relatively small.\n\n4. **Output:**\n   - The result should be presented as a percentage, rounded to two decimal places.\n\nBased on this reasoning, here is the Python program:\n\n```python\ndef solution():\n    # Define variables name and value\n    nominal_return = 8  # in percentage\n    tax_rate = 20 / 100  # convert percentage to decimal\n    inflation_rate = 2.5  # in percentage\n    \n    # Step 1: Calculate the after-tax nominal return\n    after_tax_nominal_return = nominal_return * (1 - tax_rate)\n    \n    # Step 2: Calculate the after-tax real rate of return\n    real_rate_of_return = after_tax_nominal_return - inflation_rate\n    \n    # Return the final result, formatted to two decimal places\n    return round(real_rate_of_return, 2)\n```"
        ],
        "retrieval_query": "What is the after-tax real rate of return on Lisa's investment? Answer as a percentage to two decimal places.",
        "useful_functions": [],
        "usage": {
            "completion_tokens": 420,
            "prompt_tokens": 422,
            "total_tokens": 842,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "If a security has a yearly adjusted period of 7.020 and an annual convexity of 65.180 and its return to maturity falls by 25 basis points, what is the anticipated percentage change in price (expressed as a percentage)? Answer to three decimal places.",
        "python_solution": "def solution():\n    ann_mod_dur = 7.020\n    ann_converxity = 65.180\n    delta_yield = -0.0025\n\n    price_change = (-ann_mod_dur * delta_yield) + (0.5 * ann_converxity * (delta_yield ** 2))\n    return price_change * 100  # convert to percentage",
        "ground_truth": 1.775,
        "topic": "Asset Classes & Derivatives",
        "statistics": {
            "number_statistics": {
                "args_numbers": 5,
                "question_numbers": 3,
                "context_numbers": 0,
                "total_numbers": 3
            },
            "operator_statistics": {
                "operators": {
                    "+": 1,
                    "-": 2,
                    "*": 4,
                    "/": 0,
                    "%": 0,
                    "**": 1
                },
                "total_operators": 8
            },
            "code_statistics": {
                "lines": 5,
                "parentheses": 6
            }
        },
        "difficulty": 4.1588830833596715,
        "source": "FinanceMath-validation-27",
        "context": "[]",
        "question_id": "test-2005",
        "level": "hard",
        "output": [
            "### Step-by-Step Reasoning (EC - Emphasizing Constraints):\n1. **Understand the Inputs:**\n   - The problem provides the yearly adjusted period (`modified_duration`): 7.020.\n   - The `convexity` is provided: 65.180.\n   - Yield change is specified as a decrease of 25 basis points (`-0.0025` in decimal form).\n\n2. **Key Constraints:**\n   - The anticipated change in price must be expressed as a **percentage**.\n   - Ensure that the calculation adheres to the financial formula provided.\n   - Result must be carried out to **three decimal places**.\n\n3. **Formula:**\n   - The problem requires the application of the given function to calculate the price change due to both modified duration and convexity:\n     - Contribution of modified duration: `-modified_duration * yield_change`.\n     - Contribution of convexity: `0.5 * convexity * (yield_change ** 2)`.\n     - Combine these contributions to calculate the final price change as a percentage.\n\n4. **Decimal Precision:**\n   - The resulting anticipated percentage change must be rounded to **three decimal places** for clarity and as per the problem's demand.\n\n5. **Implementation Plan:**\n   - Define the variables: `modified_duration`, `convexity`, and `yield_change`.\n   - Use the provided formula for processing the result.\n   - Return the result rounded to three decimal places.\n\nNow, the Python program:\n\n```python\ndef solution():\n    # Define variables name and value\n    modified_duration = 7.020\n    convexity = 65.180\n    yield_change = -0.0025  # Negative because it's a decrease of 25 basis points\n\n    # Calculate the contributions\n    duration_contribution = -modified_duration * yield_change\n    convexity_contribution = 0.5 * convexity * (yield_change ** 2)\n    \n    # Calculate the total percentage change\n    price_change_percentage = (duration_contribution + convexity_contribution) * 100\n\n    # Return the answer rounded to three decimal places\n    return round(price_change_percentage, 3)\n```"
        ],
        "retrieval_query": "If a security has a yearly adjusted period of 7.020 and an annual convexity of 65.180 and its return to maturity falls by 25 basis points, what is the anticipated percentage change in price (expressed as a percentage)? Answer to three decimal places.",
        "useful_functions": [
            "def calculate_price_change(modified_duration: float, convexity: float, yield_change: float) -> float:\n    \"\"\"\n    Estimate the percentage change in the price of a security based on modified duration, convexity, and yield change.\n\n    This function calculates the anticipated percentage change in the price of a security using\n    the approximate formula that combines the effects of modified duration and convexity given a change in yield.\n\n    Args:\n        modified_duration (float): The modified duration of the security. Represents the price sensitivity to changes in yield.\n        convexity (float): The convexity of the security. Represents the curvature of the price-yield relationship.\n        yield_change (float): The change in yield, expressed as a decimal. A negative value indicates a yield decrease.\n\n    Returns:\n        price_change_percentage (float): The estimated percentage change in the security's price.\n\n    Notes:\n        - Applicability: Relevant for bonds or fixed-income securities analysis to estimate price changes due to yield shifts.\n        - Constraints: Assumes small changes in yield; large yield changes may require more complex models.\n        - Considerations: This approximation may not account for all market factors affecting price. Use in conjunction with other analyses.\n    \"\"\"\n    duration_contribution = -modified_duration * yield_change\n    convexity_contribution = 0.5 * convexity * (yield_change ** 2)\n    price_change_percentage = (duration_contribution + convexity_contribution) * 100\n    \n    return price_change_percentage"
        ],
        "usage": {
            "completion_tokens": 449,
            "prompt_tokens": 698,
            "total_tokens": 1147,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "The unit contribution margin for an item is $20. A business's fixed production costs up to 300,000 units amounts to $500,000. At which production levels (in units) is the degree of operating leverage (DOL) likely to be the least? Answer to a single decimal place.",
        "python_solution": "def solution():\n    contribution_margin = 20\n    fixed_costs = 500000\n    production_levels = [100000, 200000, 300000]\n    DOLs = []\n\n    for quantity in production_levels:\n        DOL = quantity * contribution_margin / (quantity * contribution_margin - fixed_costs)\n        DOLs.append(DOL)\n\n    minimum_DOL = min(DOLs)\n\n    for i in range(len(DOLs)):\n        if DOLs[i] == minimum_DOL:\n            return production_levels[i]",
        "ground_truth": 300000.0,
        "topic": "Corporate & Securities Issuance",
        "statistics": {
            "number_statistics": {
                "args_numbers": 1,
                "question_numbers": 3,
                "context_numbers": 0,
                "total_numbers": 3
            },
            "operator_statistics": {
                "operators": {
                    "+": 0,
                    "-": 1,
                    "*": 2,
                    "/": 1,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 4
            },
            "code_statistics": {
                "lines": 11,
                "parentheses": 10
            }
        },
        "difficulty": 4.1588830833596715,
        "source": "FinanceMath-validation-83",
        "context": "[]",
        "question_id": "test-2006",
        "level": "hard",
        "output": [
            "### Step-by-step reasoning:\n\n#### 1. Understand the Problem:\n- **Unit Contribution Margin**: $20\n- **Fixed Costs**: $500,000\n- **Maximum production levels**: Up to 300,000 units.\n- **Question**: \"At which production level is the Degree of Operating Leverage (DOL) likely to be the least?\"\n\nThe \"Degree of Operating Leverage (DOL)\" declines when the company operates beyond the break-even production point. Break-even happens when the total contribution margin equals fixed production costs. For this problem, we intend to calculate the DOL for production levels up to 300,000 units and determine the level with the smallest DOL.\n\n#### 2. Relevant Formulas:\n- **Break-even point in units** = \\( \\text{Fixed Costs} / \\text{Contribution Margin} \\)\n- **Degree of Operating Leverage (DOL)** at production quantity \\( Q \\):\n  \\[\n  DOL = \\frac{Q \\cdot CM}{Q \\cdot CM - \\text{Fixed Costs}}\n  \\]\n  Here:\n  - \\( Q \\): Production level (in units),\n  - \\( CM \\): Contribution Margin per unit,\n  - Fixed Costs: Total fixed costs.\n\nAt higher production levels above the break-even point, operating income increases, and DOL decreases because fixed costs become less significant compared to the total contribution margin.\n\n#### 3. Constraints to Adhere:\n- The production level results should be expressed in **units**.\n- DOL must be calculated numerically with a constraint of **single decimal precision**.\n\nWe need to test multiple production levels (e.g., break-even point up to 300,000 units) to find the minimum DOL.\n\n#### 4. Execution Plan:\n1. Define the fixed costs, unit contribution margin, and range of production levels (up to 300,000 units).\n2. Calculate the break-even point (for direct reference).\n3. Check the DOL for a range of production levels using the formula.\n4. Find the production level where DOL is lowest beyond the break-even point.\n\nHere is the Python program to solve the problem:\n\n```python\ndef solution():\n    # Define variables name and value\n    contribution_margin = 20  # Contribution margin per unit\n    fixed_costs = 500000  # Fixed production costs\n    max_units = 300000  # Maximum production level to evaluate\n    \n    # Step 1: Calculate break-even point\n    break_even_units = fixed_costs / contribution_margin\n    \n    # Step 2: Generate production levels for calculation\n    # Only consider production levels beyond the break-even point\n    production_levels = range(int(break_even_units) + 1, max_units + 1)\n    \n    # Step 3: Initialize the variables for minimum DOL tracking\n    minimum_dol = float('inf')\n    minimum_dol_units = 0\n    \n    # Step 4: Calculate DOL for each production level\n    for quantity in production_levels:\n        DOL = (quantity * contribution_margin) / (quantity * contribution_margin - fixed_costs)\n        if DOL < minimum_dol:\n            minimum_dol = DOL\n            minimum_dol_units = quantity\n    \n    # Step 5: Return the production level with minimum DOL\n    return round(minimum_dol_units, 1)\n```"
        ],
        "retrieval_query": "The unit contribution margin for an item is $20. A business's fixed production costs up to 300,000 units amounts to $500,000. At which production levels (in units) is the degree of operating leverage (DOL) likely to be the least? Answer to a single decimal place.",
        "useful_functions": [
            "def calculate_minimum_dol_unit(contribution_margin: float, fixed_costs: float, production_levels: list) -> float:\n    \"\"\"\n    Calculate the production level with the minimum degree of operating leverage (DOL).\n\n    This function computes the degree of operating leverage (DOL) for different\n    production levels based on a given unit contribution margin and fixed costs.\n    It identifies the production level where DOL is minimized, indicating that\n    operating income is least sensitive to changes in sales volume at that level.\n\n    Args:\n        contribution_margin (float): The contribution margin per unit (revenue per unit minus variable cost per unit).\n        fixed_costs (float): The total fixed costs incurred in production.\n        production_levels (list): A list of production levels (in units) to evaluate.\n\n    Returns:\n        minimum_dol_level (float): The production level (in units) with the minimum DOL.\n\n    Notes:\n        - Applicability: Suitable for scenarios where determining the least sensitive point\n          of operating income to sales volume changes is required.\n        - Constraints: The production levels must include values beyond the break-even point\n          to observe diminishing DOL.\n        - Considerations: Ensure that the list of production levels is comprehensive enough\n          to include the point where DOL starts diminishing significantly.\n    \"\"\"\n    DOLs = []\n\n    for quantity in production_levels:\n        DOL = (quantity * contribution_margin) / (quantity * contribution_margin - fixed_costs)\n        DOLs.append(DOL)\n\n    minimum_DOL = min(DOLs)\n\n    for i in range(len(DOLs)):\n        if DOLs[i] == minimum_DOL:\n            return production_levels[i]"
        ],
        "usage": {
            "completion_tokens": 702,
            "prompt_tokens": 748,
            "total_tokens": 1450,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-1037",
        "article_title": "High-Low Index",
        "function": "def calculate_moving_average(data: list, period: int) -> list:\n    \"\"\"\n    Calculate a moving average for a given period over a data sequence.\n\n    This function calculates the moving average of a financial time series\n    data set over a specified number of periods. It is useful in smoothing\n    time series data to identify trends more easily.\n\n    Args:\n        data (list): The series of data points (e.g., index values or prices).\n        period (int): The number of periods over which to calculate the moving average.\n\n    Returns:\n        moving_averages (list): The list of moving average values, with the\n                                same length as the input data list.\n\n    Notes:\n        - The period must be a positive integer and should not exceed the length of the data.\n        - For the beginning of the data set, the moving average will only\n          start to be calculated once enough data points (equal to the period)\n          are available.\n        - Data should be provided in chronological order.\n    \"\"\"\n    if period <= 0 or period > len(data):\n        raise ValueError(\"Period must be a positive integer less than or equal to the length of the data.\")\n\n    moving_averages = []\n    for i in range(len(data)):\n        if i < period - 1:\n            moving_averages.append(None)\n        else:\n            window = data[i - period + 1:i + 1]\n            moving_averages.append(sum(window) / period)\n\n    return moving_averages",
        "statistics": {
            "number_statistics": {
                "args_numbers": 2,
                "question_numbers": 1,
                "context_numbers": 12,
                "total_numbers": 13
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 2,
                    "*": 0,
                    "/": 1,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 5
            },
            "code_statistics": {
                "lines": 8,
                "parentheses": 10
            }
        },
        "difficulty": 4.174387269895637,
        "context": "A financial analyst wants to evaluate a tech company's stock price movements over the past few weeks to identify any emerging trends. They have collected the closing prices for the last 10 trading days as follows: [205, 210, 215, 220, 222, 225, 230, 235, 236, 240]. The analyst decides to calculate the 5-day moving average of the stock prices to smooth out volatility and better understand the price trend.",
        "question": "What is the 5-day moving average of the tech company's stock price on the 10th trading day? Answer to two decimal places.",
        "python_solution": "def solution():\n    # Define the list of stock prices and the moving average period\n    stock_prices = [205, 210, 215, 220, 222, 225, 230, 235, 236, 240]\n    period = 5\n\n    # Calculate the 5-day moving average for the last available day in the data set\n    moving_averages = []\n    for i in range(len(stock_prices)):\n        if i < period - 1:\n            moving_averages.append(None)\n        else:\n            window = stock_prices[i - period + 1:i + 1]\n            moving_averages.append(sum(window) / period)\n\n    # Get the moving average on the 10th trading day\n    result = moving_averages[-1]  # The last element in the moving_averages list\n\n    # Return the final answer rounded to two decimal places\n    return round(result, 2)",
        "ground_truth": 233.2,
        "source": "FinanceReasoning-test-254",
        "question_id": "test-2007",
        "level": "hard",
        "output": [
            "### Step-by-Step Reasoning:\n1. **Understanding the Problem:**\n   - We need to calculate the 5-day moving average of a tech company's closing stock price on the 10th trading day.\n   - For a 5-day moving average, the average of the last 5 consecutive trading days should be considered.\n   - On the 10th trading day, the moving average will include the prices from the 6th, 7th, 8th, 9th, and 10th trading days.\n\n2. **Emphasizing Constraints (EC):**\n   - **Constraint 1:** Use only the last 5 days of data for the moving average calculation.\n   - **Constraint 2:** Calculate to *two decimal places* precision.\n   - **Constraint 3:** Adhere to input data exactly, i.e., use the provided prices.\n\n3. **Approach:**\n   - Extract the closing prices of the last 5 trading days ([225, 230, 235, 236, 240]).\n   - Compute the sum of these prices.\n   - Divide the sum by 5 to calculate the average.\n   - Round the result to two decimal places for output.\n\n### Python Program:\n```python\ndef solution():\n    # Define variables name and value\n    stock_prices = [205, 210, 215, 220, 222, 225, 230, 235, 236, 240]\n    \n    # Extract the last 5 days of data pertaining to the 5-day moving average\n    last_5_days = stock_prices[-5:]\n    \n    # Calculate the sum of the last 5 days and find the average\n    total = sum(last_5_days)\n    moving_average = total / 5\n    \n    # Return the moving average rounded to two decimal places\n    return round(moving_average, 2)\n```"
        ],
        "retrieval_query": "What is the 5-day moving average of the tech company's stock price on the 10th trading day? Answer to two decimal places.",
        "useful_functions": [],
        "usage": {
            "completion_tokens": 390,
            "prompt_tokens": 448,
            "total_tokens": 838,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-449",
        "article_title": "Interest Rate Options",
        "function": "def calculate_option_profit(option_type: str, strike_price: float, premium: float, yield_at_expiry: float, multiplier: int = 100) -> float:\n    \"\"\"\n    Calculate the profit or loss of an interest rate option at expiration.\n\n    This function calculates the potential profit or loss from holding an interest rate option\n    based on the option type, strike price, premium paid, and the yield at expiration. The function\n    accounts for both call and put options and uses a standard multiplier for the yield.\n\n    Args:\n        option_type (str): The type of option, either 'call' or 'put'.\n        strike_price (float): The strike price of the option.\n        premium (float): The premium paid for the option per contract.\n        yield_at_expiry (float): The yield of the underlying asset at expiration.\n        multiplier (int, optional): The multiplier for the yield, typically 100. Default is 100.\n\n    Returns:\n        profit_loss (float): The net profit or loss from the option, considering the premium paid.\n\n    Notes:\n        - Applicability: This function is applicable for calculating the settlement amounts for interest rate options.\n        - Constraints: The input option_type must be either 'call' or 'put'. Yields and premiums should be non-negative.\n        - Considerations: Ensure the multiplier reflects the options market standard to calculate correct payout values.\n    \"\"\"\n    if option_type not in ['call', 'put']:\n        raise ValueError(\"option_type must be 'call' or 'put'.\")\n        \n    option_value_at_expiry = yield_at_expiry * multiplier\n    option_value_at_strike = strike_price * multiplier\n    \n    if option_type == 'call':\n        intrinsic_value = max(0, option_value_at_expiry - option_value_at_strike)\n    elif option_type == 'put':\n        intrinsic_value = max(0, option_value_at_strike - option_value_at_expiry)\n    \n    profit_loss = intrinsic_value - (premium * multiplier)\n    \n    return profit_loss",
        "statistics": {
            "number_statistics": {
                "args_numbers": 5,
                "question_numbers": 0,
                "context_numbers": 5,
                "total_numbers": 5
            },
            "operator_statistics": {
                "operators": {
                    "+": 0,
                    "-": 3,
                    "*": 3,
                    "/": 0,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 6
            },
            "code_statistics": {
                "lines": 8,
                "parentheses": 6
            }
        },
        "difficulty": 4.189654742026425,
        "context": "An investor purchases a call option on a 5-year treasury bond with a strike price of 3.0% yield. The option premium paid by the investor is 1.5%. At the expiration date, the yield on the bond is observed to be 3.5%. The option uses a standard multiplier of 100 to calculate the profit or loss from changes in the yield.",
        "question": "What is the profit or loss that the investor makes on the expiration of the option? Provide the answer to the nearest integer.",
        "python_solution": "def solution():\n    # Given values\n    option_type = \"call\"\n    strike_price = 3.0  # percentage yield\n    premium = 1.5  # percentage premium paid\n    yield_at_expiry = 3.5  # percentage yield at expiration\n    multiplier = 100  # standard multiplier\n\n    # Calculating the option value at expiration\n    option_value_at_expiry = yield_at_expiry * multiplier\n    option_value_at_strike = strike_price * multiplier\n\n    # Determine the intrinsic value based on the option type\n    intrinsic_value = max(0, option_value_at_expiry - option_value_at_strike)\n\n    # Calculate profit or loss\n    profit_loss = intrinsic_value - (premium * multiplier)\n\n    # Return the result rounded to the nearest integer\n    return round(profit_loss)\n\n# Call the solution function to get the result\nprint(solution())",
        "ground_truth": -100,
        "source": "FinanceReasoning-test-174",
        "question_id": "test-2008",
        "level": "hard",
        "output": [
            "### Step-by-step Analysis of the Problem:\n\n**Problem Context and Given Values:**\n1. The investor has purchased a **call option** on a 5-year treasury bond.\n2. **Strike Price (yield):** 3.0%\n3. **Option Premium:** 1.5%\n4. **Yield at Expiry:** 3.5%\n5. **Multiplier:** 100 (as per standard market calculations for options settlements).\n\n**Output Required:**\n- Compute the **profit or loss** the investor earns from the option at expiration. The answer needs to be rounded to the nearest integer.\n\n---\n\n**Clarifications and Constraints (EC):**\n1. The input specifically refers to a **call option**, meaning the investor profits when the **yield at expiry** is higher than the **strike price** of 3.0%.\n2. Profit is computed as follows:\n   - Intrinsic Value = Max(0, (Yield at Expiry - Strike Price) * Multiplier)\n   - Profit/Loss = Intrinsic Value - (Option Premium * Multiplier)\n3. All values (strike price, premium, yields) should be expressed in percentages.\n4. Final output must be **rounded to the nearest integer**.\n\n---\n\n**Detailed Calculation Steps:**\n1. Calculate the **option value at expiry**:\n   - At Yield = 3.5%, and Strike = 3.0%, the intrinsic value is:\n     `Max(0, (3.5 - 3.0) * 100) = Max(0, 0.5 * 100) = 50`.\n2. Calculate the **cost of the premium**:\n   - Premium cost is `1.5% * 100 = 1.5 * 100 = 150`.\n3. Subtract the premium cost from the intrinsic value to determine the profit or loss:\n   - `Profit/Loss = Intrinsic Value - Premium Cost = 50 - 150 = -100`.\n4. Return the result rounded to the nearest integer.\n\n---\n\nNow, let's generate the Python program:\n\n```python\ndef solution():\n    # Define variables name and value\n    option_type = \"call\"\n    strike_price = 3.0  # in percentage\n    premium = 1.5  # in percentage\n    yield_at_expiry = 3.5  # in percentage\n    multiplier = 100  # Standard multiplier\n    \n    # Calculate option value at expiry and strike\n    option_value_at_expiry = yield_at_expiry * multiplier\n    option_value_at_strike = strike_price * multiplier\n    \n    # Calculate intrinsic value for a call option\n    intrinsic_value = max(0, option_value_at_expiry - option_value_at_strike)\n    \n    # Calculate profit/loss considering the premium\n    profit_loss = intrinsic_value - (premium * multiplier)\n    \n    # Return the answer rounded to the nearest integer\n    return round(profit_loss)\n```"
        ],
        "retrieval_query": "What is the profit or loss that the investor makes on the expiration of the option? Provide the answer to the nearest integer.",
        "useful_functions": [
            "def calculate_option_profit(option_type: str, strike_price: float, premium: float, yield_at_expiry: float, multiplier: int = 100) -> float:\n    \"\"\"\n    Calculate the profit or loss of an interest rate option at expiration.\n\n    This function calculates the potential profit or loss from holding an interest rate option\n    based on the option type, strike price, premium paid, and the yield at expiration. The function\n    accounts for both call and put options and uses a standard multiplier for the yield.\n\n    Args:\n        option_type (str): The type of option, either 'call' or 'put'.\n        strike_price (float): The strike price of the option.\n        premium (float): The premium paid for the option per contract.\n        yield_at_expiry (float): The yield of the underlying asset at expiration.\n        multiplier (int, optional): The multiplier for the yield, typically 100. Default is 100.\n\n    Returns:\n        profit_loss (float): The net profit or loss from the option, considering the premium paid.\n\n    Notes:\n        - Applicability: This function is applicable for calculating the settlement amounts for interest rate options.\n        - Constraints: The input option_type must be either 'call' or 'put'. Yields and premiums should be non-negative.\n        - Considerations: Ensure the multiplier reflects the options market standard to calculate correct payout values.\n    \"\"\"\n    if option_type not in ['call', 'put']:\n        raise ValueError(\"option_type must be 'call' or 'put'.\")\n        \n    option_value_at_expiry = yield_at_expiry * multiplier\n    option_value_at_strike = strike_price * multiplier\n    \n    if option_type == 'call':\n        intrinsic_value = max(0, option_value_at_expiry - option_value_at_strike)\n    elif option_type == 'put':\n        intrinsic_value = max(0, option_value_at_strike - option_value_at_expiry)\n    \n    profit_loss = intrinsic_value - (premium * multiplier)\n    \n    return profit_loss"
        ],
        "usage": {
            "completion_tokens": 607,
            "prompt_tokens": 856,
            "total_tokens": 1463,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-233",
        "article_title": "Currency Carry Trade",
        "function": "def calculate_carry_trade_profit(invested_amount: float, investment_rate: float, borrowed_amount: float, borrowing_rate: float, exchange_rate: float) -> float:\n    \"\"\"\n    Calculate the profit from a currency carry trade given interest rates and exchange rates.\n\n    This function computes the profit obtained from executing a carry trade where you borrow\n    funds in a low-interest currency and invest them in a high-interest currency, assuming no \n    significant change in exchange rates.\n\n    Args:\n        invested_amount (float): The amount converted and invested in the high-yield currency.\n        investment_rate (float): The interest rate of the investment currency.\n        borrowed_amount (float): The original amount borrowed in the low-yield currency.\n        borrowing_rate (float): The interest rate of the borrowing currency.\n        exchange_rate (float): The exchange rate when converting from borrowed to investment currency.\n\n    Returns:\n        profit (float): The profit from the carry trade in the currency of investment.\n\n    Notes:\n        - Applicability: This function is applicable when exchange rates remain stable during the investment period.\n        - Constraints: Assumes exchange rates do not change significantly; otherwise, currency fluctuations may impact profits.\n        - Considerations: Leverage is not directly included in this function but can be applied to enhance the scale of the operation.\n    \"\"\"\n    # Calculate the amount after investment\n    ending_balance = invested_amount * (1 + investment_rate)\n    \n    # Calculate the amount owed in the borrowed currency\n    amount_owed = borrowed_amount * (1 + borrowing_rate)\n    \n    # Convert the amount owed to the investment currency\n    amount_owed_converted = amount_owed / exchange_rate\n    \n    # Calculate the profit\n    profit = ending_balance - amount_owed_converted\n    \n    return profit",
        "statistics": {
            "number_statistics": {
                "args_numbers": 5,
                "question_numbers": 0,
                "context_numbers": 4,
                "total_numbers": 4
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 1,
                    "*": 2,
                    "/": 1,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 6
            },
            "code_statistics": {
                "lines": 9,
                "parentheses": 4
            }
        },
        "difficulty": 4.189654742026425,
        "context": "A global investor is exploring a currency carry trade strategy. The investor plans to borrow funds in Japan, where the interest rate is extremely low at 0.5% per annum, and invest these funds in Brazil, where the interest rate is much higher at 5% per annum. The investor borrows 1,000,000 Japanese Yen and converts this amount into Brazilian Reals using an exchange rate of 0.05. The investor holds the investment for one year, assuming that the exchange rate remains stable during this period.",
        "question": "What is the profit from this carry trade in Brazilian Reals? Answer to the nearest integer.",
        "python_solution": "def solution():\n    # Define the initial variables with provided values\n    borrowed_amount_jpy = 1_000_000  # Amount borrowed in Japanese Yen\n    borrowing_rate = 0.005  # 0.5% per annum interest rate for borrowed currency\n    investment_rate = 0.05  # 5% per annum interest rate for invested currency\n    exchange_rate = 0.05  # Exchange rate from JPY to BRL\n\n    # Calculate the amount in Brazilian Reals after conversion\n    invested_amount_brl = borrowed_amount_jpy * exchange_rate\n\n    # Calculate the ending balance after investment\n    ending_balance_brl = invested_amount_brl * (1 + investment_rate)\n\n    # Calculate the amount owed back in Japanese Yen\n    amount_owed_jpy = borrowed_amount_jpy * (1 + borrowing_rate)\n\n    # Convert the amount owed from JPY back to BRL\n    amount_owed_brl = amount_owed_jpy * exchange_rate\n\n    # Calculate the profit in Brazilian Reals\n    profit_brl = ending_balance_brl - amount_owed_brl\n\n    # Return the profit rounded to the nearest integer\n    return round(profit_brl)\n\n# Execute the solution function\nsolution()",
        "ground_truth": 2250,
        "source": "FinanceReasoning-test-226",
        "question_id": "test-2009",
        "level": "hard",
        "output": [
            "### Step-by-step Reasoning:\n\n#### 1. Analyze and Define the Problem:\n- The question involves calculating the profit of a currency carry trade.\n- The key components of a carry trade are:\n  - `invested_amount`: The amount invested in the higher-yield currency (Brazilian Reals in this case), which is derived from converting Japanese Yen.\n  - `investment_rate`: The interest rate offered in the higher-yield currency market (5% per annum).\n  - `borrowed_amount`: The amount borrowed in the low-yield currency market (1,000,000 Japanese Yen here).\n  - `borrowing_rate`: The annual interest rate in the borrowing market (0.5% per annum).\n  - `exchange_rate`: The rate for converting Japanese Yen to Brazilian Reals (0.05 JPY/BRL).\n\n#### 2. Emphasizing Constraints (EC \u2013 Highlight Constraints):\n- **Initial Conversion**: 1,000,000 JPY needs to be converted into Brazilian Reals using an exchange rate of 0.05 JPY/BRL.\n  - \\( \\text{invested\\_amount (BRL)} = \\text{borrowed\\_amount (JPY)} \\times \\text{exchange\\_rate}\\).\n- **Investment Return Calculation**: Invested funds will accrue interest at an annual rate of 5%.\n  - \\( \\text{ending\\_balance (BRL)} = \\text{invested\\_amount} \\times (1 + 0.05)\\).\n- **Borrowing Cost**: The borrowed amount in Japan will accrue interest at a rate of 0.5%:\n  - \\( \\text{amount\\_owed (JPY)} = \\text{borrowed\\_amount} \\times (1 + 0.005)\\).\n- **Reconversion**: The amount owed in Japanese Yen is converted back to Brazilian Reals:\n  - \\( \\text{amount\\_owed\\_in\\_BRL} = \\text{amount\\_owed (JPY)} / \\text{exchange\\_rate}\\).\n- **Profit Calculation**: Subtract the amount owed (converted into BRL) from the ending balance:\n  - \\( \\text{profit (BRL)} = \\text{ending\\_balance} - \\text{amount\\_owed\\_in\\_BRL}\\).\n\n#### 3. Precision Requirements:\n- The result for profit should be rounded off to the nearest integer.\n\n#### 4. Assumptions:\n- The exchange rate remains unchanged during the year-long period.\n- The exact interest formulas with simple annual interest are used.\n\nWith this plan in mind, let us proceed to write the Python program to compute the profit from this carry trade.\n\n```python\ndef solution():\n    # Define variables\n    borrowed_amount = 1000000  # Borrowed amount in JPY\n    borrowing_rate = 0.005     # Borrowing rate in Japan (0.5% per annum)\n    exchange_rate = 0.05       # Exchange rate from JPY to BRL\n    investment_rate = 0.05     # Investment rate in Brazil (5% per annum)\n    \n    # Convert borrowed amount from JPY to BRL\n    invested_amount = borrowed_amount * exchange_rate\n    \n    # Calculate the amount at the end of investment period in BRL\n    ending_balance = invested_amount * (1 + investment_rate)\n    \n    # Calculate the amount owed in JPY after one year\n    amount_owed = borrowed_amount * (1 + borrowing_rate)\n    \n    # Convert the amount owed in JPY to BRL\n    amount_owed_converted = amount_owed / exchange_rate\n    \n    # Calculate the profit in BRL\n    profit = ending_balance - amount_owed_converted\n    \n    # Return the profit rounded to the nearest integer\n    return round(profit)\n```"
        ],
        "retrieval_query": "What is the profit from this carry trade in Brazilian Reals? Answer to the nearest integer.",
        "useful_functions": [
            "def calculate_carry_trade_profit(invested_amount: float, investment_rate: float, borrowed_amount: float, borrowing_rate: float, exchange_rate: float) -> float:\n    \"\"\"\n    Calculate the profit from a currency carry trade given interest rates and exchange rates.\n\n    This function computes the profit obtained from executing a carry trade where you borrow\n    funds in a low-interest currency and invest them in a high-interest currency, assuming no \n    significant change in exchange rates.\n\n    Args:\n        invested_amount (float): The amount converted and invested in the high-yield currency.\n        investment_rate (float): The interest rate of the investment currency.\n        borrowed_amount (float): The original amount borrowed in the low-yield currency.\n        borrowing_rate (float): The interest rate of the borrowing currency.\n        exchange_rate (float): The exchange rate when converting from borrowed to investment currency.\n\n    Returns:\n        profit (float): The profit from the carry trade in the currency of investment.\n\n    Notes:\n        - Applicability: This function is applicable when exchange rates remain stable during the investment period.\n        - Constraints: Assumes exchange rates do not change significantly; otherwise, currency fluctuations may impact profits.\n        - Considerations: Leverage is not directly included in this function but can be applied to enhance the scale of the operation.\n    \"\"\"\n    # Calculate the amount after investment\n    ending_balance = invested_amount * (1 + investment_rate)\n    \n    # Calculate the amount owed in the borrowed currency\n    amount_owed = borrowed_amount * (1 + borrowing_rate)\n    \n    # Convert the amount owed to the investment currency\n    amount_owed_converted = amount_owed / exchange_rate\n    \n    # Calculate the profit\n    profit = ending_balance - amount_owed_converted\n    \n    return profit"
        ],
        "usage": {
            "completion_tokens": 807,
            "prompt_tokens": 826,
            "total_tokens": 1633,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-2253",
        "article_title": "Accumulation/Distribution Indicator (A/D)",
        "function": "def calculate_money_flow_multiplier(close: float, high: float, low: float) -> float:\n    \"\"\"\n    Calculate the Money Flow Multiplier (MFM) for a given period.\n\n    The Money Flow Multiplier is used in the calculation of the Accumulation/Distribution indicator.\n    It evaluates where the close price sits in relation to the high-low range for the period.\n\n    Args:\n        close (float): The closing price of the asset for the period.\n        high (float): The highest price of the asset for the period.\n        low (float): The lowest price of the asset for the period.\n\n    Returns:\n        mfm (float): The Money Flow Multiplier for the period.\n\n    Notes:\n        - The high must be greater than the low to avoid division by zero or invalid results.\n        - A valid range should have high > low > 0.\n        - If high == low, the multiplier is set to zero to indicate an indeterminate range.\n    \"\"\"\n    if high == low:\n        return 0.0\n\n    mfm = ((close - low) - (high - close)) / (high - low)\n    return mfm\n\ndef calculate_money_flow_volume(mfm: float, volume: float) -> float:\n    \"\"\"\n    Calculate the Money Flow Volume for a given period.\n\n    This function uses the Money Flow Multiplier and the current period's volume to calculate\n    the Money Flow Volume, which is used in cumulative technical analyses like the A/D line.\n\n    Args:\n        mfm (float): The Money Flow Multiplier for the period.\n        volume (float): The traded volume of the asset for the period.\n\n    Returns:\n        money_flow_volume (float): The Money Flow Volume for the period.\n\n    Notes:\n        - Volume must be a non-negative value.\n        - The MFM should generally be between -1 and 1, as calculated technically.\n    \"\"\"\n    money_flow_volume = mfm * volume\n    return money_flow_volume\n\ndef calculate_accumulation_distribution(previous_ad: float, current_mfv: float) -> float:\n    \"\"\"\n    Calculate the Accumulation/Distribution (A/D) line value for a given period.\n\n    The A/D line is an indicator that uses price and volume to show how an asset is being\n    accumulated or distributed over time, helping to confirm price trends.\n\n    Args:\n        previous_ad (float): The A/D value from the previous period.\n        current_mfv (float): The current period Money Flow Volume.\n\n    Returns:\n        ad (float): The updated A/D line value for the current period.\n\n    Notes:\n        - previous_ad input is crucial for continuity as the A/D is cumulative.\n        - Ensure continuity and correctness of data for meaningful analysis.\n    \"\"\"\n    ad = previous_ad + current_mfv\n    return ad",
        "statistics": {
            "number_statistics": {
                "args_numbers": 3,
                "question_numbers": 0,
                "context_numbers": 5,
                "total_numbers": 5
            },
            "operator_statistics": {
                "operators": {
                    "+": 0,
                    "-": 5,
                    "*": 0,
                    "/": 1,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 6
            },
            "code_statistics": {
                "lines": 6,
                "parentheses": 10
            }
        },
        "difficulty": 4.189654742026425,
        "context": "An investment analyst is evaluating the Accumulation/Distribution line for a stock to determine market sentiment. Over the past period, the stock had a closing price of $115, a high of $120, and a low of $110. During this period, the traded volume was 100,000 shares. The previous day's Accumulation/Distribution line value was 1,500,000. The analyst wants to calculate the updated Accumulation/Distribution line value for the current period.",
        "question": "What is the updated Accumulation/Distribution line value for the current period? Answer to the nearest integer.",
        "python_solution": "def solution():\n    # Define the parameters for the current period\n    close_price = 115\n    high_price = 120\n    low_price = 110\n    volume = 100000\n    previous_ad_value = 1500000\n\n    # Calculate the Money Flow Multiplier (MFM)\n    if high_price == low_price:\n        mfm = 0.0\n    else:\n        mfm = ((close_price - low_price) - (high_price - close_price)) / (high_price - low_price)\n\n    # Calculate the Money Flow Volume (MFV)\n    money_flow_volume = mfm * volume\n\n    # Calculate the updated Accumulation/Distribution (A/D) line value\n    updated_ad_value = previous_ad_value + money_flow_volume\n\n    # Return the final answer, rounded to the nearest integer\n    return round(updated_ad_value)\n\n# Uncomment the following line to test the solution function\n# print(solution())",
        "ground_truth": 1500000,
        "source": "FinanceReasoning-test-227",
        "question_id": "test-2010",
        "level": "hard",
        "output": [
            "### Problem Analysis:\nTo calculate the updated Accumulation/Distribution (A/D) line value for the stock, we use the standard formula for the A/D calculation:\n\n#### Formula:\n\\[\n\\text{Money Flow Multiplier (MFM)} = \\frac{(\\text{Close} - \\text{Low}) - (\\text{High} - \\text{Close})}{\\text{High} - \\text{Low}}\n\\]\n\n\\[\n\\text{Money Flow Volume (MFV)} = \\text{MFM} \\times \\text{Volume}\n\\]\n\n\\[\n\\text{Updated A/D Line} = \\text{Previous A/D Line} + \\text{MFV}\n\\]\n\nWhere:\n- Close = $115$\n- Low = $110$\n- High = $120$\n- Volume = $100,000$\n- Previous A/D Line = $1,500,000$\n\n### Step-by-Step Plan:\n1. **Emphasizing Constraints (EC):**\n   - Adhere to financial constraints such as accuracy and precision (round results where applicable).\n   - Final answer must be an integer for the updated A/D Line.\n   \n2. **Calculate the Money Flow Multiplier (MFM):**\n   \\[\n   MFM = \\frac{(115 - 110) - (120 - 115)}{120 - 110} = \\frac{(5 - 5)}{10} = 0\n   \\]\n\n3. **Calculate the Money Flow Volume (MFV):**\n   Since MFM = 0, then:\n   \\[\n   MFV = MFM \\times \\text{Volume} = 0 \\times 100,000 = 0\n   \\]\n\n4. **Calculate the Updated A/D Line:**  \n   \\[\n   \\text{Updated A/D Line} = \\text{Previous A/D Line} + \\text{MFV} = 1,500,000 + 0 = 1,500,000\n   \\]\n\nThe updated A/D line remains unchanged at 1,500,000.\n\n---\n\n### Python Program:\n\n```python\ndef solution():\n    # Define variables\n    close = 115\n    high = 120\n    low = 110\n    volume = 100000\n    previous_ad_line = 1500000\n    \n    # Calculate Money Flow Multiplier (MFM)\n    mfm = ((close - low) - (high - close)) / (high - low)\n    \n    # Calculate Money Flow Volume (MFV)\n    mfv = mfm * volume\n    \n    # Calculate Updated Accumulation/Distribution Line\n    updated_ad_line = previous_ad_line + mfv\n    \n    # Return answer rounded to the nearest integer\n    return round(updated_ad_line)\n```"
        ],
        "retrieval_query": "What is the updated Accumulation/Distribution line value for the current period? Answer to the nearest integer.",
        "useful_functions": [
            "def calculate_double_declining_balance_depreciation(initial_cost: float, useful_life: int, residual_value: float) -> float:\n    \"\"\"\n    Calculate the first-year depreciation using the double-declining balance method.\n\n    This function computes the depreciation for the first year of an asset using the\n    double-declining balance (DDB) method, which is an accelerated depreciation \n    method compared to straight-line depreciation. The DDB method applies twice the \n    straight-line depreciation rate to the reducing book value of the asset.\n\n    Args:\n        initial_cost (float): The initial cost or purchase price of the asset.\n        useful_life (int): The useful life of the asset in years.\n        residual_value (float): The expected residual or salvage value of the asset\n                                at the end of its useful life.\n\n    Returns:\n        depreciation (float): The calculated depreciation for the first year.\n\n    Notes:\n        - Applicability: This function is applicable for calculating the first-year\n                         depreciation under the double-declining balance method.\n        - Constraints: It assumes that the asset has not depreciated below its\n                       residual value in the first year.\n        - Considerations: The residual value does not affect the calculation in \n                          the first year but will limit total depreciation over the \n                          asset's life to ensure book value does not go below residual value.\n    \"\"\"\n    straight_line_rate = 1 / useful_life\n    ddb_rate = 2 * straight_line_rate\n    depreciation = ddb_rate * initial_cost\n    \n    return depreciation"
        ],
        "usage": {
            "completion_tokens": 577,
            "prompt_tokens": 776,
            "total_tokens": 1353,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-906",
        "article_title": "Median",
        "function": "def calculate_median(numbers: list) -> float:\n    \"\"\"\n    Calculate the median of a list of numbers.\n\n    This function computes the median value from a list of numbers. The median\n    is the middle value in a sorted list of numbers. If the list has an odd\n    number of elements, the median is the middle element. If the list has an\n    even number of elements, the median is the average of the two middle elements.\n\n    Args:\n        numbers (list): A list of numerical values.\n\n    Returns:\n        median (float): The median value of the list of numbers.\n\n    Notes:\n        - The input list must contain at least one number.\n        - The function first sorts the list, which might affect performance on very large datasets.\n        - The function returns a float even if the median is an integer.\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list of numbers must contain at least one element.\")\n    \n    sorted_numbers = sorted(numbers)\n    n = len(sorted_numbers)\n    midpoint = n // 2\n\n    if n % 2 == 1:\n        return float(sorted_numbers[midpoint])\n    else:\n        return (sorted_numbers[midpoint - 1] + sorted_numbers[midpoint]) / 2",
        "statistics": {
            "number_statistics": {
                "args_numbers": 1,
                "question_numbers": 1,
                "context_numbers": 11,
                "total_numbers": 12
            },
            "operator_statistics": {
                "operators": {
                    "+": 1,
                    "-": 1,
                    "*": 0,
                    "/": 3,
                    "%": 1,
                    "**": 0
                },
                "total_operators": 6
            },
            "code_statistics": {
                "lines": 7,
                "parentheses": 8
            }
        },
        "difficulty": 4.189654742026425,
        "context": "An investment bank is analyzing the median annual return rates of a portfolio consisting of different asset classes over the past 10 years. They have collected the following annual return rates (in percentage) for a particular mutual fund: 5.2, 7.1, 2.8, 6.5, 3.9, 9.0, 4.6, 8.3, 5.7, and 7.4. The bank wants to determine the median annual return rate for this mutual fund to assess its performance stability over time.",
        "question": "What is the median annual return rate for the mutual fund over the past 10 years? Answer as a percentage to two decimal places.",
        "python_solution": "def solution():\n    # Annual return rates for the mutual fund over 10 years\n    annual_returns = [5.2, 7.1, 2.8, 6.5, 3.9, 9.0, 4.6, 8.3, 5.7, 7.4]\n\n    # Sort the list of annual returns\n    sorted_returns = sorted(annual_returns)\n\n    # Calculate the number of annual return entries\n    n = len(sorted_returns)\n\n    # Find the median\n    if n % 2 == 1:\n        # Odd number of entries, the median is the middle element directly\n        median = float(sorted_returns[n // 2])\n    else:\n        # Even number of entries, the median is the average of the two middle elements\n        median = (sorted_returns[(n // 2) - 1] + sorted_returns[n // 2]) / 2.0\n\n    # Return the median rounded to two decimal places\n    return round(median, 2)\n\n# Use the solution function to calculate and return the median\nsolution()",
        "ground_truth": 6.1,
        "source": "FinanceReasoning-test-395",
        "question_id": "test-2011",
        "level": "hard",
        "output": [
            "To solve the problem step by step with advanced reasoning techniques:\n\n**Step 1: Identify Constraints (EC)**\n- The data set includes 10 annual return rates, given in percentage format.\n- The task is to determine the median annual return rate as a percentage.\n- The solution must be presented as a percentage rounded to two decimal places.\n\n**Step 2: Define Median**\n- The median is the middle value in a sorted data set. \n- If the number of data points is odd, the median is the middle value.\n- If the number of data points is even, the median is the average of the two middle values.\n\n**Step 3: Plan the Steps**\n1. Sort the given return rates in ascending order.\n2. Check the number of elements (n). If n is odd, select the middle value; if n is even, calculate the average of the two middle values.\n3. Round the result to two decimal places.\n\nNow let us implement the solution in Python:\n\n```python\ndef solution():\n    # Define variables name and value\n    return_rates = [5.2, 7.1, 2.8, 6.5, 3.9, 9.0, 4.6, 8.3, 5.7, 7.4]\n    \n    # Step 1: Sort the list in ascending order\n    sorted_rates = sorted(return_rates)\n    \n    # Step 2: Compute the median\n    n = len(sorted_rates)\n    if n % 2 == 0:  # Even number of elements\n        median = (sorted_rates[n//2 - 1] + sorted_rates[n//2]) / 2  # Average of middle two\n    else:  # Odd number of elements\n        median = sorted_rates[n//2]  # Middle element\n    \n    # Step 3: Return rounded result\n    return round(median, 2)\n```"
        ],
        "retrieval_query": "What is the median annual return rate for the mutual fund over the past 10 years? Answer as a percentage to two decimal places.",
        "useful_functions": [],
        "usage": {
            "completion_tokens": 402,
            "prompt_tokens": 468,
            "total_tokens": 870,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "If a corporation switches from last-in, first-out (LIFO) to first-in, first-out (FIFO), how much higher would the net income (in $ thousands) for 2014 be, considering that the corporate tax rate for the current and all previous years has been 30% according to the data collected by a data analyst? Answer to a single decimal place.",
        "python_solution": "def solution():\n    net_profit_margin = 0.049\n    sales = 2125\n    tax_rate = 0.3\n    lifo_reserve_2014 = 82\n    lifo_reserve_2013 = 64\n\n    net_income_lifo = net_profit_margin * sales\n    change_in_lifo_reserve = lifo_reserve_2014 - lifo_reserve_2013\n    net_income_fifo = net_income_lifo + change_in_lifo_reserve * (1 - tax_rate)\n\n    increase_in_net_income = net_income_fifo - net_income_lifo\n\n    return increase_in_net_income",
        "ground_truth": 12.6,
        "topic": "Accounting",
        "statistics": {
            "number_statistics": {
                "args_numbers": 3,
                "question_numbers": 1,
                "context_numbers": 6,
                "total_numbers": 7
            },
            "operator_statistics": {
                "operators": {
                    "+": 1,
                    "-": 3,
                    "*": 2,
                    "/": 0,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 6
            },
            "code_statistics": {
                "lines": 10,
                "parentheses": 2
            }
        },
        "difficulty": 4.189654742026425,
        "source": "FinanceMath-validation-112",
        "context": "['| ($ thousands)             |       | 2014 | 2013 |\\n|---------------------------|-------|------|------|\\n| Sales                     |       | 2125 | 2003 |\\n| End of year inventories (LIFO) |       | 312  | 280  |\\n| LIFO reserve              |       | 82   | 64   |\\n| Net profit margin         |       | 4.9% | 4.0% |']",
        "question_id": "test-2012",
        "level": "hard",
        "output": [
            "### Step-by-Step Solution Using Emphasis on Constraints (EC)\n\n**1. Problem Breakdown and Constraints Analysis:**\n   - The LIFO reserve for 2014 and 2013 is provided as `82` and `64` (in $ thousands) respectively.\n   - The tax rate is mentioned as 30% which is equivalent to `0.3` in decimal form.\n   - The impact of switching from LIFO to FIFO on net income can be calculated using the difference in the LIFO reserve.\n   - We must respect the constraint of ensuring the tax rate is correctly applied and that calculations adhere to the units provided ($ thousands).\n\n**2. Formula Under Consideration:**\n   - Change in LIFO reserve = LIFO reserve (2014) - LIFO reserve (2013)\n   - Tax impact = Change in LIFO reserve \u00d7 Corporate tax rate\n   - Net income increase = Change in LIFO reserve - Tax impact\n\n**3. Precision and Units:**\n   - The answer should be in $ thousands.\n   - The answer must be rounded to one decimal place.\n\n**4. Implementation Plan:**\n   - Assign variables for the LIFO reserves for 2014 and 2013.\n   - Assign the corporate tax rate as 0.3.\n   - Use the given financial function `calculate_net_income_increase_with_fifo` to compute the increase in net income.\n\nLet us now implement the Python program to solve this problem.\n\n```python\ndef solution():\n    # Define variables name and value\n    lifo_reserve_2014 = 82  # in $ thousands\n    lifo_reserve_2013 = 64  # in $ thousands\n    corporate_tax_rate = 0.3  # 30%\n    \n    # Financial function as described in the question\n    def calculate_net_income_increase_with_fifo(lifo_reserve_current, lifo_reserve_previous, tax_rate):\n        if not (0 <= tax_rate <= 1):  # Ensure tax rate is valid\n            raise ValueError(\"Tax rate must be between 0 and 1.\")\n            \n        change_in_lifo_reserve = lifo_reserve_current - lifo_reserve_previous\n        additional_tax = change_in_lifo_reserve * tax_rate\n        net_income_increase = change_in_lifo_reserve - additional_tax\n\n        return net_income_increase\n\n    # Calculate net income increase using the function\n    net_income_increase = calculate_net_income_increase_with_fifo(lifo_reserve_2014, lifo_reserve_2013, corporate_tax_rate)\n    \n    # Round the answer to one decimal place\n    answer = round(net_income_increase, 1)\n    \n    # return answer\n    return answer\n```"
        ],
        "retrieval_query": "If a corporation switches from last-in, first-out (LIFO) to first-in, first-out (FIFO), how much higher would the net income (in $ thousands) for 2014 be, considering that the corporate tax rate for the current and all previous years has been 30% according to the data collected by a data analyst? Answer to a single decimal place.",
        "useful_functions": [
            "def calculate_net_income_increase_with_fifo(lifo_reserve_current: float, lifo_reserve_previous: float, tax_rate: float) -> float:\n    \"\"\"\n    Calculate the increase in net income when switching from LIFO to FIFO inventory accounting method.\n\n    This function determines how much higher the net income would be when a company switches from the\n    last-in, first-out (LIFO) to the first-in, first-out (FIFO) accounting method by analyzing the change\n    in the LIFO reserve and accounting for tax effects.\n\n    Args:\n        lifo_reserve_current (float): The LIFO reserve value at the end of the current year.\n        lifo_reserve_previous (float): The LIFO reserve value at the end of the previous year.\n        tax_rate (float): The corporate tax rate applied to the increase in income from switching methods.\n\n    Returns:\n        net_income_increase (float): The increase in net income (in thousands or units consistent with input) \n                                     as a result of the accounting method switch.\n\n    Notes:\n        - Applicability: Use this function when evaluating the financial impact of changing accounting\n          methods for inventory from LIFO to FIFO.\n        - Constraints: The tax rate must be between 0 and 1.\n        - Considerations: Ensure that LIFO reserve values are consistent (e.g., both in thousands of dollars).\n    \"\"\"\n    if not (0 <= tax_rate <= 1):\n        raise ValueError(\"Tax rate must be between 0 and 1.\")\n        \n    change_in_lifo_reserve = lifo_reserve_current - lifo_reserve_previous\n    additional_tax = change_in_lifo_reserve * tax_rate\n    net_income_increase = change_in_lifo_reserve - additional_tax\n\n    return net_income_increase"
        ],
        "usage": {
            "completion_tokens": 565,
            "prompt_tokens": 885,
            "total_tokens": 1450,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "Bloomfield informs Smith that he observed 500 shares of BYYP stock being traded every 20 minutes for a duration of an hour. He also tells Smith that he saw a similar trading pattern in the stock during the previous trading day. Bloomfield instructs Smith to place an order to buy BYYP stock, assuming that a trader is looking for liquidity and is executing a large purchase order by dividing it into smaller parts. Based on Exhibit 1, what is the average effective spread of the BYYP transactions? Answer to three decimal places.",
        "python_solution": "def solution():\n    trade1_price = 41.50\n    trade1_midpoint = 41.475\n    trade2_price = 41.75\n    trade2_midpoint = 41.74\n    \n    effective_spread_trade1 = 2 * (trade1_price - trade1_midpoint)\n    effective_spread_trade2 = 2 * (trade2_price - trade2_midpoint)\n    \n    average_effective_spread = (effective_spread_trade1 + effective_spread_trade2) / 2\n    \n    return average_effective_spread",
        "ground_truth": 0.035,
        "topic": "Portfolio Management & Strategy",
        "statistics": {
            "number_statistics": {
                "args_numbers": 5,
                "question_numbers": 3,
                "context_numbers": 8,
                "total_numbers": 11
            },
            "operator_statistics": {
                "operators": {
                    "+": 1,
                    "-": 2,
                    "*": 2,
                    "/": 1,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 6
            },
            "code_statistics": {
                "lines": 8,
                "parentheses": 6
            }
        },
        "difficulty": 4.189654742026425,
        "source": "FinanceMath-validation-148",
        "context": "['| Trade | Trade Price | Prevailing Bid | Prevailing Offer |\\n|-------|-------------|----------------|------------------|\\n| 1     | 41.50       | 41.45          | 41.50            |\\n| 2     | 41.75       | 41.73          | 41.75            |']",
        "question_id": "test-2013",
        "level": "hard",
        "output": [
            "### Step-by-Step Solution using EC:\n\n#### Step 1: Understand the Formula\nThe **average effective spread** for a series of trades is calculated using the formula:\n- Effective Spread (per trade) = \\( 2 \\times | \\text{Trade Price} - \\text{Midpoint} | \\)\n- Midpoint = \\( (\\text{Prevailing Bid} + \\text{Prevailing Offer}) / 2 \\)\n\nThe **average effective spread** is the mean of these calculated effective spreads.\n\n#### Step 2: Emphasizing Constraints (EC)\n1. **Input constraints:**\n   - Trade prices, prevailing bids, and prevailing offers must be positive.\n   - Lists of trade prices, prevailing bids, and prevailing offers must have the same length.\n2. **Output constraints:**\n   - The result must be rounded to **3 decimal places** for the final output.\n\n#### Step 3: Extract Input Data from Exhibit 1\n- Trade Prices = [41.50, 41.75]\n- Prevailing Bids = [41.45, 41.73]\n- Prevailing Offers = [41.50, 41.75]\n\n#### Step 4: Calculate Effective Spread for Each Trade\n- Trade 1:\n  - Trade Price = \\( 41.50 \\)\n  - Midpoint = \\( (41.45 + 41.50) / 2 = 41.475 \\)\n  - Effective Spread = \\( 2 \\times | 41.50 - 41.475 | = 0.05 \\)\n  \n- Trade 2:\n  - Trade Price = \\( 41.75 \\)\n  - Midpoint = \\( (41.73 + 41.75) / 2 = 41.74 \\)\n  - Effective Spread = \\( 2 \\times | 41.75 - 41.74 | = 0.02 \\)\n\n#### Step 5: Compute the Average Effective Spread\n- Average Effective Spread = \\( (0.05 + 0.02) / 2 = 0.035 \\)\n\n### Python Implementation:\nThe Python implementation below calculates the result as outlined above:\n\n```python\ndef solution():\n    # Define variables for trade prices, prevailing bids, and prevailing offers\n    trade_prices = [41.50, 41.75]\n    prevailing_bids = [41.45, 41.73]\n    prevailing_offers = [41.50, 41.75]\n    \n    # Ensure the lists have the same length\n    if not (len(trade_prices) == len(prevailing_bids) == len(prevailing_offers)):\n        raise ValueError(\"Input lists must have the same length.\")\n    \n    # Initialize list for effective spreads\n    effective_spreads = []\n    \n    # Calculate effective spread for each trade\n    for i in range(len(trade_prices)):\n        trade_price = trade_prices[i]\n        bid = prevailing_bids[i]\n        offer = prevailing_offers[i]\n        \n        # Calculate midpoint\n        midpoint = (bid + offer) / 2\n        \n        # Calculate effective spread\n        effective_spread = 2 * abs(trade_price - midpoint)\n        effective_spreads.append(effective_spread)\n    \n    # Calculate the average effective spread\n    average_effective_spread = sum(effective_spreads) / len(effective_spreads)\n    \n    # Round the result to 3 decimal places\n    return round(average_effective_spread, 3)\n```"
        ],
        "retrieval_query": "Bloomfield informs Smith that he observed 500 shares of BYYP stock being traded every 20 minutes for a duration of an hour. He also tells Smith that he saw a similar trading pattern in the stock during the previous trading day. Bloomfield instructs Smith to place an order to buy BYYP stock, assuming that a trader is looking for liquidity and is executing a large purchase order by dividing it into smaller parts. Based on Exhibit 1, what is the average effective spread of the BYYP transactions? Answer to three decimal places.",
        "useful_functions": [
            "def calculate_average_effective_spread(trade_prices: list, prevailing_bids: list, prevailing_offers: list) -> float:\n    \"\"\"\n    Calculate the average effective spread of a series of trades.\n\n    This function computes the average effective spread for multiple trades. \n    The effective spread for each trade is determined using the formula:\n    Effective Spread = 2 \u00d7 |Trade Price - Midpoint|, where Midpoint = (Prevailing Bid + Prevailing Offer) / 2.\n\n    Args:\n        trade_prices (list): A list of prices at which trades were executed.\n        prevailing_bids (list): A list of prevailing bid prices corresponding to each trade.\n        prevailing_offers (list): A list of prevailing offer prices corresponding to each trade.\n\n    Returns:\n        float: The average effective spread of the trades.\n\n    Notes:\n        - This function assumes that the input lists have the same length, with each index representing data for a corresponding trade.\n        - It is important to ensure that trade prices, bids, and offers are all positive values.\n        - Any imbalances or incorrect data entries should be validated before invoking this function to ensure accurate results.\n    \"\"\"\n    if not (len(trade_prices) == len(prevailing_bids) == len(prevailing_offers)):\n        raise ValueError(\"Input lists must have the same length.\")\n\n    effective_spreads = []\n    for trade_price, bid, offer in zip(trade_prices, prevailing_bids, prevailing_offers):\n        midpoint = (bid + offer) / 2\n        effective_spread = 2 * abs(trade_price - midpoint)\n        effective_spreads.append(effective_spread)\n    \n    average_effective_spread = sum(effective_spreads) / len(effective_spreads)\n    \n    return average_effective_spread"
        ],
        "usage": {
            "completion_tokens": 723,
            "prompt_tokens": 889,
            "total_tokens": 1612,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-1824",
        "article_title": "Tax-Deductible Interest",
        "function": "def calculate_mortgage_interest_deduction(interest_paid: float, mortgage_debt: float, acquisition_date: str, filing_status: str) -> float:\n    \"\"\"\n    Calculate the deductible amount of mortgage interest for tax purposes.\n\n    This function computes the mortgage interest deduction based on the interest paid,\n    the mortgage debt amount, the acquisition date, and the taxpayer's filing status.\n    It considers the allowable debt limits that have changed due to tax law updates.\n\n    Args:\n        interest_paid (float): The total interest paid on the mortgage during the tax year.\n        mortgage_debt (float): The total mortgage debt secured by the home(s).\n        acquisition_date (str): The date when the home was acquired (in 'YYYY-MM-DD' format).\n        filing_status (str): The taxpayer's filing status ('single', 'married filing jointly', 'married filing separately').\n\n    Returns:\n        deduction (float): The deductible amount of mortgage interest, subject to debt limits.\n\n    Notes:\n        - For loans acquired on or before December 15, 2017, higher debt limits apply.\n        - Deduction limits: $750,000 debt limit after Dec. 15, 2017, ($375,000 for married filing separately);\n          $1 million debt limit on or before Dec. 15, 2017, ($500,000 for married filing separately).\n        - This function does not handle home equity loans that are not used to buy, build, or improve the home.\n        - Mortgage debt exceeding the limit proportionally reduces the deductible interest.\n    \"\"\"\n    # Determine debt limits based on acquisition date and filing status\n    limit_old = 1000000 if filing_status != 'married filing separately' else 500000\n    limit_new = 750000 if filing_status != 'married filing separately' else 375000\n    cutoff_date = \"2017-12-15\"\n\n    # Determine applicable debt limit\n    if acquisition_date <= cutoff_date:\n        applicable_limit = limit_old\n    else:\n        applicable_limit = limit_new\n\n    # Limit deduction based on debt limit\n    if mortgage_debt <= applicable_limit:\n        return interest_paid\n    else:\n        # Proportionally reduce the deduction\n        deduction = interest_paid * (applicable_limit / mortgage_debt)\n        return deduction",
        "statistics": {
            "number_statistics": {
                "args_numbers": 4,
                "question_numbers": 0,
                "context_numbers": 3,
                "total_numbers": 3
            },
            "operator_statistics": {
                "operators": {
                    "+": 0,
                    "-": 2,
                    "*": 1,
                    "/": 1,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 4
            },
            "code_statistics": {
                "lines": 16,
                "parentheses": 2
            }
        },
        "difficulty": 4.219507705176107,
        "context": "John purchased a home on January 10, 2020, and took out a mortgage with a total debt of $900,000. During the tax year, he paid a total interest of $36,000 on this mortgage. John is filing his taxes as a single taxpayer and is curious to calculate how much of the interest he paid will be deductible on his tax return.",
        "question": "What is the deductible amount of mortgage interest that John can claim on his tax return for the year? Answer to the nearest dollar.",
        "python_solution": "def solution():\n    # Given values\n    interest_paid = 36000  # Total interest paid by John\n    mortgage_debt = 900000  # Total mortgage debt\n    acquisition_date = \"2020-01-10\"\n    filing_status = \"single\"\n\n    # Determine debt limits based on acquisition date and filing status\n    limit_old = 1000000 if filing_status != 'married filing separately' else 500000\n    limit_new = 750000 if filing_status != 'married filing separately' else 375000\n    cutoff_date = \"2017-12-15\"\n\n    # Determine applicable debt limit\n    if acquisition_date <= cutoff_date:\n        applicable_limit = limit_old\n    else:\n        applicable_limit = limit_new\n\n    # Calculate deductible interest based on debt limits\n    if mortgage_debt <= applicable_limit:\n        deductible_interest = interest_paid\n    else:\n        # Proportionally reduce the deduction\n        deductible_interest = interest_paid * (applicable_limit / mortgage_debt)\n\n    # Return the deductible interest rounded to the nearest dollar\n    return round(deductible_interest)\n\n# Executing the solution function to test it\nsolution()",
        "ground_truth": 30000,
        "source": "FinanceReasoning-test-310",
        "question_id": "test-2014",
        "level": "hard",
        "output": [
            "### Approach and Reasoning\n1. **Understand the Problem**:\n   - John took out a mortgage with a total of $900,000 starting January 10, 2020.\n   - During the tax year, he paid $36,000 in interest.\n   - He is filing taxes as a \"single\" taxpayer.\n\n2. **Constraints**:\n   - The mortgage interest deduction is governed by the Tax Cuts and Jobs Act of 2017.\n   - As per the given function, for single taxpayers, mortgages issued after December 15, 2017, are subject to a cap of $750,000 for deductible interest.\n\n3. **Analysis**:\n   - Analyze key aspects of the problem:\n     - **Loan Date**: January 10, 2020, falls under \"after 2017-12-15.\"\n     - **Filing Status**: Single.\n     - **Deduction Limit**: $750,000 for single taxpayers for loans issued after December 15, 2017.\n   - Calculate the deductible interest based on the cap of $750,000 and the actual mortgage amount of $900,000. Since $900,000 exceeds the cap, only the interest attributed to $750,000 is deductible.\n\n4. **Steps to Calculate Deductible Interest**:\n   - First, calculate the proportion of the mortgage that is within the deductible limit (`750,000 / 900,000`).\n   - Apply this proportion to the total interest paid ($36,000) to determine the deductible amount.\n   - Round the result to the nearest dollar as required.\n\n### Python Program\nBelow is the program to calculate the deductible interest amount based on the given constraints and details.\n\n```python\ndef solution():\n    # Define variables\n    total_mortgage = 900000  # Given mortgage amount\n    interest_paid = 36000    # Total interest paid during the year\n    loan_date = \"2020-01-10\" # Loan date\n    filing_status = \"single\" # Filing status\n    is_secured = True        # Mortgage is secured by the home\n    deduction_limit = 750000 # Deduction cap for single taxpayer, post-2017-12-15 loans\n\n    # Calculate the deductible proportion based on mortgage limit\n    deductible_proportion = min(deduction_limit, total_mortgage) / total_mortgage\n    \n    # Calculate the deductible interest\n    deductible_interest = deductible_proportion * interest_paid\n    \n    # Return the result rounded to the nearest dollar\n    return round(deductible_interest)\n\n```"
        ],
        "retrieval_query": "What is the deductible amount of mortgage interest that John can claim on his tax return for the year? Answer to the nearest dollar.",
        "useful_functions": [
            "def calculate_mortgage_interest_deduction(mortgage_amount: float, is_secured: bool, loan_date: str, filing_status: str) -> float:\n    \"\"\"\n    Calculate the deductible mortgage interest based on loan details and filing status.\n\n    This function calculates the deductible amount of mortgage interest for tax purposes, considering the limits\n    imposed by the Tax Cuts and Jobs Act of 2017 and other IRS rules for different mortgage issuance dates and filing statuses.\n\n    Args:\n        mortgage_amount (float): The total mortgage amount remaining.\n        is_secured (bool): Whether the mortgage is a secured debt.\n        loan_date (str): The date the mortgage was issued, formatted as 'YYYY-MM-DD'.\n        filing_status (str): The filing status of the taxpayer ('single', 'married_jointly', or 'married_separately').\n\n    Returns:\n        deductible_interest (float): The portion of mortgage interest payments that is deductible.\n\n    Notes:\n        - Applicability: For homeowners itemizing deductions and claiming mortgage interest.\n        - Constraints: Mortgage must be secured by the home. Loan date affects deduction limits.\n        - Considerations: Future changes in tax law can alter deduction limits.\n    \"\"\"\n    # Define deduction limits based on filing status and loan date\n    dates_limits = {\n        ('single', 'before_1987-10-13'): float('inf'),  # Unlimited before 1987\n        ('single', '1987-10-13_to_2017-12-15'): 1_000_000,\n        ('single', 'after_2017-12-15'): 750_000,\n        ('married_jointly', 'before_1987-10-13'): float('inf'),\n        ('married_jointly', '1987-10-13_to_2017-12-15'): 1_000_000,\n        ('married_jointly', 'after_2017-12-15'): 750_000,\n        ('married_separately', 'before_1987-10-13'): float('inf'),\n        ('married_separately', '1987-10-13_to_2017-12-15'): 500_000,\n        ('married_separately', 'after_2017-12-15'): 375_000,\n    }\n    \n    # Determine date range for the loan\n    if loan_date < '1987-10-13':\n        date_range = 'before_1987-10-13'\n    elif '1987-10-13' <= loan_date <= '2017-12-15':\n        date_range = '1987-10-13_to_2017-12-15'\n    else:\n        date_range = 'after_2017-12-15'\n\n    # Calculate deductible interest based on secured status and limits\n    if not is_secured:\n        raise ValueError(\"Mortgage must be secured to qualify for interest deduction.\")\n    \n    limit = dates_limits.get((filing_status, date_range))\n    \n    deductible_interest = min(mortgage_amount, limit)\n\n    return deductible_interest"
        ],
        "usage": {
            "completion_tokens": 531,
            "prompt_tokens": 1087,
            "total_tokens": 1618,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-1235",
        "article_title": "Pareto Analysis",
        "function": "def pareto_analysis(causes: list, occurrences: list) -> tuple:\n    \"\"\"\n    Perform a Pareto analysis to identify causes with the greatest impact.\n\n    This function takes a list of causes and their corresponding occurrences to\n    identify and rank them, showing which causes account for the majority of the\n    occurrences. It applies the 80-20 rule to highlight the most impactful causes.\n\n    Args:\n        causes (list): A list of different causes contributing to a particular issue.\n        occurrences (list): A list of integers representing the number of times each cause occurs.\n\n    Returns:\n        tuple: A tuple containing two lists:\n               - ranked_causes (list): Causes sorted in descending order based on their impact.\n               - cumulative_percentages (list): Cumulative percentage impact of the causes.\n\n    Notes:\n        - Applicability: Use this function to prioritize problem areas or assess resource allocation.\n        - Constraints: The `causes` and `occurrences` lists must be of the same length.\n        - Considerations: Ensure occurrences are positive integers, and data is accurate for meaningful analysis.\n    \"\"\"\n    if len(causes) != len(occurrences):\n        raise ValueError(\"Causes and occurrences lists must have the same length.\")\n\n    # Pairing causes with their occurrences\n    cause_impact_pairs = list(zip(causes, occurrences))\n    \n    # Sorting the causes by occurrences in descending order\n    sorted_pairs = sorted(cause_impact_pairs, key=lambda x: x[1], reverse=True)\n\n    # Total occurrences for percentage calculation\n    total_occurrences = sum(occurrences)\n    \n    # Calculate cumulative percentages\n    cumulative_sum = 0\n    ranked_causes = []\n    cumulative_percentages = []\n    \n    for cause, occ in sorted_pairs:\n        cumulative_sum += occ\n        ranked_causes.append(cause)\n        cumulative_percent = (cumulative_sum / total_occurrences) * 100\n        cumulative_percentages.append(cumulative_percent)\n    \n    return ranked_causes, cumulative_percentages",
        "statistics": {
            "number_statistics": {
                "args_numbers": 2,
                "question_numbers": 0,
                "context_numbers": 7,
                "total_numbers": 7
            },
            "operator_statistics": {
                "operators": {
                    "+": 1,
                    "-": 0,
                    "*": 1,
                    "/": 1,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 3
            },
            "code_statistics": {
                "lines": 16,
                "parentheses": 14
            }
        },
        "difficulty": 4.23410650459726,
        "context": "A stock brokerage firm wants to conduct a Pareto analysis to identify the key factors contributing to customer complaints. The firm has compiled a list of causes for complaints and the number of occurrences for each cause over the last quarter. The causes and their occurrences are as follows:\n- Delayed Transactions: 120 occurrences\n- Incorrect Statements: 80 occurrences\n- Customer Support Delays: 50 occurrences\n- High Brokerage Fees: 40 occurrences\n- Platform Downtime: 30 occurrences\n\nThe firm wants to know what percentage of the total complaints is accounted for by the top two causes, applying the 80-20 rule to assist in resource allocation and problem prioritization.",
        "question": "What percentage of the total customer complaints is accounted for by the top two causes? Answer as a percentage to two decimal places.",
        "python_solution": "def solution():\n    # Define the causes and occurrences\n    causes = [\n        \"Delayed Transactions\",\n        \"Incorrect Statements\",\n        \"Customer Support Delays\",\n        \"High Brokerage Fees\",\n        \"Platform Downtime\"\n    ]\n    occurrences = [120, 80, 50, 40, 30]\n\n    # Detailed step to perform Pareto analysis manually\n    # Step 1: Pair the causes with their occurrences\n    cause_impact_pairs = list(zip(causes, occurrences))\n    \n    # Step 2: Sort these pairs in descending order of occurrences\n    sorted_pairs = sorted(cause_impact_pairs, key=lambda x: x[1], reverse=True)\n    \n    # Step 3: Calculate total occurrences\n    total_occurrences = sum(occurrences)\n    \n    # Step 4: Calculate cumulative percentages\n    cumulative_sum = 0\n    cumulative_percentages = []\n    \n    for cause, occ in sorted_pairs:\n        cumulative_sum += occ\n        cumulative_percentage = (cumulative_sum / total_occurrences) * 100\n        cumulative_percentages.append(cumulative_percentage)\n\n    # Step 5: Find the percentage accounted for by the top two causes\n    top_two_cumulative_percentage = cumulative_percentages[1]  # This gets the cumulative percentage after the second element\n\n    # Return the result, rounded to two decimal places\n    return round(top_two_cumulative_percentage, 2)\n\nsolution()",
        "ground_truth": 62.5,
        "source": "FinanceReasoning-test-190",
        "question_id": "test-2015",
        "level": "hard",
        "output": [
            "### Step-by-Step Analysis using Advanced Reasoning:\n\n#### Emphasizing Constraints (EC):\n1. **Constraints in the Problem**:\n   - The percentage must be calculated considering only the top two causes of complaints.\n   - The output must be in \"percentage\" form, accurate to two decimal places.\n   - The causes need to be ranked by their number of occurrences, starting with the most frequent cause.\n   - Sum of occurrences for all causes must be calculated to determine the total complaints.\n\n2. **Steps to Solution**:\n   - Calculate the total number of complaints received from all causes.\n   - Determine the top two causes by sorting the list of occurrences in descending order.\n   - Compute the sum of complaints for the top two causes.\n   - Divide this sum by the total complaints to calculate their contribution as a fraction.\n   - Convert the fraction to a percentage and round to two decimal places.\n\n3. **Expected Output**:\n   - A percentage representing the contribution of the top two causes to the total customer complaints.\n\n---\n\n### Python Program:\n```python\ndef solution():\n    # Define variables name and value\n    complaints = {\n        \"Delayed Transactions\": 120,\n        \"Incorrect Statements\": 80,\n        \"Customer Support Delays\": 50,\n        \"High Brokerage Fees\": 40,\n        \"Platform Downtime\": 30\n    }\n    \n    # Calculate total complaints\n    total_complaints = sum(complaints.values())\n    \n    # Sort complaints by occurrences in descending order\n    sorted_complaints = sorted(complaints.values(), reverse=True)\n    \n    # Calculate the sum of complaints for the top 2 causes\n    top_two_complaints = sum(sorted_complaints[:2])\n    \n    # Calculate percentage contribution of top 2 causes\n    percentage_top_two = (top_two_complaints / total_complaints) * 100\n    \n    # Round the result to two decimal places\n    answer = round(percentage_top_two, 2)\n    \n    # Return answer\n    return answer\n```"
        ],
        "retrieval_query": "What percentage of the total customer complaints is accounted for by the top two causes? Answer as a percentage to two decimal places.",
        "useful_functions": [],
        "usage": {
            "completion_tokens": 418,
            "prompt_tokens": 485,
            "total_tokens": 903,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-1292",
        "article_title": "Portfolio of Financial Assets",
        "function": "def calculate_portfolio_standard_deviation(weights: list, std_deviations: list, cov_matrix: list) -> float:\n    \"\"\"\n    Calculate the standard deviation of a portfolio's returns.\n\n    This function computes the overall standard deviation (volatility) of a portfolio,\n    which is a measure of risk. It takes into account both the individual asset \n    standard deviations and the covariances between different assets.\n\n    Args:\n        weights (list): A list of the weights of the assets in the portfolio. \n                        The sum of weights should equal 1.\n        std_deviations (list): A list of standard deviations of the individual assets.\n        cov_matrix (list): A matrix (2D list) of covariances between the assets. \n                           The matrix must be square and symmetric.\n\n    Returns:\n        portfolio_std_dev (float): The standard deviation of the portfolio, \n                                   representing its risk.\n\n    Notes:\n        - Applicability: This function is used in financial analysis to assess the \n          risk of an investment portfolio.\n        - Constraints: The length of weights and std_deviations lists should be \n          equal to the number of assets. The covariance matrix should be of the same size.\n        - Considerations: Ensure that all inputs are properly scaled and in matching \n          units (e.g., all in percentage terms).\n    \"\"\"\n    if not (len(weights) == len(std_deviations) == len(cov_matrix)):\n        raise ValueError(\"Input lists must have the same length.\")\n\n    if sum(weights) != 1:\n        raise ValueError(\"Sum of weights must be equal to 1.\")\n\n    n = len(weights)\n    portfolio_variance = 0.0\n\n    for i in range(n):\n        for j in range(n):\n            portfolio_variance += weights[i] * weights[j] * (\n                (std_deviations[i] * std_deviations[j]) if i == j else cov_matrix[i][j]\n            )\n    \n    portfolio_std_dev = portfolio_variance ** 0.5\n    return portfolio_std_dev",
        "statistics": {
            "number_statistics": {
                "args_numbers": 3,
                "question_numbers": 0,
                "context_numbers": 9,
                "total_numbers": 9
            },
            "operator_statistics": {
                "operators": {
                    "+": 1,
                    "-": 0,
                    "*": 3,
                    "/": 0,
                    "%": 0,
                    "**": 1
                },
                "total_operators": 5
            },
            "code_statistics": {
                "lines": 9,
                "parentheses": 10
            }
        },
        "difficulty": 4.2484952420493585,
        "context": "An investor is managing a diversified portfolio consisting of three different assets: Asset A, Asset B, and Asset C. The investor has allocated their portfolio such that 40% is invested in Asset A, 30% in Asset B, and 30% in Asset C. The annual standard deviations for these assets are 15%, 20%, and 25%, respectively. The covariance matrix for the returns of these assets is given as follows:\n\n- Covariance between Asset A and Asset B: 0.02\n- Covariance between Asset A and Asset C: 0.03\n- Covariance between Asset B and Asset C: 0.04\n\nNote: The covariance values are provided in annual terms.\n\nThe investor is interested in calculating the overall annual standard deviation of the portfolio, which serves as a measure of risk.",
        "question": "What is the overall annual standard deviation of the portfolio? Answer as a percentage to two decimal places.",
        "python_solution": "def solution():\n    # Define the weights of the assets in the portfolio\n    weights = [0.4, 0.3, 0.3]\n    \n    # Define the standard deviations of each asset\n    std_deviations = [0.15, 0.20, 0.25]\n    \n    # Define the covariance matrix\n    cov_matrix = [\n        [0.15**2, 0.02, 0.03],\n        [0.02, 0.20**2, 0.04],\n        [0.03, 0.04, 0.25**2],\n    ]\n    \n    # Initialize the portfolio variance\n    portfolio_variance = 0.0\n    \n    # Calculate the portfolio variance using the formula\n    n = len(weights)\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                # Variance contribution for the same asset\n                portfolio_variance += weights[i] * weights[j] * std_deviations[i]**2\n            else:\n                # Covariance contribution for different assets\n                portfolio_variance += weights[i] * weights[j] * cov_matrix[i][j]\n\n    # Calculate the portfolio standard deviation\n    portfolio_std_dev = portfolio_variance ** 0.5\n    \n    # Return the portfolio standard deviation as a percentage to two decimal places\n    return round(portfolio_std_dev * 100, 2)\n\nsolution()",
        "ground_truth": 17.9,
        "source": "FinanceReasoning-test-186",
        "question_id": "test-2016",
        "level": "hard",
        "output": [
            "To calculate the overall annual standard deviation of the portfolio, we will use the formula for portfolio variance and standard deviation:\n\n1. **Portfolio Variance Formula**:\n   The variance of a portfolio is given as:\n   \\[\n   \\sigma_p^2 = \\sum_{i=1}^{n}\\sum_{j=1}^{n}(w_i \\cdot w_j \\cdot \\text{Cov}(i,j))\n   \\]\n   where:\n   - \\( w_i \\) is the weight of asset \\( i \\) in the portfolio.\n   - \\( \\text{Cov}(i,j) \\) is the covariance between the returns of assets \\( i \\) and \\( j \\).\n   - \\( n \\) is the number of assets in the portfolio.\n\n2. **Standard Deviation**:\n   The portfolio standard deviation (\\( \\sigma_p \\)) is the square root of the portfolio variance:\n   \\[\n   \\sigma_p = \\sqrt{\\sigma_p^2}\n   \\]\n\n**Step-by-Step Approach**:\n1. The weights of the respective assets, \\( w_A = 0.4 \\), \\( w_B = 0.3 \\), and \\( w_C = 0.3 \\).\n2. Calculate individual variances:\n   - Variance of an asset is the square of its standard deviation, so:\n     - Variance of \\( A = (0.15)^2 \\),\n     - Variance of \\( B = (0.20)^2 \\),\n     - Variance of \\( C = (0.25)^2 \\).\n3. Utilize the covariance matrix to incorporate pairwise covariance terms.\n4. Substitute all these values into the portfolio variance formula.\n5. Compute the portfolio standard deviation as the square root of the portfolio variance.\n6. Convert the result to a percentage with two decimal places for the final answer.\n\n**Constraints to Consider**:\n- Input values like weights, standard deviations, and covariances are already appropriately scaled.\n- Final output should be expressed as a percentage rounded to two decimal places.\n\nLet's now implement this calculation in the Python program:\n\n```python\ndef solution():\n    # Define variables and their values\n    w_A = 0.4\n    w_B = 0.3\n    w_C = 0.3\n    \n    std_A = 0.15\n    std_B = 0.20\n    std_C = 0.25\n    \n    cov_AB = 0.02\n    cov_AC = 0.03\n    cov_BC = 0.04\n    \n    # Calculate variances of individual assets\n    var_A = std_A ** 2\n    var_B = std_B ** 2\n    var_C = std_C ** 2\n    \n    # Portfolio Variance Calculation\n    portfolio_variance = (w_A ** 2 * var_A +\n                          w_B ** 2 * var_B +\n                          w_C ** 2 * var_C +\n                          2 * w_A * w_B * cov_AB +\n                          2 * w_A * w_C * cov_AC +\n                          2 * w_B * w_C * cov_BC)\n    \n    # Portfolio Standard Deviation\n    portfolio_std_dev = (portfolio_variance ** 0.5) * 100  # Convert to percentage\n    \n    # Return the result rounded to two decimal places\n    return round(portfolio_std_dev, 2)\n```"
        ],
        "retrieval_query": "What is the overall annual standard deviation of the portfolio? Answer as a percentage to two decimal places.",
        "useful_functions": [],
        "usage": {
            "completion_tokens": 705,
            "prompt_tokens": 513,
            "total_tokens": 1218,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-2767",
        "article_title": "Employee Stock Purchase Plan (ESPP)",
        "function": "def calculate_taxable_income_from_espp_gain(purchase_price: float, sale_price: float, shares: int, discount: float, holding_period: int) -> float:\n    \"\"\"\n    Calculate the taxable income from an ESPP gain based on holding period and discount applied.\n\n    This function computes the portion of gain from selling shares purchased through an ESPP \n    that is subject to taxation as ordinary income or capital gains, considering the holding period.\n\n    Args:\n        purchase_price (float): The initial purchase price of one share of the stock.\n        sale_price (float): The price at which one share was sold.\n        shares (int): The number of shares sold.\n        discount (float): The ESPP discount applied to the purchase price.\n        holding_period (int): The holding period of the shares in years.\n\n    Returns:\n        taxable_income (float): The amount of income subject to ordinary tax rates.\n\n    Notes:\n        - Applicability: Useful for tax planning and filing related to ESPP gains.\n        - Constraints: Ensure accurate tracking of holding period for correct tax treatment.\n        - Considerations: Distinguish between ordinary income and capital gains tax treatment\n          depending on the holding period for shares.\n    \"\"\"\n    discounted_purchase_price = purchase_price * (1 - discount)\n    total_gain = (sale_price - discounted_purchase_price) * shares\n\n    if holding_period >= 2:\n        # Assuming two-year holding period required for favorable tax treatment\n        ordinary_income = discount * purchase_price * shares\n    else:\n        ordinary_income = total_gain\n\n    return ordinary_income",
        "statistics": {
            "number_statistics": {
                "args_numbers": 5,
                "question_numbers": 0,
                "context_numbers": 5,
                "total_numbers": 5
            },
            "operator_statistics": {
                "operators": {
                    "+": 0,
                    "-": 3,
                    "*": 4,
                    "/": 0,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 7
            },
            "code_statistics": {
                "lines": 8,
                "parentheses": 4
            }
        },
        "difficulty": 4.248495242049359,
        "context": "Jane participates in her company's Employee Stock Purchase Plan (ESPP) which offers a 15% discount on stock purchases. She bought 200 shares at a purchase price of $40 per share. After holding the shares for 18 months, she decides to sell them at $55 per share. The IRS mandates that any share held less than two years must have its gain treated entirely as ordinary income. Jane needs to calculate the taxable income from this transaction to determine her tax liability.",
        "question": "What is the taxable income from Jane's ESPP transaction? Answer to the nearest dollar.",
        "python_solution": "def solution():\n    # Define the given variables\n    purchase_price = 40.0  # Purchase price per share in dollars\n    sale_price = 55.0  # Sale price per share in dollars\n    shares = 200  # Number of shares\n    discount = 0.15  # ESPP discount\n    holding_period = 1.5  # Holding period in years (less than 2)\n\n    # Calculate the discounted purchase price per share\n    discounted_purchase_price = purchase_price * (1 - discount)\n\n    # Calculate the total gain from selling the shares\n    total_gain = (sale_price - discounted_purchase_price) * shares\n\n    # Since the holding period is less than 2 years, treat the entire gain as ordinary income\n    taxable_income = total_gain\n    \n    # Return the answer rounded to the nearest dollar\n    return round(taxable_income)\n\n# Testing the solution function\nprint(solution())",
        "ground_truth": 4200,
        "source": "FinanceReasoning-test-223",
        "question_id": "test-2017",
        "level": "hard",
        "output": [
            "To determine the taxable income from Jane's ESPP transaction, let\u2019s think through the problem step by step:\n\n1. **Understand the ESPP Discount**:\n   - Jane purchased shares at a 15% discount. This means:\n     ESPP Discount Price = 85% of Market Price\n     Market Price when assigned = $40 / 85% = $47.06 (approximately)\n\n2. **Taxable Income Calculation**:\n   - According to IRS rules, when shares are sold within 2 years:\n     - The taxable income is the difference between the fair market value at the time of purchase ($47.06) and the purchase price ($40), multiplied by the number of shares.\n\n3. **Calculate Total Taxable Income**:\n   - Using the above data:\n     Taxable Income Per Share = Market Price at Share Assignment - ESPP Purchase Price\n     Total Taxable Income = Taxable Income Per Share \u00d7 Total Shares\n     - Since gains are held for only 18 months, all gain is treated as ordinary income.\n\n4. **Emphasis on Constraints**:\n   - Result must be calculated to the nearest dollar.\n   - Units must be considered; remember, this is in USD.\n\nNow, let\u2019s generate the Python program to solve this step-by-step calculation.\n\n```python\ndef solution():\n    # Define variables name and value\n    discount_rate = 0.15\n    purchase_price = 40\n    number_of_shares = 200\n    \n    # Calculate Market Price when assigned based on ESPP\n    market_price_at_assignment = purchase_price / (1 - discount_rate)\n    \n    # Calculate taxable income per share\n    taxable_income_per_share = market_price_at_assignment - purchase_price\n    \n    # Calculate total taxable income\n    total_taxable_income = taxable_income_per_share * number_of_shares\n    \n    # Return the answer rounded to the nearest dollar\n    return round(total_taxable_income)\n```"
        ],
        "retrieval_query": "What is the taxable income from Jane's ESPP transaction? Answer to the nearest dollar.",
        "useful_functions": [
            "def calculate_annual_interest_expense(total_interest_expense: float, total_years: int) -> int:\n    \"\"\"\n    Calculate the annual interest expense using the straight-line method.\n\n    This function divides the total interest expense incurred over the entire\n    duration of a bond or similar financial instrument evenly across each\n    year using the straight-line method. The annual interest expense is rounded\n    to the nearest dollar.\n\n    Args:\n        total_interest_expense (float): The total interest expense over the\n                                        full duration of the bond or instrument.\n        total_years (int): The total number of years over which the expense is\n                           allocated.\n\n    Returns:\n        annual_interest_expense (int): The annual interest expense, rounded to\n                                       the nearest dollar.\n\n    Notes:\n        - This function assumes a straight-line allocation of interest over the\n          specified number of years.\n        - The coupon rate or interest rate is not needed when the total interest\n          expense is given.\n        - Ensure total_years is a positive integer to prevent division errors.\n    \"\"\"\n    if total_years <= 0:\n        raise ValueError(\"Total years must be a positive integer.\")\n\n    annual_interest_expense = total_interest_expense / total_years\n    return round(annual_interest_expense)"
        ],
        "usage": {
            "completion_tokens": 395,
            "prompt_tokens": 713,
            "total_tokens": 1108,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-2471",
        "article_title": "Wide-Ranging Days",
        "function": "def calculate_ema(values: list, days: int) -> float:\n    \"\"\"\n    Calculate the exponential moving average (EMA) of a list of values.\n\n    The EMA is a type of moving average that places a greater weight and significance\n    on the most recent data points. It is commonly used in financial analysis to identify\n    trends in stock prices or other financial metrics.\n\n    Args:\n        values (list): A list of numerical values to calculate the EMA for.\n        days (int): The number of periods (days) over which to calculate the EMA.\n\n    Returns:\n        ema (float): The calculated exponential moving average.\n\n    Notes:\n        - The size of `values` should be at least equal to `days`.\n        - The `days` parameter should be a positive integer.\n        - The function implementation assumes complete data points for the specified periods.\n    \"\"\"\n    if len(values) < days:\n        raise ValueError(\"The number of values must be at least equal to the number of days.\")\n    \n    k = 2 / (days + 1)\n    ema = sum(values[:days]) / days  # Start with a simple moving average for the initial period\n    for i in range(days, len(values)):\n        ema = values[i] * k + ema * (1 - k)\n    \n    return ema",
        "statistics": {
            "number_statistics": {
                "args_numbers": 2,
                "question_numbers": 1,
                "context_numbers": 14,
                "total_numbers": 15
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 1,
                    "*": 2,
                    "/": 2,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 7
            },
            "code_statistics": {
                "lines": 5,
                "parentheses": 10
            }
        },
        "difficulty": 4.248495242049359,
        "context": "An investor is analyzing the price trend of a particular stock over the past few weeks. To capture the latest price trends and smooth out fluctuations, the investor decides to calculate the 10-day Exponential Moving Average (EMA) of the stock's closing prices. The closing prices for 12 consecutive trading days are as follows: [150, 152, 153, 151, 154, 155, 158, 160, 162, 164, 166, 165]. The investor wishes to compute the latest EMA to make informed trading decisions.",
        "question": "What is the 10-day Exponential Moving Average (EMA) of the stock based on the given closing prices? Answer to two decimal places.",
        "python_solution": "def solution():\n    # Given closing prices and EMA period\n    values = [150, 152, 153, 151, 154, 155, 158, 160, 162, 164, 166, 165]\n    days = 10\n\n    # Calculate the smoothing factor\n    k = 2 / (days + 1)\n\n    # Calculate the initial simple moving average for the first 'days' prices\n    sma = sum(values[:days]) / days\n        \n    # Initialize EMA with the SMA\n    ema = sma\n\n    # Calculate EMA starting from the 'days'th data point\n    for i in range(days, len(values)):\n        ema = values[i] * k + ema * (1 - k)\n\n    # Return the final EMA rounded to two decimal places\n    return round(ema, 2)",
        "ground_truth": 159.06,
        "source": "FinanceReasoning-test-270",
        "question_id": "test-2018",
        "level": "hard",
        "output": [
            "Let's carefully analyze and solve the problem step by step using the **Emphasizing Constraints (EC)** technique:\n\n---\n\n### Step-by-step Reasoning:\n\n1. **Problem Understanding**:\n   - We need to calculate the 10-day Exponential Moving Average (EMA) of the given closing prices `[150, 152, 153, 151, 154, 155, 158, 160, 162, 164, 166, 165]`.\n   - EMA is calculated by weighting recent prices more heavily than older prices, producing a value that reacts faster to changes in price trends.\n\n2. **Constraints**:\n   - We are asked to calculate the EMA based on the past 10 days, so the calculation requires at least 10 closing prices.\n   - Adhere to the formula for EMA:\n     \\[\n     EMA_{today} = (P_{today} - EMA_{yesterday}) \\cdot \\text{Multiplier} + EMA_{yesterday}\n     \\]\n     where:\n     - \\(P_{today}\\) is today\u2019s price.\n     - Multiplier = \\( \\frac{2}{\\text{N} + 1} \\), where \\( \\text{N} \\) is the number of periods (10 here).\n   - The first EMA value is initialized using the Simple Moving Average (SMA) of the first \\( \\text{N} \\) closing prices:\n     \\[\n     SMA = \\frac{\\sum_{i=1}^N P_{i}}{N}\n     \\]\n\n3. **Plan**:\n   - Compute the initial SMA for the first 10 closing prices.\n   - Use the multiplier formula: \\( \\text{Multiplier} = \\frac{2}{10+1} \\).\n   - Iteratively calculate EMA for the remaining prices beyond 10 days.\n   - Ensure the result is accurate up to two decimal places.\n\n4. **Validation**:\n   - The provided input contains 12 closing prices, which satisfies the minimum requirement of at least 10 prices for calculating a 10-day EMA.\n   - Precisions align with financial calculations (two decimal places).\n\n5. **Final Output**:\n   - Return the calculated EMA for the latest (most recent) closing price.\n\n---\n\n### Python Code:\n```python\ndef solution():\n    # Define variables\n    closing_prices = [150, 152, 153, 151, 154, 155, 158, 160, 162, 164, 166, 165]\n    periods = 10  # The number of periods for the EMA calculation (10 days)\n    \n    # Step 1: Calculate the initial SMA for the first 'periods' closing prices\n    sma = sum(closing_prices[:periods]) / periods\n    \n    # Step 2: Calculate the multiplier\n    multiplier = 2 / (periods + 1)\n    \n    # Step 3: Initialize EMA with the SMA\n    ema = sma\n    \n    # Step 4: Iteratively calculate EMA for the remaining prices\n    for price in closing_prices[periods:]:\n        ema = (price - ema) * multiplier + ema\n    \n    # Return answer rounded to two decimal places\n    return round(ema, 2)\n```"
        ],
        "retrieval_query": "What is the 10-day Exponential Moving Average (EMA) of the stock based on the given closing prices? Answer to two decimal places.",
        "useful_functions": [
            "def calculate_ema(close_prices: list, n_periods: int) -> float:\n    \"\"\"\n    Calculate the Exponential Moving Average (EMA) for a given number of periods.\n\n    The EMA helps to smooth out price data and capture the current trend by giving\n    more weight to recent prices. It is used in technical analysis to anticipate\n    potential breakouts or identify current trends.\n\n    Args:\n        close_prices (list): A list of closing prices in chronological order.\n        n_periods (int): The number of periods over which to calculate the EMA.\n\n    Returns:\n        ema (float): The calculated exponential moving average.\n\n    Notes:\n        - Applicability: Useful for trend analysis in financial time series data.\n        - Constraints: The list of closing prices must contain at least `n_periods` values.\n        - Considerations: The first EMA value is calculated using a Simple Moving Average (SMA).\n    \"\"\"\n    # Calculate the initial SMA\n    if len(close_prices) < n_periods:\n        raise ValueError(\"The number of close prices must be at least equal to the number of periods.\")\n    \n    sma = sum(close_prices[:n_periods]) / n_periods\n\n    # Calculate the multiplier for weighting the EMA\n    multiplier = 2 / (n_periods + 1)\n    \n    # Calculate the initial EMA using the SMA\n    ema = sma\n\n    # Calculate the EMA for the rest of the periods\n    for price in close_prices[n_periods:]:\n        ema = (price - ema) * multiplier + ema\n    \n    return ema",
            "def calculate_exponential_moving_average(prices: list, period: int) -> list:\n    \"\"\"\n    Calculate the exponential moving average (EMA) of a list of prices over a specified period.\n\n    This function computes the exponential moving average, which gives greater weight to more \n    recent prices, making it more responsive to new information than the simple moving average.\n\n    Args:\n        prices (list): A list of prices (e.g., daily closing prices of a stock).\n        period (int): The number of periods over which to calculate the EMA.\n\n    Returns:\n        ema (list): A list of calculated EMA values corresponding to the input prices.\n\n    Notes:\n        - The period must be greater than 0 and less than or equal to the length of the prices list.\n        - The EMA calculation starts with the simple moving average for the first EMA value.\n        - The returned list will exclude the first (period - 1) elements because they are used to\n          initialize the calculation.\n        - The input list must contain numeric values.\n    \"\"\"\n    if period <= 0 or period > len(prices):\n        raise ValueError(\"Period must be greater than 0 and less than or equal to the length of the prices list.\")\n\n    smoothing_factor = 2 / (period + 1)\n    ema = [sum(prices[:period]) / period]  # Start with the SMA for the first value\n\n    for price in prices[period:]:\n        new_ema = (price * smoothing_factor) + ema[-1] * (1 - smoothing_factor)\n        ema.append(new_ema)\n    \n    return ema",
            "def calculate_exponential_moving_average(prices: list, smoothing: float = 2, days: int = 20) -> list:\n    \"\"\"\n    Calculate the Exponential Moving Average (EMA) of a list of prices.\n\n    This function computes the EMA, which emphasizes the latest price data more heavily \n    by using an exponentially decreasing weight for past observations. It is used in \n    financial markets to analyze data points like stock prices.\n\n    Args:\n        prices (list): A list of prices in chronological order, where each element\n                       represents the price for a given day.\n        smoothing (float): The smoothing factor typically used as 2. It determines how\n                           much weight is applied to the most recent prices. Default is 2.\n        days (int): The number of periods (days) to calculate the EMA for. Typically a \n                    10, 20, 50, or similar period is used. Default is 20.\n\n    Returns:\n        ema_values (list): A list of EMA values calculated for each price in the input list\n                           starting from the (days+1)th day. The first (days) entries will \n                           be None to indicate insufficient data to compute the EMA.\n\n    Notes:\n        - Applicability: Useful in financial analysis for smoothing out price data to \n          identify trends.\n        - Constraints: Requires at least `days` number of price entries to start calculating EMAs.\n        - Considerations: Different periods may result in different trend sensitivities;\n          shorter EMAs react quicker to price changes than longer ones.\n    \"\"\"\n    if len(prices) < days:\n        raise ValueError(\"Number of prices should be at least equal to the 'days' parameter.\")\n\n    multiplier = smoothing / (1 + days)\n    ema_values = [None] * (days - 1)\n    sma = sum(prices[:days]) / days\n    ema_values.append(sma)\n\n    for price in prices[days:]:\n        new_ema = (price - ema_values[-1]) * multiplier + ema_values[-1]\n        ema_values.append(new_ema)\n\n    return ema_values"
        ],
        "usage": {
            "completion_tokens": 674,
            "prompt_tokens": 1574,
            "total_tokens": 2248,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-333",
        "article_title": "Volume Price Trend Indicator (VPT)",
        "function": "def calculate_volume_price_trend(prices: list, volumes: list) -> list:\n    \"\"\"\n    Calculate the Volume Price Trend (VPT) for a series of prices and volumes.\n\n    The Volume Price Trend indicator helps determine the price direction and strength\n    of price change by using the cumulative volume and percentage change in price.\n\n    Args:\n        prices (list): A list of historical stock prices.\n        volumes (list): A list of trading volumes corresponding to the prices.\n\n    Returns:\n        vpt (list): A list of calculated VPT values, corresponding to the price\n                    and volume lists. The first element is set to 0, \n                    as a starting point for cumulative calculations.\n\n    Notes:\n        - Applicability: Used in technical analysis to assess the price trend and \n          volume relationship for securities.\n        - Constraints: The lengths of `prices` and `volumes` lists must be the same.\n          They should be available for the same time periods.\n        - Considerations: Ensure prices and volumes are non-negative. This function\n          assumes continuous time periods between each step in the lists.\n    \"\"\"\n    if len(prices) != len(volumes):\n        raise ValueError(\"The length of prices and volumes lists must be the same.\")\n    \n    vpt = [0]  # Initialize the VPT list with the first value as 0\n\n    for i in range(1, len(prices)):\n        price_change = (prices[i] - prices[i - 1]) / prices[i - 1]\n        vpt_value = vpt[i - 1] + price_change * volumes[i]\n        vpt.append(vpt_value)\n\n    return vpt",
        "statistics": {
            "number_statistics": {
                "args_numbers": 2,
                "question_numbers": 0,
                "context_numbers": 5,
                "total_numbers": 5
            },
            "operator_statistics": {
                "operators": {
                    "+": 1,
                    "-": 4,
                    "*": 1,
                    "/": 1,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 7
            },
            "code_statistics": {
                "lines": 6,
                "parentheses": 8
            }
        },
        "difficulty": 4.248495242049359,
        "context": "A stock analyst is examining the trading activity of a tech company over a five-day period to understand the relationship between price movements and trading volumes. The stock prices (in dollars) over these five days are recorded as [120, 123, 121, 125, 130], and the corresponding daily trading volumes (in thousands of shares) are [1500, 1600, 1550, 1700, 1800]. The analyst wants to calculate the Volume Price Trend (VPT) to assess the price trend and volume relationship for this tech company's stock.",
        "question": "What is the Volume Price Trend (VPT) value at the end of the fifth day? Answer to two decimal places.",
        "python_solution": "def solution():\n    # Define the list of stock prices and corresponding volumes\n    prices = [120, 123, 121, 125, 130]\n    volumes = [1500, 1600, 1550, 1700, 1800]\n\n    # Initialize the VPT list with the first value as 0\n    vpt = [0]\n\n    # Calculate the VPT for each day\n    for i in range(1, len(prices)):\n        price_change = (prices[i] - prices[i - 1]) / prices[i - 1]\n        vpt_value = vpt[i - 1] + price_change * volumes[i]\n        vpt.append(vpt_value)\n\n    # Return the VPT value on the fifth day\n    return round(vpt[-1], 2)",
        "ground_truth": 143.0,
        "source": "FinanceReasoning-test-272",
        "question_id": "test-2019",
        "level": "hard",
        "output": [
            "### Step-by-step Problem Analysis:\n\nWe are tasked with calculating the **Volume Price Trend (VPT)** at the end of the fifth day using the given stock prices and volumes. Here's the step-by-step plan:\n\n1. **Emphasizing Constraints (EC):**\n   - The lengths of both `prices` and `volumes` lists are the same (5 elements), which satisfies the primary constraint of the function.\n   - The stock prices and trading volumes are non-negative, ensuring valid inputs.\n   - The VPT starts with an initial value of `0` on day 1 and is calculated cumulatively over time.\n\n2. **Formula for Volume Price Trend (VPT):**\n   For a given day `i`, VPT is calculated as:\n   \\[\n   \\text{VPT}[i] = \\text{VPT}[i-1] + \\frac{\\text{prices}[i] - \\text{prices}[i-1]}{\\text{prices}[i-1]} \\times \\text{volumes}[i]\n   \\]\n\n   - `prices[i]` is the current day's price.\n   - `prices[i-1]` is the previous day's price.\n   - `volumes[i]` is the current day's trading volume.\n   - \\(\\frac{\\text{prices}[i] - \\text{prices}[i-1]}{\\text{prices}[i-1]}\\) is the percentage price change.\n\n3. **Plan for Calculation and Output:**\n   - Using the given stock prices `[120, 123, 121, 125, 130]` and trading volumes `[1500, 1600, 1550, 1700, 1800]`, compute the cumulative VPT for days 2 through 5.\n   - Round the final result to **two decimal places** as required.\n\n### Python Program:\n```python\ndef solution():\n    # Define variables: stock prices and trading volumes\n    prices = [120, 123, 121, 125, 130]\n    volumes = [1500, 1600, 1550, 1700, 1800]\n    \n    # Initialize VPT list with the first day's value as 0\n    vpt = [0]\n    \n    # Calculate VPT iteratively for subsequent days\n    for i in range(1, len(prices)):\n        price_change = (prices[i] - prices[i - 1]) / prices[i - 1]  # Percentage price change\n        vpt_value = vpt[i - 1] + price_change * volumes[i]          # Cumulative VPT calculation\n        vpt.append(vpt_value)\n    \n    # The VPT value at the end of the fifth day\n    answer = round(vpt[-1], 2)  # Round to two decimal places as required\n    \n    return answer\n```"
        ],
        "retrieval_query": "What is the Volume Price Trend (VPT) value at the end of the fifth day? Answer to two decimal places.",
        "useful_functions": [
            "def calculate_volume_price_trend(prices: list, volumes: list) -> list:\n    \"\"\"\n    Calculate the Volume Price Trend (VPT) for a series of prices and volumes.\n\n    The Volume Price Trend indicator helps determine the price direction and strength\n    of price change by using the cumulative volume and percentage change in price.\n\n    Args:\n        prices (list): A list of historical stock prices.\n        volumes (list): A list of trading volumes corresponding to the prices.\n\n    Returns:\n        vpt (list): A list of calculated VPT values, corresponding to the price\n                    and volume lists. The first element is set to 0, \n                    as a starting point for cumulative calculations.\n\n    Notes:\n        - Applicability: Used in technical analysis to assess the price trend and \n          volume relationship for securities.\n        - Constraints: The lengths of `prices` and `volumes` lists must be the same.\n          They should be available for the same time periods.\n        - Considerations: Ensure prices and volumes are non-negative. This function\n          assumes continuous time periods between each step in the lists.\n    \"\"\"\n    if len(prices) != len(volumes):\n        raise ValueError(\"The length of prices and volumes lists must be the same.\")\n    \n    vpt = [0]  # Initialize the VPT list with the first value as 0\n\n    for i in range(1, len(prices)):\n        price_change = (prices[i] - prices[i - 1]) / prices[i - 1]\n        vpt_value = vpt[i - 1] + price_change * volumes[i]\n        vpt.append(vpt_value)\n\n    return vpt"
        ],
        "usage": {
            "completion_tokens": 601,
            "prompt_tokens": 824,
            "total_tokens": 1425,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-2843",
        "article_title": "Expiration Date (Derivatives)",
        "function": "def calculate_option_greeks_delta(option_type: str, asset_price: float, strike_price: float, time_to_expiry: float, \n                                  volatility: float, risk_free_rate: float) -> float:\n    \"\"\"\n    Estimate the delta of an option.\n\n    This function approximates the delta of an option, which measures the rate\n    of change of the option price with respect to changes in the underlying asset price.\n\n    Args:\n        option_type (str): The type of the option ('call' or 'put').\n        asset_price (float): The current price of the underlying asset.\n        strike_price (float): The strike price of the option.\n        time_to_expiry (float): Time until expiry (in years).\n        volatility (float): The volatility of the underlying asset (annualized).\n        risk_free_rate (float): The annual risk-free interest rate.\n\n    Returns:\n        delta (float): The delta of the option.\n\n    Notes:\n        - Applies to both call and put options.\n        - The option type must be 'call' or 'put'.\n        - High volatility and longer time to expiry usually increase the absoluteness of delta.\n        - Delta is positive for call options and negative for put options, within theoretical bounds.\n    \"\"\"\n    from math import exp, sqrt\n    from scipy.stats import norm\n    \n    d1 = (log(asset_price / strike_price) + (risk_free_rate + 0.5 * volatility ** 2) * time_to_expiry) / (volatility * sqrt(time_to_expiry))\n    \n    if option_type.lower() == 'call':\n        delta = norm.cdf(d1)\n    elif option_type.lower() == 'put':\n        delta = norm.cdf(d1) - 1\n    else:\n        raise ValueError(\"Invalid option type. Must be 'call' or 'put'.\")\n    \n    return delta",
        "statistics": {
            "number_statistics": {
                "args_numbers": 6,
                "question_numbers": 0,
                "context_numbers": 5,
                "total_numbers": 5
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 0,
                    "*": 3,
                    "/": 2,
                    "%": 0,
                    "**": 1
                },
                "total_operators": 8
            },
            "code_statistics": {
                "lines": 4,
                "parentheses": 10
            }
        },
        "difficulty": 4.276666119016055,
        "context": "An investor is evaluating the delta of a European call option on a company's stock. The current price of the stock is $150, and the strike price of the option is set at $140. The option will expire in 0.5 years. The annualized volatility of the stock is estimated at 25%, and the annual risk-free interest rate is 2%. Delta measures the sensitivity of the option's price with respect to changes in the price of the underlying stock, and it is essential for assessing risk in an options portfolio.",
        "question": "What is the delta of the European call option? Answer as a decimal to four decimal places.",
        "python_solution": "from math import exp, sqrt, log\nfrom scipy.stats import norm\n\ndef solution():\n    # Given parameters\n    option_type = 'call'\n    asset_price = 150  # Current price of the stock\n    strike_price = 140  # Strike price of the option\n    time_to_expiry = 0.5  # Time until expiry in years\n    volatility = 0.25  # Annualized volatility\n    risk_free_rate = 0.02  # Annual risk-free interest rate\n\n    # Calculate d1 according to the Black-Scholes formula component\n    d1 = (log(asset_price / strike_price) + \n          (risk_free_rate + 0.5 * volatility ** 2) * time_to_expiry) / (volatility * sqrt(time_to_expiry))\n    \n    # Calculate delta for a call option\n    delta = norm.cdf(d1)\n    \n    # Return the delta to four decimal places\n    return round(delta, 4)\n\n# Example invocation\nresult = solution()\nresult",
        "ground_truth": 0.7038,
        "source": "FinanceReasoning-test-139",
        "question_id": "test-2020",
        "level": "hard",
        "output": [
            "Step-by-step reasoning:\n\n1. **Understand the parameters**:\n    - We are calculating the delta of a European call option based on the Black-Scholes model.\n    - The parameters provided are:\n        - `Current stock price (S)`: $150\n        - `Strike price (K)`: $140\n        - `Time to expiry (T)`: 0.5 years\n        - `Volatility (\u03c3)`: 25% (or 0.25 in decimal form)\n        - `Risk-free rate (r)`: 2% (or 0.02 in decimal form)\n    \n2. **Apply the Black-Scholes model formula**:\n    - The formula for delta of a European call option is \\( \\Delta = N(d_1) \\), where \\( N \\) is the cumulative distribution function (CDF) of the standard normal distribution.\n    - \\( d_1 = \\frac{\\ln(S/K) + (r + \\frac{\\sigma^2}{2})T}{\\sigma \\sqrt{T}} \\)\n  \n3. **Constraints and precision (EC)**:\n    - The option type is a call, so delta must be \\( N(d_1) \\), which falls within [0, 1].\n    - The result should be returned as a decimal to four decimal places.\n\n4. **Implementation**:\n    - We'll use the provided reference formula for delta calculation and break it into functional steps.\n    - Python's `scipy.stats.norm` module will be used to calculate the normal CDF, \\( N(d_1) \\).\n\nNow, let me construct the Python program:\n\n```python\ndef solution():\n    # Define variables name and value\n    current_stock_price = 150      # S\n    strike_price = 140             # K\n    time_to_expiry = 0.5           # T (in years)\n    annual_volatility = 0.25       # \u03c3\n    risk_free_rate = 0.02          # r\n\n    # Import necessary modules\n    from math import log, sqrt\n    from scipy.stats import norm\n    \n    # d1 calculation\n    d1 = (log(current_stock_price / strike_price) \n          + (risk_free_rate + 0.5 * annual_volatility ** 2) * time_to_expiry) / (annual_volatility * sqrt(time_to_expiry))\n    \n    # Delta for a call option (N(d1))\n    call_delta = norm.cdf(d1)\n\n    # Return rounded result to four decimal places\n    return round(call_delta, 4)\n\n```"
        ],
        "retrieval_query": "What is the delta of the European call option? Answer as a decimal to four decimal places.",
        "useful_functions": [
            "def calculate_option_greeks_delta(option_type: str, asset_price: float, strike_price: float, time_to_expiry: float, \n                                  volatility: float, risk_free_rate: float) -> float:\n    \"\"\"\n    Estimate the delta of an option.\n\n    This function approximates the delta of an option, which measures the rate\n    of change of the option price with respect to changes in the underlying asset price.\n\n    Args:\n        option_type (str): The type of the option ('call' or 'put').\n        asset_price (float): The current price of the underlying asset.\n        strike_price (float): The strike price of the option.\n        time_to_expiry (float): Time until expiry (in years).\n        volatility (float): The volatility of the underlying asset (annualized).\n        risk_free_rate (float): The annual risk-free interest rate.\n\n    Returns:\n        delta (float): The delta of the option.\n\n    Notes:\n        - Applies to both call and put options.\n        - The option type must be 'call' or 'put'.\n        - High volatility and longer time to expiry usually increase the absoluteness of delta.\n        - Delta is positive for call options and negative for put options, within theoretical bounds.\n    \"\"\"\n    from math import exp, sqrt\n    from scipy.stats import norm\n    \n    d1 = (log(asset_price / strike_price) + (risk_free_rate + 0.5 * volatility ** 2) * time_to_expiry) / (volatility * sqrt(time_to_expiry))\n    \n    if option_type.lower() == 'call':\n        delta = norm.cdf(d1)\n    elif option_type.lower() == 'put':\n        delta = norm.cdf(d1) - 1\n    else:\n        raise ValueError(\"Invalid option type. Must be 'call' or 'put'.\")\n    \n    return delta"
        ],
        "usage": {
            "completion_tokens": 537,
            "prompt_tokens": 849,
            "total_tokens": 1386,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-1644",
        "article_title": "Debt Issue",
        "function": "def calculate_weighted_average_cost_of_capital(equity_cost: float, debt_cost: float, \n                                               equity_value: float, debt_value: float, \n                                               tax_rate: float) -> float:\n    \"\"\"\n    Calculate the Weighted Average Cost of Capital (WACC) for a company.\n\n    This function computes the WACC, which is a measure of a company's cost of \n    capital from all sources, including debt and equity. It is widely used in \n    corporate finance to evaluate investment opportunities and financial \n    strategies.\n\n    Args:\n        equity_cost (float): The cost of equity capital, often derived from \n                             models like CAPM.\n        debt_cost (float): The after-tax cost of debt.\n        equity_value (float): The market value of the company's equity.\n        debt_value (float): The market value of the company's debt.\n        tax_rate (float): The corporate tax rate applicable to the company.\n\n    Returns:\n        wacc (float): The weighted average cost of capital.\n\n    Notes:\n        - Applicability: Applies to companies with both debt and equity financing.\n        - Constraints: Assumes market values are available and tax rate is constant.\n        - Considerations: Accurate cost estimates and market values are critical.\n    \"\"\"\n    total_value = equity_value + debt_value\n    wacc = ((equity_value / total_value) * equity_cost) + \\\n           ((debt_value / total_value) * debt_cost * (1 - tax_rate))\n    return wacc",
        "statistics": {
            "number_statistics": {
                "args_numbers": 5,
                "question_numbers": 0,
                "context_numbers": 5,
                "total_numbers": 5
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 1,
                    "*": 3,
                    "/": 2,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 8
            },
            "code_statistics": {
                "lines": 4,
                "parentheses": 10
            }
        },
        "difficulty": 4.276666119016055,
        "context": "A technology company is considering a new investment project and needs to determine its Weighted Average Cost of Capital (WACC) to make informed financial decisions. The company has a cost of equity calculated at 8% and an after-tax cost of debt at 4%. The market values of the company's equity and debt stand at 2,000,000 and 1,000,000, respectively. The corporate tax rate is 25%.",
        "question": "What is the Weighted Average Cost of Capital (WACC) for the company? Answer as a percentage to two decimal places.",
        "python_solution": "def solution():\n    # Define variables and their values\n    equity_cost = 0.08  # 8% cost of equity\n    debt_cost = 0.04   # 4% after-tax cost of debt\n    equity_value = 2000000  # Market value of equity\n    debt_value = 1000000  # Market value of debt\n    tax_rate = 0.25  # Corporate tax rate\n\n    # Calculate total market value of the company\n    total_value = equity_value + debt_value\n\n    # Calculate WACC\n    wacc = ((equity_value / total_value) * equity_cost) + \\\n           ((debt_value / total_value) * debt_cost * (1 - tax_rate))\n    \n    # Return the WACC as a percentage to two decimal places\n    return round(wacc * 100, 2)\n\n# Call the solution function to get the WACC\nsolution()",
        "ground_truth": 6.33,
        "source": "FinanceReasoning-test-162",
        "question_id": "test-2021",
        "level": "hard",
        "output": [
            "To calculate the Weighted Average Cost of Capital (WACC) for the company as described in the problem, let's proceed step-by-step:\n\n### Step-by-Step Solution Using EC (Emphasizing Constraints):\n\n1. **Understand the problem constraints and formula**:\n   - The Weighted Average Cost of Capital (WACC) is calculated as:\n     \\[ \\text{WACC} = \\left( \\frac{\\text{Equity Value}}{\\text{Total Value}} \\cdot \\text{Cost of Equity} \\right) + \\left( \\frac{\\text{Debt Value}}{\\text{Total Value}} \\cdot \\text{After-Tax Cost of Debt} \\right) \\]\n   - The after-tax cost of debt is adjusted as:\n     \\[ \\text{After-Tax Cost of Debt} = \\text{Cost of Debt} \\cdot (1 - \\text{Tax Rate}) \\]\n   - Constraints:\n     - All inputs (e.g., equity and debt market values, costs, and tax rate) are non-negative.\n     - Tax rate should be expressed as a decimal (e.g., 25% = 0.25).\n     - The answer must be rounded as a percentage to **two decimal places**.\n\n2. **Given values in the problem**:\n   - Cost of Equity = 8% = 0.08\n   - After-Tax Cost of Debt = 4% = 0.04\n   - Market Value of Equity = 2,000,000\n   - Market Value of Debt = 1,000,000\n   - Corporate Tax Rate = 25% = 0.25\n\n3. **Calculate total value and weights**:\n   - Total value of the company = Equity Value + Debt Value = 2,000,000 + 1,000,000 = 3,000,000.\n   - Weight of equity = Equity Value / Total Value = 2,000,000 / 3,000,000 = \\( \\frac{2}{3} \\).\n   - Weight of debt = Debt Value / Total Value = 1,000,000 / 3,000,000 = \\( \\frac{1}{3} \\).\n\n4. **Calculate the after-tax cost of debt**:\n   \\[ \\text{After-Tax Cost of Debt} = 0.04 \\cdot (1 - 0.25) = 0.04 \\cdot 0.75 = 0.03 \\]\n\n5. **Plug values into the WACC formula**:\n   \\[\n   \\text{WACC} = \\left( \\frac{2}{3} \\cdot 0.08 \\right) + \\left( \\frac{1}{3} \\cdot 0.03 \\right)\n   = 0.0533 + 0.01 = 0.0633\n   \\]\n\n6. **Convert WACC to percentage**:\n   - WACC = 0.0633 = 6.33% (rounded to **two decimal places**).\n\nWith this step-by-step understanding, let's write the Python program to compute this accurately:\n\n### Python Program:\n```python\ndef solution():\n    # Define variables name and value\n    cost_of_equity = 0.08  # 8%\n    after_tax_cost_of_debt = 0.04  # 4%\n    equity_market_value = 2000000  # $2,000,000\n    debt_market_value = 1000000    # $1,000,000\n    tax_rate = 0.25                # 25%\n    \n    # Calculate the total value of the firm\n    total_value = equity_market_value + debt_market_value\n    \n    # Calculate the weights of equity and debt\n    equity_weight = equity_market_value / total_value\n    debt_weight = debt_market_value / total_value\n    \n    # Adjust the cost of debt for taxes\n    after_tax_cost_of_debt = after_tax_cost_of_debt * (1 - tax_rate)\n    \n    # Calculate WACC\n    wacc = (equity_weight * cost_of_equity) + (debt_weight * after_tax_cost_of_debt)\n    \n    # Convert WACC to percentage and round to two decimal places\n    answer = round(wacc * 100, 2)\n    \n    return answer\n```"
        ],
        "retrieval_query": "What is the Weighted Average Cost of Capital (WACC) for the company? Answer as a percentage to two decimal places.",
        "useful_functions": [
            "def calculate_wacc(equity_market_value: float, debt_market_value: float, cost_of_equity: float, \n                   cost_of_debt: float, tax_rate: float) -> float:\n    \"\"\"\n    Calculate the Weighted Average Cost of Capital (WACC) for a company.\n\n    This function computes the WACC, which represents a company's average after-tax\n    cost of capital from all sources, including equity and debt. It combines the cost \n    of both equity and debt, weighted by their respective proportions in the total \n    capital used by the company.\n\n    Args:\n        equity_market_value (float): Market value of the firm's equity.\n        debt_market_value (float): Market value of the firm's debt.\n        cost_of_equity (float): Cost of equity, representing the required rate \n                                of return for equity investors.\n        cost_of_debt (float): Cost of debt, representing the effective rate paid \n                              on the company's issued debt.\n        tax_rate (float): Corporate tax rate, used to calculate the after-tax cost of debt.\n\n    Returns:\n        wacc (float): The calculated Weighted Average Cost of Capital (WACC).\n\n    Notes:\n        - Applicability: Useful for assessing the cost of capital for businesses \n          that use both equity and debt financing.\n        - Constraints: The equity and debt market values should be positive and \n          represent the total financing. The tax rate should be between 0 and 1.\n        - Considerations: It assumes taxes are constant and ignores complications \n          such as different classes of equity with different costs.\n    \"\"\"\n    total_value = equity_market_value + debt_market_value\n    equity_weight = equity_market_value / total_value\n    debt_weight = debt_market_value / total_value\n    after_tax_cost_of_debt = cost_of_debt * (1 - tax_rate)\n\n    wacc = (equity_weight * cost_of_equity) + (debt_weight * after_tax_cost_of_debt)\n    \n    return wacc",
            "def calculate_wacc(equity_value: float, equity_cost: float, debt_value: float, debt_cost: float, preferred_value: float = 0.0, preferred_cost: float = 0.0) -> float:\n    \"\"\"\n    Calculate the Weighted Average Cost of Capital (WACC).\n\n    This function calculates the WACC, which is the average rate of return a company must earn on its\n    investments to satisfy its stakeholders (equity, debt, and optionally preferred stock).\n\n    Args:\n        equity_value (float): The market value of the company's equity.\n        equity_cost (float): The cost of equity (expected return).\n        debt_value (float): The market value of the company's debt.\n        debt_cost (float): The cost of debt (interest rate).\n        preferred_value (float, optional): The market value of preferred stock. Defaults to 0.0.\n        preferred_cost (float, optional): The cost of preferred stock (dividend rate). Defaults to 0.0.\n\n    Returns:\n        wacc (float): The weighted average cost of capital.\n\n    Notes:\n        - Applicability: This function is applicable for companies looking to calculate their WACC as a benchmark\n          for investment evaluation.\n        - Constraints: Assumes all values provided are non-negative and that the sum of equity_value, debt_value,\n          and preferred_value is greater than zero.\n        - Considerations: The costs used should reflect market conditions and expectations; tax shields are not\n          considered in this basic version.\n    \"\"\"\n    total_value = equity_value + debt_value + preferred_value\n    if total_value == 0:\n        raise ValueError(\"The sum of equity, debt, and preferred stock values must be greater than zero.\")\n\n    weight_equity = equity_value / total_value\n    weight_debt = debt_value / total_value\n    weight_preferred = preferred_value / total_value\n\n    wacc = (weight_equity * equity_cost) + (weight_debt * debt_cost) + (weight_preferred * preferred_cost)\n    \n    return wacc",
            "def calculate_weighted_average_cost_of_capital(equity_cost: float, debt_cost: float, \n                                               equity_value: float, debt_value: float, \n                                               tax_rate: float) -> float:\n    \"\"\"\n    Calculate the Weighted Average Cost of Capital (WACC) for a company.\n\n    This function computes the WACC, which is a measure of a company's cost of \n    capital from all sources, including debt and equity. It is widely used in \n    corporate finance to evaluate investment opportunities and financial \n    strategies.\n\n    Args:\n        equity_cost (float): The cost of equity capital, often derived from \n                             models like CAPM.\n        debt_cost (float): The after-tax cost of debt.\n        equity_value (float): The market value of the company's equity.\n        debt_value (float): The market value of the company's debt.\n        tax_rate (float): The corporate tax rate applicable to the company.\n\n    Returns:\n        wacc (float): The weighted average cost of capital.\n\n    Notes:\n        - Applicability: Applies to companies with both debt and equity financing.\n        - Constraints: Assumes market values are available and tax rate is constant.\n        - Considerations: Accurate cost estimates and market values are critical.\n    \"\"\"\n    total_value = equity_value + debt_value\n    wacc = ((equity_value / total_value) * equity_cost) + \\\n           ((debt_value / total_value) * debt_cost * (1 - tax_rate))\n    return wacc"
        ],
        "usage": {
            "completion_tokens": 914,
            "prompt_tokens": 1591,
            "total_tokens": 2505,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-2452",
        "article_title": "Weighted Average Cost of Capital\u00a0(WACC)",
        "function": "def calculate_wacc(equity_market_value: float, debt_market_value: float, cost_of_equity: float, \n                   cost_of_debt: float, tax_rate: float) -> float:\n    \"\"\"\n    Calculate the Weighted Average Cost of Capital (WACC) for a company.\n\n    This function computes the WACC, which represents a company's average after-tax\n    cost of capital from all sources, including equity and debt. It combines the cost \n    of both equity and debt, weighted by their respective proportions in the total \n    capital used by the company.\n\n    Args:\n        equity_market_value (float): Market value of the firm's equity.\n        debt_market_value (float): Market value of the firm's debt.\n        cost_of_equity (float): Cost of equity, representing the required rate \n                                of return for equity investors.\n        cost_of_debt (float): Cost of debt, representing the effective rate paid \n                              on the company's issued debt.\n        tax_rate (float): Corporate tax rate, used to calculate the after-tax cost of debt.\n\n    Returns:\n        wacc (float): The calculated Weighted Average Cost of Capital (WACC).\n\n    Notes:\n        - Applicability: Useful for assessing the cost of capital for businesses \n          that use both equity and debt financing.\n        - Constraints: The equity and debt market values should be positive and \n          represent the total financing. The tax rate should be between 0 and 1.\n        - Considerations: It assumes taxes are constant and ignores complications \n          such as different classes of equity with different costs.\n    \"\"\"\n    total_value = equity_market_value + debt_market_value\n    equity_weight = equity_market_value / total_value\n    debt_weight = debt_market_value / total_value\n    after_tax_cost_of_debt = cost_of_debt * (1 - tax_rate)\n\n    wacc = (equity_weight * cost_of_equity) + (debt_weight * after_tax_cost_of_debt)\n    \n    return wacc",
        "statistics": {
            "number_statistics": {
                "args_numbers": 5,
                "question_numbers": 0,
                "context_numbers": 5,
                "total_numbers": 5
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 1,
                    "*": 3,
                    "/": 2,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 8
            },
            "code_statistics": {
                "lines": 6,
                "parentheses": 6
            }
        },
        "difficulty": 4.276666119016055,
        "context": "Crestwood Manufacturing is evaluating its overall cost of financing to make strategic decisions about future investments. The company has a market value of equity currently standing at 15 million dollars and a market value of debt amounting to 5 million dollars. The expected return required by equity investors, or the cost of equity, is 12%. Crestwood has managed to negotiate a cost of debt at an effective rate of 5%. The corporate tax rate applicable to the company is 25%.\n\nIn order to proceed with its investment plans, the company wants to accurately understand its Weighted Average Cost of Capital (WACC), which will give Crestwood a clearer view of the minimum return it needs from investments to maintain its market value.",
        "question": "What is the Weighted Average Cost of Capital (WACC) for Crestwood Manufacturing? Answer as a percentage to two decimal places.",
        "python_solution": "def solution():\n    # Define the market values and costs\n    equity_market_value = 15000000  # in dollars\n    debt_market_value = 5000000     # in dollars\n    cost_of_equity = 0.12           # 12%\n    cost_of_debt = 0.05             # 5%\n    tax_rate = 0.25                 # 25%\n\n    # Calculate total market value\n    total_value = equity_market_value + debt_market_value\n    \n    # Calculate the weight of equity and debt\n    equity_weight = equity_market_value / total_value\n    debt_weight = debt_market_value / total_value\n    \n    # Compute the after-tax cost of debt\n    after_tax_cost_of_debt = cost_of_debt * (1 - tax_rate)\n    \n    # Calculate the WACC\n    wacc = (equity_weight * cost_of_equity) + (debt_weight * after_tax_cost_of_debt)\n    \n    # Convert to percentage and round to two decimal places\n    wacc_percentage = wacc * 100\n    \n    # Return the final WACC as a percentage to two decimal places\n    return round(wacc_percentage, 2)\n\n# Calling the solution function\nsolution()",
        "ground_truth": 9.94,
        "source": "FinanceReasoning-test-179",
        "question_id": "test-2022",
        "level": "hard",
        "output": [
            "### Step-by-Step Solution:\n\n#### Analyzing the Problem\nWe need to calculate the Weighted Average Cost of Capital (WACC) for Crestwood Manufacturing using the information provided. The WACC is calculated as a weighted sum of the cost of equity and the after-tax cost of debt, based on their respective weights in the company's capital structure.\n\n#### Formula for WACC:\n\\[\nWACC = \\left( \\frac{\\text{Equity Market Value}}{\\text{Total Market Value}} \\times \\text{Cost of Equity} \\right) + \\left( \\frac{\\text{Debt Market Value}}{\\text{Total Market Value}} \\times \\text{After-Tax Cost of Debt} \\right)\n\\]\n\nWhere:\n- **Equity Market Value**: Total market valuation of equity in the company.\n- **Debt Market Value**: Total market valuation of debt in the company.\n- **Cost of Equity**: Required return rate by equity investors.\n- **Cost of Debt**: Effective rate paid on company debt.\n- **After-Tax Cost of Debt**: \\(\\text{Cost of Debt} \\times (1 - \\text{Tax Rate})\\).\n- **Total Market Value**: \\(\\text{Equity Market Value} + \\text{Debt Market Value}\\).\n\n#### Input Values:\n- Equity Market Value = 15,000,000 USD\n- Debt Market Value = 5,000,000 USD\n- Cost of Equity = 12% (0.12 in decimal)\n- Cost of Debt = 5% (0.05 in decimal)\n- Corporate Tax Rate = 25% (0.25 in decimal)\n\n#### Emphasizing Constraints (EC):\n1. The tax rate should be applied as a decimal precision: \\(0.25\\).\n2. The cost of equity and debt should also remain as decimals: \\(0.12\\) and \\(0.05\\), respectively.\n3. The answer should be returned as a percentage rounded to two decimal places.\n\n#### Steps:\n1. Calculate the total market value: \\( \\text{Total Market Value} = \\text{Equity Market Value} + \\text{Debt Market Value}\\).\n2. Calculate the weights of equity and debt:\n   - \\( \\text{Weight of Equity} = \\frac{\\text{Equity Market Value}}{\\text{Total Market Value}}\\)\n   - \\( \\text{Weight of Debt} = \\frac{\\text{Debt Market Value}}{\\text{Total Market Value}}\\)\n3. Compute the after-tax cost of debt: \\( \\text{After-Tax Cost of Debt} = \\text{Cost of Debt} \\times (1 - \\text{Tax Rate})\\).\n4. Use the WACC formula to calculate WACC.\n5. Convert the result back to a percentage and round it to two decimal places.\n\n#### Python Program:\n```python\ndef solution():\n    # Define variables name and value\n    equity_market_value = 15_000_000  # Market value of equity\n    debt_market_value = 5_000_000    # Market value of debt\n    cost_of_equity = 0.12            # Cost of equity as decimal (12%)\n    cost_of_debt = 0.05              # Cost of debt as decimal (5%)\n    corporate_tax_rate = 0.25        # Corporate tax rate as decimal (25%)\n\n    # Total market value\n    total_market_value = equity_market_value + debt_market_value\n\n    # Weights of equity and debt\n    weight_of_equity = equity_market_value / total_market_value\n    weight_of_debt = debt_market_value / total_market_value\n\n    # After-tax cost of debt\n    after_tax_cost_of_debt = cost_of_debt * (1 - corporate_tax_rate)\n\n    # Calculate WACC\n    wacc = (weight_of_equity * cost_of_equity) + (weight_of_debt * after_tax_cost_of_debt)\n    \n    # Convert WACC to percentage and round to two decimal places\n    return round(wacc * 100, 2)\n```"
        ],
        "retrieval_query": "What is the Weighted Average Cost of Capital (WACC) for Crestwood Manufacturing? Answer as a percentage to two decimal places.",
        "useful_functions": [
            "def calculate_wacc(equity_market_value: float, debt_market_value: float, cost_of_equity: float, \n                   cost_of_debt: float, tax_rate: float) -> float:\n    \"\"\"\n    Calculate the Weighted Average Cost of Capital (WACC) for a company.\n\n    This function computes the WACC, which represents a company's average after-tax\n    cost of capital from all sources, including equity and debt. It combines the cost \n    of both equity and debt, weighted by their respective proportions in the total \n    capital used by the company.\n\n    Args:\n        equity_market_value (float): Market value of the firm's equity.\n        debt_market_value (float): Market value of the firm's debt.\n        cost_of_equity (float): Cost of equity, representing the required rate \n                                of return for equity investors.\n        cost_of_debt (float): Cost of debt, representing the effective rate paid \n                              on the company's issued debt.\n        tax_rate (float): Corporate tax rate, used to calculate the after-tax cost of debt.\n\n    Returns:\n        wacc (float): The calculated Weighted Average Cost of Capital (WACC).\n\n    Notes:\n        - Applicability: Useful for assessing the cost of capital for businesses \n          that use both equity and debt financing.\n        - Constraints: The equity and debt market values should be positive and \n          represent the total financing. The tax rate should be between 0 and 1.\n        - Considerations: It assumes taxes are constant and ignores complications \n          such as different classes of equity with different costs.\n    \"\"\"\n    total_value = equity_market_value + debt_market_value\n    equity_weight = equity_market_value / total_value\n    debt_weight = debt_market_value / total_value\n    after_tax_cost_of_debt = cost_of_debt * (1 - tax_rate)\n\n    wacc = (equity_weight * cost_of_equity) + (debt_weight * after_tax_cost_of_debt)\n    \n    return wacc",
            "def calculate_weighted_average_cost_of_capital(equity_cost: float, debt_cost: float, \n                                               equity_value: float, debt_value: float, \n                                               tax_rate: float) -> float:\n    \"\"\"\n    Calculate the Weighted Average Cost of Capital (WACC) for a company.\n\n    This function computes the WACC, which is a measure of a company's cost of \n    capital from all sources, including debt and equity. It is widely used in \n    corporate finance to evaluate investment opportunities and financial \n    strategies.\n\n    Args:\n        equity_cost (float): The cost of equity capital, often derived from \n                             models like CAPM.\n        debt_cost (float): The after-tax cost of debt.\n        equity_value (float): The market value of the company's equity.\n        debt_value (float): The market value of the company's debt.\n        tax_rate (float): The corporate tax rate applicable to the company.\n\n    Returns:\n        wacc (float): The weighted average cost of capital.\n\n    Notes:\n        - Applicability: Applies to companies with both debt and equity financing.\n        - Constraints: Assumes market values are available and tax rate is constant.\n        - Considerations: Accurate cost estimates and market values are critical.\n    \"\"\"\n    total_value = equity_value + debt_value\n    wacc = ((equity_value / total_value) * equity_cost) + \\\n           ((debt_value / total_value) * debt_cost * (1 - tax_rate))\n    return wacc",
            "def calculate_weighted_average_cost_of_capital(weight_equity: float, cost_equity: float, weight_debt: float, \n                                               pretax_cost_debt: float, tax_rate: float) -> float:\n    \"\"\"\n    Calculate the weighted average cost of capital (WACC) for a company.\n\n    This function computes the WACC by weighting the cost of equity and the after-tax cost of debt\n    according to their respective proportions in the company's capital structure.\n\n    Args:\n        weight_equity (float): The proportion of capital financed by common equity. Must be between 0 and 1.\n        cost_equity (float): The cost of common equity as a decimal. Must be between 0 and 1.\n        weight_debt (float): The proportion of capital financed by debt. Must be between 0 and 1.\n        pretax_cost_debt (float): The pretax cost of debt as a decimal. Must be between 0 and 1.\n        tax_rate (float): The corporate tax rate as a decimal. Must be between 0 and 1.\n\n    Returns:\n        wacc (float): The weighted average cost of capital as a decimal.\n\n    Notes:\n        - This function assumes the sum of `weight_equity` and `weight_debt` equals 1.\n        - The WACC is returned as a decimal and may be converted to a percentage by multiplying by 100.\n        - The function assumes all inputs are provided as decimals (e.g., 10% should be input as 0.10).\n    \"\"\"\n    cost_debt_after_tax = pretax_cost_debt * (1 - tax_rate)\n    wacc = (weight_equity * cost_equity) + (weight_debt * cost_debt_after_tax)\n    return wacc"
        ],
        "usage": {
            "completion_tokens": 851,
            "prompt_tokens": 1592,
            "total_tokens": 2443,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-3067",
        "article_title": "Options Contract",
        "function": "def calculate_option_profit(call: bool, current_price: float, strike_price: float, premium_per_share: float, contracts: int, expiration_price: float) -> float:\n    \"\"\"\n    Calculate the profit or loss from an options contract at expiration.\n\n    This function calculates the potential profit or loss from a call or put option \n    at expiration, taking into account the strike price, premium paid, and final \n    price of the underlying asset.\n\n    Args:\n        call (bool): True for a call option, False for a put option.\n        current_price (float): The current price of the underlying asset.\n        strike_price (float): The pre-determined price at which the underlying asset can be bought or sold.\n        premium_per_share (float): The premium paid per share for the option contract.\n        contracts (int): The number of option contracts, typically representing 100 shares each.\n        expiration_price (float): The price of the underlying asset at expiration.\n\n    Returns:\n        profit_or_loss (float): The net profit or loss from the options trade at expiration.\n\n    Notes:\n        - Applicability: Helps assess the potential financial outcome of entering an options position.\n        - Constraints: Assumes each contract represents 100 shares.\n        - Considerations: This function does not consider trading fees, taxes, or other transaction costs.\n    \"\"\"\n    shares_per_contract = 100\n    total_shares = shares_per_contract * contracts\n    total_premium = premium_per_share * total_shares\n\n    if call:\n        intrinsic_value = max(0, expiration_price - strike_price)\n    else:\n        intrinsic_value = max(0, strike_price - expiration_price)\n\n    total_intrinsic_value = intrinsic_value * total_shares\n    profit_or_loss = total_intrinsic_value - total_premium\n    \n    return profit_or_loss",
        "statistics": {
            "number_statistics": {
                "args_numbers": 6,
                "question_numbers": 1,
                "context_numbers": 6,
                "total_numbers": 7
            },
            "operator_statistics": {
                "operators": {
                    "+": 0,
                    "-": 3,
                    "*": 3,
                    "/": 0,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 6
            },
            "code_statistics": {
                "lines": 10,
                "parentheses": 4
            }
        },
        "difficulty": 4.276666119016055,
        "context": "An investor is considering purchasing options to profit from potential market movements. They decide to buy put options on TechCo, whose current stock price is $150 per share. The investor buys 5 put option contracts, each with a strike price of $145 and a premium of $3.25 per share. At expiration, TechCo's stock price drops to $140 per share. Each option contract represents 100 shares. The investor wants to know the profit or loss from this options trade.",
        "question": "What is the investor's net profit or loss from the put options on TechCo at expiration, given that each contract represents 100 shares? Answer in dollars to the nearest integer.",
        "python_solution": "def solution():\n    # Define variables based on the problem statement\n    call = False  # Put option\n    current_price = 150  # Current price of the stock\n    strike_price = 145  # Strike price of the put option\n    premium_per_share = 3.25  # Premium paid per share\n    contracts = 5  # Number of option contracts\n    expiration_price = 140  # Price of the stock at expiration\n\n    # Additional parameters for calculation\n    shares_per_contract = 100\n    total_shares = shares_per_contract * contracts\n    total_premium = premium_per_share * total_shares\n\n    # Calculate intrinsic value for a put option\n    intrinsic_value = max(0, strike_price - expiration_price)\n\n    # Calculate total intrinsic value and profit or loss\n    total_intrinsic_value = intrinsic_value * total_shares\n    profit_or_loss = total_intrinsic_value - total_premium\n\n    # Return the final result\n    return round(profit_or_loss)\n\n# Implement the solution function to solve the problem\nsolution()",
        "ground_truth": 875,
        "source": "FinanceReasoning-test-182",
        "question_id": "test-2023",
        "level": "hard",
        "output": [
            "### Step-by-Step Reasoning Using Advanced Reasoning Techniques:\n\n#### Task:\nDetermine the investor's net profit or loss from trading put options at expiration.\n\n#### Emphasizing Constraints (EC):\n1. Each contract represents 100 shares.\n2. Input values:\n   - Current stock price = $150.\n   - Strike price = $145.\n   - Premium per share = $3.25.\n   - Stock price at expiration = $140.\n3. Total put options purchased = 5 contracts.\n4. Any profit or loss for the investor must take into account:\n   - The intrinsic value (profit due to the fall in stock price).\n   - The cost of buying the contracts (premium paid).\n5. Output:\n   - The result should be the net profit/loss **in dollars rounded to the nearest integer**.\n\n#### Process:\n1. Calculate the intrinsic value per share at expiration:\n   - Intrinsic value (per share) = max(Strike Price - Stock Price at Expiration, 0).\n   - This is the profit gained per share if the stock price drops below the strike price.\n\n2. Compute the total intrinsic value:\n   - Total intrinsic value = Intrinsic value per share \u00d7 (Number of shares per contract) \u00d7 (Number of contracts).\n\n3. Calculate the total premium paid:\n   - Total premium = Premium per share \u00d7 (Number of shares per contract) \u00d7 (Number of contracts).\n\n4. Subtract the total premium paid from the total intrinsic value to get the net profit or loss:\n   - Net Profit/Loss = Total intrinsic value - Total premium.\n\n5. Return the result rounded to the nearest integer.\n\n---\n\n### Python Program:\n```python\ndef solution():\n    # Define variables\n    current_stock_price = 150\n    strike_price = 145\n    premium_per_share = 3.25\n    stock_price_at_expiration = 140\n    number_of_contracts = 5\n    shares_per_contract = 100\n    \n    # Step 1: Calculate intrinsic value per share\n    intrinsic_value_per_share = max(strike_price - stock_price_at_expiration, 0)\n    \n    # Step 2: Total intrinsic value\n    total_intrinsic_value = intrinsic_value_per_share * shares_per_contract * number_of_contracts\n    \n    # Step 3: Calculate total premium paid\n    total_premium_paid = premium_per_share * shares_per_contract * number_of_contracts\n    \n    # Step 4: Calculate net profit or loss\n    net_profit_or_loss = total_intrinsic_value - total_premium_paid\n    \n    # Return the result rounded to the nearest integer\n    return round(net_profit_or_loss)\n```\n\nBy adhering to the constraints and carefully calculating step-by-step, this solution should provide the correct net profit or loss in dollars to the nearest integer."
        ],
        "retrieval_query": "What is the investor's net profit or loss from the put options on TechCo at expiration, given that each contract represents 100 shares? Answer in dollars to the nearest integer.",
        "useful_functions": [
            "def calculate_cash_spent_on_share_repurchase(shares_repurchased: int, share_price: float) -> int:\n    \"\"\"\n    Calculate the total cash spent on repurchasing shares of common stock.\n\n    This function computes the cash spent to repurchase a number of shares\n    at a specific price per share and returns the result in millions, rounded to the nearest integer.\n\n    Args:\n        shares_repurchased (int): The number of shares repurchased.\n        share_price (float): The price per share at which the shares were repurchased.\n\n    Returns:\n        cash_spent_millions (int): The total cash spent on repurchasing shares, in millions,\n                                   rounded to the nearest integer.\n\n    Notes:\n        - Applicability: This function is applicable for calculating the cost of share repurchases\n          when the number of shares and price per share are known.\n        - Constraints: Ensure the share_price and shares_repurchased are non-negative.\n        - Considerations: The result is rounded to the nearest integer to represent the amount in millions.\n    \"\"\"\n    if shares_repurchased < 0 or share_price < 0:\n        raise ValueError(\"Shares repurchased and share price must be non-negative.\")\n\n    cash_spent = shares_repurchased * share_price\n    cash_spent_millions = round(cash_spent / 1_000_000)\n    \n    return cash_spent_millions"
        ],
        "usage": {
            "completion_tokens": 573,
            "prompt_tokens": 759,
            "total_tokens": 1332,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-966",
        "article_title": "Multi-Factor Model",
        "function": "def calculate_multi_factor_return(intercept: float, market_return: float, factor_returns: list, betas: list, error_term: float) -> float:\n    \"\"\"\n    Calculate the expected return of a security using a multi-factor model.\n\n    This function computes the expected return of a security based on multiple\n    factors, incorporating the market return, factor-specific betas, and an error term.\n\n    Args:\n        intercept (float): The intercept term of the model.\n        market_return (float): The return of the market.\n        factor_returns (list): A list of returns for each factor used in the model.\n        betas (list): A list of beta coefficients corresponding to the market and each factor.\n                      Includes the market beta as the first element.\n        error_term (float): The error term representing unexplained variations.\n\n    Returns:\n        expected_return (float): The expected return of the security according to the multi-factor model.\n\n    Notes:\n        - The length of `factor_returns` must match the length of `betas` minus one\n          since the market beta is also included in `betas`.\n        - This function assumes `factor_returns` and `betas` are provided in the same\n          order of factors.\n        - The model does not account for macroeconomic changes impacting future returns.\n    \"\"\"\n    if len(betas) != len(factor_returns) + 1:\n        raise ValueError(\"The length of betas must be one more than the length of factor_returns.\")\n\n    # Start with the intercept\n    expected_return = intercept\n\n    # Add the contribution from the market return\n    expected_return += betas[0] * market_return\n\n    # Add the contributions from each of the factors\n    for i in range(len(factor_returns)):\n        expected_return += betas[i + 1] * factor_returns[i]\n\n    # Add the error term\n    expected_return += error_term\n\n    return expected_return",
        "statistics": {
            "number_statistics": {
                "args_numbers": 5,
                "question_numbers": 0,
                "context_numbers": 8,
                "total_numbers": 8
            },
            "operator_statistics": {
                "operators": {
                    "+": 4,
                    "-": 0,
                    "*": 2,
                    "/": 0,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 6
            },
            "code_statistics": {
                "lines": 10,
                "parentheses": 4
            }
        },
        "difficulty": 4.276666119016055,
        "context": "A portfolio manager is evaluating the expected return of a new technology fund using a multi-factor model. The model includes an intercept of 0.02 and considers a market return of 5% for the period. The fund's exposure to various macroeconomic factors includes a technology index return of 3% and an interest rate sensitivity with a return of -1%. The betas with respect to these factors are 1.2 for the market, 0.8 for the technology index, and -0.5 for the interest rate factor. Additionally, the model accounts for an error term of 0.01 to capture unexplained variations in the fund's performance.",
        "question": "What is the expected return of the technology fund according to the multi-factor model? Answer as a percentage to two decimal places.",
        "python_solution": "def solution():\n    # Define variables and their values based on the problem context\n    intercept = 0.02\n    market_return = 0.05\n    factor_returns = [0.03, -0.01]  # Technology index return and interest rate factor return\n    betas = [1.2, 0.8, -0.5]  # Betas for market, technology index and interest rate factor\n    error_term = 0.01\n\n    # Calculate expected return\n    expected_return = intercept\n    expected_return += betas[0] * market_return\n\n    # Add contribution from each factor\n    for i in range(len(factor_returns)):\n        expected_return += betas[i + 1] * factor_returns[i]\n\n    # Add the error term\n    expected_return += error_term\n\n    # Return the result as a percentage\n    return round(expected_return * 100, 2)\n\n# Uncomment the following line to test the solution in a Python environment\n# print(solution())",
        "ground_truth": 11.9,
        "source": "FinanceReasoning-test-207",
        "question_id": "test-2024",
        "level": "hard",
        "output": [
            "To find the expected return of the technology fund according to the multi-factor model, let us carefully analyze and calculate step by step:\n\n---\n\n### Step 1: Understanding the Formula\nThe expected return for a fund using a multi-factor model is calculated using the following formula:\n\n\\[\n\\text{Expected Return} = \\text{Intercept} + (\\text{Beta}_1 \\times \\text{Factor}_1) + (\\text{Beta}_2 \\times \\text{Factor}_2) + \\ldots + (\\text{Error Term})\n\\]\n\nHere:\n- **Intercept**: 0.02\n- **Market Factor Return (Factor 1)**: 5% (or 0.05)\n- **Technology Index Return (Factor 2)**: 3% (or 0.03)\n- **Interest Rate Sensitivity (Factor 3)**: -1% (or -0.01)\n- **Betas**:\n  - Beta\u2081 (Market): 1.2\n  - Beta\u2082 (Technology Index): 0.8\n  - Beta\u2083 (Interest Rate): -0.5\n- **Error Term**: 0.01\n\n---\n\n### Step 2: Emphasizing Constraints (EC)\n1. **Use Decimal Precision**: We must ensure all percentage values (e.g., 5%, 3%) are converted into decimals for a consistent computation process. Thus:\n   - 5% \u2192 0.05\n   - 3% \u2192 0.03\n   - -1% \u2192 -0.01\n2. **Final Answer as Percentage**: The final expected return should be expressed as a percentage to **two decimal places**.\n3. **Add All Factors Properly**: Make sure each factor is multiplied with its respective beta and all terms are summed.\n\n---\n\n### Step 3: Performing the Calculation\nPlugging in the given values into the formula:\n\n\\[\n\\text{Expected Return} =\n\\text{Intercept} + (\\beta_M \\times R_M) + (\\beta_T \\times R_T) + (\\beta_I \\times R_I) + \\text{Error Term}\n\\]\n\nSubstitute the values:\n- \\(\\text{Intercept} = 0.02\\)\n- \\((\\beta_M \\times R_M) = 1.2 \\times 0.05 = 0.06\\)\n- \\((\\beta_T \\times R_T) = 0.8 \\times 0.03 = 0.024\\)\n- \\((\\beta_I \\times R_I) = -0.5 \\times -0.01 = 0.005\\)\n- \\(\\text{Error Term} = 0.01\\)\n\nSum all these components:\n\\[\n\\text{Expected Return} = 0.02 + 0.06 + 0.024 + 0.005 + 0.01 = 0.119\n\\]\n\nConvert this to a percentage:\n\\[\n\\text{Expected Return (\\%)} = 11.90\\%\n\\]\n\n---\n\n### Step 4: Writing the Python Program\nLet's implement the calculation in Python:\n\n```python\ndef solution():\n    # Define variables name and value\n    intercept = 0.02\n    beta_market = 1.2\n    beta_technology = 0.8\n    beta_interest_rate = -0.5\n    market_return = 0.05\n    technology_index_return = 0.03\n    interest_rate_return = -0.01\n    error_term = 0.01\n\n    # Calculate expected return\n    expected_return = (intercept +\n                       (beta_market * market_return) +\n                       (beta_technology * technology_index_return) +\n                       (beta_interest_rate * interest_rate_return) +\n                       error_term)\n    \n    # Convert to percentage form with two decimal places\n    return round(expected_return * 100, 2)\n```"
        ],
        "retrieval_query": "What is the expected return of the technology fund according to the multi-factor model? Answer as a percentage to two decimal places.",
        "useful_functions": [
            "def calculate_previous_year_net_interest_income(current_year_income: float, current_year_growth_rate: float) -> float:\n    \"\"\"\n    Calculate the net interest income for the previous year based on the current year's income and growth rate.\n\n    This function calculates the net interest income from the previous year using the provided current year net interest\n    income and the growth rate from the previous year to the current year. It is useful when analyzing financial trends\n    across multiple years.\n\n    Args:\n        current_year_income (float): The net interest income for the current year.\n        current_year_growth_rate (float): The growth rate from the previous year to the current year, expressed as a percentage.\n\n    Returns:\n        previous_year_income (float): The calculated net interest income for the previous year.\n\n    Notes:\n        - Applicability: This function is applicable for analyzing net interest income trends over consecutive years.\n        - Constraints: The growth rate must not be 100% or -100%, as this will lead to division by zero or negative results.\n        - Considerations: Ensure accuracy in input values; the growth rate should be realistic and based on solid data.\n    \"\"\"\n    if current_year_growth_rate <= -100 or current_year_growth_rate == 100:\n        raise ValueError(\"Growth rate must not be 100% or -100% to avoid invalid calculations.\")\n\n    adjusted_growth_factor = 1 + (current_year_growth_rate / 100)\n    previous_year_income = current_year_income / adjusted_growth_factor\n    \n    return previous_year_income"
        ],
        "usage": {
            "completion_tokens": 824,
            "prompt_tokens": 803,
            "total_tokens": 1627,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-994",
        "article_title": "5-6 Hybrid Adjustable-Rate Mortgage (5-6 Hybrid ARM)",
        "function": "def calculate_adjustable_payment(principal: float, fully_indexed_rate: float, loan_term_months: int) -> float:\n    \"\"\"\n    Calculate the monthly payment for a period of an adjustable-rate mortgage (ARM) based on \n    the fully indexed rate.\n\n    This function determines the monthly payment amount for a given loan principal and fully\n    indexed interest rate using a specified loan term in months.\n\n    Args:\n        principal (float): The remaining principal amount of the loan.\n        fully_indexed_rate (float): The fully indexed interest rate as a decimal (e.g., 0.07 for 7%).\n        loan_term_months (int): The number of months remaining in the loan term.\n\n    Returns:\n        monthly_payment (float): The calculated monthly payment amount.\n\n    Notes:\n        - Applicability: Useful for calculating payments after the fixed period ends in an ARM.\n        - Constraints: Principal and fully indexed rate must be non-negative; term must be greater than 0.\n        - Considerations: Fully indexed rate should be adjusted for monthly compounding in the calculation.\n    \"\"\"\n    if principal < 0 or fully_indexed_rate < 0 or loan_term_months <= 0:\n        raise ValueError(\"Principal, fully indexed rate must be non-negative and term must be positive.\")\n\n    monthly_rate = fully_indexed_rate / 12\n    monthly_payment = principal * (monthly_rate * (1 + monthly_rate) ** loan_term_months) / \\\n                      ((1 + monthly_rate) ** loan_term_months - 1)\n    \n    return monthly_payment",
        "statistics": {
            "number_statistics": {
                "args_numbers": 3,
                "question_numbers": 0,
                "context_numbers": 4,
                "total_numbers": 4
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 1,
                    "*": 2,
                    "/": 2,
                    "%": 0,
                    "**": 2
                },
                "total_operators": 9
            },
            "code_statistics": {
                "lines": 4,
                "parentheses": 8
            }
        },
        "difficulty": 4.276666119016055,
        "context": "John recently refinanced his adjustable-rate mortgage (ARM) after the initial fixed period ended. He has a remaining principal balance of \\$350,000 on his mortgage. The loan's new fully indexed interest rate is 5% per annum. The remaining loan term is 20 years (240 months). John wants to know what his new monthly payment will be after the rate adjustment.",
        "question": "What will John's new monthly payment be on his ARM? Answer to the nearest cent.",
        "python_solution": "def solution():\n    # Define the given variables\n    principal = 350000  # Remaining principal balance in dollars\n    fully_indexed_rate = 0.05  # Fully indexed annual interest rate (5%)\n    loan_term_months = 240  # Remaining loan term in months (20 years)\n\n    # Convert annual interest rate to a monthly interest rate\n    monthly_rate = fully_indexed_rate / 12\n\n    # Calculate the monthly payment using the mortgage formula\n    monthly_payment = principal * (monthly_rate * (1 + monthly_rate) ** loan_term_months) / \\\n                      ((1 + monthly_rate) ** loan_term_months - 1)\n\n    # Return the monthly payment rounded to the nearest cent\n    return round(monthly_payment, 2)\n\n# Example usage\nprint(solution())  # This should output the computed monthly payment",
        "ground_truth": 2309.85,
        "source": "FinanceReasoning-test-244",
        "question_id": "test-2025",
        "level": "hard",
        "output": [
            "To solve this problem, let us proceed step by step using \"Emphasizing Constraints (EC)\" to ensure we respect the constraints and calculate the correct answer.\n\n---\n\n### Step-by-Step Analysis\n\n#### 1. Inputs and Constraints:\n   - **Principal Amount (Loan Balance)**: \\$350,000 (must be non-negative).\n   - **Fully Indexed Annual Interest Rate**: 5% (0.05 as a decimal, non-negative).\n   - **Remaining Loan Term**: 20 years or 240 months (term must be greater than 0).\n   - We will calculate the **monthly payment** under the fully indexed rate with monthly compounding interest.\n\n#### 2. Formula Used:\n   - To calculate the monthly payment, the formula for an amortized loan is:\n     \\[\n     M = P \\times \\frac{r (1 + r)^n}{(1 + r)^n - 1}\n     \\]\n     Where:\n     - \\( M \\) = Monthly Payment\n     - \\( P \\) = Principal (\\$350,000)\n     - \\( r \\) = Monthly Interest Rate (\\(\\frac{\\text{Annual Rate}}{12}\\))\n     - \\( n \\) = Number of Months (240)\n\n#### 3. Important Considerations:\n   - Ensure that all inputs are positive or non-negative as required.\n   - Round the final **monthly payment** result to the nearest cent as requested.\n\n#### 4. Implementation:\n   - We will use the `calculate_monthly_payment` function logic as the basis for our computation, as it adheres to the requirements.\n\n---\n\nHere is the Python program implementing the above logic:\n\n```python\ndef solution():\n    # Define variables name and value\n    principal = 350_000  # Remaining loan balance in dollars\n    annual_interest_rate = 0.05  # Fully indexed annual interest rate in decimal form\n    loan_term_months = 20 * 12  # Remaining loan term in months (240 months)\n\n    # Monthly interest rate calculation\n    monthly_interest_rate = annual_interest_rate / 12\n\n    # Monthly payment calculation using the amortization formula\n    monthly_payment = (principal * monthly_interest_rate) / (1 - (1 + monthly_interest_rate) ** -loan_term_months)\n\n    # Return the answer rounded to the nearest cent\n    return round(monthly_payment, 2)\n```"
        ],
        "retrieval_query": "What will John's new monthly payment be on his ARM? Answer to the nearest cent.",
        "useful_functions": [
            "def calculate_adjustable_payment(principal: float, fully_indexed_rate: float, loan_term_months: int) -> float:\n    \"\"\"\n    Calculate the monthly payment for a period of an adjustable-rate mortgage (ARM) based on \n    the fully indexed rate.\n\n    This function determines the monthly payment amount for a given loan principal and fully\n    indexed interest rate using a specified loan term in months.\n\n    Args:\n        principal (float): The remaining principal amount of the loan.\n        fully_indexed_rate (float): The fully indexed interest rate as a decimal (e.g., 0.07 for 7%).\n        loan_term_months (int): The number of months remaining in the loan term.\n\n    Returns:\n        monthly_payment (float): The calculated monthly payment amount.\n\n    Notes:\n        - Applicability: Useful for calculating payments after the fixed period ends in an ARM.\n        - Constraints: Principal and fully indexed rate must be non-negative; term must be greater than 0.\n        - Considerations: Fully indexed rate should be adjusted for monthly compounding in the calculation.\n    \"\"\"\n    if principal < 0 or fully_indexed_rate < 0 or loan_term_months <= 0:\n        raise ValueError(\"Principal, fully indexed rate must be non-negative and term must be positive.\")\n\n    monthly_rate = fully_indexed_rate / 12\n    monthly_payment = principal * (monthly_rate * (1 + monthly_rate) ** loan_term_months) / \\\n                      ((1 + monthly_rate) ** loan_term_months - 1)\n    \n    return monthly_payment",
            "def calculate_monthly_payment(principal: float, annual_interest_rate: float, term_months: int) -> float:\n    \"\"\"\n    Calculate the monthly payment required to repay a loan.\n\n    This function calculates the monthly payment needed to repay a loan\n    within a specified term at a given annual interest rate using the \n    formula for amortizing loans.\n\n    Args:\n        principal (float): The total amount of the loan.\n        annual_interest_rate (float): The annual interest rate (as a decimal).\n                                      For example, 11% should be input as 0.11.\n        term_months (int): The term of the loan in months.\n\n    Returns:\n        monthly_payment (float): The monthly payment amount needed to repay\n                                 the loan over its term.\n\n    Notes:\n        - The formula used assumes a fixed interest rate for the entire term.\n        - Interest is compounded monthly.\n        - The calculated monthly payment does not include taxes or insurance, if applicable.\n    \"\"\"\n    if annual_interest_rate < 0 or principal < 0 or term_months <= 0:\n        raise ValueError(\"Invalid input values: ensure all values are positive and term is greater than 0.\")\n    \n    monthly_interest_rate = annual_interest_rate / 12\n    if monthly_interest_rate == 0:  # Handle case where interest rate is 0%\n        monthly_payment = principal / term_months\n    else:\n        monthly_payment = (principal * monthly_interest_rate) / (1 - (1 + monthly_interest_rate) ** -term_months)\n    \n    return monthly_payment\n\n\ndef calculate_total_interest_paid(principal: float, monthly_payment: float, term_months: int) -> float:\n    \"\"\"\n    Calculate the total interest paid over the life of a loan.\n\n    This function computes the total interest paid when repaying a loan with\n    specified monthly payments over a given term.\n\n    Args:\n        principal (float): The initial amount of the loan.\n        monthly_payment (float): The monthly payment amount.\n        term_months (int): The total number of months to repay the loan.\n\n    Returns:\n        total_interest_paid (float): The total interest amount paid over the term.\n\n    Notes:\n        - The calculation assumes that the loan is fully repaid using equal monthly payments.\n        - Does not account for early repayments or additional fees that may alter total interest.\n    \"\"\"\n    if monthly_payment <= 0 or principal < 0 or term_months <= 0:\n        raise ValueError(\"Invalid input values: ensure payments and principal are positive and term is greater than 0.\")\n    \n    total_paid = monthly_payment * term_months\n    total_interest_paid = total_paid - principal\n    \n    return total_interest_paid",
            "def calculate_fixed_rate_payment(principal: float, annual_interest_rate: float, years: int) -> float:\n    \"\"\"\n    Calculate the monthly payment for a fixed-rate loan.\n\n    This function computes the fixed monthly payment required to fully amortize\n    a loan over a specified number of years, given the loan principal and an\n    annual interest rate.\n\n    Args:\n        principal (float): The initial amount of the loan.\n        annual_interest_rate (float): The annual interest rate as a decimal (e.g., 0.045 for 4.5%).\n        years (int): The term of the loan in years.\n\n    Returns:\n        monthly_payment (float): The monthly payment required to fully amortize\n                                 the loan over the specified term.\n\n    Notes:\n        - The monthly interest rate is calculated from the annual interest rate.\n        - The function uses the annuity formula for calculating the payment.\n        - Applicability: This function is applicable for fixed-rate loans.\n        - Constraints: The annual interest rate must be non-negative.\n        - Considerations: Ensure the principal and years are positive values.\n    \"\"\"\n    if annual_interest_rate < 0:\n        raise ValueError(\"Annual interest rate must be non-negative.\")\n    \n    monthly_interest_rate = annual_interest_rate / 12\n    number_of_payments = years * 12\n    \n    if monthly_interest_rate == 0:  # Special case for zero interest\n        return principal / number_of_payments\n    \n    monthly_payment = (principal * monthly_interest_rate) / (1 - (1 + monthly_interest_rate) ** -number_of_payments)\n    \n    return monthly_payment"
        ],
        "usage": {
            "completion_tokens": 494,
            "prompt_tokens": 1649,
            "total_tokens": 2143,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-1636",
        "article_title": "Debt",
        "function": "def calculate_monthly_payment(principal: float, annual_interest_rate: float, years: int) -> float:\n    \"\"\"\n    Calculate the monthly payment required to fully repay a loan over a specified time period\n    using a fixed interest rate.\n\n    This calculation is applicable for fixed-rate loans including standard repayment plans for\n    student loans or mortgages.\n\n    Args:\n        principal (float): The initial amount of the loan.\n        annual_interest_rate (float): The annual interest rate as a percentage.\n        years (int): The total time in years over which the loan is to be repaid.\n\n    Returns:\n        monthly_payment (float): The amount to be paid monthly to repay the loan in full.\n\n    Notes:\n        - Applicability: Use for fixed-rate loans.\n        - Constraints: Interest rate should be greater than 0; years should be a positive integer.\n        - Considerations: This does not account for fees, taxes, or insurance that may also be part\n                          of monthly payments.\n    \"\"\"\n    if annual_interest_rate <= 0:\n        raise ValueError(\"Interest rate must be greater than zero.\")\n    if years <= 0:\n        raise ValueError(\"Years must be a positive integer.\")\n\n    monthly_interest_rate = annual_interest_rate / 100 / 12\n    number_of_payments = years * 12\n\n    monthly_payment = (principal * monthly_interest_rate) / \\\n                      (1 - (1 + monthly_interest_rate) ** -number_of_payments)\n\n    return monthly_payment",
        "statistics": {
            "number_statistics": {
                "args_numbers": 3,
                "question_numbers": 0,
                "context_numbers": 3,
                "total_numbers": 3
            },
            "operator_statistics": {
                "operators": {
                    "+": 1,
                    "-": 2,
                    "*": 2,
                    "/": 3,
                    "%": 0,
                    "**": 1
                },
                "total_operators": 9
            },
            "code_statistics": {
                "lines": 5,
                "parentheses": 6
            }
        },
        "difficulty": 4.276666119016055,
        "context": "A recent college graduate, Emily, plans to take out a student loan to cover her tuition for a master's program. The total amount needed is $35,000. The loan has a fixed annual interest rate of 5% and will be repaid over a period of 10 years. Emily wants to know how much she will have to pay monthly to fully repay the loan within the given time frame, assuming there are no additional fees, taxes, or insurance costs.",
        "question": "What is the monthly payment required for Emily to fully repay the loan? Answer to the nearest cent.",
        "python_solution": "def solution():\n    # Define the variables\n    principal = 35000  # Loan amount\n    annual_interest_rate = 5  # Annual interest rate in percentage\n    years = 10  # Loan duration in years\n\n    # Convert annual interest rate to a monthly interest rate\n    monthly_interest_rate = annual_interest_rate / 100 / 12\n    \n    # Calculate the total number of monthly payments\n    number_of_payments = years * 12\n    \n    # Calculate the monthly payment using the formula for an amortizing loan\n    monthly_payment = (principal * monthly_interest_rate) / \\\n                      (1 - (1 + monthly_interest_rate) ** -number_of_payments)\n    \n    # Return the result to the nearest cent\n    return round(monthly_payment, 2)",
        "ground_truth": 371.23,
        "source": "FinanceReasoning-test-251",
        "question_id": "test-2026",
        "level": "hard",
        "output": [
            "To solve this problem, we will calculate the monthly payment required for Emily to fully repay her loan over a period of 10 years under the constraints provided. Here are the steps:\n\n### Step-by-Step Thought Process:\n\n1. **Understanding the Problem:**\n   - Loan amount: $35,000.\n   - Annual interest rate: 5% or 0.05 (as a decimal).\n   - Loan repayment period: 10 years or 120 months (since 1 year = 12 months).\n\n2. **Constraints:**\n   - The result should be accurate to the nearest cent.\n   - The interest rate must be divided by 12 to obtain the monthly interest rate.\n   - Compound interest formula for loan amortization needs to be used to compute the monthly payment.\n\n3. **The Formula for Monthly Payment:**\n   The formula to calculate equal monthly payments for a fixed-rate loan is given by:\n   \\[\n   P = \\frac{L \\cdot r \\cdot (1 + r)^n}{(1 + r)^n - 1}\n   \\]\n   Where:\n   - \\( P \\): Monthly payment.\n   - \\( L \\): Loan amount (principal).\n   - \\( r \\): Monthly interest rate (annual rate divided by 12).\n   - \\( n \\): Total number of payments (years * 12).\n\n4. **Implementation:**\n   - Convert the annual interest rate to a monthly interest rate.\n   - Multiply the years by 12 to get the total number of payments.\n   - Use the given formula to compute the monthly payment.\n   - Round the result to two decimal places as per the constraint.\n\n### Python Program:\nBelow is the program that performs the above calculations:\n\n```python\ndef solution():\n    # Define variables\n    loan_amount = 35000  # Principal (L)\n    annual_interest_rate = 5  # Annual interest rate in percentage\n    years = 10  # Loan term in years\n    \n    # Convert annual interest rate to a decimal and calculate monthly interest rate\n    monthly_interest_rate = annual_interest_rate / 100 / 12  # r\n    \n    # Calculate total number of payments\n    total_payments = years * 12  # n\n    \n    # Use the formula to calculate the monthly payment\n    monthly_payment = (loan_amount * monthly_interest_rate * (1 + monthly_interest_rate) ** total_payments) / \\\n                      ((1 + monthly_interest_rate) ** total_payments - 1)\n    \n    # Round the result to 2 decimal places\n    return round(monthly_payment, 2)\n```"
        ],
        "retrieval_query": "What is the monthly payment required for Emily to fully repay the loan? Answer to the nearest cent.",
        "useful_functions": [
            "def calculate_monthly_payment(loan_amount: float, annual_interest_rate: float, number_of_payments: int) -> float:\n    \"\"\"\n    Calculate the total monthly payment for an amortized loan.\n\n    This function computes the monthly payment required to fully amortize a loan\n    over a specified term, given the loan's amount, the annual interest rate,\n    and the number of payments. It uses the standard amortization formula for loans.\n\n    Args:\n        loan_amount (float): The total amount of the loan.\n        annual_interest_rate (float): The annual interest rate as a decimal (e.g., 0.03 for 3%).\n        number_of_payments (int): The total number of payments over the life of the loan.\n\n    Returns:\n        total_payment (float): The calculated total monthly payment.\n\n    Notes:\n        - Applicability: Use this function to calculate monthly payments for fixed-rate loans.\n        - Constraints: The annual_interest_rate should be divided by 12 for monthly rate calculation.\n        - Considerations: Ensure the interest rate and number of payments are greater than zero.\n    \"\"\"\n    monthly_rate = annual_interest_rate / 12\n    if monthly_rate == 0:\n        return loan_amount / number_of_payments\n    total_payment = loan_amount * (monthly_rate * (1 + monthly_rate) ** number_of_payments) / ((1 + monthly_rate) ** number_of_payments - 1)\n    \n    return total_payment",
            "def calculate_monthly_payment(principal: float, annual_interest_rate: float, years: int) -> float:\n    \"\"\"\n    Calculate the monthly payment required to fully repay a loan over a specified time period\n    using a fixed interest rate.\n\n    This calculation is applicable for fixed-rate loans including standard repayment plans for\n    student loans or mortgages.\n\n    Args:\n        principal (float): The initial amount of the loan.\n        annual_interest_rate (float): The annual interest rate as a percentage.\n        years (int): The total time in years over which the loan is to be repaid.\n\n    Returns:\n        monthly_payment (float): The amount to be paid monthly to repay the loan in full.\n\n    Notes:\n        - Applicability: Use for fixed-rate loans.\n        - Constraints: Interest rate should be greater than 0; years should be a positive integer.\n        - Considerations: This does not account for fees, taxes, or insurance that may also be part\n                          of monthly payments.\n    \"\"\"\n    if annual_interest_rate <= 0:\n        raise ValueError(\"Interest rate must be greater than zero.\")\n    if years <= 0:\n        raise ValueError(\"Years must be a positive integer.\")\n\n    monthly_interest_rate = annual_interest_rate / 100 / 12\n    number_of_payments = years * 12\n\n    monthly_payment = (principal * monthly_interest_rate) / \\\n                      (1 - (1 + monthly_interest_rate) ** -number_of_payments)\n\n    return monthly_payment",
            "def calculate_monthly_payment(principal: float, annual_interest_rate: float, term_months: int) -> float:\n    \"\"\"\n    Calculate the monthly payment required to repay a loan.\n\n    This function calculates the monthly payment needed to repay a loan\n    within a specified term at a given annual interest rate using the \n    formula for amortizing loans.\n\n    Args:\n        principal (float): The total amount of the loan.\n        annual_interest_rate (float): The annual interest rate (as a decimal).\n                                      For example, 11% should be input as 0.11.\n        term_months (int): The term of the loan in months.\n\n    Returns:\n        monthly_payment (float): The monthly payment amount needed to repay\n                                 the loan over its term.\n\n    Notes:\n        - The formula used assumes a fixed interest rate for the entire term.\n        - Interest is compounded monthly.\n        - The calculated monthly payment does not include taxes or insurance, if applicable.\n    \"\"\"\n    if annual_interest_rate < 0 or principal < 0 or term_months <= 0:\n        raise ValueError(\"Invalid input values: ensure all values are positive and term is greater than 0.\")\n    \n    monthly_interest_rate = annual_interest_rate / 12\n    if monthly_interest_rate == 0:  # Handle case where interest rate is 0%\n        monthly_payment = principal / term_months\n    else:\n        monthly_payment = (principal * monthly_interest_rate) / (1 - (1 + monthly_interest_rate) ** -term_months)\n    \n    return monthly_payment\n\n\ndef calculate_total_interest_paid(principal: float, monthly_payment: float, term_months: int) -> float:\n    \"\"\"\n    Calculate the total interest paid over the life of a loan.\n\n    This function computes the total interest paid when repaying a loan with\n    specified monthly payments over a given term.\n\n    Args:\n        principal (float): The initial amount of the loan.\n        monthly_payment (float): The monthly payment amount.\n        term_months (int): The total number of months to repay the loan.\n\n    Returns:\n        total_interest_paid (float): The total interest amount paid over the term.\n\n    Notes:\n        - The calculation assumes that the loan is fully repaid using equal monthly payments.\n        - Does not account for early repayments or additional fees that may alter total interest.\n    \"\"\"\n    if monthly_payment <= 0 or principal < 0 or term_months <= 0:\n        raise ValueError(\"Invalid input values: ensure payments and principal are positive and term is greater than 0.\")\n    \n    total_paid = monthly_payment * term_months\n    total_interest_paid = total_paid - principal\n    \n    return total_interest_paid"
        ],
        "usage": {
            "completion_tokens": 535,
            "prompt_tokens": 1617,
            "total_tokens": 2152,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-1817",
        "article_title": "Tax Brackets",
        "function": "def calculate_federal_tax(income: float, tax_brackets: list) -> float:\n    \"\"\"\n    Calculate the federal tax owed based on a progressive tax system.\n\n    This function calculates the total federal tax owed based on a given income\n    and the corresponding tax brackets. It uses a progressive tax rate structure\n    where different portions of the income are taxed at different rates according\n    to specified income levels or brackets.\n\n    Args:\n        income (float): The total taxable income of the individual.\n        tax_brackets (list): A list of tuples where each tuple contains:\n                             - The upper limit of the income for the bracket.\n                             - The tax rate for the bracket.\n\n    Returns:\n        total_tax (float): The total federal tax owed.\n\n    Notes:\n        - Make sure the tax brackets list is sorted in ascending order of income limits.\n        - The last bracket should ideally have an upper limit of None to indicate that\n          there is no upper bound.\n        - Tax brackets should cover all possible income levels.\n        - The function assumes that income below the first bracket limit is taxed at 0%.\n\n    Constraints:\n        - Income must be a non-negative float.\n        - Tax brackets list must not be empty and should cover all income levels.\n    \"\"\"\n    total_tax = 0\n    previous_limit = 0\n\n    for upper_limit, rate in tax_brackets:\n        if income <= upper_limit:\n            total_tax += (income - previous_limit) * rate\n            break\n        else:\n            total_tax += (upper_limit - previous_limit) * rate\n            previous_limit = upper_limit\n\n    return total_tax",
        "statistics": {
            "number_statistics": {
                "args_numbers": 3,
                "question_numbers": 1,
                "context_numbers": 8,
                "total_numbers": 9
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 2,
                    "*": 2,
                    "/": 0,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 6
            },
            "code_statistics": {
                "lines": 10,
                "parentheses": 4
            }
        },
        "difficulty": 4.276666119016055,
        "context": "Sarah is a recent graduate who just started her first full-time job. She earns an annual salary of $75,000. The country's federal tax system employs a progressive tax rate, where different portions of income are taxed at varying rates. The tax brackets are structured as follows: the first $10,000 of income is not taxed, the next $20,000 is taxed at 10%, the subsequent $30,000 at 15%, and any income over $60,000 is taxed at 25%. Sarah is trying to budget her expenses and needs to know how much she will owe in federal taxes with her current salary.",
        "question": "What is the total federal tax Sarah owes on her $75,000 salary? Answer to the nearest integer.",
        "python_solution": "def solution():\n    # Define variables\n    income = 75000\n    \n    # Define tax brackets as a list of tuples (upper limit, tax rate)\n    # The last bracket has None as its upper limit to imply no upper bound\n    tax_brackets = [\n        (10000, 0.00),  # $0 - $10,000: 0%\n        (30000, 0.10),  # $10,001 - $30,000: 10%\n        (60000, 0.15),  # $30,001 - $60,000: 15%\n        (None, 0.25)    # $60,001 and above: 25%\n    ]\n    \n    # Initialize total tax\n    total_tax = 0\n    previous_limit = 0\n\n    for upper_limit, rate in tax_brackets:\n        if upper_limit is None:\n            # Calculate tax for income beyond the last defined bracket\n            total_tax += (income - previous_limit) * rate\n            break\n        else:\n            if income <= upper_limit:\n                # Calculate tax for the portion of income within the current bracket\n                total_tax += (income - previous_limit) * rate\n                break\n            else:\n                # Calculate tax for the full bracket\n                total_tax += (upper_limit - previous_limit) * rate\n                previous_limit = upper_limit\n\n    return round(total_tax)",
        "ground_truth": 10250,
        "source": "FinanceReasoning-test-263",
        "question_id": "test-2027",
        "level": "hard",
        "output": [
            "### Step-by-Step Reasoning Using EC (Emphasizing Constraints)\n\n1. **Understand the Problem and Its Constraints**:\n   - Sarah's salary is $75,000, and the tax calculation follows a progressive system.\n   - The tax brackets are defined with specific segments and rates:\n     - First $10,000: No tax (0%).\n     - Next $20,000: 10%.\n     - Next $30,000: 15%.\n     - Any amount above $60,000: 25%. \n   - We are tasked with calculating the total federal taxes Sarah owes, rounded to the nearest integer.\n   - The program must handle the tax brackets progressively and ensure accurate allocation of income across brackets.\n\n2. **Constraints from the Problem Context**:\n   - The tax brackets must be applied sequentially and correctly.\n   - The total income must not be double-counted across brackets.\n   - There should be clear differentiation between the taxable ranges.\n   - The answer must be rounded to the nearest integer for precision.\n\n3. **Example Calculation**:\n   - First $10,000: Tax = $0.\n   - Next $20,000 ($10,000 - $30,000): Tax = $20,000 * 10% = $2,000.\n   - Next $30,000 ($30,000 - $60,000): Tax = $30,000 * 15% = $4,500.\n   - Remaining $15,000 ($60,000 - $75,000): Tax = $15,000 * 25% = $3,750.\n   - Total Tax = $0 + $2,000 + $4,500 + $3,750 = $10,250.\n   - Rounded total tax = 10,250 (already an integer).\n\n4. **Generate Python Code**:\n   - Implement a function to calculate tax using the provided tax bracket data.\n   - Ensure the last tax bracket correctly handles \"income over $60,000.\"\n\nHere is the Python program:\n\n```python\ndef solution():\n    # Define variables name and value\n    income = 75000\n    tax_brackets = [\n        (10000, 0.00),  # First $10,000 taxed at 0%\n        (30000, 0.10),  # Next $20,000 taxed at 10%\n        (60000, 0.15),  # Next $30,000 taxed at 15%\n        (float('inf'), 0.25)  # Any income above $60,000 taxed at 25%\n    ]\n\n    # Initialize total tax and a variable to track the previous limit\n    total_tax = 0\n    previous_limit = 0\n\n    # Calculate tax progressively based on brackets\n    for upper_limit, rate in tax_brackets:\n        if income <= upper_limit:\n            total_tax += (income - previous_limit) * rate\n            break\n        total_tax += (upper_limit - previous_limit) * rate\n        previous_limit = upper_limit\n\n    # Return the total tax rounded to the nearest integer\n    return round(total_tax)\n```"
        ],
        "retrieval_query": "What is the total federal tax Sarah owes on her $75,000 salary? Answer to the nearest integer.",
        "useful_functions": [
            "def calculate_federal_tax(income: float, tax_brackets: list) -> float:\n    \"\"\"\n    Calculate the federal tax owed based on a progressive tax system.\n\n    This function calculates the total federal tax owed based on a given income\n    and the corresponding tax brackets. It uses a progressive tax rate structure\n    where different portions of the income are taxed at different rates according\n    to specified income levels or brackets.\n\n    Args:\n        income (float): The total taxable income of the individual.\n        tax_brackets (list): A list of tuples where each tuple contains:\n                             - The upper limit of the income for the bracket.\n                             - The tax rate for the bracket.\n\n    Returns:\n        total_tax (float): The total federal tax owed.\n\n    Notes:\n        - Make sure the tax brackets list is sorted in ascending order of income limits.\n        - The last bracket should ideally have an upper limit of None to indicate that\n          there is no upper bound.\n        - Tax brackets should cover all possible income levels.\n        - The function assumes that income below the first bracket limit is taxed at 0%.\n\n    Constraints:\n        - Income must be a non-negative float.\n        - Tax brackets list must not be empty and should cover all income levels.\n    \"\"\"\n    total_tax = 0\n    previous_limit = 0\n\n    for upper_limit, rate in tax_brackets:\n        if income <= upper_limit:\n            total_tax += (income - previous_limit) * rate\n            break\n        else:\n            total_tax += (upper_limit - previous_limit) * rate\n            previous_limit = upper_limit\n\n    return total_tax"
        ],
        "usage": {
            "completion_tokens": 650,
            "prompt_tokens": 820,
            "total_tokens": 1470,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-2249",
        "article_title": "Accumulated Depreciation",
        "function": "def calculate_double_declining_balance_depreciation(asset_value: float, salvage_value: float, useful_life_years: int, year: int) -> float:\n    \"\"\"\n    Calculate annual accumulated depreciation using the double-declining balance method.\n\n    This function computes the double declining depreciation expense for a given year \n    by applying a doubled percentage rate based on the straight line rate.\n\n    Args:\n        asset_value (float): The initial purchase price of the asset.\n        salvage_value (float): The estimated value of the asset at the end of its useful life.\n        useful_life_years (int): The useful lifespan of the asset in years.\n        year (int): The specific year for which the depreciation is being calculated.\n\n    Returns:\n        annual_depreciation (float): The annual depreciation expense for the specified year.\n\n    Notes:\n        - Useful for assets that depreciate more aggressively in their early years.\n        - Year must be greater than 0 and within the useful life range.\n        - The calculated depreciation should not reduce the book value below salvage value.\n    \"\"\"\n    if year <= 0 or year > useful_life_years:\n        raise ValueError(\"Year must be within the useful life range and greater than 0.\")\n    rate = 2 / useful_life_years\n    current_book_value = asset_value\n    for _ in range(1, year):\n        current_depreciation = current_book_value * rate\n        current_book_value -= current_depreciation\n        if current_book_value < salvage_value:\n            current_book_value = salvage_value\n    annual_depreciation = current_book_value * rate\n    if current_book_value - annual_depreciation < salvage_value:\n        annual_depreciation = current_book_value - salvage_value\n    return annual_depreciation",
        "statistics": {
            "number_statistics": {
                "args_numbers": 4,
                "question_numbers": 0,
                "context_numbers": 3,
                "total_numbers": 3
            },
            "operator_statistics": {
                "operators": {
                    "+": 0,
                    "-": 3,
                    "*": 2,
                    "/": 1,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 6
            },
            "code_statistics": {
                "lines": 11,
                "parentheses": 2
            }
        },
        "difficulty": 4.276666119016055,
        "context": "A company purchases a manufacturing machine for an initial price of $120,000. This machine is estimated to have a useful life of 5 years and a salvage value of $20,000 at the end of its useful life. The company decides to use the double-declining balance method to calculate annual depreciation. The financial manager wants to know the depreciation expense for the third year.",
        "question": "What is the third-year depreciation expense for the machine using the double-declining balance method? Answer to the nearest dollar.",
        "python_solution": "def solution():\n    # Define the variables based on the problem statement\n    asset_value = 120000            # Initial cost of the machine\n    salvage_value = 20000           # Salvage value at the end of its useful life\n    useful_life_years = 5           # Useful life in years\n    year = 3                        # Calculate depreciation for the third year\n\n    # Calculate the depreciation rate for double-declining balance\n    rate = 2 / useful_life_years\n\n    # Initialize the current book value as the initial asset value\n    current_book_value = asset_value\n    # Calculate accumulated depreciation up to the year before the desired year\n    for _ in range(1, year):\n        current_depreciation = current_book_value * rate\n        current_book_value -= current_depreciation\n        # Ensure book value does not fall below salvage value in previous years\n        if current_book_value < salvage_value:\n            current_book_value = salvage_value\n\n    # Calculate depreciation for the desired year\n    annual_depreciation = current_book_value * rate\n    # Ensure annual depreciation does not reduce book value below salvage value\n    if current_book_value - annual_depreciation < salvage_value:\n        annual_depreciation = current_book_value - salvage_value\n\n    # Return the result rounded to the nearest dollar\n    return round(annual_depreciation)",
        "ground_truth": 17280,
        "source": "FinanceReasoning-test-309",
        "question_id": "test-2028",
        "level": "hard",
        "output": [
            "### Step-by-Step Reasoning Using Emphasizing Constraints (EC):\n\n1. **Understand the Given Problem:**\n   - The machine\u2019s purchase price is $120,000.\n   - The estimated salvage value at the end of its useful life is $20,000.\n   - Useful life is 5 years.\n   - The method of depreciation is double-declining balance (DDB).\n   - We are tasked with calculating the **third-year depreciation expense**.\n   - The answer must be rounded to the nearest dollar.\n\n2. **Constraints to Follow:**\n   - Ensure that during the depreciation calculation, the **book value does not go below the salvage value**.\n   - Limit the depreciation calculation **to integers** (for rounding purposes in the final result).\n   - Ensure the depreciation expense is calculated **for the third year only**.\n\n3. **Formulate the Solution:**\n   - Double-declining balance uses twice the straight-line depreciation rate. \n   - Straight-line rate = \\( \\frac{1}{\\text{useful life}} = \\frac{1}{5} = 0.2 \\).\n   - Double-declining rate = \\( 2 \\times 0.2 = 0.4 \\) or 40%.\n   - Depreciation in each year is calculated as:\n     - \\( \\text{Depreciation} = \\text{Current Book Value} \\times \\text{Rate} \\),\n       where the book value is reduced annually by the depreciation expense.\n\n4. **Iterate through the Years (1 to 3):**\n   - Start with the initial book value of $120,000.\n   - For each year, calculate the depreciation, subtract it from the book value, and ensure the book value doesn\u2019t go below the salvage value ($20,000).\n   - Stop at the end of year 3, and return the depreciation for the third year.\n\n5. **Edge Cases and Validation:**\n   - If year requested is outside the useful life range (1\u20135), the function should raise a validation error.\n   - Ensure rounding to the nearest dollar for the final answer.\n\nNow, based on this logical plan, let\u2019s write the Python program.\n\n```python\ndef solution():\n    # Define variables: initial book value, salvage value, useful life, and year of interest\n    initial_book_value = 120000  # Initial purchase price\n    salvage_value = 20000  # Salvage value at the end of useful life\n    useful_life_years = 5  # Useful life of the machine\n    target_year = 3  # Year for which we want to find depreciation\n\n    # Calculate the double-declining rate\n    double_declining_rate = 2 / useful_life_years\n\n    # Initialize book value\n    book_value = initial_book_value\n    \n    # Loop through the years and calculate depreciation\n    for year in range(1, target_year + 1):\n        # Calculate depreciation for the current year\n        depreciation = book_value * double_declining_rate\n        \n        # Ensure depreciation doesn't reduce book value below salvage value\n        if book_value - depreciation < salvage_value:\n            depreciation = book_value - salvage_value\n        \n        # Reduce the book value by the depreciation expense\n        book_value -= depreciation\n        \n        # If we're at the target year, return depreciation for this year\n        if year == target_year:\n            return round(depreciation)\n```"
        ],
        "retrieval_query": "What is the third-year depreciation expense for the machine using the double-declining balance method? Answer to the nearest dollar.",
        "useful_functions": [
            "def calculate_double_declining_balance_depreciation(asset_value: float, salvage_value: float, useful_life_years: int, year: int) -> float:\n    \"\"\"\n    Calculate annual accumulated depreciation using the double-declining balance method.\n\n    This function computes the double declining depreciation expense for a given year \n    by applying a doubled percentage rate based on the straight line rate.\n\n    Args:\n        asset_value (float): The initial purchase price of the asset.\n        salvage_value (float): The estimated value of the asset at the end of its useful life.\n        useful_life_years (int): The useful lifespan of the asset in years.\n        year (int): The specific year for which the depreciation is being calculated.\n\n    Returns:\n        annual_depreciation (float): The annual depreciation expense for the specified year.\n\n    Notes:\n        - Useful for assets that depreciate more aggressively in their early years.\n        - Year must be greater than 0 and within the useful life range.\n        - The calculated depreciation should not reduce the book value below salvage value.\n    \"\"\"\n    if year <= 0 or year > useful_life_years:\n        raise ValueError(\"Year must be within the useful life range and greater than 0.\")\n    rate = 2 / useful_life_years\n    current_book_value = asset_value\n    for _ in range(1, year):\n        current_depreciation = current_book_value * rate\n        current_book_value -= current_depreciation\n        if current_book_value < salvage_value:\n            current_book_value = salvage_value\n    annual_depreciation = current_book_value * rate\n    if current_book_value - annual_depreciation < salvage_value:\n        annual_depreciation = current_book_value - salvage_value\n    return annual_depreciation",
            "def calculate_doubling_declining_balance_depreciation(initial_book_value: float, salvage_value: float, useful_life_years: int, year: int) -> float:\n    \"\"\"\n    Calculate the depreciation expense using the Double-Declining Balance (DDB) method for a specific year.\n\n    This function calculates the depreciation expense for a given year using the double-declining balance method,\n    an accelerated depreciation method that calculates depreciation expense at double the rate of the straight-line method.\n\n    Args:\n        initial_book_value (float): The initial cost of the asset.\n        salvage_value (float): The value of the asset at the end of its useful life.\n        useful_life_years (int): The useful life of the asset in years.\n        year (int): The year for which to calculate the depreciation expense (starting from 1).\n\n    Returns:\n        depreciation_expense (float): The depreciation expense for the specified year.\n\n    Notes:\n        - Applicability: Use for assets that rapidly lose value or become obsolete, such as technology equipment.\n        - Constraints: The calculation stops once the book value reaches or falls below the salvage value.\n        - Considerations: Ensure the year parameter does not exceed the useful life of the asset.\n    \"\"\"\n    if year < 1 or year > useful_life_years:\n        raise ValueError(\"Year must be within the useful life of the asset\")\n\n    book_value = initial_book_value\n    straight_line_rate = 1 / useful_life_years\n    double_declining_rate = 2 * straight_line_rate\n\n    for current_year in range(1, year + 1):\n        depreciation_expense = book_value * double_declining_rate\n        book_value -= depreciation_expense\n\n        if book_value < salvage_value:\n            depreciation_expense = book_value + depreciation_expense - salvage_value\n            book_value = salvage_value\n\n    return max(0, depreciation_expense)"
        ],
        "usage": {
            "completion_tokens": 710,
            "prompt_tokens": 1203,
            "total_tokens": 1913,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-3076",
        "article_title": "Ordinary Income",
        "function": "def apply_marginal_tax_rate(income: float, tax_brackets: list) -> float:\n    \"\"\"\n    Calculate tax liability using marginal tax rates.\n\n    This function applies the appropriate marginal tax rates to calculate the total\n    tax liability for a given income based on provided tax brackets.\n\n    Args:\n        income (float): The total income to be taxed.\n        tax_brackets (list): A list of tuples where each tuple contains the income limit\n                             and the tax rate (e.g., [(limit1, rate1), (limit2, rate2), ...]).\n\n    Returns:\n        tax_liability (float): The total tax liability based on the income and tax brackets.\n\n    Notes:\n        - Applicability: Useful for calculating taxes for individuals and businesses.\n        - Constraints: Ensure the tax brackets are sorted in ascending order of income limits.\n        - Considerations: This does not account for tax deductions or credits.\n    \"\"\"\n    tax_liability = 0.0\n    previous_limit = 0.0\n\n    for limit, rate in tax_brackets:\n        if income > limit:\n            tax_liability += (limit - previous_limit) * rate\n            previous_limit = limit\n        else:\n            tax_liability += (income - previous_limit) * rate\n            break\n\n    return tax_liability",
        "statistics": {
            "number_statistics": {
                "args_numbers": 2,
                "question_numbers": 1,
                "context_numbers": 11,
                "total_numbers": 12
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 2,
                    "*": 2,
                    "/": 0,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 6
            },
            "code_statistics": {
                "lines": 10,
                "parentheses": 4
            }
        },
        "difficulty": 4.276666119016055,
        "context": "Alice has recently received a significant annual bonus and wants to calculate her tax liability for the year. Her total taxable income, including the bonus, amounts to 115,000. The tax rates are structured progressively as follows: 10% on income up to 10,000, 15% on income over 10,000 and up to 40,000, 20% on income over 40,000 and up to 90,000, and 25% on income over 90,000. Alice wants to know how much she must pay in taxes for the year in total.",
        "question": "What is the total tax liability for Alice based on her annual income of 115,000? Answer to the nearest integer.",
        "python_solution": "def solution():\n    # Define Alice's total income\n    income = 115000\n    \n    # Define the tax brackets as tuples of (income limit, tax rate)\n    tax_brackets = [\n        (10000, 0.10),  # 10% on income up to 10,000\n        (40000, 0.15),  # 15% on income over 10,000 and up to 40,000\n        (90000, 0.20),  # 20% on income over 40,000 and up to 90,000\n        (float('inf'), 0.25)  # 25% on income over 90,000\n    ]\n    \n    # Initialize the tax liability and previous limit\n    tax_liability = 0.0\n    previous_limit = 0.0\n    \n    # Calculate the total tax liability based on the marginal tax rates\n    for limit, rate in tax_brackets:\n        if income > limit:\n            tax_liability += (limit - previous_limit) * rate\n            previous_limit = limit\n        else:\n            tax_liability += (income - previous_limit) * rate\n            break\n\n    # Return the tax liability rounded to the nearest integer\n    return round(tax_liability)",
        "ground_truth": 21750,
        "source": "FinanceReasoning-test-322",
        "question_id": "test-2029",
        "level": "hard",
        "output": [
            "Let us solve the problem step by step using the **Emphasizing Constraints (EC)** technique:\n\n---\n\n### Problem Understanding\n1. Alice's taxable income: \\$115,000.\n2. Tax rates are applied progressively as follows:\n   - **10%** on income up to \\$10,000.\n   - **15%** on income from \\$10,001 to \\$40,000.\n   - **20%** on income from \\$40,001 to \\$90,000.\n   - **25%** on income above \\$90,000.\n3. The task is to calculate Alice's total tax liability.\n\n---\n\n### Constraints and Observations\n1. The tax brackets should be strictly ordered in ascending order.\n2. We need to calculate taxes progressively\u2014different parts of income are taxed at different rates.\n3. The result must be rounded to the nearest integer.\n\n---\n\n### Calculation Steps\nTo compute the total tax liability for \\$115,000:\n\n1. Compute the tax on each bracket:\n   - For \\$0 to \\$10,000 at 10%.\n   - For \\$10,001 to \\$40,000 at 15%.\n   - For \\$40,001 to \\$90,000 at 20%.\n   - For income exceeding \\$90,000 at 25%.\n\n2. Sum up the tax liabilities from all tax brackets.\n\n---\n\n### Implementation Plan\nWe'll:\n1. Store the tax brackets (\\$10,000, \\$40,000, \\$90,000) and corresponding rates (0.10, 0.15, 0.20, 0.25).\n2. Iterate through each bracket, calculate the tax for that segment, and accumulate the total tax liability.\n3. Handle the case for any income above the highest bracket (\\$90,000).\n4. Return the total tax liability rounded to the nearest integer.\n\n---\n\n### Python Program\nHere is the implementation:\n\n```python\ndef solution():\n    # Define variables for taxable income, tax brackets, and tax rates\n    taxable_income = 115000\n    tax_brackets = [10000, 40000, 90000]\n    tax_rates = [0.10, 0.15, 0.20, 0.25]\n    \n    # Initialize total tax liability\n    total_tax = 0\n    \n    # Iterate over brackets to compute tax liability\n    previous_bracket = 0\n    for i, bracket in enumerate(tax_brackets):\n        if taxable_income > bracket:\n            # Tax the income portion within the current bracket\n            total_tax += (bracket - previous_bracket) * tax_rates[i]\n            previous_bracket = bracket\n        else:\n            # Tax the remaining income in the current bracket range\n            total_tax += (taxable_income - previous_bracket) * tax_rates[i]\n            return round(total_tax)  # Return the rounded tax liability\n    \n    # Tax any income above the highest bracket\n    total_tax += (taxable_income - previous_bracket) * tax_rates[-1]\n    return round(total_tax)\n```"
        ],
        "retrieval_query": "What is the total tax liability for Alice based on her annual income of 115,000? Answer to the nearest integer.",
        "useful_functions": [
            "def calculate_tax_liability(taxable_income: float, tax_brackets: list, tax_rates: list) -> float:\n    \"\"\"\n    Calculate the tax liability based on taxable income and tax brackets.\n\n    This function calculates the tax liability using a progressive tax system,\n    where different portions of income are taxed at different rates.\n\n    Args:\n        taxable_income (float): The taxable income on which taxes are to be calculated.\n        tax_brackets (list): The income thresholds for each tax rate.\n        tax_rates (list): The tax rates corresponding to each tax bracket.\n\n    Returns:\n        tax_liability (float): The total tax liability.\n\n    Notes:\n        - Applicability: Useful for determining taxes using U.S.-style progressive tax systems.\n        - Constraints: Tax brackets and tax rates should have the same length.\n        - Considerations: Ensure that tax brackets are ordered in ascending order.\n    \"\"\"\n    if len(tax_brackets) != len(tax_rates):\n        raise ValueError(\"Tax brackets and tax rates must have the same length.\")\n    \n    tax_liability = 0.0\n    for i, rate in enumerate(tax_rates):\n        if i == 0:\n            lower_bound = 0\n        else:\n            lower_bound = tax_brackets[i-1]\n        \n        upper_bound = tax_brackets[i]\n        \n        if taxable_income > lower_bound:\n            amount_to_tax = min(taxable_income, upper_bound) - lower_bound\n            tax_liability += amount_to_tax * rate\n    \n    if taxable_income > tax_brackets[-1]:\n        tax_liability += (taxable_income - tax_brackets[-1]) * tax_rates[-1]\n    \n    return tax_liability",
            "def apply_marginal_tax_rate(income: float, tax_brackets: list) -> float:\n    \"\"\"\n    Calculate tax liability using marginal tax rates.\n\n    This function applies the appropriate marginal tax rates to calculate the total\n    tax liability for a given income based on provided tax brackets.\n\n    Args:\n        income (float): The total income to be taxed.\n        tax_brackets (list): A list of tuples where each tuple contains the income limit\n                             and the tax rate (e.g., [(limit1, rate1), (limit2, rate2), ...]).\n\n    Returns:\n        tax_liability (float): The total tax liability based on the income and tax brackets.\n\n    Notes:\n        - Applicability: Useful for calculating taxes for individuals and businesses.\n        - Constraints: Ensure the tax brackets are sorted in ascending order of income limits.\n        - Considerations: This does not account for tax deductions or credits.\n    \"\"\"\n    tax_liability = 0.0\n    previous_limit = 0.0\n\n    for limit, rate in tax_brackets:\n        if income > limit:\n            tax_liability += (limit - previous_limit) * rate\n            previous_limit = limit\n        else:\n            tax_liability += (income - previous_limit) * rate\n            break\n\n    return tax_liability",
            "def calculate_progressive_tax(income: float, brackets: list, rates: list) -> float:\n    \"\"\"\n    Calculate the tax liability using a progressive tax system.\n\n    This function computes the tax liability for a given income based on a \n    progressive tax system, where the tax rate increases with income brackets.\n\n    Args:\n        income (float): The total income subject to taxation.\n        brackets (list): A sorted list of income thresholds for tax brackets.\n        rates (list): A list of tax rates corresponding to each bracket.\n\n    Returns:\n        tax_liability (float): The calculated tax liability.\n\n    Notes:\n        - Applicability: Suitable for tax systems using progressive rates.\n        - Constraints: The brackets list should be sorted in ascending order, \n          with a rate for each bracket.\n        - Considerations: The function assumes brackets and rates are aligned, \n          with each rate applicable to income above the previous bracket and \n          up to the current bracket.\n    \"\"\"\n    if len(brackets) != len(rates):\n        raise ValueError(\"The number of brackets must match the number of rates.\")\n\n    tax_liability = 0.0\n    previous_bracket_limit = 0.0\n\n    for i, (bracket, rate) in enumerate(zip(brackets, rates)):\n        if income > bracket:\n            tax_liability += (bracket - previous_bracket_limit) * rate\n            previous_bracket_limit = bracket\n        else:\n            tax_liability += (income - previous_bracket_limit) * rate\n            break\n    \n    return tax_liability"
        ],
        "usage": {
            "completion_tokens": 630,
            "prompt_tokens": 1431,
            "total_tokens": 2061,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-1584",
        "article_title": "Risk Management",
        "function": "def calculate_standard_deviation(returns: list) -> float:\n    \"\"\"\n    Calculate the standard deviation of a series of investment returns.\n\n    This function computes the standard deviation, which is a measure of\n    dispersion or volatility, for a given list of investment returns.\n    This metric is often used in finance to assess investment risk.\n\n    Args:\n        returns (list): A list of investment returns (e.g., [0.05, 0.02, -0.01]).\n\n    Returns:\n        standard_deviation (float): The standard deviation of the returns.\n\n    Notes:\n        - Applicability: This function is applicable to any dataset where\n          the standard deviation is a relevant measure of risk or dispersion.\n        - Constraints: Ensure that the input list is not empty.\n        - Considerations: Returns should ideally represent the same time intervals\n          and be in the same units (e.g., percentages).\n    \"\"\"\n    if not returns:\n        raise ValueError(\"The returns list must not be empty.\")\n\n    mean_return = sum(returns) / len(returns)\n    variance = sum((r - mean_return) ** 2 for r in returns) / len(returns)\n    standard_deviation = variance ** 0.5\n    \n    return standard_deviation\n\ndef calculate_beta(portfolio_returns: list, market_returns: list) -> float:\n    \"\"\"\n    Calculate the beta of a portfolio in relation to the market.\n\n    Beta is a measure of a portfolio's volatility or systematic risk in\n    comparison to the market as a whole. It is derived using the covariance\n    between portfolio returns and market returns, divided by the variance\n    of the market returns.\n\n    Args:\n        portfolio_returns (list): A list of returns for the portfolio.\n        market_returns (list): A list of returns for the market benchmark.\n\n    Returns:\n        beta (float): The beta value indicating the relative volatility.\n\n    Notes:\n        - Applicability: This function is relevant for comparing a portfolio's\n          risk to the market risk.\n        - Constraints: Both input lists must be of equal length and not empty.\n        - Considerations: Returns should correspond to the same time periods\n          and be in the same units.\n    \"\"\"\n    if len(portfolio_returns) != len(market_returns):\n        raise ValueError(\"Lists portfolio_returns and market_returns must be of equal length.\")\n    \n    market_mean = sum(market_returns) / len(market_returns)\n    portfolio_mean = sum(portfolio_returns) / len(portfolio_returns)\n\n    covariance = sum((pr - portfolio_mean) * (mr - market_mean) for pr, mr in zip(portfolio_returns, market_returns)) / len(portfolio_returns)\n    market_variance = sum((mr - market_mean) ** 2 for mr in market_returns) / len(market_returns)\n\n    beta = covariance / market_variance\n\n    return beta",
        "statistics": {
            "number_statistics": {
                "args_numbers": 1,
                "question_numbers": 0,
                "context_numbers": 24,
                "total_numbers": 24
            },
            "operator_statistics": {
                "operators": {
                    "+": 0,
                    "-": 2,
                    "*": 0,
                    "/": 2,
                    "%": 0,
                    "**": 2
                },
                "total_operators": 6
            },
            "code_statistics": {
                "lines": 6,
                "parentheses": 12
            }
        },
        "difficulty": 4.276666119016055,
        "context": "An investment analyst is evaluating two portfolios to understand their relative risks and volatilities. The analyst gathers data on the monthly returns of both portfolios for the past year. For Portfolio A, the monthly returns are recorded as [0.02, 0.03, 0.01, -0.01, 0.02, 0.01, 0.03, 0.02, 0.01, 0.02, 0.01, 0.04], while the monthly returns of the market, used as a benchmark, are [0.01, 0.02, 0.02, -0.02, 0.03, 0.02, 0.01, 0.02, 0.03, 0.01, 0.02, 0.03]. The analyst is tasked with calculating the beta of Portfolio A to understand how the portfolio's risk compares with the market's risk.",
        "question": "What is the beta of Portfolio A relative to the market? Answer to two decimal places.",
        "python_solution": "def solution():\n    # Define the monthly returns for Portfolio A and the market\n    portfolio_returns = [0.02, 0.03, 0.01, -0.01, 0.02, 0.01, 0.03, 0.02, 0.01, 0.02, 0.01, 0.04]\n    market_returns = [0.01, 0.02, 0.02, -0.02, 0.03, 0.02, 0.01, 0.02, 0.03, 0.01, 0.02, 0.03]\n\n    # Calculate the mean of returns for both the portfolio and the market\n    portfolio_mean = sum(portfolio_returns) / len(portfolio_returns)\n    market_mean = sum(market_returns) / len(market_returns)\n\n    # Calculate covariance between portfolio and market returns\n    covariance = sum((pr - portfolio_mean) * (mr - market_mean) for pr, mr in zip(portfolio_returns, market_returns)) / len(portfolio_returns)\n    \n    # Calculate variance of market returns\n    market_variance = sum((mr - market_mean) ** 2 for mr in market_returns) / len(market_returns)\n    \n    # Calculate beta\n    beta = covariance / market_variance\n\n    # Return the beta value rounded to two decimal places\n    return round(beta, 2)",
        "ground_truth": 0.53,
        "source": "FinanceReasoning-test-352",
        "question_id": "test-2030",
        "level": "hard",
        "output": [
            "To calculate the beta of Portfolio A relative to the market, we need to evaluate its volatility against the market using the historical monthly returns provided. Beta is a financial metric that measures the sensitivity of the portfolio's returns relative to the benchmark (market). It is calculated as:\n\n\\[\n\\text{Beta} = \\frac{\\text{Covariance of Portfolio Returns and Market Returns}}{\\text{Variance of Market Returns}}\n\\]\n\nHere are the steps for the calculation:\n\n### Step-by-Step Approach:\n\n1. **Adhere to Constraints**:\n   - Both `Portfolio A` and `market` return lists must have the same length.\n   - Use appropriate precision (answer rounded to two decimal places).\n   - Input data consists of monthly returns.\n\n2. **Methodology**:\n   - Compute the mean (average) of Portfolio A returns and market returns.\n   - Calculate the **variance** of the market returns. The variance is calculated as:\n     \\[\n     \\text{Variance} = \\frac{\\sum_{i=1}^{n} (\\text{Market Return}_i - \\mu_\\text{market})^2}{n-1}\n     \\]\n     where \\( \\mu_\\text{market} \\) is the average of market returns.\n   - Compute the **covariance** between Portfolio A returns and market returns:\n     \\[\n     \\text{Covariance} = \\frac{\\sum_{i=1}^{n} (\\text{Portfolio A Return}_i - \\mu_\\text{Portfolio}) \\cdot (\\text{Market Return}_i - \\mu_\\text{market})}{n-1}\n     \\]\n   - Calculate Beta as the ratio of covariance to variance:\n     \\[\n     \\text{Beta} = \\frac{\\text{Covariance}}{\\text{Variance}}\n     \\]\n\n3. **Tools**:\n   - Compute all values precisely and ensure normalization between covariance and variance.\n\n4. **Edge Cases**:\n   - Ensure no division by zero (e.g., variance must not be zero).\n\nUsing the above methodology, we can create a Python program to calculate the Beta.\n\n---\n\n```python\ndef solution():\n    # Step 1: Define the input data\n    portfolio_a_returns = [0.02, 0.03, 0.01, -0.01, 0.02, 0.01, 0.03, 0.02, 0.01, 0.02, 0.01, 0.04]\n    market_returns = [0.01, 0.02, 0.02, -0.02, 0.03, 0.02, 0.01, 0.02, 0.03, 0.01, 0.02, 0.03]\n    \n    # Step 2: Verify the inputs have the same length\n    if len(portfolio_a_returns) != len(market_returns):\n        raise ValueError(\"Return lists must have the same length.\")\n    \n    # Step 3: Calculate the means of portfolio and market returns\n    mean_portfolio = sum(portfolio_a_returns) / len(portfolio_a_returns)\n    mean_market = sum(market_returns) / len(market_returns)\n    \n    # Step 4: Calculate the covariance between Portfolio A and market\n    covariance = sum(\n        (portfolio_a - mean_portfolio) * (market - mean_market)\n        for portfolio_a, market in zip(portfolio_a_returns, market_returns)\n    ) / (len(portfolio_a_returns) - 1)\n    \n    # Step 5: Calculate the variance of the market returns\n    variance_market = sum(\n        (market - mean_market) ** 2 for market in market_returns\n    ) / (len(market_returns) - 1)\n    \n    # Step 6: Calculate the beta\n    beta = covariance / variance_market\n    \n    # Step 7: Return the beta rounded to two decimal places\n    return round(beta, 2)\n```"
        ],
        "retrieval_query": "What is the beta of Portfolio A relative to the market? Answer to two decimal places.",
        "useful_functions": [
            "def calculate_beta(stock_returns: list, market_returns: list) -> float:\n    \"\"\"\n    Calculate the beta of a stock, indicating its volatility relative to the market.\n\n    Beta is a measure of a stock's volatility in relation to the overall market.\n    A beta of 1 indicates that the stock's price tends to move with the market.\n    A beta greater than 1 indicates greater volatility than the market, while a beta less\n    than 1 indicates less volatility.\n\n    Args:\n        stock_returns (list): A list of periodic return rates for the stock.\n        market_returns (list): A list of periodic return rates for the market benchmark,\n                               such as the S&P 500. Must be of the same length as stock_returns.\n\n    Returns:\n        beta (float): The beta of the stock relative to the market.\n\n    Notes:\n        - Applicability: Used in assessing the risk and expected return of a stock or portfolio.\n        - Constraints: The input lists must represent returns for the same periods and must have\n          the same length.\n        - Considerations: Beta reflects past volatility and may not predict future volatility.\n          Values could be affected by outliers in the historical data.\n    \"\"\"\n    if len(stock_returns) != len(market_returns):\n        raise ValueError(\"Both input lists must have the same number of elements.\")\n\n    market_variance = sum((r - (sum(market_returns) / len(market_returns))) ** 2 for r in market_returns)\n    covariance = sum((s - (sum(stock_returns) / len(stock_returns))) * \n                     (m - (sum(market_returns) / len(market_returns))) for s, m in zip(stock_returns, market_returns))\n\n    if market_variance == 0:\n        raise ValueError(\"Market variance is zero, cannot calculate beta.\")\n    \n    beta = covariance / market_variance\n    \n    return beta",
            "def calculate_beta(asset_returns: list, benchmark_returns: list) -> float:\n    \"\"\"\n    Calculate the beta of a security relative to a benchmark index.\n\n    This function computes the beta, which measures the volatility or systematic\n    risk of a security or portfolio in comparison to the market as a whole.\n\n    Args:\n        asset_returns (list): A list of returns for the asset in question.\n        benchmark_returns (list): A list of returns for the benchmark index,\n                                  such as the S&P 500.\n\n    Returns:\n        beta (float): The beta of the asset relative to the benchmark.\n\n    Notes:\n        - Applicability: Use this function to assess the relative risk of an asset.\n        - Constraints: The lengths of asset_returns and benchmark_returns\n                       must match.\n        - Considerations: A beta of 1 indicates that the asset's price moves\n                          with the market. A beta greater than 1 indicates greater\n                          volatility than the market, and less than 1 indicates\n                          less volatility.\n    \"\"\"\n    if len(asset_returns) != len(benchmark_returns):\n        raise ValueError(\"The returns lists must be of the same length.\")\n\n    covariance = sum((a - sum(asset_returns) / len(asset_returns)) * \n                     (b - sum(benchmark_returns) / len(benchmark_returns)) \n                     for a, b in zip(asset_returns, benchmark_returns)) / len(asset_returns)\n                     \n    variance = sum((b - sum(benchmark_returns) / len(benchmark_returns)) ** 2 for b in benchmark_returns) / len(benchmark_returns)\n    \n    beta = covariance / variance\n\n    return beta",
            "def calculate_beta(asset_returns: list, market_returns: list) -> float:\n    \"\"\"\n    Calculate the beta of an asset, which measures its volatility in relation to the market.\n\n    Beta is used in finance to gauge the risk of an asset relative to the overall market. It indicates \n    whether the asset tends to move with the market (beta > 1), is less volatile (beta < 1), or is inversely \n    correlated (beta < 0).\n\n    Args:\n        asset_returns (list): A list of historical returns for the asset.\n        market_returns (list): A list of historical returns for the market, typically represented by an index.\n\n    Returns:\n        beta (float): The calculated beta value of the asset.\n\n    Notes:\n        - Applicability: Suitable for portfolios or individual securities with return data.\n        - Constraints: Requires consistent timeframes and return intervals for asset and market data.\n        - Considerations: May not account for duplication or regime change in highly volatile periods.\n    \"\"\"\n    if len(asset_returns) != len(market_returns):\n        raise ValueError(\"Asset and market return lists must have the same length.\")\n    \n    # Calculate covariance between asset and market, and variance of the market\n    covariance = sum((a - sum(asset_returns) / len(asset_returns)) * (m - sum(market_returns) / len(market_returns))\n                     for a, m in zip(asset_returns, market_returns)) / (len(asset_returns) - 1)\n    market_variance = sum((m - sum(market_returns) / len(market_returns)) ** 2 for m in market_returns) / (len(market_returns) - 1)\n    \n    beta = covariance / market_variance\n    \n    return beta"
        ],
        "usage": {
            "completion_tokens": 833,
            "prompt_tokens": 1636,
            "total_tokens": 2469,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "Superior Inc. anticipates paying dividends of $0.5 per share for the upcoming two years. Dividends are predicted to increase at a 6% growth rate after that. Given a 10% rate of return, what is the worth of Superior's common equity? Answer to three decimal places.",
        "python_solution": "def solution():\n    D01=D02=0.5 \n    P02=0.5*(1.06)/(0.1-0.06)\n    V= (0.5)/1.1+(0.5+P02)/(1.1**2)\n    return V",
        "ground_truth": 11.818,
        "topic": "Asset Classes & Derivatives",
        "statistics": {
            "number_statistics": {
                "args_numbers": 4,
                "question_numbers": 3,
                "context_numbers": 0,
                "total_numbers": 3
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 1,
                    "*": 1,
                    "/": 3,
                    "%": 0,
                    "**": 1
                },
                "total_operators": 8
            },
            "code_statistics": {
                "lines": 4,
                "parentheses": 10
            }
        },
        "difficulty": 4.276666119016055,
        "source": "FinanceMath-validation-10",
        "context": "[]",
        "question_id": "test-2031",
        "level": "hard",
        "output": [
            "### Step-by-Step Analysis Using EC (Emphasizing Constraints):\n\n1. **Understanding the Question**:\n   - The problem requires us to calculate the worth of Superior's common equity based on the provided dividend information and growth rates.\n   - We are using the Two-Stage Dividend Discount Model (DDM).\n   \n2. **Constraints**:\n   - We are given:\n     - Fixed dividends for the first two years = $0.5 per share each year.\n     - A perpetual growth rate of dividends beyond these two years = 6% (0.06).\n     - The required rate of return (discount rate) = 10% (0.10).\n   - The answer must be presented to **three decimal places**. This is a formatting constraint we must adhere to.\n\n3. **Approach**:\n   - Use the two-stage dividend discount model. It calculates:\n     - Present value of dividends during the initial fixed period (years 1 and 2).\n     - Present value of growing dividends after the fixed period (perpetuity starting from year 3).\n   - Formula for perpetuity:\n     \\[\n     P = \\frac{D}{r - g}\n     \\]\n     where:\n     - \\( D \\) = dividend at the beginning of the perpetual phase (calculated by compounding the last fixed dividend with growth rate),\n     - \\( r \\) = required rate of return,\n     - \\( g \\) = growth rate.\n   - Combine the present value of the fixed dividends and the perpetual phase dividends.\n\n4. **Mathematical Breakdown**:\n   - Present value of year 1 dividend:\n     \\[\n     PV_1 = \\frac{0.5}{(1 + 0.10)^1}\n     \\]\n   - Present value of year 2 dividend:\n     \\[\n     PV_2 = \\frac{0.5}{(1 + 0.10)^2}\n     \\]\n   - Dividend at year 3 to perpetuity:\n     \\[\n     D_3 = 0.5 \\times (1 + 0.06)\n     \\]\n   - Present value of perpetuity:\n     \\[\n     PV_{\\text{perpetuity}} = \\frac{D_3}{0.10 - 0.06} \\times \\frac{1}{(1 + 0.10)^2}\n     \\]\n   - Add all components to determine the total worth of equity:\n     \\[\n     \\text{Equity Worth} = PV_1 + PV_2 + PV_{\\text{perpetuity}}\n     \\]\n\n5. **Implementation via Python**:\n   - Define the variables for dividends, rates, and periods.\n   - Perform the mathematical calculations step-by-step as outlined.\n   - Format the answer to three decimal places before returning.\n\nHere is the Python program:\n\n```python\ndef solution():\n    # Define variables\n    fixed_dividend = 0.5  # Fixed dividend for years 1 and 2\n    growth_rate = 0.06    # Perpetual growth rate\n    discount_rate = 0.10  # Required rate of return\n    periods = 2           # Number of years of fixed dividends\n    \n    # Calculate present value of fixed dividends (years 1 and 2)\n    pv_year_1 = fixed_dividend / (1 + discount_rate)**1\n    pv_year_2 = fixed_dividend / (1 + discount_rate)**2\n    \n    # Calculate the first dividend of the perpetuity phase (year 3)\n    dividend_3 = fixed_dividend * (1 + growth_rate)\n    \n    # Calculate the present value of the perpetuity\n    perpetuity_value = dividend_3 / (discount_rate - growth_rate)\n    pv_perpetuity = perpetuity_value / (1 + discount_rate)**2\n    \n    # Total worth of equity\n    equity_worth = pv_year_1 + pv_year_2 + pv_perpetuity\n    \n    # Return answer rounded to three decimal places\n    return round(equity_worth, 3)\n```"
        ],
        "retrieval_query": "Superior Inc. anticipates paying dividends of $0.5 per share for the upcoming two years. Dividends are predicted to increase at a 6% growth rate after that. Given a 10% rate of return, what is the worth of Superior's common equity? Answer to three decimal places.",
        "useful_functions": [
            "def calculate_inherent_worth(risk_free_rate: float, beta: float, market_risk_premium: float,\n                             dividends: list, long_term_growth_rate: float, periods: int = 2) -> float:\n    \"\"\"\n    Calculate the inherent worth of a company per share using the two-step dividend discount model (DDM).\n\n    This function utilizes the capital asset pricing model (CAPM) to determine the required rate of return\n    and then applies the two-step dividend discount model to evaluate the inherent worth of a company's stock.\n\n    Args:\n        risk_free_rate (float): The current risk-free rate expressed as a decimal.\n        beta (float): The beta of the stock, indicating its volatility compared to the market.\n        market_risk_premium (float): The expected market risk premium expressed as a decimal.\n        dividends (list): A list of expected dividends per share for the initial period(s), starting from year 1.\n                          This should include all dividends up to the end of the specified periods.\n        long_term_growth_rate (float): The growth rate of dividends starting after the specified periods, expressed as a decimal.\n        periods (int, optional): The number of initial periods for which dividends are explicitly provided. Default is 2.\n\n    Returns:\n        inherent_worth (float): The calculated inherent worth of the stock per share.\n\n    Notes:\n        - This function assumes that dividends grow at a stable rate after the specified number of periods.\n        - The required rate of return (r) is calculated as risk_free_rate + beta * market_risk_premium.\n        - The function assumes dividends are given in chronological order and are scaled to the same currency.\n        - Ensure inputs like the risk-free rate, growth rate, and market risk premium are in decimal form (e.g., 5% as 0.05).\n        - The model does not account for changes in share price due to external factors unrelated to dividends.\n    \"\"\"\n    # Calculate the required rate of return using CAPM\n    required_rate_of_return = risk_free_rate + beta * market_risk_premium\n    \n    # Calculate the present value of dividends for initial periods\n    present_value_of_dividends = sum(dividends[i] / ((1 + required_rate_of_return) ** (i + 1)) for i in range(periods))\n    \n    # Calculate the terminal value at the end of specified periods\n    last_dividend = dividends[-1]\n    dividend_at_steady_growth = last_dividend * (1 + long_term_growth_rate)\n    terminal_value = dividend_at_steady_growth / (required_rate_of_return - long_term_growth_rate)\n    \n    # Calculate the present value of the terminal value\n    present_value_of_terminal_value = terminal_value / ((1 + required_rate_of_return) ** periods)\n    \n    # Sum the present values to get the total inherent worth\n    inherent_worth = present_value_of_dividends + present_value_of_terminal_value\n    \n    return inherent_worth",
            "def calculate_two_stage_dividend_discount(fixed_dividends: list, growth_rate: float, \n                                          discount_rate: float, initial_dividend: float,\n                                          growth_start_year: int) -> float:\n    \"\"\"\n    Calculate the value of common equity using the two-stage dividend discount model.\n\n    This function computes the present value of a stock based on fixed dividends for a few years \n    followed by perpetual growth. It is particularly useful for valuing firms expected to have \n    a period of stable dividends before transitioning to a constant growth rate.\n\n    Args:\n        fixed_dividends (list): List of dividends for the period with fixed payouts.\n        growth_rate (float): The perpetual growth rate of dividends after the fixed period.\n                             Must be between 0 and 1 (exclusive).\n        discount_rate (float): The required rate of return for the equity. Must be greater \n                               than zero and greater than growth_rate.\n        initial_dividend (float): The dividend at the start of the perpetual growth phase.\n        growth_start_year (int): The year when the perpetual growth phase begins, \n                                 corresponding to the first year of the growth rate application.\n\n    Returns:\n        equity_value (float): The present value of the company's common equity.\n\n    Notes:\n        - Applicability: Ideal for valuing firms with an anticipated fixed dividend period \n          followed by a stable growth phase (two-stage model).\n        - Constraints: The growth rate must be positive and smaller than the discount rate \n          to ensure a valid perpetuity calculation.\n        - Considerations: Ensure all rates are expressed in decimal form (e.g., 5% as 0.05).\n    \"\"\"\n    # Calculate the present value of fixed dividends\n    pv_fixed_dividends = sum(dividend / ((1 + discount_rate) ** (i + 1)) \n                             for i, dividend in enumerate(fixed_dividends))\n    \n    # Determine the future value of the perpetuity at the beginning of the growth phase\n    future_value_growth = initial_dividend * (1 + growth_rate) / (discount_rate - growth_rate)\n    \n    # Calculate the present value of the growing perpetuity\n    pv_growth = future_value_growth / ((1 + discount_rate) ** growth_start_year)\n    \n    # Sum the present values to get the total equity value\n    equity_value = pv_fixed_dividends + pv_growth\n    \n    return equity_value",
            "def calculate_cumulative_total_shareholder_return(initial_value: float, final_value: float) -> float:\n    \"\"\"\n    Calculate the percentage cumulative total shareholder return over a period.\n\n    This function computes the cumulative total shareholder return given the initial\n    investment value and the final value at the end of the investment period. The return\n    accounts for price appreciation and assumed reinvestment of dividends.\n\n    Args:\n        initial_value (float): The initial value of the investment (e.g., $100).\n        final_value (float): The final value of the investment at the end of the\n                             period, including price appreciation and reinvested dividends.\n\n    Returns:\n        percent_return (float): The percentage cumulative total shareholder return\n                                expressed as a percentage to three decimal places.\n\n    Notes:\n        - Applicability: This function is applicable for evaluating the performance of\n          an investment over a specified time period.\n        - Constraints: Initial and final values must be positive numbers.\n        - Considerations: The function assumes dividends are reinvested and does not\n          account for taxes or fees.\n    \"\"\"\n    if initial_value <= 0:\n        raise ValueError(\"Initial value must be positive.\")\n    \n    percent_return = ((final_value / initial_value) - 1) * 100\n    \n    return percent_return"
        ],
        "usage": {
            "completion_tokens": 844,
            "prompt_tokens": 1771,
            "total_tokens": 2615,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "A researcher collects the following data on a bond: Roughly modified duration 10.3829 and roughly modified convexity 141.217. What is the projected percentage price alteration for the bond should the yield to maturity fall by 50 bps (expressed as a percentage)? Answer to three decimal places.",
        "python_solution": "def solution():\n    MD = 10.3829\n    Convexity = 141.217\n    Delta_Yield= -0.005\n    Percentage_change_in_bond_price = ((-MD*Delta_Yield)+(0.5*Convexity*(Delta_Yield)**2))  \n    return Percentage_change_in_bond_price*100",
        "ground_truth": 5.368,
        "topic": "Asset Classes & Derivatives",
        "statistics": {
            "number_statistics": {
                "args_numbers": 5,
                "question_numbers": 3,
                "context_numbers": 0,
                "total_numbers": 3
            },
            "operator_statistics": {
                "operators": {
                    "+": 1,
                    "-": 2,
                    "*": 4,
                    "/": 0,
                    "%": 0,
                    "**": 1
                },
                "total_operators": 8
            },
            "code_statistics": {
                "lines": 5,
                "parentheses": 8
            }
        },
        "difficulty": 4.276666119016055,
        "source": "FinanceMath-validation-102",
        "context": "[]",
        "question_id": "test-2032",
        "level": "hard",
        "output": [
            "To solve this problem, let's break it down step by step while adhering to advanced reasoning techniques, particularly by emphasizing constraints:\n\n### Step 1: Constraints and Formula\n1. **Constraints**:\n   - The given data includes \"modified duration\" and \"modified convexity\". These are key financial measures used to project changes in bond prices when the yield changes.\n   - The yield to maturity (YTM) falls by 50 basis points (bps), which is equivalent to -0.005 in decimal form.\n   - The final answer is to be expressed as a percentage and rounded to three decimal places.\n\n2. **Formula**:\n   The projected percentage price change is calculated using:\n   \\[\n   \\Delta P \\% = - (Modified\\ Duration \\times \\Delta Yield) + \\frac{1}{2} \\times Modified\\ Convexity \\times (\\Delta Yield)^2\n   \\]\n   - \\( Modified\\ Duration \\): Measure of price sensitivity to changes in yield.\n   - \\( Modified\\ Convexity \\): Measure of how the duration changes with yield changes.\n   - \\( \\Delta Yield = -0.005 \\): Change in yield (given as a fall by 50bps).\n\n3. Round the final result to three decimal places.\n\n### Step 2: Implementation\nUsing the above formula, we will compute the projected percentage price change.\n\n```python\ndef solution():\n    # Define variables name and value\n    modified_duration = 10.3829  # Modified duration of the bond\n    modified_convexity = 141.217  # Modified convexity of the bond\n    delta_yield = -0.005  # Change in yield, falling by 50 basis points\n    \n    # Calculate the price percentage alteration\n    price_change_percentage = (- (modified_duration * delta_yield) \n                               + (0.5 * modified_convexity * delta_yield**2))\n    \n    # Return the answer, rounded to three decimal places\n    return round(price_change_percentage, 3)\n```\n\nThis program should correctly compute the percentage price alteration rounded to three decimal places."
        ],
        "retrieval_query": "A researcher collects the following data on a bond: Roughly modified duration 10.3829 and roughly modified convexity 141.217. What is the projected percentage price alteration for the bond should the yield to maturity fall by 50 bps (expressed as a percentage)? Answer to three decimal places.",
        "useful_functions": [],
        "usage": {
            "completion_tokens": 434,
            "prompt_tokens": 390,
            "total_tokens": 824,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "What is the value of the Paasche index for the consumption basket shown in Exhibit 1 for December? Answer to three decimal places.",
        "python_solution": "def solution():\n    numerator = (120 * 1) + (50 * 0.8)\n    denominator = (120 * 0.9) + (50 * 0.6)\n    paasche_index = (numerator/denominator) * 100\n    return paasche_index",
        "ground_truth": 115.942,
        "topic": "Market Analysis & Economics",
        "statistics": {
            "number_statistics": {
                "args_numbers": 4,
                "question_numbers": 1,
                "context_numbers": 4,
                "total_numbers": 5
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 0,
                    "*": 5,
                    "/": 1,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 8
            },
            "code_statistics": {
                "lines": 4,
                "parentheses": 10
            }
        },
        "difficulty": 4.276666119016055,
        "source": "FinanceMath-validation-118",
        "context": "['| Date         |November 2010   |         | December 2010  |         |\\n| -------------|:--------------:| -------:|:--------------:| -------:|\\n| Goods        |Quantity        |Price    |Quantity        |Price    |\\n| Sugar        |70kg            |\u20ac0.90/kg |120kg           |\u20ac1.00/kg |\\n| Cotton       |60kg            |\u20ac0.60/kg |50kg            |\u20ac0.80/kg |']",
        "question_id": "test-2033",
        "level": "hard",
        "output": [
            "### Step-by-Step Reasoning:\n\n1. **Understand the Problem and Constraint (EC Technique):**\n    - We need to calculate the Paasche index for the consumption basket (sugar and cotton) in December 2010.\n    - The Paasche index formula is:\n    \n      \\[\n      PI = \\left( \\frac{\\sum (\\text{Current Price} \\times \\text{Current Quantity})}{\\sum (\\text{Base Price} \\times \\text{Current Quantity})} \\right) \\times 100\n      \\]\n      where:\n      - Numerator sums up total expenditures for December quantities at December prices.\n      - Denominator sums up total expenditures for December quantities but at November (base) prices.\n    \n    - Constraints:\n      - Both input lists for base prices, current prices, and quantities must have the same length.\n      - Prices and quantities must be non-negative, as negative values wouldn't make sense in this context.\n\n2. **Extract Data:**\n    - From the table:\n      - November (Base Period):\n        - Sugar: Price = \u20ac0.90/kg\n        - Cotton: Price = \u20ac0.60/kg\n      - December (Current Period):\n        - Sugar: Price = \u20ac1.00/kg, Quantity = 120kg\n        - Cotton: Price = \u20ac0.80/kg, Quantity = 50kg\n\n3. **Organize Input Values:**\n    - Current prices: [\u20ac1.00 for sugar, \u20ac0.80 for cotton]\n    - Current quantities: [120kg for sugar, 50kg for cotton]\n    - Base prices: [\u20ac0.90 for sugar, \u20ac0.60 for cotton]\n\n4. **Calculate Components of the Paasche Index:**\n    - Numerator: Compute December expenditure using December prices and quantities:\n      \\[\n      (\\text{Sugar: } 1.00 \\times 120) + (\\text{Cotton: } 0.80 \\times 50)\n      \\]\n    - Denominator: Compute December expenditure using November prices and December quantities:\n      \\[\n      (\\text{Sugar: } 0.90 \\times 120) + (\\text{Cotton: } 0.60 \\times 50)\n      \\]\n    - Compute the Paasche Index using the formula and round to three decimal places.\n\n5. **Write a Python program using the `calculate_paasche_index` function to make the calculations.**\n\n---\n\n### Python Program:\n\n```python\ndef solution():\n    # Define variables name and value\n    current_prices = [1.00, 0.80]  # December prices for sugar and cotton\n    current_quantities = [120, 50]  # December quantities for sugar and cotton\n    base_prices = [0.90, 0.60]  # November prices for sugar and cotton\n    \n    # Calculate numerator and denominator for Paasche Index\n    numerator = sum(current_price * current_quantity for current_price, current_quantity in zip(current_prices, current_quantities))\n    denominator = sum(base_price * current_quantity for base_price, current_quantity in zip(base_prices, current_quantities))\n    \n    # Calculate the Paasche Index\n    paasche_index = (numerator / denominator) * 100\n    answer = round(paasche_index, 3)  # Round answer to three decimal places\n    \n    # Return the answer\n    return answer\n```"
        ],
        "retrieval_query": "What is the value of the Paasche index for the consumption basket shown in Exhibit 1 for December? Answer to three decimal places.",
        "useful_functions": [
            "def calculate_paasche_index(current_prices: list, current_quantities: list, base_prices: list) -> float:\n    \"\"\"\n    Calculate the Paasche price index for a given set of goods.\n\n    The Paasche price index measures the relative change in the price of a \n    basket of goods, by comparing the cost of the current period's basket \n    at current prices to the cost of the same basket at base period prices.\n\n    Args:\n        current_prices (list): A list of current prices for each good.\n        current_quantities (list): A list of quantities for each good in \n                                   the current period.\n        base_prices (list): A list of base prices for each good, typically from a\n                            previous period for comparison.\n    \n    Returns:\n        paasche_index (float): The calculated Paasche index as a percentage \n                               (rounded to three decimal places).\n\n    Notes:\n        - Applicability: This function is applicable for calculating the \n                         Paasche index in financial and economic analysis.\n        - Constraints: \n          - All input lists must have the same length.\n          - Prices and quantities should be non-negative numbers.\n        - Considerations: The accuracy of the Paasche index depends on the \n                          accuracy and relevancy of the price data used.\n    \"\"\"\n    if not (len(current_prices) == len(current_quantities) == len(base_prices)):\n        raise ValueError(\"All input lists must have the same length.\")\n\n    numerator = sum(p * q for p, q in zip(current_prices, current_quantities))\n    denominator = sum(bp * q for bp, q in zip(base_prices, current_quantities))\n    \n    paasche_index = (numerator / denominator) * 100\n    return round(paasche_index, 3)"
        ],
        "usage": {
            "completion_tokens": 707,
            "prompt_tokens": 834,
            "total_tokens": 1541,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "An investor from Australia currently manages an equity portfolio valued at A$240 million. He is contemplating adjusting the portfolio based on an evaluation of the risk and return possibilities confronting the Australian economy. The table below contains data pertaining to the Australian investment markets and the economic situation: Using the data in the table, determine the anticipated annual equity return using the Grinold\u2013Kroner model (the number of outstanding shares is presumed to remain unchanged) (expressed as a percentage)? Answer to three decimal places.",
        "python_solution": "def solution():\n    annual_income_return = 2.4 / 100\n    expected_annual_real_earning_growth = 5.0 / 100\n    expected_inflation_rate = 2.3 / 100\n    expected_nominal_earning_growth_return = expected_annual_real_earning_growth + expected_inflation_rate\n    expected_repricing_return = (14 - 14.5) / 14.5 \n    return (annual_income_return + expected_nominal_earning_growth_return + expected_repricing_return) * 100",
        "ground_truth": 6.252,
        "topic": "Market Analysis & Economics",
        "statistics": {
            "number_statistics": {
                "args_numbers": 5,
                "question_numbers": 1,
                "context_numbers": 15,
                "total_numbers": 16
            },
            "operator_statistics": {
                "operators": {
                    "+": 3,
                    "-": 1,
                    "*": 1,
                    "/": 4,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 9
            },
            "code_statistics": {
                "lines": 6,
                "parentheses": 4
            }
        },
        "difficulty": 4.276666119016055,
        "source": "FinanceMath-validation-126",
        "context": "['| 10-Year Historical | Current | Capital Market Expectations |\\n|---|---|---|\\n| Average government bond yield: 2.8% | 10-year government bond yield:2.3% | |\\n| Average annual equity return: 4.6% | Year-over-year equity return:-9.4% | |\\n| Average annual inflation rate: 2.3% | Year-over-year inflation rate:2.1% | Expected annual inflation: 2.3% |\\n| Equity market P/E (beginning of period): 15x | Current equity market P/E: 14.5x | Expected equity market P/E: 14.0x |\\n| Average annual dividend income return: 2.6% | | Expected annual income return: 2.4% |\\n| Average annual real earnings growth: 6.0% | | Expected annual real earnings growth: 5.0% |']",
        "question_id": "test-2034",
        "level": "hard",
        "output": [
            "The Grinold\u2013Kroner model is used to estimate the expected return on equity. The formula for this model is as follows:\n\n\\[\n\\text{Anticipated Annual Equity Return} = \\text{Dividend Yield} + (\\text{Inflation Rate} + \\text{Real Earnings Growth}) + (\\text{Change in P/E Ratio})\n\\]\n\nGiven the details in the table:\n1. **Dividend Yield**: It's mentioned that the expected annual income return is 2.4%.\n2. **Inflation Rate**: The expected annual inflation rate is given as 2.3%.\n3. **Real Earnings Growth**: The expected annual real earnings growth is given as 5.0%.\n4. **Change in P/E Ratio**: Given current P/E is 14.5x and expected P/E is 14.0x, we calculate the annualized change as follows:\n   \\[\n   \\text{Change in P/E Ratio} = \\frac{\\text{Expected P/E} - \\text{Current P/E}}{\\text{Current P/E}}\n   \\]\n\nNow, let's carefully work through the steps ensuring we adhere to constraints:\n- The change in P/E ratio must be calculated as a percentage.\n- All required values, like the dividend yield, inflation rate, and real earnings growth, must be expressed in percentages.\n- The anticipated equity return must be expressed to three decimal places.\n\nHere's the well-structured Python program to compute the anticipated annual equity return:\n\n```python\ndef solution():\n    # Define variables from the table\n    dividend_yield = 2.4  # in percentage\n    inflation_rate = 2.3  # in percentage\n    real_earnings_growth = 5.0  # in percentage\n    current_pe = 14.5\n    expected_pe = 14.0\n\n    # Calculate the change in P/E ratio as a percentage\n    change_in_pe = ((expected_pe - current_pe) / current_pe) * 100\n\n    # Calculate the anticipated annual equity return using Grinold\u2013Kroner model\n    anticipated_equity_return = dividend_yield + (inflation_rate + real_earnings_growth) + change_in_pe\n\n    # Return results rounded to three decimal places\n    return round(anticipated_equity_return, 3)\n\n```"
        ],
        "retrieval_query": "An investor from Australia currently manages an equity portfolio valued at A$240 million. He is contemplating adjusting the portfolio based on an evaluation of the risk and return possibilities confronting the Australian economy. The table below contains data pertaining to the Australian investment markets and the economic situation: Using the data in the table, determine the anticipated annual equity return using the Grinold\u2013Kroner model (the number of outstanding shares is presumed to remain unchanged) (expressed as a percentage)? Answer to three decimal places.",
        "useful_functions": [
            "def calculate_sustainable_growth_rate(net_profit_margin: float, retention_rate: float, \n                                      asset_turnover: float, financial_leverage_multiplier: float) -> float:\n    \"\"\"\n    Calculate the sustainable growth rate (SGR) of a company.\n\n    This function computes the sustainable growth rate using the formula SGR = ROE \u00d7 Retention Rate,\n    where ROE (Return on Equity) is derived from the DuPont formula: \n    ROE = Net Profit Margin \u00d7 Asset Turnover \u00d7 Financial Leverage Multiplier.\n\n    Args:\n        net_profit_margin (float): The net profit margin as a decimal (e.g., 20% is 0.20).\n        retention_rate (float): The retention rate as a decimal (e.g., 60% is 0.60).\n        asset_turnover (float): The asset turnover ratio, representing revenue/average assets.\n        financial_leverage_multiplier (float): The financial leverage multiplier, representing total assets/total equity.\n\n    Returns:\n        sustainable_growth_rate (float): The sustainable growth rate expressed as a percentage.\n\n    Notes:\n        - Applicability: Useful for assessing the growth potential of a company without increasing financial leverage.\n        - Constraints: All input percentages should be provided as decimals between 0 and 1.\n        - Considerations: Ensure accurate input values to calculate an accurate sustainable growth rate.\n    \"\"\"\n    roe = net_profit_margin * asset_turnover * financial_leverage_multiplier\n    sustainable_growth_rate = retention_rate * roe\n    return round(sustainable_growth_rate * 100, 1)"
        ],
        "usage": {
            "completion_tokens": 483,
            "prompt_tokens": 957,
            "total_tokens": 1440,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "What is the yearly geometric mean return of this investment over a three-year period (expressed as a percentage)? Answer to two decimal places.",
        "python_solution": "def solution():\n    return round((((1 + 0.2) * (1 - 0.3) * (1 + 0.15))**(1/3) - 1) * 100, 2)",
        "ground_truth": -1.15,
        "topic": "Portfolio Management & Strategy",
        "statistics": {
            "number_statistics": {
                "args_numbers": 4,
                "question_numbers": 0,
                "context_numbers": 3,
                "total_numbers": 3
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 2,
                    "*": 3,
                    "/": 1,
                    "%": 0,
                    "**": 1
                },
                "total_operators": 9
            },
            "code_statistics": {
                "lines": 1,
                "parentheses": 14
            }
        },
        "difficulty": 4.276666119016055,
        "source": "FinanceMath-validation-187",
        "context": "['| Year | Return(%) |\\n|------|----------|\\n| 2009 | 20       |\\n| 2010 | -30      |\\n| 2011 | 15       |']",
        "question_id": "test-2035",
        "level": "hard",
        "output": [
            "To solve this problem, we need to calculate the geometric mean return of the investment over the three-year period. Let's break down the solution using the \"Emphasizing Constraints (EC)\" approach.\n\n### Step-by-step reasoning:\n\n1. **Understanding the Geometric Mean Formula:**\n   The formula for the geometric mean return is:\n   \\[\n   R_{\\text{geometric mean}} = \\left( \\prod_{i=1}^n (1 + R_i) \\right)^{\\frac{1}{n}} - 1\n   \\]\n   where \\( R_i \\) is the return for year \\( i \\) (in decimal form, not percentage), and \\( n \\) is the number of periods (years).\n\n2. **Handling Constraints:**\n   - We are given the returns in percentages, so we must convert them to decimals before using them in calculations.\n   - We are required to calculate the result to two decimal places.\n\n3. **Values Provided:**\n   - 2009 return = 20% \u2192 0.20 in decimal\n   - 2010 return = -30% \u2192 -0.30 in decimal\n   - 2011 return = 15% \u2192 0.15 in decimal\n\n4. **Geometric Mean Computation:**\n   - Add \\( 1 \\) to each decimal return: \\( (1 + 0.20), (1 - 0.30), (1 + 0.15) \\).\n   - Take the product of these values: \\( (1.20) \\cdot (0.70) \\cdot (1.15) \\).\n   - Raise the product to the power of \\( \\frac{1}{3} \\) since there are \\( 3 \\) years.\n   - Subtract \\( 1 \\) from the resulting value to obtain the geometric mean.\n\n5. **Expression as a Percentage:**\n   - The result must be converted back to a percentage by multiplying by \\( 100 \\).\n   - Round the final answer to two decimal places.\n\n### Python Implementation:\n\n```python\ndef solution():\n    # Define yearly returns in decimals\n    returns = [0.20, -0.30, 0.15]\n    \n    # Step 1: Convert returns to (1 + Ri) and compute the product\n    product = 1\n    for r in returns:\n        product *= (1 + r)\n    \n    # Step 2: Calculate the geometric mean return\n    n = len(returns)  # Number of periods (years)\n    geometric_mean = (product ** (1 / n)) - 1\n    \n    # Step 3: Convert to percentage and round to two decimal places\n    answer = round(geometric_mean * 100, 2)\n    \n    # Return the final answer\n    return answer\n```\n\nThis program calculates the geometric mean return to two decimal places as required, and all constraints (e.g., precise decimal math, rounding to two decimal places) are followed."
        ],
        "retrieval_query": "What is the yearly geometric mean return of this investment over a three-year period (expressed as a percentage)? Answer to two decimal places.",
        "useful_functions": [],
        "usage": {
            "completion_tokens": 627,
            "prompt_tokens": 399,
            "total_tokens": 1026,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "Lemon owned 2000 shares of Spectrol Corp. common stock that were purchased in year 1 at $10.50 per share. In year 4 Lemon received a 5% non-taxable dividend of Spectrol common stock. In year 5 the stock split 2-for-1. In the current year Lemon sold 800 shares. What is Lemon's basis in the 800 shares of stock sold? Answer to the closest dollar.",
        "context": "",
        "statistics": {
            "number_statistics": {
                "question_numbers": 9,
                "context_numbers": 0,
                "total_numbers": 9
            },
            "operator_statistics": {
                "operators": {
                    "+": 1,
                    "-": 0,
                    "*": 3,
                    "/": 2,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 6
            },
            "code_statistics": {
                "lines": 9,
                "parentheses": 6
            }
        },
        "difficulty": 4.276666119016055,
        "ground_truth": 4000,
        "source": "FinCode-test-21",
        "python_solution": "shares = 2000.0\npurchase_price = 10.50\ndividend = 0.05\nshares_sold = 800\ncommon_stock = shares * purchase_price\nprice_per_share = common_stock / (2000 * (1.0 + dividend)) \nprice_per_split_share = price_per_share / 2.0\nbasis = shares_sold * price_per_split_share\nround(basis)",
        "question_id": "test-2036",
        "level": "hard",
        "output": [
            "To determine the basis of the 800 shares of stock Lemon sold, we need to factor in the initial per-share cost basis, the impact of the 5% stock dividend, and the effect of the 2-for-1 stock split. Here's the step-by-step reasoning process:\n\n---\n\n### **Step 1: Establish Initial Basis**\n- In Year 1, Lemon purchased **2000 shares** at $10.50 per share.\n- **Initial Investment = 2000 shares \u00d7 $10.50/share = $21,000**\n\n---\n\n### **Step 2: Impact of the 5% Non-Taxable Stock Dividend (Year 4)**\n- A 5% non-taxable stock dividend increases Lemon's total shares without changing the total cost basis ($21,000). Thus, his per-share basis *decreases*.\n- Additional shares received due to a 5% dividend:\n  **Additional Shares = Original Shares \u00d7 5% = 2000 \u00d7 0.05 = 100 shares**\n- Total shares after dividend:\n  **Total Shares = 2000 original shares + 100 dividend shares = 2100 shares**\n- Adjusted cost basis per share:\n  **Cost Basis/Share = Total Investment \u00f7 Total Shares = $21,000 \u00f7 2100 = $10.00/share**\n\n---\n\n### **Step 3: Impact of the 2-for-1 Stock Split (Year 5)**\n- The 2-for-1 stock split doubles the number of shares while halving the cost basis per share.\n- Total shares after the split:\n  **Total Shares = 2100 shares \u00d7 2 = 4200 shares**\n- Adjusted cost basis per share:\n  **Cost Basis/Share = $10.00 \u00f7 2 = $5.00/share**\n\n---\n\n### **Step 4: Sold 800 Shares in the Current Year**\n- The cost basis for 800 shares sold:\n  **Basis of 800 Shares = 800 shares \u00d7 $5.00/share = $4,000**\n\n---\n\n### **Constraints Highlighted (EC)**\n- **Round the final basis to the closest dollar.**\n- **Ensure proper handling of the stock dividend and stock split to adjust cost basis.**\n\n---\n\n### **Conclusion**\nThus, Lemon's basis in the 800 shares of stock sold is **$4,000**, rounded to the dollar.\n\n---\n\n### **Python Program**\nHere is the Python program to calculate the basis:\n\n```python\ndef solution():\n    # Define initial shared details\n    initial_shares = 2000\n    initial_price_per_share = 10.50\n    total_investment = initial_shares * initial_price_per_share  # Initial cost basis\n    \n    # Apply the 5% non-taxable dividend\n    dividend_percentage = 0.05\n    additional_shares = initial_shares * dividend_percentage\n    total_shares_after_dividend = initial_shares + additional_shares\n    cost_basis_per_share_post_dividend = total_investment / total_shares_after_dividend  # Updated cost basis/share\n    \n    # Apply 2-for-1 stock split\n    total_shares_after_split = total_shares_after_dividend * 2\n    cost_basis_per_share_post_split = cost_basis_per_share_post_dividend / 2  # Updated cost basis/share\n    \n    # Calculate the basis for the 800 shares sold\n    shares_sold = 800\n    basis_of_sold_shares = shares_sold * cost_basis_per_share_post_split\n    \n    # Round to the closest dollar and return\n    return round(basis_of_sold_shares)\n```"
        ],
        "retrieval_query": "Lemon owned 2000 shares of Spectrol Corp. common stock that were purchased in year 1 at $10.50 per share. In year 4 Lemon received a 5% non-taxable dividend of Spectrol common stock. In year 5 the stock split 2-for-1. In the current year Lemon sold 800 shares. What is Lemon's basis in the 800 shares of stock sold? Answer to the closest dollar.",
        "useful_functions": [],
        "usage": {
            "completion_tokens": 754,
            "prompt_tokens": 407,
            "total_tokens": 1161,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "The capital structure of Merritt Co. is 20% common equity and debt equal to 80%. The cost of common equity is 10% and the pretax cost of debt is 5%. Merritt's tax rate is 21%. What is Merritt's weighted-average cost of capital? Answer as a percent to two decimal places.",
        "context": "",
        "statistics": {
            "number_statistics": {
                "question_numbers": 5,
                "context_numbers": 0,
                "total_numbers": 5
            },
            "operator_statistics": {
                "operators": {
                    "+": 1,
                    "-": 1,
                    "*": 4,
                    "/": 0,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 6
            },
            "code_statistics": {
                "lines": 8,
                "parentheses": 8
            }
        },
        "difficulty": 4.276666119016055,
        "ground_truth": 5.16,
        "source": "FinCode-test-38",
        "python_solution": "w_common_equity = 0.2\ncost_common_equity = 0.1\nw_debt = 0.8\ncost_debt = 0.05\ntax_rate = 0.21\ncost_debt_after_tax = cost_debt * (1 - tax_rate)\nweighted_average_cost_of_capital = (w_common_equity * cost_common_equity) + (w_debt * cost_debt_after_tax)\nround(weighted_average_cost_of_capital * 100, 2)",
        "question_id": "test-2037",
        "level": "hard",
        "output": [
            "Let's solve the problem step-by-step while utilizing the constraints and adhering to the principles of financial calculations.\n\n### Step-by-Step Reasoning\n\n1. **Identify the key inputs**:\n   - Merritt's capital structure is:\n     - 20% equity (weight = 0.20)\n     - 80% debt (weight = 0.80)\n   - Cost of equity (\\(r_e\\)) = 10% (or 0.10 as a decimal).\n   - Cost of debt (\\(r_d\\)), referred to as the pretax cost of debt = 5% (or 0.05 as a decimal).\n   - Corporate tax rate (\\(T\\)) = 21% (or 0.21 as a decimal).\n\n2. **Constraints to adhere to (Emphasizing Constraints - EC)**:\n   - All monetary and percentage values are represented as decimals in calculations (e.g., 10% as 0.10). This ensures smooth mathematical computations.\n   - The final weighted-average cost of capital (WACC) should be expressed as a percentage with 2 decimal places of precision for clarity.\n\n3. **Formula for WACC**:\n   The weighted-average cost of capital is calculated as:\n   \\[\n   \\text{WACC} = (w_e \\cdot r_e) + (w_d \\cdot r_d \\cdot (1 - T))\n   \\]\n   Where:\n   - \\(w_e\\): Weight of equity (0.20 in this case),\n   - \\(r_e\\): Cost of equity (0.10),\n   - \\(w_d\\): Weight of debt (0.80),\n   - \\(r_d\\): Pretax cost of debt (0.05),\n   - \\(T\\): Corporate tax rate (0.21).\n\n4. **After-tax cost of debt**:\n   Since debt payments are tax-deductible, the after-tax cost of debt is computed as:\n   \\[\n   \\text{After-tax cost of debt} = r_d \\cdot (1 - T)\n   \\]\n   Substituting \\(r_d = 0.05\\) and \\(T = 0.21\\):\n   \\[\n   \\text{After-tax cost of debt} = 0.05 \\cdot (1 - 0.21) = 0.05 \\cdot 0.79 = 0.0395\n   \\]\n\n5. **Calculate WACC**:\n   Plugging all values into the WACC formula:\n   \\[\n   \\text{WACC} = (0.20 \\cdot 0.10) + (0.80 \\cdot 0.0395)\n   \\]\n   Compute each term:\n   - \\(0.20 \\cdot 0.10 = 0.02\\),\n   - \\(0.80 \\cdot 0.0395 = 0.0316\\).\n   Add the two components:\n   \\[\n   \\text{WACC} = 0.02 + 0.0316 = 0.0516\n   \\]\n\n6. **Express WACC as a percentage**:\n   Convert \\(0.0516\\) to a percentage:\n   \\[\n   \\text{WACC} = 5.16\\%\n   \\]\n\nNow, we will implement the solution as a Python program.\n\n```python\ndef solution():\n    # Define variables\n    weight_equity = 0.20  # 20% equity\n    weight_debt = 0.80    # 80% debt\n    cost_of_equity = 0.10 # 10% cost of common equity\n    pretax_cost_of_debt = 0.05 # 5% pretax cost of debt\n    tax_rate = 0.21       # 21% corporate tax rate\n    \n    # Calculate after-tax cost of debt\n    after_tax_cost_of_debt = pretax_cost_of_debt * (1 - tax_rate)\n    \n    # Calculate WACC\n    wacc = (weight_equity * cost_of_equity) + (weight_debt * after_tax_cost_of_debt)\n    \n    # Convert WACC to percentage and round to two decimal places\n    return round(wacc * 100, 2)\n\n```"
        ],
        "retrieval_query": "The capital structure of Merritt Co. is 20% common equity and debt equal to 80%. The cost of common equity is 10% and the pretax cost of debt is 5%. Merritt's tax rate is 21%. What is Merritt's weighted-average cost of capital? Answer as a percent to two decimal places.",
        "useful_functions": [
            "def calculate_wacc(equity_market_value: float, debt_market_value: float, cost_of_equity: float, \n                   cost_of_debt: float, tax_rate: float) -> float:\n    \"\"\"\n    Calculate the Weighted Average Cost of Capital (WACC) for a company.\n\n    This function computes the WACC, which represents a company's average after-tax\n    cost of capital from all sources, including equity and debt. It combines the cost \n    of both equity and debt, weighted by their respective proportions in the total \n    capital used by the company.\n\n    Args:\n        equity_market_value (float): Market value of the firm's equity.\n        debt_market_value (float): Market value of the firm's debt.\n        cost_of_equity (float): Cost of equity, representing the required rate \n                                of return for equity investors.\n        cost_of_debt (float): Cost of debt, representing the effective rate paid \n                              on the company's issued debt.\n        tax_rate (float): Corporate tax rate, used to calculate the after-tax cost of debt.\n\n    Returns:\n        wacc (float): The calculated Weighted Average Cost of Capital (WACC).\n\n    Notes:\n        - Applicability: Useful for assessing the cost of capital for businesses \n          that use both equity and debt financing.\n        - Constraints: The equity and debt market values should be positive and \n          represent the total financing. The tax rate should be between 0 and 1.\n        - Considerations: It assumes taxes are constant and ignores complications \n          such as different classes of equity with different costs.\n    \"\"\"\n    total_value = equity_market_value + debt_market_value\n    equity_weight = equity_market_value / total_value\n    debt_weight = debt_market_value / total_value\n    after_tax_cost_of_debt = cost_of_debt * (1 - tax_rate)\n\n    wacc = (equity_weight * cost_of_equity) + (debt_weight * after_tax_cost_of_debt)\n    \n    return wacc",
            "def calculate_weighted_average_cost_of_capital(weight_equity: float, cost_equity: float, weight_debt: float, \n                                               pretax_cost_debt: float, tax_rate: float) -> float:\n    \"\"\"\n    Calculate the weighted average cost of capital (WACC) for a company.\n\n    This function computes the WACC by weighting the cost of equity and the after-tax cost of debt\n    according to their respective proportions in the company's capital structure.\n\n    Args:\n        weight_equity (float): The proportion of capital financed by common equity. Must be between 0 and 1.\n        cost_equity (float): The cost of common equity as a decimal. Must be between 0 and 1.\n        weight_debt (float): The proportion of capital financed by debt. Must be between 0 and 1.\n        pretax_cost_debt (float): The pretax cost of debt as a decimal. Must be between 0 and 1.\n        tax_rate (float): The corporate tax rate as a decimal. Must be between 0 and 1.\n\n    Returns:\n        wacc (float): The weighted average cost of capital as a decimal.\n\n    Notes:\n        - This function assumes the sum of `weight_equity` and `weight_debt` equals 1.\n        - The WACC is returned as a decimal and may be converted to a percentage by multiplying by 100.\n        - The function assumes all inputs are provided as decimals (e.g., 10% should be input as 0.10).\n    \"\"\"\n    cost_debt_after_tax = pretax_cost_debt * (1 - tax_rate)\n    wacc = (weight_equity * cost_equity) + (weight_debt * cost_debt_after_tax)\n    return wacc"
        ],
        "usage": {
            "completion_tokens": 900,
            "prompt_tokens": 1176,
            "total_tokens": 2076,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "The full-employment gross domestic product is $1.3 trillion, and the actual gross domestic product is $1.2 trillion. The marginal propensity to consume is 0.8. When inflation is ignored, what increase in government expenditures is necessary to produce full employment? Answer in billions of dollars.",
        "context": "",
        "statistics": {
            "number_statistics": {
                "question_numbers": 3,
                "context_numbers": 0,
                "total_numbers": 3
            },
            "operator_statistics": {
                "operators": {
                    "+": 0,
                    "-": 2,
                    "*": 3,
                    "/": 1,
                    "%": 0,
                    "**": 3
                },
                "total_operators": 9
            },
            "code_statistics": {
                "lines": 6,
                "parentheses": 4
            }
        },
        "difficulty": 4.276666119016055,
        "ground_truth": 20,
        "source": "FinCode-test-45",
        "python_solution": "full_employment_gdp = 1.3 * 10**12\nactual_gdp = 1.2 * 10**12\nmpc = 0.8\ngdp_diff = full_employment_gdp - actual_gdp\nspending = (1 - mpc) * gdp_diff / 10**9\nround(spending)",
        "question_id": "test-2038",
        "level": "hard",
        "output": [
            "**Step-by-step Thinking:**\n\nWe need to determine the required increase in government expenditures to close the full-employment gap in GDP, taking into account the multiplier effect caused by the marginal propensity to consume (MPC).\n\n### Step 1: Understand the full-employment GDP gap\n- Given:\n  - Full-employment GDP = $1.3 trillion\n  - Actual GDP = $1.2 trillion\n- The GDP gap is:\n  \\[ \\text{GDP Gap} = \\text{Full-employment GDP} - \\text{Actual GDP} \\]\n  Substituting values:\n  \\[ \\text{GDP Gap} = 1.3 - 1.2 = 0.1 \\text{ trillion dollars (or 100 billion dollars).} \\]\n\n### Step 2: Understand the multiplier and its relationship\nThe expenditure multiplier depends on the marginal propensity to consume (MPC). The formula for the multiplier is:\n\\[ \\text{Multiplier} = \\frac{1}{1 - \\text{MPC}} \\]\nGiven:\n  - MPC = 0.8\n  \\[ \\text{Multiplier} = \\frac{1}{1 - 0.8} = \\frac{1}{0.2} = 5 \\]\n\n### Step 3: Link the GDP Gap to increase in government expenditures\nThe multiplier effect links the government spending change to the overall change in GDP:\n\\[ \\text{GDP Gap} = \\text{Multiplier} \\times \\text{Change in Government Expenditures} \\]\nRearrange to solve for \\(\\text{Change in Government Expenditures}\\):\n\\[ \\text{Change in Government Expenditures} = \\frac{\\text{GDP Gap}}{\\text{Multiplier}} \\]\nSubstitute the values:\n  - GDP Gap = 100 billion dollars (0.1 trillion dollars)\n  - Multiplier = 5\n  \\[ \\text{Change in Government Expenditures} = \\frac{100}{5} = 20 \\text{ billion dollars}. \\]\n\n### Step 4: Constraints and Units\n- Since the question asks for the answer in billions of dollars, we ensure our calculations align with this unit.\n- Inflation is ignored as per the prompt, ensuring simpler calculations.\n\n### Python Program:\n```python\ndef solution():\n    # Define variables\n    full_employment_gdp_trillion = 1.3  # in trillions of dollars\n    actual_gdp_trillion = 1.2          # in trillions of dollars\n    mpc = 0.8                          # Marginal Propensity to Consume\n\n    # Step 1: Calculate the GDP gap in trillions\n    gdp_gap_trillion = full_employment_gdp_trillion - actual_gdp_trillion\n\n    # Step 2: Calculate the multiplier\n    multiplier = 1 / (1 - mpc)\n\n    # Step 3: Calculate the required change in government expenditures in trillions\n    change_in_expenditures_trillion = gdp_gap_trillion / multiplier\n\n    # Convert the result to billions\n    answer_in_billions = change_in_expenditures_trillion * 1000  # Convert from trillions to billions\n\n    # Return answer in billions\n    return answer_in_billions\n```"
        ],
        "retrieval_query": "The full-employment gross domestic product is $1.3 trillion, and the actual gross domestic product is $1.2 trillion. The marginal propensity to consume is 0.8. When inflation is ignored, what increase in government expenditures is necessary to produce full employment? Answer in billions of dollars.",
        "useful_functions": [
            "def calculate_gdp(consumption: float, investment: float, government_spending: float, exports: float, imports: float) -> float:\n    \"\"\"\n    Calculate the Gross Domestic Product (GDP) using the expenditure approach.\n\n    This function computes the GDP by summing the consumption, investment, \n    government spending, and net exports (exports minus imports). It is based on \n    the standard expenditure method of calculating GDP, providing a measure of \n    the economic activity within a country.\n\n    Args:\n        consumption (float): The total value of all goods and services consumed \n                             within the economy.\n        investment (float): The total expenditure on goods and services that \n                            will be used for future production.\n        government_spending (float): Total government expenditures on goods and services.\n        exports (float): The total value of goods and services produced domestically \n                         and sold abroad.\n        imports (float): The total value of goods and services produced abroad and \n                         sold domestically.\n\n    Returns:\n        gdp (float): The calculated Gross Domestic Product.\n\n    Notes:\n        - This function calculates GDP using the expenditure approach.\n        - Net exports (exports minus imports) are included in the calculation.\n        - Applicability: This function can be used for economic data analysis where \n          GDP calculation from expenditure is relevant.\n        - Constraints: Ensure input values are in the same currency and time period.\n        - Considerations: The method does not adjust for seasonal effects, inflation, \n          or purchasing power parity.\n    \"\"\"\n    gdp = consumption + investment + government_spending + exports - imports\n    \n    return gdp"
        ],
        "usage": {
            "completion_tokens": 684,
            "prompt_tokens": 719,
            "total_tokens": 1403,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "the specific reserves in the alll as of december 31 , 2012 were what percent of the tdr portfolio? Answer to three decimal places.",
        "context": "troubled debt restructurings ( tdrs ) a tdr is a loan whose terms have been restructured in a manner that grants a concession to a borrower experiencing financial difficulties . tdrs typically result from our loss mitigation activities and include rate reductions , principal forgiveness , postponement/reduction of scheduled amortization , extensions , and bankruptcy discharges where no formal reaffirmation was provided by the borrower and therefore a concession has been granted based upon discharge from personal liability , which are intended to minimize economic loss and to avoid foreclosure or repossession of collateral . in those situations where principal is forgiven , the amount of such principal forgiveness is immediately charged some tdrs may not ultimately result in the full collection of principal and interest , as restructured , and result in potential incremental losses . these potential incremental losses have been factored into our overall alll estimate . the level of any subsequent defaults will likely be affected by future economic conditions . once a loan becomes a tdr , it will continue to be reported as a tdr until it is ultimately repaid in full , the collateral is foreclosed upon , or it is fully charged off . we held specific reserves in the alll of $ 587 million and $ 580 million at december 31 , 2012 and december 31 , 2011 , respectively , for the total tdr portfolio . table 71 : summary of troubled debt restructurings in millions dec . 31 dec . 31 .\n\n| In millions | Dec. 312012 | Dec. 312011 |\n| :--- | :--- | :--- |\n| Total consumer lending (a) | $2,318 | $1,798 |\n| Total commercial lending | 541 | 405 |\n| Total TDRs | $2,859 | $2,203 |\n| Nonperforming | $1,589 | $1,141 |\n| Accruing (b) | 1,037 | 771 |\n| Credit card (c) | 233 | 291 |\n| Total TDRs | $2,859 | $2,203 |\n\n( a ) pursuant to regulatory guidance issued in the third quarter of 2012 , additional troubled debt restructurings related to changes in treatment of certain loans of $ 366 million in 2012 , net of charge-offs , resulting from bankruptcy where no formal reaffirmation was provided by the borrower and therefore a concession has been granted based upon discharge from personal liability were added to the consumer lending population . the additional tdr population increased nonperforming loans by $ 288 million . charge-offs have been taken where the fair value less costs to sell the collateral was less than the recorded investment of the loan and were $ 128.1 million . of these nonperforming loans , approximately 78% ( 78 % ) were current on their payments at december 31 , 2012 . ( b ) accruing loans have demonstrated a period of at least six months of performance under the restructured terms and are excluded from nonperforming loans . ( c ) includes credit cards and certain small business and consumer credit agreements whose terms have been restructured and are tdrs . however , since our policy is to exempt these loans from being placed on nonaccrual status as permitted by regulatory guidance as generally these loans are directly charged off in the period that they become 180 days past due , these loans are excluded from nonperforming loans . the following table quantifies the number of loans that were classified as tdrs as well as the change in the recorded investments as a result of the tdr classification during the years ended december 31 , 2012 and 2011 . additionally , the table provides information about the types of tdr concessions . the principal forgiveness tdr category includes principal forgiveness and accrued interest forgiveness . these types of tdrs result in a write down of the recorded investment and a charge-off if such action has not already taken place . the rate reduction tdr category includes reduced interest rate and interest deferral . the tdrs within this category would result in reductions to future interest income . the other tdr category primarily includes postponement/reduction of scheduled amortization , as well as contractual extensions . in some cases , there have been multiple concessions granted on one loan . when there have been multiple concessions granted , the principal forgiveness tdr was prioritized for purposes of determining the inclusion in the table below . for example , if there is principal forgiveness in conjunction with lower interest rate and postponement of amortization , the type of concession will be reported as principal forgiveness . second in priority would be rate reduction . for example , if there is an interest rate reduction in conjunction with postponement of amortization , the type of concession will be reported as a rate reduction . the pnc financial services group , inc . 2013 form 10-k 155 .\n",
        "statistics": {
            "number_statistics": {
                "question_numbers": 1,
                "context_numbers": 31,
                "total_numbers": 32
            },
            "operator_statistics": {
                "operators": {
                    "+": 1,
                    "-": 0,
                    "*": 1,
                    "/": 4,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 6
            },
            "code_statistics": {
                "lines": 12,
                "parentheses": 0
            }
        },
        "difficulty": 4.276666119016055,
        "ground_truth": 20.532,
        "source": "CodeFinQA-test-590",
        "python_solution": "specific_reserves_2012 = 587\nspecific_reserves_2011 = 580\ntotal_specific_reserves = specific_reserves_2012 + specific_reserves_2011\ntotal_tdr_portfolio = 2859\nnonperforming_loans = 1589\naccruing_loans = 1037\ncredit_card_loans = 233\ntotal_tdrs = total_tdr_portfolio\nnonperforming_loans_percent = nonperforming_loans / total_tdrs\naccruing_loans_percent = accruing_loans / total_tdrs\ncredit_card_loans_percent = credit_card_loans / total_tdrs\nanswer = specific_reserves_2012 / total_tdr_portfolio * 100",
        "question_id": "test-2039",
        "level": "hard",
        "output": [
            "Let's solve the problem step by step using the \"Emphasizing Constraints\" (EC) reasoning technique:\n\n### Step-by-step solution:\n\n1. **Understand the given data and question:**  \n   - As of December 31, 2012, the specific reserves in the Allowance for Loan and Lease Losses (ALLL) were $587 million.  \n   - The Total Troubled Debt Restructuring (TDR) portfolio was $2,859 million.  \n   - We are tasked with determining what percentage the specific reserves in ALLL represent of the TDR portfolio.  \n   - The answer should be expressed as a percentage **to three decimal places**.\n\n2. **Identify constraints:**  \n   - Ensure the output is in a percent format and rounded to three decimal places.  \n   - Division of reserves by the portfolio should yield a fraction, which we multiply by 100 to convert to a percentage.\n\n3. **Objective:** Calculate the percentage using the formula:  \n   \\[\n   \\text{Percentage} = \\left(\\frac{\\text{Specific Reserves (ALLL)}}{\\text{TDR Portfolio}}\\right) \\times 100\n   \\]  \n   Substituting the given values:  \n   \\[\n   \\text{Percentage} = \\left(\\frac{587}{2859}\\right) \\times 100\n   \\]\n\n4. **Python program generation:** The calculation will be coded with precision to ensure that the answer is rounded to **three decimal places**.\n\nHere is the Python program that calculates the percentage:\n\n```python\ndef solution():\n    # Define variables name and value\n    specific_reserves = 587  # Specific reserves in ALLL as of December 31, 2012 (in million USD)\n    tdr_portfolio = 2859    # TDR Portfolio as of December 31, 2012 (in million USD)\n    \n    # Perform the percentage calculation\n    percentage = (specific_reserves / tdr_portfolio) * 100\n    \n    # Return the result rounded to three decimal places\n    return round(percentage, 3)\n```\n\nWhen you run this program, it will output the answer to the question."
        ],
        "retrieval_query": "the specific reserves in the alll as of december 31 , 2012 were what percent of the tdr portfolio? Answer to three decimal places.",
        "useful_functions": [],
        "usage": {
            "completion_tokens": 451,
            "prompt_tokens": 1339,
            "total_tokens": 1790,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "interest rate derivatives made up how much of the net total derivatives for 2015? Answer to three decimal places.",
        "context": "jpmorgan chase & co./2015 annual report 127 receivables from customers receivables from customers primarily represent margin loans to prime and retail brokerage clients that are collateralized through a pledge of assets maintained in clients 2019 brokerage accounts which are subject to daily minimum collateral requirements . in the event that the collateral value decreases , a maintenance margin call is made to the client to provide additional collateral into the account . if additional collateral is not provided by the client , the client 2019s position may be liquidated by the firm to meet the minimum collateral requirements . lending-related commitments the firm uses lending-related financial instruments , such as commitments ( including revolving credit facilities ) and guarantees , to meet the financing needs of its customers . the contractual amounts of these financial instruments represent the maximum possible credit risk should the counterparties draw down on these commitments or the firm fulfills its obligations under these guarantees , and the counterparties subsequently fail to perform according to the terms of these contracts . in the firm 2019s view , the total contractual amount of these wholesale lending-related commitments is not representative of the firm 2019s likely actual future credit exposure or funding requirements . in determining the amount of credit risk exposure the firm has to wholesale lending-related commitments , which is used as the basis for allocating credit risk capital to these commitments , the firm has established a 201cloan-equivalent 201d amount for each commitment ; this amount represents the portion of the unused commitment or other contingent exposure that is expected , based on average portfolio historical experience , to become drawn upon in an event of a default by an obligor . the loan-equivalent amount of the firm 2019s lending- related commitments was $ 212.4 billion and $ 216.5 billion as of december 31 , 2015 and 2014 , respectively . clearing services the firm provides clearing services for clients entering into securities and derivative transactions . through the provision of these services the firm is exposed to the risk of non-performance by its clients and may be required to share in losses incurred by central counterparties ( 201cccps 201d ) . where possible , the firm seeks to mitigate its credit risk to its clients through the collection of adequate margin at inception and throughout the life of the transactions and can also cease provision of clearing services if clients do not adhere to their obligations under the clearing agreement . for further discussion of clearing services , see note 29 . derivative contracts in the normal course of business , the firm uses derivative instruments predominantly for market-making activities . derivatives enable customers to manage exposures to fluctuations in interest rates , currencies and other markets . the firm also uses derivative instruments to manage its own credit and other market risk exposure . the nature of the counterparty and the settlement mechanism of the derivative affect the credit risk to which the firm is exposed . for otc derivatives the firm is exposed to the credit risk of the derivative counterparty . for exchange- traded derivatives ( 201cetd 201d ) , such as futures and options and 201ccleared 201d over-the-counter ( 201cotc-cleared 201d ) derivatives , the firm is generally exposed to the credit risk of the relevant ccp . where possible , the firm seeks to mitigate its credit risk exposures arising from derivative transactions through the use of legally enforceable master netting arrangements and collateral agreements . for further discussion of derivative contracts , counterparties and settlement types , see note 6 . the following table summarizes the net derivative receivables for the periods presented . derivative receivables .\n\n| December 31, (in millions) | 2015 | 2014 |\n| :--- | :--- | :--- |\n| Interest rate | $26,363 | $33,725 |\n| Credit derivatives | 1,423 | 1,838 |\n| Foreign exchange | 17,177 | 21,253 |\n| Equity | 5,529 | 8,177 |\n| Commodity | 9,185 | 13,982 |\n| Total, net of cash collateral | 59,677 | 78,975 |\n| Liquid securities and other cash collateral held against derivative receivables | (16,580) | (19,604) |\n| Total, net of all collateral | $43,097 | $59,371 |\n\nderivative receivables reported on the consolidated balance sheets were $ 59.7 billion and $ 79.0 billion at december 31 , 2015 and 2014 , respectively . these amounts represent the fair value of the derivative contracts , after giving effect to legally enforceable master netting agreements and cash collateral held by the firm . however , in management 2019s view , the appropriate measure of current credit risk should also take into consideration additional liquid securities ( primarily u.s . government and agency securities and other group of seven nations ( 201cg7 201d ) government bonds ) and other cash collateral held by the firm aggregating $ 16.6 billion and $ 19.6 billion at december 31 , 2015 and 2014 , respectively , that may be used as security when the fair value of the client 2019s exposure is in the firm 2019s favor . the decrease in derivative receivables was predominantly driven by declines in interest rate derivatives , commodity derivatives , foreign exchange derivatives and equity derivatives due to market movements , maturities and settlements related to client- driven market-making activities in cib. .\n",
        "statistics": {
            "number_statistics": {
                "question_numbers": 0,
                "context_numbers": 29,
                "total_numbers": 29
            },
            "operator_statistics": {
                "operators": {
                    "+": 5,
                    "-": 0,
                    "*": 1,
                    "/": 1,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 7
            },
            "code_statistics": {
                "lines": 11,
                "parentheses": 0
            }
        },
        "difficulty": 4.343805421853684,
        "ground_truth": 44.176,
        "source": "CodeFinQA-test-712",
        "python_solution": "interest_rate_derivatives = 26363\ncredit_derivatives = 1423\nforeign_exchange_derivatives = 17177\nequity_derivatives = 5529\ncommodity_derivatives = 9185\ntotal_derivatives = interest_rate_derivatives + credit_derivatives + foreign_exchange_derivatives + equity_derivatives + commodity_derivatives\ncash_collateral = 43097\nliquid_securities_and_other_cash_collateral = 16580\ntotal_collateral = cash_collateral + liquid_securities_and_other_cash_collateral\ntotal_derivative_receivables = 59677\nanswer = interest_rate_derivatives / total_derivative_receivables * 100",
        "question_id": "test-2040",
        "level": "hard",
        "output": [
            "### Step-by-step reasoning using Emphasizing Constraints (EC)\n1. **Constraint Identification**:\n    - The question asks us to compute what proportion of the total net derivatives in 2015 are attributed to interest rate derivatives.\n    - The result must be displayed to **three decimal places**.\n\n2. **Data Extraction**:\n    - From the table, the 2015 value for **interest rate derivatives** is $26,363 million.\n    - The **total derivative net of all collateral** in 2015 is $43,097 million.\n\n3. **Computation**:\n    - The proportion of interest rate derivatives relative to the total is calculated as:  \n      \\( \\text{Proportion} = \\frac{\\text{Interest Rate Derivatives}}{\\text{Total Net of All Collateral}} \\)\n    - The result must then be rounded to three decimal places.\n\n4. **Output Constraints**:\n    - Ensure the output is rounded to 3 decimal places using proper formatting or Python's rounding function.\n\nWith the reasoning complete, let us proceed to implement this in Python:\n\n```python\ndef solution():\n    # Define variables name and value\n    interest_rate_derivatives_2015 = 26363  # in millions\n    total_net_derivatives_2015 = 43097  # in millions\n    \n    # Do math calculation to get the proportion\n    proportion = interest_rate_derivatives_2015 / total_net_derivatives_2015\n    \n    # Round the result to three decimal places\n    answer = round(proportion, 3)\n    \n    # return answer\n    return answer\n```"
        ],
        "retrieval_query": "interest rate derivatives made up how much of the net total derivatives for 2015? Answer to three decimal places.",
        "useful_functions": [],
        "usage": {
            "completion_tokens": 332,
            "prompt_tokens": 1455,
            "total_tokens": 1787,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-645",
        "article_title": "Fundamental Analysis",
        "function": "def calculate_profitability_ratios(revenue: float, cogs: float, operating_income: float, net_income: float, total_assets: float, shareholders_equity: float) -> dict:\n    \"\"\"\n    Calculate key profitability ratios for a company.\n\n    This function computes various profitability ratios that help in assessing\n    a company's ability to generate profit from its operations. These ratios are\n    commonly used in fundamental analysis to evaluate financial performance.\n\n    Args:\n        revenue (float): The total revenue or sales generated by the company.\n        cogs (float): The cost of goods sold by the company.\n        operating_income (float): The income from operations before interest and taxes.\n        net_income (float): The total net income of the company after all expenses.\n        total_assets (float): The total assets owned by the company.\n        shareholders_equity (float): The total equity held by the company's shareholders.\n\n    Returns:\n        dict: A dictionary containing the calculated profitability ratios:\n              - 'gross_profit_margin': Ratio of gross profit to revenue.\n              - 'operating_profit_margin': Ratio of operating income to revenue.\n              - 'net_profit_margin': Ratio of net income to revenue.\n              - 'return_on_assets': Ratio of net income to total assets.\n              - 'return_on_equity': Ratio of net income to shareholders' equity.\n\n    Notes:\n        - Applicability: Suitable for use in financial analysis to gauge profitability.\n        - Constraints: Input values must be positive. Revenue should not be zero.\n        - Considerations: Ensure accuracy of input financial data.\n    \"\"\"\n    if revenue <= 0:\n        raise ValueError(\"Revenue must be greater than zero.\")\n    \n    gross_profit_margin = (revenue - cogs) / revenue\n    operating_profit_margin = operating_income / revenue\n    net_profit_margin = net_income / revenue\n    return_on_assets = net_income / total_assets\n    return_on_equity = net_income / shareholders_equity\n\n    return {\n        'gross_profit_margin': gross_profit_margin,\n        'operating_profit_margin': operating_profit_margin,\n        'net_profit_margin': net_profit_margin,\n        'return_on_assets': return_on_assets,\n        'return_on_equity': return_on_equity\n    }",
        "statistics": {
            "number_statistics": {
                "args_numbers": 6,
                "question_numbers": 0,
                "context_numbers": 6,
                "total_numbers": 6
            },
            "operator_statistics": {
                "operators": {
                    "+": 0,
                    "-": 1,
                    "*": 0,
                    "/": 5,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 6
            },
            "code_statistics": {
                "lines": 12,
                "parentheses": 2
            }
        },
        "difficulty": 4.356708826689592,
        "context": "XYZ Corporation, a technology company, generated a total revenue of $750,000 for the fiscal year. The cost of goods sold (COGS) during this period amounted to $450,000. The company reported an operating income of $225,000, and after considering all expenses, the net income stood at $150,000. As of the end of the year, XYZ Corporation's total assets were valued at $1,000,000, while the shareholders' equity was $600,000. As an analyst, you are tasked with evaluating the company's financial performance using key profitability ratios.",
        "question": "What is the gross profit margin of XYZ Corporation? Provide your answer as a percentage rounded to two decimal places.",
        "python_solution": "def solution():\n    # Define given financial values\n    revenue = 750000\n    cogs = 450000\n\n    # Calculate the Gross Profit\n    gross_profit = revenue - cogs\n\n    # Calculate the Gross Profit Margin as a ratio of Gross Profit to Revenue\n    gross_profit_margin = (gross_profit / revenue) * 100\n\n    # Return the result rounded to two decimal places\n    return round(gross_profit_margin, 2)\n\n# Call the solution method and capture the result\nresult = solution()\n# You can print the result or use it as needed\nprint(result)",
        "ground_truth": 40.0,
        "source": "FinanceReasoning-test-243",
        "question_id": "test-2041",
        "level": "hard",
        "output": [
            "To solve this problem, let us apply the following steps using the advanced reasoning technique \"Emphasizing Constraints (EC)\":\n\n### Step-by-Step Analysis:\n1. **Understand the Definition of Gross Profit Margin**:\n   - The gross profit margin is a profitability ratio calculated using the formula:\n     \\[\n     \\text{Gross Profit Margin (\\%)} = \\left( \\frac{\\text{Gross Profit}}{\\text{Sales}} \\right) \\times 100\n     \\]\n   - Gross profit is determined by subtracting the Cost of Goods Sold (COGS) from the total revenue (sales):\n     \\[\n     \\text{Gross Profit} = \\text{Sales (Revenue)} - \\text{Cost of Goods Sold (COGS)}\n     \\]\n\n2. **Adhere to Constraints**:\n   - Ensure that:\n     - The sales (revenue) figure is greater than zero. Since the given revenue is $750,000, this constraint is satisfied.\n     - The result should be returned as a percentage rounded to **two decimal places**.\n\n3. **Identify the Given Parameters**:\n   - Sales (Revenue): $750,000\n   - COGS: $450,000\n\n4. **Compute Gross Profit**:\n   - Gross Profit = Sales - COGS = $750,000 - $450,000 = $300,000\n\n5. **Calculate Gross Profit Margin**:\n   - Substitute the variables into the formula:\n     \\[\n     \\text{Gross Profit Margin (\\%)} = \\left( \\frac{300,000}{750,000} \\right) \\times 100\n     \\]\n     Simplify:\n     \\[\n     \\text{Gross Profit Margin (\\%)} = 40.00\n     \\]\n\n6. **Output the Result**:\n   - Return the gross profit margin as 40.00%.\n\nWith the problem reasoned through step-by-step, let us write the Python program to calculate the gross profit margin.\n\n### Python Program:\n```python\ndef solution():\n    # Define variables name and value\n    sales = 750000  # Total revenue\n    cogs = 450000   # Cost of goods sold (COGS)\n    \n    # Do math calculation to get the gross profit margin\n    gross_profit = sales - cogs  # Gross profit\n    gross_profit_margin = (gross_profit / sales) * 100  # Convert to percentage\n    \n    # return answer rounded to two decimal places\n    return round(gross_profit_margin, 2)\n```"
        ],
        "retrieval_query": "What is the gross profit margin of XYZ Corporation? Provide your answer as a percentage rounded to two decimal places.",
        "useful_functions": [
            "def calculate_gross_profit_margin(sales: float, cost_of_sales: float) -> float:\n    \"\"\"\n    Calculate the gross profit margin as a percentage.\n\n    This function computes the gross profit margin for a company using the\n    current rate method, which is relevant for translating foreign subsidiaries'\n    results into a reporting currency under certain accounting principles.\n    The function calculates the gross profit margin based on sales and cost\n    of sales figures.\n\n    Args:\n        sales (float): The total sales revenue of the company or subsidiary in\n                       its local currency.\n        cost_of_sales (float): The total cost of sales or cost of goods sold in\n                               the same local currency as the sales.\n\n    Returns:\n        gross_profit_margin (float): The gross profit margin expressed as a\n                                     percentage, rounded to three decimal places.\n\n    Notes:\n        - Applicability: This function is applicable when calculating the gross\n          profit margin for financial statements that require currency\n          translation under the current rate method.\n        - Constraints: The sales value must be greater than zero to avoid division by zero.\n        - Considerations: When the exchange rate affects both sales and cost of sales uniformly,\n          the rate cancels out in the calculation, making this function directly applicable.\n    \"\"\"\n    if sales <= 0:\n        raise ValueError(\"Sales must be greater than zero.\")\n\n    gross_profit = sales - cost_of_sales\n    gross_profit_margin = (gross_profit / sales) * 100\n\n    return round(gross_profit_margin, 3)"
        ],
        "usage": {
            "completion_tokens": 525,
            "prompt_tokens": 790,
            "total_tokens": 1315,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-1225",
        "article_title": "Guppy Multiple Moving Average (GMMA)",
        "function": "def calculate_ema(close_prices: list, n_periods: int) -> float:\n    \"\"\"\n    Calculate the Exponential Moving Average (EMA) for a given number of periods.\n\n    The EMA helps to smooth out price data and capture the current trend by giving\n    more weight to recent prices. It is used in technical analysis to anticipate\n    potential breakouts or identify current trends.\n\n    Args:\n        close_prices (list): A list of closing prices in chronological order.\n        n_periods (int): The number of periods over which to calculate the EMA.\n\n    Returns:\n        ema (float): The calculated exponential moving average.\n\n    Notes:\n        - Applicability: Useful for trend analysis in financial time series data.\n        - Constraints: The list of closing prices must contain at least `n_periods` values.\n        - Considerations: The first EMA value is calculated using a Simple Moving Average (SMA).\n    \"\"\"\n    # Calculate the initial SMA\n    if len(close_prices) < n_periods:\n        raise ValueError(\"The number of close prices must be at least equal to the number of periods.\")\n    \n    sma = sum(close_prices[:n_periods]) / n_periods\n\n    # Calculate the multiplier for weighting the EMA\n    multiplier = 2 / (n_periods + 1)\n    \n    # Calculate the initial EMA using the SMA\n    ema = sma\n\n    # Calculate the EMA for the rest of the periods\n    for price in close_prices[n_periods:]:\n        ema = (price - ema) * multiplier + ema\n    \n    return ema",
        "statistics": {
            "number_statistics": {
                "args_numbers": 2,
                "question_numbers": 1,
                "context_numbers": 12,
                "total_numbers": 13
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 1,
                    "*": 1,
                    "/": 2,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 6
            },
            "code_statistics": {
                "lines": 10,
                "parentheses": 6
            }
        },
        "difficulty": 4.356708826689592,
        "context": "An investor is analyzing the daily closing prices of a tech stock to determine its trend. Over the past 10 days, the closing prices were as follows: [150, 152, 153, 150, 155, 157, 158, 160, 162, 161]. To understand the trend more effectively, the investor decides to calculate a 5-day Exponential Moving Average (EMA) from this data.",
        "question": "What is the 5-day Exponential Moving Average (EMA) of the stock based on the given closing prices? Answer to two decimal places.",
        "python_solution": "def solution():\n    # Closing prices for the past 10 days\n    close_prices = [150, 152, 153, 150, 155, 157, 158, 160, 162, 161]\n\n    # Define the number of periods for EMA calculation\n    n_periods = 5\n    \n    # Calculate the initial Simple Moving Average (SMA) for the first n periods\n    sma = sum(close_prices[:n_periods]) / n_periods\n\n    # Calculate the weighting multiplier for the EMA\n    multiplier = 2 / (n_periods + 1)\n    \n    # Initialize EMA with the initial SMA\n    ema = sma\n\n    # Calculate the EMA for the remaining periods\n    for price in close_prices[n_periods:]:\n        ema = (price - ema) * multiplier + ema\n    \n    # Return the EMA rounded to two decimal places\n    return round(ema, 2)\n\n# Calling the function and printing the result for verification\nprint(solution())",
        "ground_truth": 159.33,
        "source": "FinanceReasoning-test-258",
        "question_id": "test-2042",
        "level": "hard",
        "output": [
            "To calculate the 5-day Exponential Moving Average (EMA), let's think through the problem step-by-step with the \"Emphasizing Constraints (EC)\" technique:\n\n1. **Understand the Constraints**:\n   - The calculation of the EMA requires at least `n_periods` (5 in this case) values for closing prices. The input list has 10 days of prices, satisfying the condition.\n   - For EMA, the initial value is the Simple Moving Average (SMA) of the first `n_periods` (5 days).\n   - From the sixth day onward, EMA is calculated recursively using the formula:\n     \\[\n     EMA_{t} = (\\text{Price}_t - EMA_{t-1}) \\times M + EMA_{t-1}\n     \\]\n     where:\n     - \\( \\text{Price}_t \\): Price on the current day.\n     - \\( EMA_{t-1} \\): EMA of the previous day.\n     - \\( M \\): The multiplier, defined as \\( \\frac{2}{n+1} \\), where \\( n \\) is the period (5 days).\n\n2. **Adherence to Decimal Precision**:\n   - The result should be accurate to **two decimal places**.\n\n3. **Break the Steps Down**:\n   - Calculate the initial SMA over the first 5 days.\n   - Determine the multiplier \\( M = 2 / (5 + 1) = 0.3333 \\).\n   - Apply the EMA formula iteratively to compute the 5-day EMA up to the last day in the list.\n   - Return the final EMA value (last value in the EMA sequence) rounded to two decimal places.\n\nNow, I'll construct a Python program to implement this logic:\n\n```python\ndef solution():\n    # Define variables name and value\n    closing_prices = [150, 152, 153, 150, 155, 157, 158, 160, 162, 161]\n    n_periods = 5  # The period for EMA\n\n    # Step 1: Calculate the initial Simple Moving Average (SMA)\n    sma = sum(closing_prices[:n_periods]) / n_periods\n\n    # Step 2: Define the multiplier\n    multiplier = 2 / (n_periods + 1)\n\n    # Step 3: Initialize the EMA with the initial SMA\n    ema = sma\n\n    # Step 4: Calculate the EMA iteratively for the remaining prices\n    for price in closing_prices[n_periods:]:\n        ema = (price - ema) * multiplier + ema\n\n    # Step 5: Return the final EMA value rounded to two decimal places\n    return round(ema, 2)\n```"
        ],
        "retrieval_query": "What is the 5-day Exponential Moving Average (EMA) of the stock based on the given closing prices? Answer to two decimal places.",
        "useful_functions": [
            "def calculate_ema(close_prices: list, n_periods: int) -> float:\n    \"\"\"\n    Calculate the Exponential Moving Average (EMA) for a given number of periods.\n\n    The EMA helps to smooth out price data and capture the current trend by giving\n    more weight to recent prices. It is used in technical analysis to anticipate\n    potential breakouts or identify current trends.\n\n    Args:\n        close_prices (list): A list of closing prices in chronological order.\n        n_periods (int): The number of periods over which to calculate the EMA.\n\n    Returns:\n        ema (float): The calculated exponential moving average.\n\n    Notes:\n        - Applicability: Useful for trend analysis in financial time series data.\n        - Constraints: The list of closing prices must contain at least `n_periods` values.\n        - Considerations: The first EMA value is calculated using a Simple Moving Average (SMA).\n    \"\"\"\n    # Calculate the initial SMA\n    if len(close_prices) < n_periods:\n        raise ValueError(\"The number of close prices must be at least equal to the number of periods.\")\n    \n    sma = sum(close_prices[:n_periods]) / n_periods\n\n    # Calculate the multiplier for weighting the EMA\n    multiplier = 2 / (n_periods + 1)\n    \n    # Calculate the initial EMA using the SMA\n    ema = sma\n\n    # Calculate the EMA for the rest of the periods\n    for price in close_prices[n_periods:]:\n        ema = (price - ema) * multiplier + ema\n    \n    return ema",
            "def calculate_exponential_moving_average(prices: list, period: int) -> list:\n    \"\"\"\n    Calculate the exponential moving average (EMA) of a list of prices over a specified period.\n\n    This function computes the exponential moving average, which gives greater weight to more \n    recent prices, making it more responsive to new information than the simple moving average.\n\n    Args:\n        prices (list): A list of prices (e.g., daily closing prices of a stock).\n        period (int): The number of periods over which to calculate the EMA.\n\n    Returns:\n        ema (list): A list of calculated EMA values corresponding to the input prices.\n\n    Notes:\n        - The period must be greater than 0 and less than or equal to the length of the prices list.\n        - The EMA calculation starts with the simple moving average for the first EMA value.\n        - The returned list will exclude the first (period - 1) elements because they are used to\n          initialize the calculation.\n        - The input list must contain numeric values.\n    \"\"\"\n    if period <= 0 or period > len(prices):\n        raise ValueError(\"Period must be greater than 0 and less than or equal to the length of the prices list.\")\n\n    smoothing_factor = 2 / (period + 1)\n    ema = [sum(prices[:period]) / period]  # Start with the SMA for the first value\n\n    for price in prices[period:]:\n        new_ema = (price * smoothing_factor) + ema[-1] * (1 - smoothing_factor)\n        ema.append(new_ema)\n    \n    return ema",
            "def calculate_exponential_moving_average(prices: list, smoothing: float = 2, days: int = 20) -> list:\n    \"\"\"\n    Calculate the Exponential Moving Average (EMA) of a list of prices.\n\n    This function computes the EMA, which emphasizes the latest price data more heavily \n    by using an exponentially decreasing weight for past observations. It is used in \n    financial markets to analyze data points like stock prices.\n\n    Args:\n        prices (list): A list of prices in chronological order, where each element\n                       represents the price for a given day.\n        smoothing (float): The smoothing factor typically used as 2. It determines how\n                           much weight is applied to the most recent prices. Default is 2.\n        days (int): The number of periods (days) to calculate the EMA for. Typically a \n                    10, 20, 50, or similar period is used. Default is 20.\n\n    Returns:\n        ema_values (list): A list of EMA values calculated for each price in the input list\n                           starting from the (days+1)th day. The first (days) entries will \n                           be None to indicate insufficient data to compute the EMA.\n\n    Notes:\n        - Applicability: Useful in financial analysis for smoothing out price data to \n          identify trends.\n        - Constraints: Requires at least `days` number of price entries to start calculating EMAs.\n        - Considerations: Different periods may result in different trend sensitivities;\n          shorter EMAs react quicker to price changes than longer ones.\n    \"\"\"\n    if len(prices) < days:\n        raise ValueError(\"Number of prices should be at least equal to the 'days' parameter.\")\n\n    multiplier = smoothing / (1 + days)\n    ema_values = [None] * (days - 1)\n    sma = sum(prices[:days]) / days\n    ema_values.append(sma)\n\n    for price in prices[days:]:\n        new_ema = (price - ema_values[-1]) * multiplier + ema_values[-1]\n        ema_values.append(new_ema)\n\n    return ema_values"
        ],
        "usage": {
            "completion_tokens": 567,
            "prompt_tokens": 1548,
            "total_tokens": 2115,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "What was the average rental expense in millions for 2000 through 2002? Answer to three decimal places.",
        "context": "the contracts were valued as of april 1 , 2002 , and an asset and a corresponding gain of $ 127 million , net of income taxes , was recorded as a cumulative effect of a change in accounting principle in the second quarter of 2002 . the majority of the gain recorded relates to the warrior run contract , as the asset value of the deepwater contract on april 1 , 2002 , was less than $ 1 million . the warrior run contract qualifies and was designated as a cash flow hedge as defined by sfas no . 133 and hedge accounting is applied for this contract subsequent to april 1 , 2002 . the contract valuations were performed using current forward electricity and gas price quotes and current market data for other contract variables . the forward curves used to value the contracts include certain assumptions , including projections of future electricity and gas prices in periods where future prices are not quoted . fluctuations in market prices and their impact on the assumptions will cause the value of these contracts to change . such fluctuations will increase the volatility of the company 2019s reported results of operations . 11 . commitments , contingencies and risks operating leases 2014as of december 31 , 2002 , the company was obligated under long-term non-cancelable operating leases , primarily for office rental and site leases . rental expense for operating leases , excluding amounts related to the sale/leaseback discussed below , was $ 31 million $ 32 million and $ 13 million in the years ended december 31 , 2002 , 2001and 2000 , respectively , including commitments of businesses classified as discontinued amounting to $ 6 million in 2002 , $ 16 million in 2001 and $ 6 million in 2000 . the future minimum lease commitments under these leases are as follows ( in millions ) : discontinued total operations .\n\n|  | Total | Discontinued Operations |\n| :--- | :--- | :--- |\n| 2003 | $30 | $4 |\n| 2004 | 20 | 4 |\n| 2005 | 15 | 3 |\n| 2006 | 11 | 1 |\n| 2007 | 9 | 1 |\n| Thereafter | 84 | 1 |\n| Total | $169 | $14 |\n\nsale/leaseback 2014in may 1999 , a subsidiary of the company acquired six electric generating stations from new york state electric and gas ( 2018 2018nyseg 2019 2019 ) . concurrently , the subsidiary sold two of the plants to an unrelated third party for $ 666 million and simultaneously entered into a leasing arrangement with the unrelated party . this transaction has been accounted for as a sale/leaseback with operating lease treatment . rental expense was $ 54 million , $ 58 million and $ 54 million in 2002 , 2001 and 2000 , respectively . future minimum lease commitments are as follows ( in millions ) : in connection with the lease of the two power plants , the subsidiary is required to maintain a rent reserve account equal to the maximum semi-annual payment with respect to the sum of the basic rent ( other then deferrable basic rent ) and fixed charges expected to become due in the immediately succeeding three-year period . at december 31 , 2002 , 2001 and 2000 , the amount deposited in the rent reserve account approximated .\n",
        "statistics": {
            "number_statistics": {
                "question_numbers": 0,
                "context_numbers": 34,
                "total_numbers": 34
            },
            "operator_statistics": {
                "operators": {
                    "+": 5,
                    "-": 0,
                    "*": 0,
                    "/": 1,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 6
            },
            "code_statistics": {
                "lines": 12,
                "parentheses": 2
            }
        },
        "difficulty": 4.356708826689592,
        "ground_truth": 80.667,
        "source": "CodeFinQA-test-91",
        "python_solution": "sale_leaseback_2000 = 54\nsale_leaseback_2001 = 58\nsale_leaseback_2002 = 54\noperating_lease_2000 = 13\noperating_lease_2001 = 32\noperating_lease_2002 = 31\n\ntotal_rent_2000 = sale_leaseback_2000 + operating_lease_2000\ntotal_rent_2001 = sale_leaseback_2001 + operating_lease_2001\ntotal_rent_2002 = sale_leaseback_2002 + operating_lease_2002\n\ntotal_rent = total_rent_2000 + total_rent_2001 + total_rent_2002\naverage_rent = total_rent / 3\nanswer = round(average_rent, 3)",
        "question_id": "test-2043",
        "level": "hard",
        "output": [
            "To accurately solve the problem, let us first think through the steps using the Emphasizing Constraints (EC) reasoning technique:\n\n1. **Constraints Definition:**\n   - The data provided includes rental expenses for each year from 2000 to 2002: $31 million (2002), $32 million (2001), and $13 million (2000).\n   - We must calculate the *average rental expense* for these three years.\n   - The answer must be formatted to three decimal places.\n\n2. **Plan for Calculation:**\n   - Sum up the rental expenses for the years 2000, 2001, and 2002.\n   - Divide the total rental expense by the number of years (3) to determine the average.\n   - Return the result formatted to three decimal places.\n\n3. **Program Development:**\n   - Define the rental expenses as a list of numerical values: `[31, 32, 13]`.\n   - Compute the total expenses using the `sum()` function.\n   - Calculate the average by dividing the total by the number of elements.\n   - Round the calculated average to three decimal places using Python's `round()` function.\n\nHere is the Python implementation:\n\n```python\ndef solution():\n    # Define variables name and value\n    rental_expenses = [31, 32, 13]  # Rental expenses for 2002, 2001, and 2000 (in millions)\n    \n    # Calculate the total rental expense\n    total_expense = sum(rental_expenses)\n    \n    # Calculate the average rental expense\n    average_expense = total_expense / len(rental_expenses)\n    \n    # Round the result to three decimal places\n    answer = round(average_expense, 3)\n    \n    # Return the answer\n    return answer\n```"
        ],
        "retrieval_query": "What was the average rental expense in millions for 2000 through 2002? Answer to three decimal places.",
        "useful_functions": [
            "def calculate_average_rental_expense(rental_expenses: list) -> float:\n    \"\"\"\n    Calculate the average rental expense over a given period.\n\n    This function computes the average of rental expenses provided\n    for a sequence of time periods. It is useful for determining the \n    average cost associated with rental agreements or leases over \n    multiple years.\n\n    Args:\n        rental_expenses (list): A list of rental expenses (in millions) \n                                for each period, where each element \n                                represents the rental expense for a \n                                specific year.\n\n    Returns:\n        average_expense (float): The average rental expense across the \n                                 given periods.\n\n    Notes:\n        - Applicability: Suitable for calculating the mean of financial \n          rental figures over any set of time periods.\n        - Constraints: The list must contain numerical values representing \n          rental expenses.\n        - Considerations: Ensure the list is not empty before passing, \n          as dividing by zero will raise an exception.\n    \"\"\"\n    if not rental_expenses:\n        raise ValueError(\"The rental_expenses list must not be empty.\")\n\n    total_rent = sum(rental_expenses)\n    average_expense = total_rent / len(rental_expenses)\n\n    return average_expense"
        ],
        "usage": {
            "completion_tokens": 375,
            "prompt_tokens": 1314,
            "total_tokens": 1689,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-917",
        "article_title": "Minimum Lease Payment",
        "function": "def calculate_present_value_of_lease_payments(lease_payments: list, interest_rate: float, residual_value: float, num_periods: int) -> float:\n    \"\"\"\n    Calculate the present value of lease payments, including the residual value.\n\n    This function computes the present value of a series of lease payments,\n    along with the residual value of the leased asset, using a given interest \n    rate. The function is useful in the financial analysis of leases to determine \n    the current value of future lease obligations under both operating and capital leases.\n\n    Args:\n        lease_payments (list): A list of lease payments (payment amount per period).\n        interest_rate (float): The interest rate used to discount future lease payments \n                               (expressed as a decimal).\n        residual_value (float): The estimated residual value of the leased asset at \n                                the end of the lease term.\n        num_periods (int): The total number of payment periods in the lease.\n\n    Returns:\n        present_value (float): The calculated present value of the minimum lease payments \n                               including the residual value.\n\n    Notes:\n        - Applicability: This function applies to the estimation of lease value for \n          accounting and financial decision-making purposes.\n        - Constraints: The interest rate should be positive, and the number of payment periods \n          should be a positive integer.\n        - Considerations: Ensure that lease payments and the residual value are in the same \n          currency and time period as the interest rate.\n    \"\"\"\n    present_value = sum(payment / ((1 + interest_rate) ** (i + 1)) for i, payment in enumerate(lease_payments))\n    present_value += residual_value / ((1 + interest_rate) ** num_periods)\n    \n    return present_value",
        "statistics": {
            "number_statistics": {
                "args_numbers": 4,
                "question_numbers": 0,
                "context_numbers": 4,
                "total_numbers": 4
            },
            "operator_statistics": {
                "operators": {
                    "+": 4,
                    "-": 0,
                    "*": 0,
                    "/": 2,
                    "%": 0,
                    "**": 2
                },
                "total_operators": 8
            },
            "code_statistics": {
                "lines": 3,
                "parentheses": 14
            }
        },
        "difficulty": 4.382026634673881,
        "context": "A car dealership is evaluating whether to lease a fleet of vehicles for its operations. The lease agreement includes annual payments of 10,000 for each of the next 5 years. At the end of the lease term, the vehicles have an estimated residual value of 15,000. The dealership wants to calculate the present value of these lease payments, considering an annual interest rate of 8%.",
        "question": "What is the present value of the lease payments, including the residual value, for the dealership? Answer to the nearest dollar.",
        "python_solution": "def solution():\n    # Define the given values\n    lease_payments = [10000] * 5  # Equal payments of 10,000 for each of the 5 years\n    interest_rate = 0.08         # Annual interest rate of 8%\n    residual_value = 15000       # Estimated residual value at the end of the lease term\n    num_periods = 5              # Total number of payment periods\n\n    # Calculate the present value of the lease payments\n    present_value = 0\n    for i in range(num_periods):\n        payment = lease_payments[i]\n        present_value += payment / ((1 + interest_rate) ** (i + 1))\n    \n    # Add the present value of the residual value\n    present_value += residual_value / ((1 + interest_rate) ** num_periods)\n\n    # Return the final answer rounded to the nearest dollar\n    return round(present_value)\n\n# Call the solution function\nsolution()",
        "ground_truth": 50136,
        "source": "FinanceReasoning-test-189",
        "question_id": "test-2044",
        "level": "hard",
        "output": [
            "To solve the problem of calculating the present value of the lease payments including the residual value, let's break the problem into step-by-step reasoning using the Emphasizing Constraints (EC) approach:\n\n### Step 1: Define Functional Requirements\n- We need to compute the present value of:\n  - Annual lease payments of $10,000 for 5 years.\n  - A residual value of $15,000 at the end of the lease term.\n- The discount rate (or interest rate) used for the calculations is 8% annually.\n- Convert the interest rate into a decimal format (i.e., 8% = 0.08).\n\n### Step 2: Constraints\n- **Payment Period**: There are fixed payments of $10,000 over 5 years (5 periods).\n- **Precision**: The output should be rounded to the nearest dollar.\n- **Numerical Validations**:\n  - The interest rate must be expressed as a positive decimal.\n  - The number of payment periods should be a positive integer.\n- Ensure that both payments and the residual value are expressed in the same unit (dollars).\n\n### Step 3: Mathematical Formula\nWe will use the present value formula for lease payments and residual value:\n- Present value of lease payments:\n  \\[\n  PV_{\\text{payments}} = \\sum_{i=1}^{n} \\frac{\\text{payment}}{(1 + r)^i}\n  \\]\n  where \\(r\\) is the interest rate, \\(i\\) is the period (1 to \\(n\\)), and \\(n\\) is the number of periods (5).\n- Present value of residual value:\n  \\[\n  PV_{\\text{residual}} = \\frac{\\text{residual value}}{(1 + r)^n}\n  \\]\n- Total present value:\n  \\[\n  PV_{\\text{total}} = PV_{\\text{payments}} + PV_{\\text{residual}}\n  \\]\n\n### Step 4: Implementation Outline\n1. Define the inputs:\n   - `lease_payments` in a list format (5 payments of $10,000).\n   - `residual_value` as $15,000.\n   - `interest_rate` as 0.08.\n   - `num_periods` as 5.\n2. Sum the discounted payment values for \\( n \\) periods.\n3. Calculate the discounted residual value.\n4. Add both results and round to the nearest dollar.\n\nNow, let's write the Python program for this computation.\n\n```python\ndef solution():\n    # Define variables name and value\n    interest_rate = 0.08  # Annual interest rate as decimal\n    lease_payment = 10000  # Payment amount per period in dollars\n    num_periods = 5  # Number of payment periods\n    residual_value = 15000  # Residual value of the leased vehicles in dollars\n    \n    # Step 1: Calculate present value of lease payments\n    lease_payments = [lease_payment] * num_periods\n    pv_lease_payments = sum(payment / ((1 + interest_rate) ** (i + 1)) for i, payment in enumerate(lease_payments))\n    \n    # Step 2: Calculate present value of residual value\n    pv_residual_value = residual_value / ((1 + interest_rate) ** num_periods)\n    \n    # Step 3: Total present value\n    total_present_value = pv_lease_payments + pv_residual_value\n    \n    # Round result to nearest dollar\n    answer = round(total_present_value)\n    \n    # return answer\n    return answer\n```"
        ],
        "retrieval_query": "What is the present value of the lease payments, including the residual value, for the dealership? Answer to the nearest dollar.",
        "useful_functions": [
            "def calculate_present_value_of_lease_payments(lease_payments: list, interest_rate: float, residual_value: float, num_periods: int) -> float:\n    \"\"\"\n    Calculate the present value of lease payments, including the residual value.\n\n    This function computes the present value of a series of lease payments,\n    along with the residual value of the leased asset, using a given interest \n    rate. The function is useful in the financial analysis of leases to determine \n    the current value of future lease obligations under both operating and capital leases.\n\n    Args:\n        lease_payments (list): A list of lease payments (payment amount per period).\n        interest_rate (float): The interest rate used to discount future lease payments \n                               (expressed as a decimal).\n        residual_value (float): The estimated residual value of the leased asset at \n                                the end of the lease term.\n        num_periods (int): The total number of payment periods in the lease.\n\n    Returns:\n        present_value (float): The calculated present value of the minimum lease payments \n                               including the residual value.\n\n    Notes:\n        - Applicability: This function applies to the estimation of lease value for \n          accounting and financial decision-making purposes.\n        - Constraints: The interest rate should be positive, and the number of payment periods \n          should be a positive integer.\n        - Considerations: Ensure that lease payments and the residual value are in the same \n          currency and time period as the interest rate.\n    \"\"\"\n    present_value = sum(payment / ((1 + interest_rate) ** (i + 1)) for i, payment in enumerate(lease_payments))\n    present_value += residual_value / ((1 + interest_rate) ** num_periods)\n    \n    return present_value"
        ],
        "usage": {
            "completion_tokens": 750,
            "prompt_tokens": 799,
            "total_tokens": 1549,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-1480",
        "article_title": "Refinance",
        "function": "def calculate_new_payment(principal: float, old_interest_rate: float, new_interest_rate: float, remaining_term_years: int) -> float:\n    \"\"\"\n    Calculate the new monthly payment after refinancing a loan at a new interest rate.\n\n    This function computes the new monthly payment for a loan when refinancing into\n    a new interest rate while maintaining the original principal and taking into account\n    the remaining loan term. It is useful for understanding the impact of reduced interest\n    rates on monthly repayments.\n\n    Args:\n        principal (float): The outstanding principal of the loan to be refinanced.\n        old_interest_rate (float): The initial annual interest rate before refinancing (as a decimal).\n        new_interest_rate (float): The new annual interest rate after refinancing (as a decimal).\n        remaining_term_years (int): The number of years remaining on the original loan term.\n\n    Returns:\n        new_payment (float): The new estimated monthly payment after refinancing.\n\n    Notes:\n        - This calculation assumes fixed-rate loans with monthly compounding.\n        - Interest rates should be provided as decimal values (e.g., 4% as 0.04).\n        - The remaining loan term is considered in years and converted to months.\n        - This does not account for potential refinancing fees or other costs.\n    \"\"\"\n    monthly_rate = new_interest_rate / 12\n    total_payments = remaining_term_years * 12\n\n    new_payment = principal * (monthly_rate * (1 + monthly_rate) ** total_payments) / ((1 + monthly_rate) ** total_payments - 1)\n    \n    return new_payment",
        "statistics": {
            "number_statistics": {
                "args_numbers": 4,
                "question_numbers": 1,
                "context_numbers": 4,
                "total_numbers": 5
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 1,
                    "*": 3,
                    "/": 2,
                    "%": 0,
                    "**": 2
                },
                "total_operators": 10
            },
            "code_statistics": {
                "lines": 4,
                "parentheses": 8
            }
        },
        "difficulty": 4.382026634673881,
        "context": "A homeowner has an outstanding mortgage balance of $200,000 with an interest rate of 5% per annum, and 20 years remaining on the loan term. With market conditions changing, the homeowner has an opportunity to refinance at a lower interest rate of 3.5% per annum. The homeowner wants to know what their new monthly payment would be if they refinanced at the new rate while keeping the remaining term unchanged.",
        "question": "What will be the new monthly payment after refinancing the mortgage at a 3.5% annual interest rate? Answer to the nearest cent.",
        "python_solution": "def solution():\n    # Define the initial loan details for refinancing\n    principal = 200000  # Outstanding principal\n    new_interest_rate = 0.035  # New annual interest rate after refinancing\n    remaining_term_years = 20  # Number of years remaining on the loan\n\n    # Calculate monthly interest rate from annual\n    monthly_rate = new_interest_rate / 12\n\n    # Calculate total number of monthly payments\n    total_payments = remaining_term_years * 12\n\n    # Calculate the new monthly payment using the loan amortization formula\n    new_payment = principal * (monthly_rate * (1 + monthly_rate) ** total_payments) / ((1 + monthly_rate) ** total_payments - 1)\n\n    # Return the new monthly payment, rounded to the nearest cent\n    return round(new_payment, 2)",
        "ground_truth": 1159.92,
        "source": "FinanceReasoning-test-198",
        "question_id": "test-2045",
        "level": "hard",
        "output": [
            "To solve the given problem, we must compute the new monthly payment for refinancing a loan at a lower interest rate (3.5% per annum) while keeping the remaining loan term unchanged (20 years). The computation involves an amortizing loan calculation where monthly payments cover both interest and principal.\n\n### Step-by-step reasoning:\n\n1. **Emphasizing Constraints (EC):**\n   - Inputs:\n     - Principal (`loan_amount`) = $200,000.\n     - New annual interest rate (`annual_interest_rate`) = 3.5%.\n     - Loan term in years (`loan_term_years`) = 20.\n   - Outputs:\n     - We need the **new monthly payment**, rounded to the nearest cent.\n   - Formula: We'll use the fixed-rate loan formula for monthly payments:\n     \\[\n     M = P \\cdot \\frac{r(1 + r)^n}{(1 + r)^n - 1}\n     \\]\n     where:\n     - \\( M \\): Monthly payment (what we calculate),\n     - \\( P \\): Loan principal,\n     - \\( r \\): Monthly interest rate (annual interest rate / 12),\n     - \\( n \\): Total number of monthly payments (loan term in years \u00d7 12).\n\n2. **Breakdown of Computation:**\n   - Convert the annual interest rate to a monthly interest rate:\n     \\[\n     r = \\frac{\\text{annual interest rate}}{12}\n     \\]\n   - Compute the total number of monthly payments:\n     \\[\n     n = \\text{loan term in years} \\times 12\n     \\]\n   - Substitute values into the amortization formula to determine the new monthly payment \\( M \\).\n\n3. **Precision Handling:**\n   - Ensure the result is precise to 2 decimal places (nearest cent).\n   - Handle potential rounding issues correctly.\n\n4. **Implementation:**\n   - Implement the calculation in Python, adhering to the constraints and ensuring the precision is respected.\n\nHere is the Python program:\n\n```python\ndef solution():\n    # Define variables\n    loan_amount = 200000  # Principal amount ($)\n    annual_interest_rate = 3.5  # New annual interest rate (%)\n    loan_term_years = 20  # Remaining loan term (years)\n    \n    # Convert annual interest rate to monthly interest rate (decimal form)\n    monthly_interest_rate = annual_interest_rate / 100 / 12  # Divide by 100 to convert % to decimal, then by 12 for monthly rate\n    \n    # Calculate total number of monthly payments\n    number_of_payments = loan_term_years * 12  # Total monthly payments\n    \n    # Apply the monthly payment formula\n    monthly_payment = loan_amount * (monthly_interest_rate * (1 + monthly_interest_rate) ** number_of_payments) / \\\n                      ((1 + monthly_interest_rate) ** number_of_payments - 1)\n    \n    # Round to the nearest cent\n    return round(monthly_payment, 2)\n```"
        ],
        "retrieval_query": "What will be the new monthly payment after refinancing the mortgage at a 3.5% annual interest rate? Answer to the nearest cent.",
        "useful_functions": [
            "def calculate_new_payment(principal: float, old_interest_rate: float, new_interest_rate: float, remaining_term_years: int) -> float:\n    \"\"\"\n    Calculate the new monthly payment after refinancing a loan at a new interest rate.\n\n    This function computes the new monthly payment for a loan when refinancing into\n    a new interest rate while maintaining the original principal and taking into account\n    the remaining loan term. It is useful for understanding the impact of reduced interest\n    rates on monthly repayments.\n\n    Args:\n        principal (float): The outstanding principal of the loan to be refinanced.\n        old_interest_rate (float): The initial annual interest rate before refinancing (as a decimal).\n        new_interest_rate (float): The new annual interest rate after refinancing (as a decimal).\n        remaining_term_years (int): The number of years remaining on the original loan term.\n\n    Returns:\n        new_payment (float): The new estimated monthly payment after refinancing.\n\n    Notes:\n        - This calculation assumes fixed-rate loans with monthly compounding.\n        - Interest rates should be provided as decimal values (e.g., 4% as 0.04).\n        - The remaining loan term is considered in years and converted to months.\n        - This does not account for potential refinancing fees or other costs.\n    \"\"\"\n    monthly_rate = new_interest_rate / 12\n    total_payments = remaining_term_years * 12\n\n    new_payment = principal * (monthly_rate * (1 + monthly_rate) ** total_payments) / ((1 + monthly_rate) ** total_payments - 1)\n    \n    return new_payment",
            "def calculate_monthly_payment(principal: float, annual_interest_rate: float, years: int) -> float:\n    \"\"\"\n    Calculate the monthly payment required to fully repay a loan over a specified time period\n    using a fixed interest rate.\n\n    This calculation is applicable for fixed-rate loans including standard repayment plans for\n    student loans or mortgages.\n\n    Args:\n        principal (float): The initial amount of the loan.\n        annual_interest_rate (float): The annual interest rate as a percentage.\n        years (int): The total time in years over which the loan is to be repaid.\n\n    Returns:\n        monthly_payment (float): The amount to be paid monthly to repay the loan in full.\n\n    Notes:\n        - Applicability: Use for fixed-rate loans.\n        - Constraints: Interest rate should be greater than 0; years should be a positive integer.\n        - Considerations: This does not account for fees, taxes, or insurance that may also be part\n                          of monthly payments.\n    \"\"\"\n    if annual_interest_rate <= 0:\n        raise ValueError(\"Interest rate must be greater than zero.\")\n    if years <= 0:\n        raise ValueError(\"Years must be a positive integer.\")\n\n    monthly_interest_rate = annual_interest_rate / 100 / 12\n    number_of_payments = years * 12\n\n    monthly_payment = (principal * monthly_interest_rate) / \\\n                      (1 - (1 + monthly_interest_rate) ** -number_of_payments)\n\n    return monthly_payment",
            "def calculate_monthly_payment(loan_amount: float, annual_interest_rate: float, loan_term_years: int) -> float:\n    \"\"\"\n    Calculate the monthly payment for an amortizing loan.\n\n    This function computes the total monthly payment required to repay a loan amount\n    over a specified term with a given annual interest rate. It is commonly used in\n    creating amortization schedules for loans such as mortgages or car loans.\n\n    Args:\n        loan_amount (float): The principal amount of the loan.\n        annual_interest_rate (float): The annual interest rate as a decimal (e.g., 0.03 for 3%).\n        loan_term_years (int): The term of the loan in years.\n\n    Returns:\n        monthly_payment (float): The monthly payment amount.\n\n    Notes:\n        - The annual interest rate is divided by 12 to obtain the monthly rate.\n        - The loan term in years is multiplied by 12 to obtain the total number of payments.\n        - Not applicable for non-amortizing or interest-only loans.\n    \"\"\"\n    monthly_interest_rate = annual_interest_rate / 12\n    number_of_payments = loan_term_years * 12\n    monthly_payment = loan_amount * (monthly_interest_rate * (1 + monthly_interest_rate) ** number_of_payments) / (\n        (1 + monthly_interest_rate) ** number_of_payments - 1)\n    \n    return monthly_payment\n\ndef calculate_amortization_schedule(loan_amount: float, annual_interest_rate: float, loan_term_years: int) -> list:\n    \"\"\"\n    Generate an amortization schedule showing the breakdown of payments over the loan term.\n\n    This function returns a list of dictionaries where each dictionary represents a payment period,\n    detailing the beginning balance, total payment, interest payment, principal payment, and ending balance.\n\n    Args:\n        loan_amount (float): The principal amount of the loan.\n        annual_interest_rate (float): The annual interest rate as a decimal (e.g., 0.03 for 3%).\n        loan_term_years (int): The term of the loan in years.\n\n    Returns:\n        schedule (list): A list of dictionaries, each containing:\n                         - 'Period': The period number.\n                         - 'Beginning Balance': Loan balance at the start of the period.\n                         - 'Payment': The total payment for the period.\n                         - 'Interest': The interest component of the payment.\n                         - 'Principal': The principal component of the payment.\n                         - 'Ending Balance': Loan balance at the end of the period.\n\n    Notes:\n        - Assumes a fixed interest and principal repayment schedule.\n        - Intends to provide a complete loan amortization overview.\n        - Suitable for traditional fully-amortizing loans.\n    \"\"\"\n    monthly_payment = calculate_monthly_payment(loan_amount, annual_interest_rate, loan_term_years)\n    monthly_interest_rate = annual_interest_rate / 12\n    number_of_payments = loan_term_years * 12\n\n    schedule = []\n    beginning_balance = loan_amount\n\n    for period in range(1, number_of_payments + 1):\n        interest_payment = beginning_balance * monthly_interest_rate\n        principal_payment = monthly_payment - interest_payment\n        ending_balance = beginning_balance - principal_payment\n\n        schedule.append({\n            'Period': period,\n            'Beginning Balance': beginning_balance,\n            'Payment': monthly_payment,\n            'Interest': interest_payment,\n            'Principal': principal_payment,\n            'Ending Balance': ending_balance\n        })\n\n        beginning_balance = ending_balance\n\n    return schedule"
        ],
        "usage": {
            "completion_tokens": 620,
            "prompt_tokens": 1817,
            "total_tokens": 2437,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-2309",
        "article_title": "Amortization Schedule",
        "function": "def calculate_amortization_schedule(loan_amount: float, annual_interest_rate: float, number_of_payments: int) -> list:\n    \"\"\"\n    Calculate an amortization schedule for a loan.\n\n    This function generates an amortization schedule that details each payment period,\n    showing the beginning loan balance, payment amount, interest due, principal due,\n    and ending loan balance. It is helpful for understanding how each payment is applied\n    towards interest and principal.\n\n    Args:\n        loan_amount (float): The initial amount of the loan.\n        annual_interest_rate (float): The annual interest rate as a decimal (e.g., 0.03 for 3%).\n        number_of_payments (int): The total number of payments (usually months for loans).\n\n    Returns:\n        schedule (list): A list of dictionaries representing the amortization schedule.\n\n    Notes:\n        - Applicability: Suitable for fixed-rate loans where payments are made periodically.\n        - Constraints: All input values must be positive numbers.\n        - Considerations: Consider rounding each computed value for better precision in financial contexts.\n    \"\"\"\n    monthly_payment = calculate_monthly_payment(loan_amount, annual_interest_rate, number_of_payments)\n    balance = loan_amount\n    monthly_rate = annual_interest_rate / 12\n    schedule = []\n\n    for _ in range(number_of_payments):\n        interest_payment = balance * monthly_rate\n        principal_payment = monthly_payment - interest_payment\n        ending_balance = balance - principal_payment\n\n        schedule.append({\n            'Beginning Balance': balance,\n            'Payment': monthly_payment,\n            'Interest': interest_payment,\n            'Principal': principal_payment,\n            'Ending Balance': ending_balance\n        })\n\n        balance = ending_balance\n\n    return schedule",
        "statistics": {
            "number_statistics": {
                "args_numbers": 3,
                "question_numbers": 0,
                "context_numbers": 3,
                "total_numbers": 3
            },
            "operator_statistics": {
                "operators": {
                    "+": 0,
                    "-": 2,
                    "*": 1,
                    "/": 1,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 4
            },
            "code_statistics": {
                "lines": 17,
                "parentheses": 6
            }
        },
        "difficulty": 4.382026634673881,
        "context": "John is planning to take out a car loan to purchase a vehicle worth 35,000 USD. The loan is offered by his bank with a fixed annual interest rate of 4.8%, and the loan term is 5 years. John wants to understand the financial implications of this loan, especially the monthly payment amount he would need to cover the loan over the entire duration, without overlooking how much of his payment goes towards paying off interest versus the principal.",
        "question": "What is the monthly payment John needs to make for his car loan? Answer in USD to the nearest cent.",
        "python_solution": "def solution():\n    # Given values\n    loan_amount = 35000  # The principal amount of the loan\n    annual_interest_rate = 0.048  # Annual interest rate of 4.8%\n    loan_term_years = 5  # Loan term in years\n    number_of_payments = loan_term_years * 12  # 5 years converted to monthly payments\n    \n    # Monthly interest rate calculation\n    monthly_interest_rate = annual_interest_rate / 12\n    \n    # Calculating monthly payment using the formula for an annuity payment (fixed installment loan)\n    # Monthly Payment = P * (r(1 + r)^N) / ((1 + r)^N - 1)\n    # where:\n    # P = loan_amount (principal)\n    # r = monthly_interest_rate\n    # N = number_of_payments\n    P = loan_amount\n    r = monthly_interest_rate\n    N = number_of_payments\n    \n    # Calculate monthly payment\n    monthly_payment = P * (r * (1 + r) ** N) / ((1 + r) ** N - 1)\n    \n    # Return the monthly payment rounded to the nearest cent\n    return round(monthly_payment, 2)\n\n# Running the solution function to compute the answer\nsolution_monthly_payment = solution()\nsolution_monthly_payment",
        "ground_truth": 657.29,
        "source": "FinanceReasoning-test-205",
        "question_id": "test-2046",
        "level": "hard",
        "output": [
            "To solve this problem, we need to carefully evaluate the constraints and calculate the monthly payment John needs to make in order to repay his car loan. Let's break it down step by step:\n\n### Step 1: Analyze the inputs\n1. **Principal Loan Amount (P)**: The total value of the car loan is \\( 35,000 \\, \\text{USD} \\).\n2. **Annual Interest Rate (r)**: The fixed annual interest rate is \\( 4.8\\% \\) (expressed in decimal form as \\( 0.048 \\)).\n3. **Loan Term (T)**: The loan term is \\( 5 \\, \\text{years} \\), which is equal to \\( 5 \\times 12 = 60 \\, \\text{months} \\).\n\n### Step 2: Emphasize Constraints (EC)\n- We must round the final result to the nearest cent (2 decimal precision).\n- Monthly payment is calculated using the **Amortization formula**:\n  \\[\n  M = P \\times \\frac{r_m}{1 - (1 + r_m)^{-n}}\n  \\]\n  where:\n  - \\( M \\) is the monthly payment.\n  - \\( P \\) is the principal loan amount.\n  - \\( r_m \\) is the monthly interest rate (\\( r / 12 \\)).\n  - \\( n \\) is the total number of monthly payments (\\( T \\times 12 \\)).\n\n### Step 3: Implement the formula\nUsing the inputs:\n- \\( r_m = \\frac{0.048}{12} = 0.004 \\) (monthly interest rate).\n- \\( n = 60 \\, \\text{months} \\).\n\nSubstituting values into the formula will give the exact monthly payment.\n\n### Python Program\nNow, let's write the Python program to calculate the monthly payment:\n\n```python\ndef solution():\n    # Define variables name and value\n    loan_amount = 35000  # Principal amount in USD\n    annual_interest_rate = 4.8 / 100  # Convert percentage to decimal\n    loan_term_years = 5  # Loan term in years\n    \n    # Calculations\n    monthly_interest_rate = annual_interest_rate / 12  # Monthly interest rate\n    number_of_payments = loan_term_years * 12  # Total number of monthly payments\n    \n    # Monthly payment formula\n    monthly_payment = (loan_amount * monthly_interest_rate) / \\\n                      (1 - (1 + monthly_interest_rate) ** -number_of_payments)\n    \n    # Return answer rounded to the nearest cent\n    return round(monthly_payment, 2)\n```\n\nThis program computes the fixed monthly payment required for John to repay his car loan within the specified period. It uses the provided inputs, adheres to constraints, and ensures precision."
        ],
        "retrieval_query": "What is the monthly payment John needs to make for his car loan? Answer in USD to the nearest cent.",
        "useful_functions": [
            "def calculate_monthly_payment(principal: float, annual_interest_rate: float, term_months: int) -> float:\n    \"\"\"\n    Calculate the monthly payment required to repay a loan.\n\n    This function calculates the monthly payment needed to repay a loan\n    within a specified term at a given annual interest rate using the \n    formula for amortizing loans.\n\n    Args:\n        principal (float): The total amount of the loan.\n        annual_interest_rate (float): The annual interest rate (as a decimal).\n                                      For example, 11% should be input as 0.11.\n        term_months (int): The term of the loan in months.\n\n    Returns:\n        monthly_payment (float): The monthly payment amount needed to repay\n                                 the loan over its term.\n\n    Notes:\n        - The formula used assumes a fixed interest rate for the entire term.\n        - Interest is compounded monthly.\n        - The calculated monthly payment does not include taxes or insurance, if applicable.\n    \"\"\"\n    if annual_interest_rate < 0 or principal < 0 or term_months <= 0:\n        raise ValueError(\"Invalid input values: ensure all values are positive and term is greater than 0.\")\n    \n    monthly_interest_rate = annual_interest_rate / 12\n    if monthly_interest_rate == 0:  # Handle case where interest rate is 0%\n        monthly_payment = principal / term_months\n    else:\n        monthly_payment = (principal * monthly_interest_rate) / (1 - (1 + monthly_interest_rate) ** -term_months)\n    \n    return monthly_payment\n\n\ndef calculate_total_interest_paid(principal: float, monthly_payment: float, term_months: int) -> float:\n    \"\"\"\n    Calculate the total interest paid over the life of a loan.\n\n    This function computes the total interest paid when repaying a loan with\n    specified monthly payments over a given term.\n\n    Args:\n        principal (float): The initial amount of the loan.\n        monthly_payment (float): The monthly payment amount.\n        term_months (int): The total number of months to repay the loan.\n\n    Returns:\n        total_interest_paid (float): The total interest amount paid over the term.\n\n    Notes:\n        - The calculation assumes that the loan is fully repaid using equal monthly payments.\n        - Does not account for early repayments or additional fees that may alter total interest.\n    \"\"\"\n    if monthly_payment <= 0 or principal < 0 or term_months <= 0:\n        raise ValueError(\"Invalid input values: ensure payments and principal are positive and term is greater than 0.\")\n    \n    total_paid = monthly_payment * term_months\n    total_interest_paid = total_paid - principal\n    \n    return total_interest_paid",
            "def calculate_monthly_payment(principal: float, annual_interest_rate: float, years: int) -> float:\n    \"\"\"\n    Calculate the monthly payment required to fully repay a loan over a specified time period\n    using a fixed interest rate.\n\n    This calculation is applicable for fixed-rate loans including standard repayment plans for\n    student loans or mortgages.\n\n    Args:\n        principal (float): The initial amount of the loan.\n        annual_interest_rate (float): The annual interest rate as a percentage.\n        years (int): The total time in years over which the loan is to be repaid.\n\n    Returns:\n        monthly_payment (float): The amount to be paid monthly to repay the loan in full.\n\n    Notes:\n        - Applicability: Use for fixed-rate loans.\n        - Constraints: Interest rate should be greater than 0; years should be a positive integer.\n        - Considerations: This does not account for fees, taxes, or insurance that may also be part\n                          of monthly payments.\n    \"\"\"\n    if annual_interest_rate <= 0:\n        raise ValueError(\"Interest rate must be greater than zero.\")\n    if years <= 0:\n        raise ValueError(\"Years must be a positive integer.\")\n\n    monthly_interest_rate = annual_interest_rate / 100 / 12\n    number_of_payments = years * 12\n\n    monthly_payment = (principal * monthly_interest_rate) / \\\n                      (1 - (1 + monthly_interest_rate) ** -number_of_payments)\n\n    return monthly_payment",
            "def calculate_monthly_payment(loan_amount: float, annual_interest_rate: float, loan_term_years: int) -> float:\n    \"\"\"\n    Calculate the monthly payment for a loan based on the loan amount, annual interest rate, and term.\n\n    This function estimates the fixed monthly payment required to pay off a loan\n    under specified conditions using the formula for an amortizing loan.\n\n    Args:\n        loan_amount (float): The total amount of the loan.\n        annual_interest_rate (float): The annual interest rate as a decimal (e.g., 0.05 for 5%).\n        loan_term_years (int): The total number of years over which the loan will be repaid.\n\n    Returns:\n        monthly_payment (float): The calculated fixed monthly payment for the loan.\n\n    Notes:\n        - Applicability: Useful for estimating monthly payments in financial planning.\n        - Constraints: The annual interest rate should be greater than 0.\n        - Considerations: Payments do not include additional fees like taxes or insurance.\n    \"\"\"\n    monthly_interest_rate = annual_interest_rate / 12\n    number_of_payments = loan_term_years * 12\n    \n    if annual_interest_rate == 0:\n        monthly_payment = loan_amount / number_of_payments\n    else:\n        monthly_payment = (loan_amount * monthly_interest_rate) / (1 - (1 + monthly_interest_rate) ** -number_of_payments)\n    \n    return monthly_payment"
        ],
        "usage": {
            "completion_tokens": 592,
            "prompt_tokens": 1614,
            "total_tokens": 2206,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-429",
        "article_title": "Installment Debt",
        "function": "def calculate_monthly_installment(principal: float, annual_interest_rate: float, periods: int) -> float:\n    \"\"\"\n    Calculate the monthly installment payment for an amortized loan.\n\n    This function computes the equal monthly payment required to pay off \n    an amortized loan over a certain number of periods with a fixed \n    annual interest rate.\n\n    Args:\n        principal (float): The total amount of the loan (or cost financed) in currency units.\n        annual_interest_rate (float): The annual interest rate as a decimal (e.g., 0.08 for 8%).\n        periods (int): The total number of monthly payments (loan term in months).\n\n    Returns:\n        monthly_payment (float): The calculated monthly installment payment amount.\n\n    Notes:\n        - This function assumes that the interest compounds monthly.\n        - The annual interest rate is divided by 12 to get the monthly interest rate.\n        - This function uses the formula for an annuity to calculate the payments.\n        - A ValueError will be raised if the parameters are not valid (e.g., negative values).\n    \"\"\"\n    if principal <= 0 or annual_interest_rate < 0 or periods <= 0:\n        raise ValueError(\"Principal, interest rate, and periods must be positive values.\")\n\n    monthly_interest_rate = annual_interest_rate / 12\n    \n    # Special handling for zero interest rate\n    if monthly_interest_rate == 0:\n        monthly_payment = principal / periods\n    else:\n        monthly_payment = (principal * monthly_interest_rate) / (1 - (1 + monthly_interest_rate) ** -periods)\n\n    return monthly_payment",
        "statistics": {
            "number_statistics": {
                "args_numbers": 3,
                "question_numbers": 0,
                "context_numbers": 4,
                "total_numbers": 4
            },
            "operator_statistics": {
                "operators": {
                    "+": 1,
                    "-": 2,
                    "*": 1,
                    "/": 3,
                    "%": 0,
                    "**": 1
                },
                "total_operators": 8
            },
            "code_statistics": {
                "lines": 7,
                "parentheses": 6
            }
        },
        "difficulty": 4.382026634673881,
        "context": "John is planning to purchase a new car and needs to take out a loan to finance it. The car costs $25,000, and John decides to make a down payment of $5,000. He plans to finance the remaining amount through a loan. The bank offers him a loan with an annual interest rate of 5% to be repaid over 4 years. John wants to know the monthly installment he will need to pay in order to fully repay the loan, assuming the interest is compounded monthly.",
        "question": "What will be the amount of John's monthly installment payment to the nearest cent?",
        "python_solution": "def solution():\n    # Define the variables and their values\n    car_cost = 25000\n    down_payment = 5000\n    annual_interest_rate = 0.05\n    loan_term_years = 4\n    \n    # Calculate the principal\n    principal = car_cost - down_payment\n    \n    # Convert loan_term_years to loan_term_months\n    periods = loan_term_years * 12\n    \n    # Calculate the monthly interest rate\n    monthly_interest_rate = annual_interest_rate / 12\n    \n    # Calculate the monthly installment payment using the formula for an annuity\n    if monthly_interest_rate == 0:\n        # Handle zero interest rate case, though not applicable here\n        monthly_payment = principal / periods\n    else:\n        monthly_payment = (principal * monthly_interest_rate) / (1 - (1 + monthly_interest_rate) ** -periods)\n    \n    # Return the calculated monthly installment payment, rounded to the nearest cent\n    return round(monthly_payment, 2)",
        "ground_truth": 460.59,
        "source": "FinanceReasoning-test-231",
        "question_id": "test-2047",
        "level": "hard",
        "output": [
            "To calculate the monthly installment of John's car loan, let us apply the financial formula for an amortized loan. Here's how we can break down the problem step by step:\n\n### Step-by-Step Thought Process:\n1. **Identify the Principal Amount (Loan Amount)**:\n   - The total cost of the car is $25,000.\n   - John makes a down payment of $5,000. This means the principal loan amount is:\n     \\[\n     \\text{Loan Amount (Principal)} = \\text{Car Price} - \\text{Down Payment} = 25,000 - 5,000 = 20,000\n     \\]\n\n2. **Interest Rate**:\n   - The bank offers an annual interest rate of 5%. We need to calculate its equivalent monthly interest rate:\n     \\[\n     \\text{Monthly Interest Rate} = \\frac{\\text{Annual Interest Rate}}{12} = \\frac{5\\%}{12} = 0.0041667\n     \\]\n\n3. **Loan Term**:\n   - The loan is for 4 years. Converting the term from years to months (since the payments are monthly):\n     \\[\n     \\text{Number of Payments} (\\text{Periods}) = \\text{Years} \\times 12 = 4 \\times 12 = 48\n     \\]\n\n4. **Constraints**:\n   - We assume that the interest is compounded monthly, as stated in the problem.\n   - All input values (loan amount, rate, periods) are positive. \n   - Results should adhere to 2 decimal places, \"to the nearest cent.\"\n\n5. **Amortized Loan Formula**:\n   - The formula to calculate monthly payment (\\(M\\)) is given as:\n     \\[\n     M = \\frac{P \\cdot r \\cdot (1 + r)^{n}}{(1 + r)^{n} - 1}\n     \\]\n     Where:\n     - \\(P\\): Principal amount (\\$20,000)\n     - \\(r\\): Monthly interest rate (0.0041667)\n     - \\(n\\): Number of monthly payments (48)\n\n6. **Implement the Solution in Python**:\n   - Using the formula, calculate the monthly payment \\(M\\).\n   - Ensure the result is rounded to 2 decimal places for the final output.\n\n### Python Program:\n```python\ndef solution():\n    # Define variables name and value\n    car_price = 25000    # Total cost of the car\n    down_payment = 5000  # Down payment made by John\n    loan_amount = car_price - down_payment  # Principal loan amount\n    \n    annual_interest_rate = 5  # Annual interest rate (in percentage)\n    loan_term_years = 4       # Loan term in years\n    \n    # Converting annual interest rate to monthly interest rate (as decimal)\n    monthly_rate = annual_interest_rate / 100 / 12\n    \n    # Converting loan term in years to loan term in months\n    total_months = loan_term_years * 12\n    \n    # Calculate monthly payment using the amortized loan formula\n    monthly_payment = (loan_amount * monthly_rate * (1 + monthly_rate) ** total_months) / \\\n                      ((1 + monthly_rate) ** total_months - 1)\n    \n    # Round result to the nearest cent (2 decimal places)\n    monthly_payment = round(monthly_payment, 2)\n    \n    # Return the monthly payment\n    return monthly_payment\n```\n\n### Notes:\n- We adhere to the constraint of 2 decimal precision for the solution.\n- The calculated monthly payment will be returned in the same unit (currency), ensuring consistency.\n\n"
        ],
        "retrieval_query": "What will be the amount of John's monthly installment payment to the nearest cent?",
        "useful_functions": [
            "def calculate_monthly_payment(principal: float, annual_interest_rate: float, years: int) -> float:\n    \"\"\"\n    Calculate the monthly payment required to fully repay a loan over a specified time period\n    using a fixed interest rate.\n\n    This calculation is applicable for fixed-rate loans including standard repayment plans for\n    student loans or mortgages.\n\n    Args:\n        principal (float): The initial amount of the loan.\n        annual_interest_rate (float): The annual interest rate as a percentage.\n        years (int): The total time in years over which the loan is to be repaid.\n\n    Returns:\n        monthly_payment (float): The amount to be paid monthly to repay the loan in full.\n\n    Notes:\n        - Applicability: Use for fixed-rate loans.\n        - Constraints: Interest rate should be greater than 0; years should be a positive integer.\n        - Considerations: This does not account for fees, taxes, or insurance that may also be part\n                          of monthly payments.\n    \"\"\"\n    if annual_interest_rate <= 0:\n        raise ValueError(\"Interest rate must be greater than zero.\")\n    if years <= 0:\n        raise ValueError(\"Years must be a positive integer.\")\n\n    monthly_interest_rate = annual_interest_rate / 100 / 12\n    number_of_payments = years * 12\n\n    monthly_payment = (principal * monthly_interest_rate) / \\\n                      (1 - (1 + monthly_interest_rate) ** -number_of_payments)\n\n    return monthly_payment",
            "def calculate_monthly_payment(loan_amount: float, annual_interest_rate: float, number_of_payments: int) -> float:\n    \"\"\"\n    Calculate the total monthly payment for an amortized loan.\n\n    This function computes the monthly payment required to fully amortize a loan\n    over a specified term, given the loan's amount, the annual interest rate,\n    and the number of payments. It uses the standard amortization formula for loans.\n\n    Args:\n        loan_amount (float): The total amount of the loan.\n        annual_interest_rate (float): The annual interest rate as a decimal (e.g., 0.03 for 3%).\n        number_of_payments (int): The total number of payments over the life of the loan.\n\n    Returns:\n        total_payment (float): The calculated total monthly payment.\n\n    Notes:\n        - Applicability: Use this function to calculate monthly payments for fixed-rate loans.\n        - Constraints: The annual_interest_rate should be divided by 12 for monthly rate calculation.\n        - Considerations: Ensure the interest rate and number of payments are greater than zero.\n    \"\"\"\n    monthly_rate = annual_interest_rate / 12\n    if monthly_rate == 0:\n        return loan_amount / number_of_payments\n    total_payment = loan_amount * (monthly_rate * (1 + monthly_rate) ** number_of_payments) / ((1 + monthly_rate) ** number_of_payments - 1)\n    \n    return total_payment",
            "def calculate_monthly_installment(principal: float, annual_interest_rate: float, periods: int) -> float:\n    \"\"\"\n    Calculate the monthly installment payment for an amortized loan.\n\n    This function computes the equal monthly payment required to pay off \n    an amortized loan over a certain number of periods with a fixed \n    annual interest rate.\n\n    Args:\n        principal (float): The total amount of the loan (or cost financed) in currency units.\n        annual_interest_rate (float): The annual interest rate as a decimal (e.g., 0.08 for 8%).\n        periods (int): The total number of monthly payments (loan term in months).\n\n    Returns:\n        monthly_payment (float): The calculated monthly installment payment amount.\n\n    Notes:\n        - This function assumes that the interest compounds monthly.\n        - The annual interest rate is divided by 12 to get the monthly interest rate.\n        - This function uses the formula for an annuity to calculate the payments.\n        - A ValueError will be raised if the parameters are not valid (e.g., negative values).\n    \"\"\"\n    if principal <= 0 or annual_interest_rate < 0 or periods <= 0:\n        raise ValueError(\"Principal, interest rate, and periods must be positive values.\")\n\n    monthly_interest_rate = annual_interest_rate / 12\n    \n    # Special handling for zero interest rate\n    if monthly_interest_rate == 0:\n        monthly_payment = principal / periods\n    else:\n        monthly_payment = (principal * monthly_interest_rate) / (1 - (1 + monthly_interest_rate) ** -periods)\n\n    return monthly_payment"
        ],
        "usage": {
            "completion_tokens": 771,
            "prompt_tokens": 1397,
            "total_tokens": 2168,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-579",
        "article_title": "Fixed-Rate Mortgage",
        "function": "def calculate_monthly_mortgage_payment(principal: float, annual_interest_rate: float, loan_term_years: int) -> float:\n    \"\"\"\n    Calculate the monthly mortgage payment for a fixed-rate mortgage.\n\n    This function computes the monthly payment amount for a fixed-rate mortgage \n    given the principal loan amount, annual interest rate, and loan term in years.\n\n    Args:\n        principal (float): The principal loan amount (the amount that you borrow).\n        annual_interest_rate (float): The annual interest rate as a decimal \n                                      (e.g., 0.05 for 5%).\n        loan_term_years (int): The number of years required to repay the loan.\n\n    Returns:\n        monthly_payment (float): The calculated monthly payment amount.\n\n    Notes:\n        - The calculation assumes consistent monthly payments for the entire loan term.\n        - The function assumes that interest compounds monthly.\n        - Payments can still include additional expenses like taxes and insurance, \n          which aren't considered here.\n        - Ensure the annual interest rate is converted into a monthly rate \n          (i.e., divide by 12) for calculations.\n    \"\"\"\n    monthly_interest_rate = annual_interest_rate / 12\n    number_of_payments = loan_term_years * 12\n    monthly_payment = (principal * monthly_interest_rate * (1 + monthly_interest_rate) ** number_of_payments) / ((1 + monthly_interest_rate) ** number_of_payments - 1)\n\n    return monthly_payment",
        "statistics": {
            "number_statistics": {
                "args_numbers": 3,
                "question_numbers": 0,
                "context_numbers": 5,
                "total_numbers": 5
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 1,
                    "*": 3,
                    "/": 2,
                    "%": 0,
                    "**": 2
                },
                "total_operators": 10
            },
            "code_statistics": {
                "lines": 4,
                "parentheses": 8
            }
        },
        "difficulty": 4.382026634673881,
        "context": "Sarah plans to purchase a house and needs to secure a fixed-rate mortgage to finance the purchase. The house is priced at $300,000, and Sarah will make a down payment of $60,000. The bank offers her a 30-year mortgage with an annual interest rate of 4.5%. She would like to know the monthly mortgage payment she will need to make to fully repay the loan over 30 years.",
        "question": "What will be Sarah's monthly mortgage payment? Answer to the nearest dollar.",
        "python_solution": "def solution():\n    # Define variables based on the problem statement\n    house_price = 300000\n    down_payment = 60000\n    principal = house_price - down_payment\n    annual_interest_rate = 0.045\n    loan_term_years = 30\n\n    # Calculate the monthly interest rate\n    monthly_interest_rate = annual_interest_rate / 12\n\n    # Calculate the number of total payments\n    number_of_payments = loan_term_years * 12\n\n    # Calculate the monthly mortgage payment using the formula\n    monthly_payment = (principal * monthly_interest_rate * (1 + monthly_interest_rate) ** number_of_payments) / ((1 + monthly_interest_rate) ** number_of_payments - 1)\n\n    # Return the final answer rounded to the nearest dollar\n    return round(monthly_payment)",
        "ground_truth": 1216,
        "source": "FinanceReasoning-test-234",
        "question_id": "test-2048",
        "level": "hard",
        "output": [
            "### Step-by-Step Analysis Using Emphasizing Constraints (EC)\n\n1. **Define the Problem**:\n   - Sarah plans to purchase a house worth $300,000 and will make a down payment of $60,000.\n   - She needs a mortgage for the remaining amount of $240,000 ($300,000 - $60,000).\n   - The mortgage is a fixed-rate loan with an annual interest rate of 4.5% over 30 years.\n   - The goal is to calculate Sarah's monthly mortgage payment, rounded to the nearest dollar.\n\n2. **Constraints**:\n   - The mortgage payment calculation uses a fixed annual interest rate.\n   - The payments are made monthly, and there are no additional costs (insurance, taxes, etc.).\n   - The compounded interest rate needs conversion from an annual percentage rate (4.5%) into a monthly rate.\n   - The total loan period consists of 30 years, calculated as 360 months (30 \u00d7 12).\n   - The solution must return the final payment rounded to the nearest dollar.\n\n3. **Calculation**:\n   - The monthly interest rate can be calculated by dividing the annual rate by 12.\n   - The total number of payments is calculated as the loan term (in years) multiplied by 12.\n   - The monthly payment \\( P \\) is calculated using the formula for fixed-rate loan payments:\n     \\[\n     P = \\frac{L \\cdot r \\cdot (1+r)^n}{(1+r)^n - 1}\n     \\]\n     Where:\n     - \\( L \\) = loan amount (principal)\n     - \\( r \\) = monthly interest rate (annual interest rate \u00f7 12)\n     - \\( n \\) = total number of payments (loan term \\(\\times 12\\))\n\n4. **Use the Provided Functionality**:\n   - The problem can be solved using the first function `calculate_monthly_payment`, which aligns with the specified formula and constraints.\n\n5. **Implementation**:\n   - Input the variables: principal = $240,000, annual interest rate = 4.5%, loan term = 30 years.\n   - Call the appropriate function to calculate the monthly payment.\n   - Round the result to the nearest dollar.\n\n### Python Program Implementation\n```python\ndef solution():\n    # Define variables\n    house_price = 300000\n    down_payment = 60000\n    loan_amount = house_price - down_payment  # Loan principal\n    annual_interest_rate = 4.5  # Annual interest rate in percentage\n    loan_term_years = 30  # Loan duration in years\n\n    # Monthly payment calculation using the provided formula\n    monthly_interest_rate = annual_interest_rate / 100 / 12\n    total_payments = loan_term_years * 12\n    monthly_payment = (loan_amount * monthly_interest_rate) / \\\n                      (1 - (1 + monthly_interest_rate) ** -total_payments)\n\n    # Round to the nearest dollar\n    answer = round(monthly_payment)\n    \n    # Return the answer\n    return answer\n```"
        ],
        "retrieval_query": "What will be Sarah's monthly mortgage payment? Answer to the nearest dollar.",
        "useful_functions": [
            "def calculate_monthly_payment(principal: float, annual_interest_rate: float, years: int) -> float:\n    \"\"\"\n    Calculate the monthly mortgage payment for a fixed-rate period.\n\n    This function computes the monthly payment for a mortgage based on the loan\n    principal, annual fixed interest rate, and duration of the loan in years.\n\n    Args:\n        principal (float): The loan amount (principal) in dollars.\n        annual_interest_rate (float): The annual fixed interest rate as a percentage (e.g., 3.5 for 3.5%).\n        years (int): The number of years for the fixed-rate period.\n\n    Returns:\n        monthly_payment (float): The monthly mortgage payment in dollars.\n\n    Notes:\n        - This function assumes a fixed interest rate for the specified period.\n        - The interest rate should be provided as a percentage, not a decimal.\n        - The result will be a positive float representing the payment amount.\n        - This calculation does not include taxes, insurance, or other fees.\n    \"\"\"\n    monthly_interest_rate = annual_interest_rate / 100 / 12\n    number_of_payments = years * 12\n    if annual_interest_rate == 0:\n        return principal / number_of_payments\n    monthly_payment = (principal * monthly_interest_rate) / \\\n                      (1 - (1 + monthly_interest_rate) ** -number_of_payments)\n    return monthly_payment\n\ndef calculate_adjusted_monthly_payment(principal: float, years: int, index_rate: float, margin: float) -> float:\n    \"\"\"\n    Calculate the adjusted monthly mortgage payment after the fixed-rate period.\n\n    This function computes the monthly payment for a mortgage based on the loan\n    principal, remaining years, indexed rate, and bank margin, after the initial\n    fixed rate period has ended.\n\n    Args:\n        principal (float): The remaining loan amount (principal) in dollars.\n        years (int): The remaining number of years on the loan.\n        index_rate (float): The current index rate as a percentage (e.g., 3 for 3%).\n        margin (float): The bank's margin as a percentage.\n\n    Returns:\n        adjusted_monthly_payment (float): The adjusted monthly payment in dollars.\n\n    Notes:\n        - The function assumes the interest rate is adjusted based on an index rate plus a margin.\n        - The rates should be provided as percentages, not decimals.\n        - This calculation does not account for potential rate caps.\n        - The function is meant for transition from fixed to adjustable rates.\n    \"\"\"\n    adjusted_annual_rate = index_rate + margin\n    monthly_interest_rate = adjusted_annual_rate / 100 / 12\n    number_of_payments = years * 12\n    if adjusted_annual_rate == 0:\n        return principal / number_of_payments\n    adjusted_monthly_payment = (principal * monthly_interest_rate) / \\\n                               (1 - (1 + monthly_interest_rate) ** -number_of_payments)\n    return adjusted_monthly_payment",
            "def calculate_monthly_mortgage_payment(loan_amount: float, annual_interest_rate: float, loan_term_years: int) -> float:\n    \"\"\"\n    Calculate the monthly mortgage payment for an amortizing loan.\n\n    This function computes the monthly payment amount for a fixed-rate mortgage,\n    given the loan amount, annual interest rate, and the term of the loan in years.\n    It uses the formula for calculating payments on an amortizing loan.\n\n    Args:\n        loan_amount (float): The total amount of the loan.\n        annual_interest_rate (float): The annual interest rate as a percentage (e.g., 5.8 for 5.8%).\n        loan_term_years (int): The loan term in years.\n\n    Returns:\n        monthly_payment (float): The calculated monthly payment amount.\n\n    Notes:\n        - Applicability: Suitable for fixed-rate mortgages where payments are made monthly.\n        - Constraints: The annual interest rate should be positive and expressed as a percentage.\n        - Considerations: This calculation assumes a fully amortizing loan with no additional fees or insurance.\n    \"\"\"\n    monthly_interest_rate = annual_interest_rate / 12 / 100\n    number_of_payments = loan_term_years * 12\n    \n    # Calculate the monthly payment using the formula for an amortizing loan\n    monthly_payment = loan_amount * (monthly_interest_rate * (1 + monthly_interest_rate) ** number_of_payments) / \\\n                      ((1 + monthly_interest_rate) ** number_of_payments - 1)\n\n    return monthly_payment",
            "def calculate_monthly_mortgage_payment(principal: float, annual_interest_rate: float, loan_term_years: int) -> float:\n    \"\"\"\n    Calculate the monthly mortgage payment for a fixed-rate mortgage.\n\n    This function computes the monthly payment amount for a fixed-rate mortgage \n    given the principal loan amount, annual interest rate, and loan term in years.\n\n    Args:\n        principal (float): The principal loan amount (the amount that you borrow).\n        annual_interest_rate (float): The annual interest rate as a decimal \n                                      (e.g., 0.05 for 5%).\n        loan_term_years (int): The number of years required to repay the loan.\n\n    Returns:\n        monthly_payment (float): The calculated monthly payment amount.\n\n    Notes:\n        - The calculation assumes consistent monthly payments for the entire loan term.\n        - The function assumes that interest compounds monthly.\n        - Payments can still include additional expenses like taxes and insurance, \n          which aren't considered here.\n        - Ensure the annual interest rate is converted into a monthly rate \n          (i.e., divide by 12) for calculations.\n    \"\"\"\n    monthly_interest_rate = annual_interest_rate / 12\n    number_of_payments = loan_term_years * 12\n    monthly_payment = (principal * monthly_interest_rate * (1 + monthly_interest_rate) ** number_of_payments) / ((1 + monthly_interest_rate) ** number_of_payments - 1)\n\n    return monthly_payment"
        ],
        "usage": {
            "completion_tokens": 641,
            "prompt_tokens": 1675,
            "total_tokens": 2316,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "According to previous studies, Smith has chosen the following independent variables to forecast the initial returns of an IPO: Underwriter rank = 1\u201310, with 10 being the highest rank; Pre-offer price adjustment (Represented as a decimal) = (Offer price \u2013 Initial filing price)/Initial filing price; Offer size ($ millions) = Shares sold x Offer price; Fraction retained (Represented as a decimal) = Portion of total company shares kept by insiders Smith's Regression Results Dependent Variable: IPO Initial Return (Represented in Decimal Form, i.e., 1% = 0.01) The forthcoming IPO has these characteristics: underwriter rank = 6; pre-offer price adjustment = 0.04; offer size = $40 million; fraction retained = 0.70. Based on Smith\u2019s regression analysis, what is the anticipated initial return for the forthcoming IPO? Answer to three decimal places.",
        "python_solution": "def solution():\n    underwriter_rank = 6\n    pre_offer_price_adjustment = 0.04\n    offer_size = 40 \n    fraction_retained = 0.70\n\n    IR = 0.0477 + (0.0150 * underwriter_rank) + (0.435 * pre_offer_price_adjustment) - (0.0009 * offer_size) + (0.05 * fraction_retained)\n    return IR",
        "ground_truth": 0.154,
        "topic": "Quantitative Analysis & Valuation",
        "statistics": {
            "number_statistics": {
                "args_numbers": 8,
                "question_numbers": 9,
                "context_numbers": 15,
                "total_numbers": 24
            },
            "operator_statistics": {
                "operators": {
                    "+": 3,
                    "-": 1,
                    "*": 4,
                    "/": 0,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 8
            },
            "code_statistics": {
                "lines": 6,
                "parentheses": 8
            }
        },
        "difficulty": 4.382026634673881,
        "source": "FinanceMath-validation-66",
        "context": "['| Variable           | Coefficient (bj) | Standard Error | t-Statistic |\\n|--------------------|------------------|----------------|-------------|\\n| Intercept          | 0.0477           | 0.0019         | 25.11       |\\n| Underwriter rank   | 0.0150           | 0.0049         | 3.06        |\\n| Pre-offer          | 0.4350           | 0.0202         | 21.53       |\\n| price adjustment   |                  |                |             |\\n| Offer size         | -0.0009          | 0.0011         | -0.82       |\\n| Fraction retained  | 0.0500           | 0.0260         | 1.92        |']",
        "question_id": "test-2049",
        "level": "hard",
        "output": [
            "To solve this problem, let's first break it down step-by-step:\n\n### Step 1: Understand the regression equation\nThe regression results provided give us the coefficients for the independent variables to forecast the dependent variable, which is the IPO initial return. The regression equation takes the following form:\n\n\\[\n\\text{IPO Initial Return} = \\beta_0 + \\beta_1 (\\text{Underwriter Rank}) + \\beta_2 (\\text{Pre-offer Price Adjustment}) + \\beta_3 (\\text{Offer Size}) + \\beta_4 (\\text{Fraction Retained})\n\\]\n\nHere:\n- \\( \\beta_0 \\) is the intercept,\n- \\( \\beta_1, \\beta_2, \\beta_3, \\beta_4 \\) are the coefficients provided for the respective variables.\n\n### Step 2: Assign values for each variable\nGiven values for the forthcoming IPO:\n- Underwriter rank = 6\n- Pre-offer price adjustment = 0.04\n- Offer size = $40 million\n- Fraction retained = 0.70\n\n### Step 3: Substitute regression coefficients\nFrom the table given:\n- Intercept (\\( \\beta_0 \\)) = 0.0477\n- \\( \\beta_1 \\) (Underwriter rank coefficient) = 0.0150\n- \\( \\beta_2 \\) (Pre-offer price adjustment coefficient) = 0.4350\n- \\( \\beta_3 \\) (Offer size coefficient) = -0.0009\n- \\( \\beta_4 \\) (Fraction retained coefficient) = 0.0500\n\n### Step 4: Formulate the equation for substitution\nSubstitute all values into the regression equation:\n\n\\[\n\\text{IPO Initial Return} = 0.0477 + 0.0150 \\cdot 6 + 0.4350 \\cdot 0.04 - 0.0009 \\cdot 40 + 0.0500 \\cdot 0.70\n\\]\n\nFinally, calculate the numerical result while adhering to the constraints of rounding the final answer to three decimal places.\n\n### Python Program:\n```python\ndef solution():\n    # Define variables name and value\n    intercept = 0.0477\n    underwriter_rank_coefficient = 0.0150\n    underwriter_rank = 6\n    pre_offer_adj_coefficient = 0.4350\n    pre_offer_adjustment = 0.04\n    offer_size_coefficient = -0.0009\n    offer_size = 40\n    fraction_retained_coefficient = 0.0500\n    fraction_retained = 0.70\n\n    # Apply the regression equation\n    ipo_initial_return = (\n        intercept +\n        underwriter_rank_coefficient * underwriter_rank +\n        pre_offer_adj_coefficient * pre_offer_adjustment +\n        offer_size_coefficient * offer_size +\n        fraction_retained_coefficient * fraction_retained\n    )\n    \n    # Round the result to three decimal places\n    return round(ipo_initial_return, 3)\n```"
        ],
        "retrieval_query": "According to previous studies, Smith has chosen the following independent variables to forecast the initial returns of an IPO: Underwriter rank = 1\u201310, with 10 being the highest rank; Pre-offer price adjustment (Represented as a decimal) = (Offer price \u2013 Initial filing price)/Initial filing price; Offer size ($ millions) = Shares sold x Offer price; Fraction retained (Represented as a decimal) = Portion of total company shares kept by insiders Smith's Regression Results Dependent Variable: IPO Initial Return (Represented in Decimal Form, i.e., 1% = 0.01) The forthcoming IPO has these characteristics: underwriter rank = 6; pre-offer price adjustment = 0.04; offer size = $40 million; fraction retained = 0.70. Based on Smith\u2019s regression analysis, what is the anticipated initial return for the forthcoming IPO? Answer to three decimal places.",
        "useful_functions": [],
        "usage": {
            "completion_tokens": 646,
            "prompt_tokens": 688,
            "total_tokens": 1334,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "The following spot and forward rates are provided: Present 1-year spot rate is 6%. The one-year forward rate one year from now is 8%. The one-year forward rate two years from now is 10%. What is the worth of a 3-year, 10% annually paid, bond with a par value of $1000? Answer to three decimal places.",
        "python_solution": "def solution():\n    bond_value = 100 / (1.06) + 100 / ((1.06) * (1.08)) + 1100 / ((1.06) * (1.08) * (1.1))\n    return bond_value",
        "ground_truth": 1055.206,
        "topic": "Asset Classes & Derivatives",
        "statistics": {
            "number_statistics": {
                "args_numbers": 4,
                "question_numbers": 6,
                "context_numbers": 0,
                "total_numbers": 6
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 0,
                    "*": 3,
                    "/": 3,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 8
            },
            "code_statistics": {
                "lines": 2,
                "parentheses": 16
            }
        },
        "difficulty": 4.382026634673881,
        "source": "FinanceMath-validation-134",
        "context": "[]",
        "question_id": "test-2050",
        "level": "hard",
        "output": [
            "To solve the problem, we need to calculate the value of a 3-year bond using spot and forward rates. The bond has a 10% annual coupon rate, a par (face) value of $1,000, and the given rates for discounting are:\n\n- 1-year spot rate: 6%\n- 1-year forward rate one year from now: 8%\n- 1-year forward rate two years from now: 10%\n\n### Steps to Solve:\n1. **Evaluate Constraints (Emphasizing Constraints - EC):**\n   - The first rate (spot rate) and subsequent forward rates are all annual and expressed as percentages. We'll convert them to decimals for calculation.\n   - We assume all cash flows occur annually.\n   - The discounting process must respect the order of rates:\n     - The first period is discounted using the spot rate.\n     - Future periods apply forward rates cumulatively.\n   - Ensure the final answer is rounded to three decimal places, as requested.\n\n2. **Define Bond Cash Flows:**\n   - The bond pays a 10% coupon each year based on the par value: \\( \\text{Coupon Payment} = 10\\% \\times 1000 = \\$100 \\).\n   - At the end of year 3, the bondholder receives the final coupon payment (\\$100) plus the par value (\\$1,000).\n\n3. **Discount the Cash Flows:**\n   - The bond cash flows are: \n     \\( [100, 100, 100 + 1000] = [100, 100, 1100] \\) \n   - Discount each cash flow to the present using the respective discount factor:\n     - Year 1: \\( \\frac{\\text{Cash Flow}}{(1 + \\text{spot rate})} \\)\n     - Year 2: \\( \\frac{\\text{Cash Flow}}{(1 + \\text{spot rate})(1 + \\text{forward rate 1})} \\)\n     - Year 3: \\( \\frac{\\text{Cash Flow}}{(1 + \\text{spot rate})(1 + \\text{forward rate 1})(1 + \\text{forward rate 2})} \\)\n\n4. **Accumulate the Present Value:**\n   - Sum the discounted values of bond cash flows to get the total present value.\n\n5. **Output Calculation:**\n   - Round the resultant value to three decimal places as per the problem constraints.\n\nGiven these steps, I will now construct the Python program to compute the bond's value.\n\n```python\ndef solution():\n    # Define variables\n    coupon_rate = 0.10  # 10% coupon rate\n    par_value = 1000    # Par value of the bond\n    years = 3           # Bond maturity in years\n    spot_rate = 0.06    # 1-year spot rate (6%)\n    forward_rates = [0.08, 0.10]  # Forward rates for years 2 and 3\n    \n    # Cash flows of the bond\n    cash_flows = [coupon_rate * par_value] * (years - 1) + [coupon_rate * par_value + par_value]\n    \n    # Discount each cash flow to the present\n    discount_factors = [1 / (1 + spot_rate)]  # Discount factor for year 1\n    cumulative_rate = 1 + spot_rate           # Initial cumulative rate for discounting\n\n    # Compute discount factors for years 2 and 3\n    for rate in forward_rates:\n        cumulative_rate *= (1 + rate)\n        discount_factors.append(1 / cumulative_rate)\n\n    # Calculate the bond value\n    bond_value = sum(cf * df for cf, df in zip(cash_flows, discount_factors))\n    \n    # Return the bond value rounded to three decimal places\n    return round(bond_value, 3)\n```"
        ],
        "retrieval_query": "The following spot and forward rates are provided: Present 1-year spot rate is 6%. The one-year forward rate one year from now is 8%. The one-year forward rate two years from now is 10%. What is the worth of a 3-year, 10% annually paid, bond with a par value of $1000? Answer to three decimal places.",
        "useful_functions": [
            "def calculate_bond_value(coupon_rate: float, par_value: float, years: int, spot_rate: float, forward_rates: list) -> float:\n    \"\"\"\n    Calculate the present value of a bond given its coupon rate, par value, and interest rates.\n\n    This function computes the present value of a bond based on its annual coupon payments,\n    its par value, and a series of interest rates (a spot rate for the first year and\n    forward rates for subsequent periods).\n\n    Args:\n        coupon_rate (float): The annual coupon rate of the bond as a decimal (e.g., 0.10 for 10%).\n        par_value (float): The par value of the bond.\n        years (int): The number of years until maturity.\n        spot_rate (float): The present year spot rate as a decimal (e.g., 0.06 for 6%).\n        forward_rates (list of float): A list of forward rates for each subsequent year,\n                                       starting from year 2 (e.g., [0.08, 0.10] for\n                                       forward rates in years 2 and 3).\n\n    Returns:\n        bond_value (float): The present value of the bond.\n\n    Notes:\n        - Applicability: This function is used to determine the bond's value using discounting \n                          based on the time value of money.\n        - Constraints: \n            1. The list of forward rates should contain one less element than the number of years.\n            2. All rates must be provided as decimals greater than -1.\n        - Considerations: Ensure rates are correct and consistent with the units (e.g., annual).\n    \"\"\"\n    if spot_rate <= -1 or any(rate <= -1 for rate in forward_rates):\n        raise ValueError(\"All rates must be greater than -1.\")\n\n    cash_flows = [coupon_rate * par_value] * (years - 1) + [coupon_rate * par_value + par_value]\n    discount_factors = [1 / (1 + spot_rate)]\n    cumulative_rate = 1 + spot_rate\n\n    for rate in forward_rates:\n        cumulative_rate *= (1 + rate)\n        discount_factors.append(1 / cumulative_rate)\n\n    bond_value = sum(cf * df for cf, df in zip(cash_flows, discount_factors))\n    \n    return round(bond_value, 3)"
        ],
        "usage": {
            "completion_tokens": 812,
            "prompt_tokens": 907,
            "total_tokens": 1719,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "What is the standard deviation of sales for an organization, given its probability distribution? Answer to three decimal places.",
        "python_solution": "def solution():\n    # defining probabilities and sales\n    prob = [0.05, 0.70, 0.25]\n    sales = [70, 40, 25]\n\n    # calculating expected sales\n    expected_sales = sum(p*s for p, s in zip(prob, sales))\n\n    # calculating variance\n    variance = sum(p*((s - expected_sales) ** 2) for p, s in zip(prob, sales))\n\n    # computing the standard deviation\n    std_dev = variance ** 0.5\n\n    return std_dev",
        "ground_truth": 9.808,
        "topic": "Quantitative Analysis & Valuation",
        "statistics": {
            "number_statistics": {
                "args_numbers": 5,
                "question_numbers": 0,
                "context_numbers": 6,
                "total_numbers": 6
            },
            "operator_statistics": {
                "operators": {
                    "+": 0,
                    "-": 1,
                    "*": 2,
                    "/": 0,
                    "%": 0,
                    "**": 2
                },
                "total_operators": 5
            },
            "code_statistics": {
                "lines": 10,
                "parentheses": 12
            }
        },
        "difficulty": 4.382026634673881,
        "source": "FinanceMath-validation-142",
        "context": "['| Probability | Sales ($ millions) |\\n|-------------|--------------------|\\n| 0.05        | 70                 |\\n| 0.70        | 40                 |\\n| 0.25        | 25                 |']",
        "question_id": "test-2051",
        "level": "hard",
        "output": [
            "Let's consider the problem step-by-step.\n\n### Step-by-Step Thought Process\n\n1. **Understanding the Data**:  \n   We are provided with a probability distribution for sales in $ million:\n   - Probability `0.05` for sales `70`.\n   - Probability `0.70` for sales `40`.\n   - Probability `0.25` for sales `25`.\n\n2. **Goal**:  \n   Compute the standard deviation (SD) of the sales values based on the given probability distribution. The result must be rounded to **three decimal places** (constraint).\n\n3. **Standard Deviation Formula** with probabilities:  \n   The formula for standard deviation with given probabilities is:\n   \\[\n   \\sigma = \\sqrt{\\sum{p_i (x_i - \\mu)^2}}\n   \\]\n   Here:\n   - \\( p_i \\) = probability of each sales value.\n   - \\( x_i \\) = corresponding sales value.\n   - \\( \\mu \\) = expected value of sales (mean).\n\n4. **Mean (Expected Value)** Formula:  \n   The expected value \\(\\mu\\) is computed as:\n   \\[\n   \\mu = \\sum{p_i \\cdot x_i}\n   \\]\n\n5. **Calculation Process**:\n   - First, compute \\(\\mu\\) (expected value).\n   - Then, calculate the variance \\(\\sigma^2 = \\sum{p_i (x_i - \\mu)^2}\\).\n   - Finally, compute the standard deviation as \\(\\sigma = \\sqrt{\\sigma^2}\\).\n\n6. **Adhering to Constraints**:\n   - The output must be accurate to three decimal places.\n   - Perform the computations systematically to avoid errors.\n\n---\n\n### Python Implementation\nNow, we'll implement the solution using the explained process:\n\n```python\ndef solution():\n    # Define the given data\n    probabilities = [0.05, 0.70, 0.25]\n    sales = [70, 40, 25]\n    \n    # Step 1: Calculate the mean (expected value)\n    mean = sum(p * x for p, x in zip(probabilities, sales))\n    \n    # Step 2: Calculate variance\n    variance = sum(p * ((x - mean) ** 2) for p, x in zip(probabilities, sales))\n    \n    # Step 3: Calculate standard deviation\n    std_deviation = variance ** 0.5\n    \n    # Return the result rounded to three decimal places\n    return round(std_deviation, 3)\n```"
        ],
        "retrieval_query": "What is the standard deviation of sales for an organization, given its probability distribution? Answer to three decimal places.",
        "useful_functions": [],
        "usage": {
            "completion_tokens": 530,
            "prompt_tokens": 401,
            "total_tokens": 931,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-12",
        "article_title": "Years Certain Annuity",
        "function": "def calculate_annuity_payout(principal: float, interest_rate: float, periods: int) -> float:\n    \"\"\"\n    Calculate the periodic annuity payout for a years certain annuity.\n\n    This function computes the regular payment amount for a fixed period annuity\n    given the initial principal, the periodic interest rate, and the number of periods.\n\n    Args:\n        principal (float): The initial amount of money invested in the annuity.\n        interest_rate (float): The interest rate per period as a decimal (e.g., 0.05 for 5%).\n        periods (int): The number of periods (e.g., months or years) over which payments are made.\n\n    Returns:\n        payout (float): The amount of each periodic payment.\n\n    Notes:\n        - Applicability: This function is applicable for fixed period or years certain annuities.\n        - Constraints: Interest rate must be greater than -1, and periods must be a positive integer.\n        - Considerations: Payments are assumed to be made at the end of each period.\n    \"\"\"\n    if interest_rate <= -1:\n        raise ValueError(\"Interest rate must be greater than -1.\")\n    if periods <= 0:\n        raise ValueError(\"Periods must be a positive integer.\")\n    \n    if interest_rate == 0:\n        payout = principal / periods\n    else:\n        payout = principal * (interest_rate * (1 + interest_rate) ** periods) / ((1 + interest_rate) ** periods - 1)\n    \n    return payout",
        "statistics": {
            "number_statistics": {
                "args_numbers": 3,
                "question_numbers": 0,
                "context_numbers": 4,
                "total_numbers": 4
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 1,
                    "*": 2,
                    "/": 2,
                    "%": 0,
                    "**": 2
                },
                "total_operators": 9
            },
            "code_statistics": {
                "lines": 5,
                "parentheses": 8
            }
        },
        "difficulty": 4.394449154672439,
        "context": "A retiree invests a lump sum of $200,000 into a fixed-term annuity that guarantees regular monthly payouts for a period of 20 years. The annuity offers a monthly interest rate of 0.33% (or 0.0033 as a decimal). The retiree would like to know the amount they will receive as a monthly payout from this annuity.",
        "question": "What is the monthly payout amount from the annuity? Answer to the nearest dollar.",
        "python_solution": "def solution():\n    # Define variables based on the given problem context\n    principal = 200000  # The lump sum invested in the annuity\n    interest_rate = 0.0033  # Monthly interest rate as a decimal\n    periods = 20 * 12  # Total number of periods (months)\n\n    # Implement the annuity payout calculation\n    if interest_rate == 0:\n        monthly_payout = principal / periods\n    else:\n        monthly_payout = principal * (interest_rate * (1 + interest_rate) ** periods) / ((1 + interest_rate) ** periods - 1)\n\n    # Round the payout to the nearest dollar and return\n    return round(monthly_payout)",
        "ground_truth": 1208,
        "source": "FinanceReasoning-test-225",
        "question_id": "test-2052",
        "level": "hard",
        "output": [
            "To solve this problem, we are given the following information:\n- The lump sum (principal) invested in the annuity: $200,000.\n- The monthly interest rate provided as a decimal: 0.0033 (or 0.33%).\n- The term of the annuity in years: 20 years.\n- The monthly payouts are to be calculated.\n\n### Step-by-step Reasoning\n\n### Step 1: Understand the constraints\n1. **Interest Rate Constraint**: The monthly interest rate given as 0.0033 must be used. It must also be non-negative and less than 1.\n2. **Number of Periods Constraint**: We are told the annuity will pay out for 20 years. Since the payouts are monthly, the total number of periods is \\( 20 \\times 12 = 240 \\).\n3. **Calculation Formula**:\n   The formula to calculate the monthly payout (PMT) for an annuity with fixed-term payments is:\n   \\[\n   PMT = P \\cdot \\frac{i \\cdot (1 + i)^n}{(1 + i)^n - 1}\n   \\]\n   where:\n   - \\( P \\): Principal or lump sum ($200,000 in this case)\n   - \\( i \\): Monthly interest rate (0.0033)\n   - \\( n \\): Total number of payments (240)\n   \n4. **Desired Output**: The monthly payout must be rounded to the nearest dollar.\n\nThe information adheres to the domain constraints. All parameters such as principal, interest rate, and periods are non-negative. The interest rate is given as a decimal for computation.\n\n### Step 2: Implement the formula in Python\nWe will write a Python program to compute the monthly payout using the provided data and formula. Here's the implementation:\n\n```python\ndef solution():\n    # Define variables name and value\n    principal = 200000  # Initial lump sum investment\n    monthly_interest_rate = 0.0033  # Monthly interest rate as a decimal\n    total_periods = 20 * 12  # Total number of periods (20 years * 12 months)\n    \n    # Use the annuity formula to calculate the monthly payout\n    monthly_payout = (principal * monthly_interest_rate * (1 + monthly_interest_rate) ** total_periods) / \\\n                     ((1 + monthly_interest_rate) ** total_periods - 1)\n    \n    # Round the answer to the nearest dollar\n    answer = round(monthly_payout)\n    \n    # Return the answer\n    return answer\n```"
        ],
        "retrieval_query": "What is the monthly payout amount from the annuity? Answer to the nearest dollar.",
        "useful_functions": [
            "def calculate_annuity_payout(principal: float, interest_rate: float, periods: int) -> float:\n    \"\"\"\n    Calculate the periodic annuity payout for a years certain annuity.\n\n    This function computes the regular payment amount for a fixed period annuity\n    given the initial principal, the periodic interest rate, and the number of periods.\n\n    Args:\n        principal (float): The initial amount of money invested in the annuity.\n        interest_rate (float): The interest rate per period as a decimal (e.g., 0.05 for 5%).\n        periods (int): The number of periods (e.g., months or years) over which payments are made.\n\n    Returns:\n        payout (float): The amount of each periodic payment.\n\n    Notes:\n        - Applicability: This function is applicable for fixed period or years certain annuities.\n        - Constraints: Interest rate must be greater than -1, and periods must be a positive integer.\n        - Considerations: Payments are assumed to be made at the end of each period.\n    \"\"\"\n    if interest_rate <= -1:\n        raise ValueError(\"Interest rate must be greater than -1.\")\n    if periods <= 0:\n        raise ValueError(\"Periods must be a positive integer.\")\n    \n    if interest_rate == 0:\n        payout = principal / periods\n    else:\n        payout = principal * (interest_rate * (1 + interest_rate) ** periods) / ((1 + interest_rate) ** periods - 1)\n    \n    return payout",
            "def calculate_annuity_monthly_payment(premium: float, annual_interest_rate: float, years: int) -> float:\n    \"\"\"\n    Calculate the monthly payment for an immediate annuity.\n\n    This function computes the monthly payment for an income annuity given an upfront\n    lump sum payment (premium), an annual interest rate, and the number of years for \n    which the payments will be made.\n\n    Args:\n        premium (float): The initial lump sum payment for the annuity.\n        annual_interest_rate (float): The annual interest rate in decimal form (e.g., 0.05 for 5%).\n        years (int): The number of years the annuity is expected to pay out.\n\n    Returns:\n        monthly_payment (float): The calculated monthly payment from the annuity.\n\n    Notes:\n        - Applicability: This function is applicable for immediate annuities where payments\n          start promptly after the premium is paid.\n        - Constraints: The annual interest rate should be non-negative. The number of years\n          must be positive.\n        - Considerations: This function assumes a constant annual interest rate and does not\n          account for inflation or taxes, which can affect the real value of payments over time.\n    \"\"\"\n    if annual_interest_rate < 0:\n        raise ValueError(\"Annual interest rate must be non-negative.\")\n    if years <= 0:\n        raise ValueError(\"Number of years must be positive.\")\n\n    monthly_interest_rate = annual_interest_rate / 12\n    total_periods = years * 12\n    if monthly_interest_rate == 0:\n        monthly_payment = premium / total_periods\n    else:\n        monthly_payment = (premium * monthly_interest_rate) / (1 - (1 + monthly_interest_rate) ** -total_periods)\n\n    return monthly_payment"
        ],
        "usage": {
            "completion_tokens": 536,
            "prompt_tokens": 1112,
            "total_tokens": 1648,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-616",
        "article_title": "Forward Rate",
        "function": "def calculate_forward_rate(spot_rate_short: float, spot_rate_long: float, period_short: int, period_long: int) -> float:\n    \"\"\"\n    Calculate the forward rate between two periods given the spot rates for those periods.\n\n    This function computes the forward rate based on the spot rates of two different periods.\n    It is used in financial contexts to derive the future interest rate for investments.\n\n    Args:\n        spot_rate_short (float): The spot rate for the shorter period (e.g., annual interest rate).\n        spot_rate_long (float): The spot rate for the longer period.\n        period_short (int): The number of years for the shorter period.\n        period_long (int): The number of years for the longer period.\n\n    Returns:\n        forward_rate (float): The forward rate, representing the future interest rate implied by the \n                              spot rates.\n\n    Notes:\n        - Applicability: Useful in bond markets, forex markets, and other financial analyses involving \n          future interest rate predictions.\n        - Constraints: The period_short should be less than period_long.\n        - Considerations: Ensure that rates are expressed in decimal form (e.g., 3% as 0.03), and the \n          periods are denominated in the same time units.\n    \"\"\"\n    if period_short >= period_long:\n        raise ValueError(\"The short period must be less than the long period.\")\n\n    forward_rate = (((1 + spot_rate_long) ** period_long) / ((1 + spot_rate_short) ** period_short)) ** (1 / (period_long - period_short)) - 1\n    return forward_rate",
        "statistics": {
            "number_statistics": {
                "args_numbers": 4,
                "question_numbers": 1,
                "context_numbers": 5,
                "total_numbers": 6
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 2,
                    "*": 0,
                    "/": 2,
                    "%": 0,
                    "**": 3
                },
                "total_operators": 9
            },
            "code_statistics": {
                "lines": 2,
                "parentheses": 14
            }
        },
        "difficulty": 4.394449154672439,
        "context": "A pension fund manager is evaluating the yields on government bonds to predict future interest rates. The fund has data on a 2-year bond with a yield (spot rate) of 2.5% and a 5-year bond with a yield of 3.5%. Using these spot rates, the manager wants to calculate the expected annualized forward rate for the 3-year period starting two years from now, to make informed investment decisions.",
        "question": "What is the expected annualized forward rate for the 3-year period starting two years from now, given the provided spot rates? Answer as a percentage to two decimal places.",
        "python_solution": "def solution():\n    # Define the spot rates as decimal values\n    spot_rate_short = 0.025  # 2.5% for the 2-year period\n    spot_rate_long = 0.035   # 3.5% for the 5-year period\n\n    # Define the periods in years\n    period_short = 2\n    period_long = 5\n\n    # Perform the forward rate calculation using the given formula\n    try:\n        forward_rate = (((1 + spot_rate_long) ** period_long) / ((1 + spot_rate_short) ** period_short)) ** (1 / (period_long - period_short)) - 1\n    except ZeroDivisionError:\n        return \"Invalid periods provided, 'period_long' must be greater than 'period_short'\"\n\n    # Convert the forward rate to percentage format and round to two decimal places\n    forward_rate_percentage = forward_rate * 100\n    return round(forward_rate_percentage, 2)\n\nprint(solution())  # This line is for testing purpose, should output: 4.02",
        "ground_truth": 4.17,
        "source": "FinanceReasoning-test-232",
        "question_id": "test-2053",
        "level": "hard",
        "output": [
            "To solve this problem, I will use the provided `calculate_implied_forward_rate_after_years` function to calculate the expected annualized 3-year forward rate starting 2 years from now. Let's break this problem into steps:\n\n1. **Define the Spot Rates and Periods**:\n   - The given 2-year spot rate (short term) is 2.5% (0.025 in decimal).\n   - The given 5-year spot rate (long term) is 3.5% (0.035 in decimal).\n   - The shorter period (years_short) is 2 years.\n   - The longer period (years_long) is 5 years.\n\n2. **Constraints and Conversion**:\n   - Spot rates should be in decimal form for the calculation (e.g., 2.5% as 0.025).\n   - `years_long` (5) must be greater than `years_short` (2), and this condition is satisfied.\n\n3. **Use the Provided Formula**:\n   - Compute the future value of both long-term and short-term spot rates.\n   - Calculate the implied forward rate using the formula:\n     \\[\n     \\text{implied\\_forward\\_rate} = \\left(\\frac{(1 + \\text{spot\\_rate\\_long})^{\\text{years\\_long}}}{(1 + \\text{spot\\_rate\\_short})^{\\text{years\\_short}}}\\right)^{\\frac{1}{(\\text{years\\_long} - \\text{years\\_short})}} - 1\n     \\]\n\n4. **Output as Percentage to Two Decimal Places**:\n   - Multiply by 100 to convert it to a percentage.\n   - Round the answer to two decimal places as requested.\n\nNow let's write the Python program:\n\n```python\ndef solution():\n    def calculate_implied_forward_rate_after_years(spot_rate_short: float, spot_rate_long: float, years_short: int, years_long: int) -> float:\n        if years_long <= years_short:\n            raise ValueError(\"years_long must be greater than years_short.\")\n        \n        rate_long_term = (1 + spot_rate_long) ** years_long\n        rate_short_term = (1 + spot_rate_short) ** years_short\n        \n        implied_forward_rate = (rate_long_term / rate_short_term) ** (1 / (years_long - years_short)) - 1\n        \n        return implied_forward_rate * 100  # Convert to percentage\n    \n    # Define variables\n    spot_rate_short = 0.025  # 2.5% spot rate for 2 years in decimal\n    spot_rate_long = 0.035  # 3.5% spot rate for 5 years in decimal\n    years_short = 2         # Shorter period in years\n    years_long = 5          # Longer period in years\n    \n    # Calculate the implied forward rate\n    forward_rate = calculate_implied_forward_rate_after_years(spot_rate_short, spot_rate_long, years_short, years_long)\n    \n    # Round the result to two decimal places\n    answer = round(forward_rate, 2)\n    \n    return answer\n```"
        ],
        "retrieval_query": "What is the expected annualized forward rate for the 3-year period starting two years from now, given the provided spot rates? Answer as a percentage to two decimal places.",
        "useful_functions": [
            "def calculate_implied_forward_rate_after_years(spot_rate_short: float, spot_rate_long: float, years_short: int, years_long: int) -> float:\n    \"\"\"\n    Calculate the implied forward rate for an investment after a specified number of years.\n\n    This function computes the implied forward rate that will apply after a certain\n    number of years, based on given short-term and long-term spot rates. This is useful\n    for financial analysis when estimating future interest rates in the context of bonds \n    or loan agreements.\n\n    Args:\n        spot_rate_short (float): The spot rate for the shorter period in decimal form (e.g., 1.65% as 0.0165).\n        spot_rate_long (float): The spot rate for the longer period in decimal form (e.g., 2.15% as 0.0215).\n        years_short (int): The number of years for the short-term spot rate.\n        years_long (int): The number of years for the long-term spot rate.\n\n    Returns:\n        implied_forward_rate (float): The calculated implied forward rate as a percentage.\n\n    Notes:\n        - Applicability: This function applies to scenarios where forward interest rates\n          need to be derived from spot rates.\n        - Constraints: `years_long` must be greater than `years_short`.\n        - Considerations: Ensure spot rates are in decimal form and represent annual rates.\n    \"\"\"\n    if years_long <= years_short:\n        raise ValueError(\"years_long must be greater than years_short.\")\n\n    rate_long_term = (1 + spot_rate_long) ** years_long\n    rate_short_term = (1 + spot_rate_short) ** years_short\n\n    implied_forward_rate = (rate_long_term / rate_short_term) ** (1 / (years_long - years_short)) - 1\n\n    return implied_forward_rate * 100"
        ],
        "usage": {
            "completion_tokens": 668,
            "prompt_tokens": 843,
            "total_tokens": 1511,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-581",
        "article_title": "Fixed-Rate Payment",
        "function": "def calculate_fixed_rate_payment(principal: float, annual_interest_rate: float, years: int) -> float:\n    \"\"\"\n    Calculate the monthly payment for a fixed-rate loan.\n\n    This function computes the fixed monthly payment required to fully amortize\n    a loan over a specified number of years, given the loan principal and an\n    annual interest rate.\n\n    Args:\n        principal (float): The initial amount of the loan.\n        annual_interest_rate (float): The annual interest rate as a decimal (e.g., 0.045 for 4.5%).\n        years (int): The term of the loan in years.\n\n    Returns:\n        monthly_payment (float): The monthly payment required to fully amortize\n                                 the loan over the specified term.\n\n    Notes:\n        - The monthly interest rate is calculated from the annual interest rate.\n        - The function uses the annuity formula for calculating the payment.\n        - Applicability: This function is applicable for fixed-rate loans.\n        - Constraints: The annual interest rate must be non-negative.\n        - Considerations: Ensure the principal and years are positive values.\n    \"\"\"\n    if annual_interest_rate < 0:\n        raise ValueError(\"Annual interest rate must be non-negative.\")\n    \n    monthly_interest_rate = annual_interest_rate / 12\n    number_of_payments = years * 12\n    \n    if monthly_interest_rate == 0:  # Special case for zero interest\n        return principal / number_of_payments\n    \n    monthly_payment = (principal * monthly_interest_rate) / (1 - (1 + monthly_interest_rate) ** -number_of_payments)\n    \n    return monthly_payment",
        "statistics": {
            "number_statistics": {
                "args_numbers": 3,
                "question_numbers": 3,
                "context_numbers": 3,
                "total_numbers": 6
            },
            "operator_statistics": {
                "operators": {
                    "+": 1,
                    "-": 2,
                    "*": 2,
                    "/": 3,
                    "%": 0,
                    "**": 1
                },
                "total_operators": 9
            },
            "code_statistics": {
                "lines": 6,
                "parentheses": 6
            }
        },
        "difficulty": 4.394449154672439,
        "context": "John is considering taking out a fixed-rate loan to purchase a car. The loan amount he needs is $25,000. The bank offers him a fixed annual interest rate of 5% with a loan term of 5 years. John wants to know how much he will need to pay monthly to fully pay off the loan by the end of the term.",
        "question": "What is the fixed monthly payment John needs to make to fully amortize the $25,000 loan over 5 years at an annual interest rate of 5%? Answer to the nearest cent.",
        "python_solution": "def solution():\n    # Define the given loan details\n    principal = 25000  # Loan amount in dollars\n    annual_interest_rate = 0.05  # Annual interest rate as a decimal\n    years = 5  # Loan term in years\n\n    # Calculate the monthly interest rate and the total number of payments\n    monthly_interest_rate = annual_interest_rate / 12\n    number_of_payments = years * 12\n\n    # Check special case for zero interest rate\n    if monthly_interest_rate == 0:\n        monthly_payment = principal / number_of_payments\n    else:\n        # Calculate the monthly payment using the annuity formula\n        monthly_payment = (principal * monthly_interest_rate) / (1 - (1 + monthly_interest_rate) ** -number_of_payments)\n\n    # Return the monthly payment rounded to the nearest cent\n    return round(monthly_payment, 2)\n\n# Output the solution\nsolution()",
        "ground_truth": 471.78,
        "source": "FinanceReasoning-test-233",
        "question_id": "test-2054",
        "level": "hard",
        "output": [
            "### Step-by-Step Reasoning\n\n#### 1. **Understanding the Problem**\n- John wants to calculate the **fixed monthly payment** to amortize (completely pay off) a loan of $25,000 over 5 years, with an annual fixed interest rate of 5%.\n- The mathematical formula for fixed monthly payment of an amortized loan is:\n  \n  \\[\n  M = P \\cdot \\frac{r \\cdot (1 + r)^n}{(1 + r)^n - 1}\n  \\]\n  where:\n  - \\(M\\) = Monthly payment\n  - \\(P\\) = Loan amount (Principal): $25,000\n  - \\(r\\) = Monthly interest rate (Annual interest rate \\( \\div 12\\)): \\(5\\% / 12\\)\n  - \\(n\\) = Number of monthly payments (Loan term in years \\( \\cdot 12\\)): \\(5 \\cdot 12 = 60\\) months\n\n#### 2. **Constraints and Precision (EC)**\n- The answer should be rounded to the nearest cent (2 decimal places).\n- We must apply the formula for calculating the monthly payment accurately without rounding intermediate results until the final step.\n\n#### 3. **Plan to Solve**\n1. Define the loan amount (\\(P = 25000\\)).\n2. Calculate the monthly interest rate (\\(r = \\frac{5\\%}{12} = 0.00416667\\)).\n3. Calculate the number of payments (\\(n = 60\\)).\n4. Use the formula for the monthly payment \\(M\\).\n5. Round and return the result to two decimal places.\n\n#### 4. **Python Implementation**\nThe following Python code calculates the fixed monthly payment.\n\n```python\ndef solution():\n    # Define variables name and value\n    loan_amount = 25000  # Principal\n    annual_interest_rate = 0.05  # 5% annual interest rate\n    loan_term_years = 5  # Loan term in years\n    \n    # Calculate monthly interest rate and number of payments\n    monthly_interest_rate = annual_interest_rate / 12  # Monthly rate\n    number_of_payments = loan_term_years * 12  # Total number of payments\n    \n    # Calculate fixed monthly payment using the amortization formula\n    monthly_payment = loan_amount * (monthly_interest_rate * (1 + monthly_interest_rate) ** number_of_payments) / (\n        (1 + monthly_interest_rate) ** number_of_payments - 1)\n    \n    # Round to the nearest cent\n    answer = round(monthly_payment, 2)\n    \n    # Return the answer\n    return answer\n```"
        ],
        "retrieval_query": "What is the fixed monthly payment John needs to make to fully amortize the $25,000 loan over 5 years at an annual interest rate of 5%? Answer to the nearest cent.",
        "useful_functions": [
            "def calculate_monthly_payment(loan_amount: float, annual_interest_rate: float, number_of_payments: int) -> float:\n    \"\"\"\n    Calculate the total monthly payment for an amortized loan.\n\n    This function computes the monthly payment required to fully amortize a loan\n    over a specified term, given the loan's amount, the annual interest rate,\n    and the number of payments. It uses the standard amortization formula for loans.\n\n    Args:\n        loan_amount (float): The total amount of the loan.\n        annual_interest_rate (float): The annual interest rate as a decimal (e.g., 0.03 for 3%).\n        number_of_payments (int): The total number of payments over the life of the loan.\n\n    Returns:\n        total_payment (float): The calculated total monthly payment.\n\n    Notes:\n        - Applicability: Use this function to calculate monthly payments for fixed-rate loans.\n        - Constraints: The annual_interest_rate should be divided by 12 for monthly rate calculation.\n        - Considerations: Ensure the interest rate and number of payments are greater than zero.\n    \"\"\"\n    monthly_rate = annual_interest_rate / 12\n    if monthly_rate == 0:\n        return loan_amount / number_of_payments\n    total_payment = loan_amount * (monthly_rate * (1 + monthly_rate) ** number_of_payments) / ((1 + monthly_rate) ** number_of_payments - 1)\n    \n    return total_payment",
            "def calculate_monthly_payment(loan_amount: float, annual_interest_rate: float, loan_term_years: int) -> float:\n    \"\"\"\n    Calculate the monthly payment for an amortizing loan.\n\n    This function computes the total monthly payment required to repay a loan amount\n    over a specified term with a given annual interest rate. It is commonly used in\n    creating amortization schedules for loans such as mortgages or car loans.\n\n    Args:\n        loan_amount (float): The principal amount of the loan.\n        annual_interest_rate (float): The annual interest rate as a decimal (e.g., 0.03 for 3%).\n        loan_term_years (int): The term of the loan in years.\n\n    Returns:\n        monthly_payment (float): The monthly payment amount.\n\n    Notes:\n        - The annual interest rate is divided by 12 to obtain the monthly rate.\n        - The loan term in years is multiplied by 12 to obtain the total number of payments.\n        - Not applicable for non-amortizing or interest-only loans.\n    \"\"\"\n    monthly_interest_rate = annual_interest_rate / 12\n    number_of_payments = loan_term_years * 12\n    monthly_payment = loan_amount * (monthly_interest_rate * (1 + monthly_interest_rate) ** number_of_payments) / (\n        (1 + monthly_interest_rate) ** number_of_payments - 1)\n    \n    return monthly_payment\n\ndef calculate_amortization_schedule(loan_amount: float, annual_interest_rate: float, loan_term_years: int) -> list:\n    \"\"\"\n    Generate an amortization schedule showing the breakdown of payments over the loan term.\n\n    This function returns a list of dictionaries where each dictionary represents a payment period,\n    detailing the beginning balance, total payment, interest payment, principal payment, and ending balance.\n\n    Args:\n        loan_amount (float): The principal amount of the loan.\n        annual_interest_rate (float): The annual interest rate as a decimal (e.g., 0.03 for 3%).\n        loan_term_years (int): The term of the loan in years.\n\n    Returns:\n        schedule (list): A list of dictionaries, each containing:\n                         - 'Period': The period number.\n                         - 'Beginning Balance': Loan balance at the start of the period.\n                         - 'Payment': The total payment for the period.\n                         - 'Interest': The interest component of the payment.\n                         - 'Principal': The principal component of the payment.\n                         - 'Ending Balance': Loan balance at the end of the period.\n\n    Notes:\n        - Assumes a fixed interest and principal repayment schedule.\n        - Intends to provide a complete loan amortization overview.\n        - Suitable for traditional fully-amortizing loans.\n    \"\"\"\n    monthly_payment = calculate_monthly_payment(loan_amount, annual_interest_rate, loan_term_years)\n    monthly_interest_rate = annual_interest_rate / 12\n    number_of_payments = loan_term_years * 12\n\n    schedule = []\n    beginning_balance = loan_amount\n\n    for period in range(1, number_of_payments + 1):\n        interest_payment = beginning_balance * monthly_interest_rate\n        principal_payment = monthly_payment - interest_payment\n        ending_balance = beginning_balance - principal_payment\n\n        schedule.append({\n            'Period': period,\n            'Beginning Balance': beginning_balance,\n            'Payment': monthly_payment,\n            'Interest': interest_payment,\n            'Principal': principal_payment,\n            'Ending Balance': ending_balance\n        })\n\n        beginning_balance = ending_balance\n\n    return schedule",
            "def calculate_monthly_payment(loan_amount: float, annual_interest_rate: float, loan_term_years: int) -> float:\n    \"\"\"\n    Calculate the monthly payment for a loan based on the loan amount, annual interest rate, and term.\n\n    This function estimates the fixed monthly payment required to pay off a loan\n    under specified conditions using the formula for an amortizing loan.\n\n    Args:\n        loan_amount (float): The total amount of the loan.\n        annual_interest_rate (float): The annual interest rate as a decimal (e.g., 0.05 for 5%).\n        loan_term_years (int): The total number of years over which the loan will be repaid.\n\n    Returns:\n        monthly_payment (float): The calculated fixed monthly payment for the loan.\n\n    Notes:\n        - Applicability: Useful for estimating monthly payments in financial planning.\n        - Constraints: The annual interest rate should be greater than 0.\n        - Considerations: Payments do not include additional fees like taxes or insurance.\n    \"\"\"\n    monthly_interest_rate = annual_interest_rate / 12\n    number_of_payments = loan_term_years * 12\n    \n    if annual_interest_rate == 0:\n        monthly_payment = loan_amount / number_of_payments\n    else:\n        monthly_payment = (loan_amount * monthly_interest_rate) / (1 - (1 + monthly_interest_rate) ** -number_of_payments)\n    \n    return monthly_payment"
        ],
        "usage": {
            "completion_tokens": 562,
            "prompt_tokens": 1775,
            "total_tokens": 2337,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-391",
        "article_title": "Incurred But Not Reported (IBNR)",
        "function": "def calculate_ibnr_reserve(claim_amounts: list, claim_paid_dates: list, claim_settlement_expenses: list, reinsurance_paid_claims: list, reinsurance_paid_expenses: list, discount_rate: float) -> float:\n    \"\"\"\n    Calculate the Incurred But Not Reported (IBNR) reserve for insurance claims.\n\n    This function estimates the reserve amount needed for claims that have been incurred\n    but not yet reported (IBNR) by analyzing claim amounts, settlement expenses, and reinsurance contributions.\n\n    Args:\n        claim_amounts (list): A list of claim amounts incurred but not reported.\n        claim_paid_dates (list): Dates when claims were paid (used for time value calculation).\n        claim_settlement_expenses (list): Expenses related to settlement of claims.\n        reinsurance_paid_claims (list): Amounts paid by reinsurance for claims.\n        reinsurance_paid_expenses (list): Expenses covered by reinsurance.\n        discount_rate (float): Discount rate for present value estimation of reserve; must be greater than -1.\n\n    Returns:\n        ibnr_reserve (float): The estimated reserve for IBNR claims.\n\n    Notes:\n        - Applicability: Applicable for insurers calculating reserves for unreported claims.\n        - Constraints: Discount rate must be greater than -1, and all lists should be of equal length.\n        - Considerations: Ensures that the reserve accounts for reinsurance and discounts future liabilities.\n    \"\"\"\n    if discount_rate <= -1:\n        raise ValueError(\"Discount rate must be greater than -1.\")\n\n    if not (len(claim_amounts) == len(claim_paid_dates) == len(claim_settlement_expenses) == len(reinsurance_paid_claims) == len(reinsurance_paid_expenses)):\n        raise ValueError(\"All input lists must have the same length.\")\n\n    total_claims_net_of_reinsurance = sum(claim_amounts[i] - reinsurance_paid_claims[i] for i in range(len(claim_amounts)))\n    total_expenses_net_of_reinsurance = sum(claim_settlement_expenses[i] - reinsurance_paid_expenses[i] for i in range(len(claim_settlement_expenses)))\n    \n    total_net_liabilities = total_claims_net_of_reinsurance + total_expenses_net_of_reinsurance\n    ibnr_reserve = total_net_liabilities / ((1 + discount_rate) ** len(claim_amounts))  # Assuming uniform period for simplicity\n    \n    return ibnr_reserve",
        "statistics": {
            "number_statistics": {
                "args_numbers": 6,
                "question_numbers": 0,
                "context_numbers": 5,
                "total_numbers": 5
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 2,
                    "*": 0,
                    "/": 1,
                    "%": 0,
                    "**": 1
                },
                "total_operators": 6
            },
            "code_statistics": {
                "lines": 5,
                "parentheses": 18
            }
        },
        "difficulty": 4.430816798843313,
        "context": "A medium-sized insurance company is conducting its year-end financial assessment to determine the reserves required for claims that have been incurred but are not yet reported (IBNR). The company has identified a list of potential claim amounts totaling $150,000, with an incurred date from which the claims may arise. In addition, the estimated settlement expenses amount to $30,000. For these claims, the reinsurance has agreed to cover claim amounts and expenses up to a total of $70,000 and $10,000, respectively. The company is using a discount rate of 5% per annum to account for the present value estimation of future liabilities.",
        "question": "What is the estimated IBNR reserve that the insurance company should set aside for the future liabilities, considering the reinsurance agreements and the discount rate? Answer to the nearest dollar.",
        "python_solution": "def solution():\n    # Define input data\n    claim_amounts = [150000]  # Total claim amounts incurred but not reported\n    claim_settlement_expenses = [30000]  # Estimated settlement expenses\n    reinsurance_paid_claims = [70000]  # Amount covered by reinsurance for claims\n    reinsurance_paid_expenses = [10000]  # Expenses covered by reinsurance\n    discount_rate = 0.05  # Discount rate used for present value calculation\n\n    # Compute total claims and expenses net of reinsurance\n    total_claims_net_of_reinsurance = claim_amounts[0] - reinsurance_paid_claims[0]\n    total_expenses_net_of_reinsurance = claim_settlement_expenses[0] - reinsurance_paid_expenses[0]\n\n    # Total net liabilities computed\n    total_net_liabilities = total_claims_net_of_reinsurance + total_expenses_net_of_reinsurance\n\n    # Calculate the IBNR reserve using the present value formula\n    ibnr_reserve = total_net_liabilities / (1 + discount_rate)\n\n    # Return the rounded IBNR reserve estimate\n    return round(ibnr_reserve)\n\n# Calling the solution to check the result\nsolution()",
        "ground_truth": 95238,
        "source": "FinanceReasoning-test-101",
        "question_id": "test-2055",
        "level": "hard",
        "output": [
            "### Step-by-Step Solution Using Advanced Reasoning Techniques\n1. **Emphasizing Constraints (EC)**:\n   - The reinsurance coverage is limited to $70,000 for claims and $10,000 for expenses. We must ensure the claim amounts and settlement expenses are appropriately reduced by these limits.\n   - The discount rate for present value estimation of future liabilities is given as 5% per annum, i.e., a factor of \\(1.05\\).\n   - We are told to estimate the reserve to the nearest dollar.\n   - There is no breakdown given for individual claim amounts, settlement expenses, or their applicable dates. Therefore, we treat the amounts as a lump sum single liability.\n   - We assume one time period (e.g., one year) for discounting purposes because no specific dates were provided for the claim amounts or settlement expenses.\n\n2. **Details of the Calculation**:\n   - Net liability for claims = Total claim amounts - Reinsurance coverage for claims.\n   - Net liability for settlement expenses = Total settlement expenses - Reinsurance coverage for expenses.\n   - Total net liability = Net liability for claims + Net liability for settlement expenses.\n   - Discount the total net liability using the discount rate of 5%.\n   - Round the resulting reserve to the nearest dollar.\n\n3. **Summary of Variables**:\n   - Total claim amounts: $150,000 \n   - Total settlement expenses: $30,000\n   - Reinsurance coverage for claims: $70,000\n   - Reinsurance coverage for expenses: $10,000\n   - Discount rate: 5% or 0.05.\n\nNow, we will calculate the estimated IBNR reserve using these steps in a Python program.\n\n---\n\n```python\ndef solution():\n    # Define variables name and value\n    total_claim_amounts = 150000\n    total_settlement_expenses = 30000\n    reinsurance_coverage_claims = 70000\n    reinsurance_coverage_expenses = 10000\n    discount_rate = 0.05  # 5% per annum\n    \n    # Step 1: Net liabilities calculation\n    net_claims = total_claim_amounts - reinsurance_coverage_claims\n    net_expenses = total_settlement_expenses - reinsurance_coverage_expenses\n    total_net_liabilities = net_claims + net_expenses\n    \n    # Step 2: Discount the total liabilities to present value\n    ibnr_reserve = total_net_liabilities / (1 + discount_rate)\n    \n    # Step 3: Round the result to the nearest dollar\n    answer = round(ibnr_reserve)\n    \n    # Return the final IBNR reserve estimate\n    return answer\n```"
        ],
        "retrieval_query": "What is the estimated IBNR reserve that the insurance company should set aside for the future liabilities, considering the reinsurance agreements and the discount rate? Answer to the nearest dollar.",
        "useful_functions": [
            "def calculate_ibnr_reserve(claim_amounts: list, claim_paid_dates: list, claim_settlement_expenses: list, reinsurance_paid_claims: list, reinsurance_paid_expenses: list, discount_rate: float) -> float:\n    \"\"\"\n    Calculate the Incurred But Not Reported (IBNR) reserve for insurance claims.\n\n    This function estimates the reserve amount needed for claims that have been incurred\n    but not yet reported (IBNR) by analyzing claim amounts, settlement expenses, and reinsurance contributions.\n\n    Args:\n        claim_amounts (list): A list of claim amounts incurred but not reported.\n        claim_paid_dates (list): Dates when claims were paid (used for time value calculation).\n        claim_settlement_expenses (list): Expenses related to settlement of claims.\n        reinsurance_paid_claims (list): Amounts paid by reinsurance for claims.\n        reinsurance_paid_expenses (list): Expenses covered by reinsurance.\n        discount_rate (float): Discount rate for present value estimation of reserve; must be greater than -1.\n\n    Returns:\n        ibnr_reserve (float): The estimated reserve for IBNR claims.\n\n    Notes:\n        - Applicability: Applicable for insurers calculating reserves for unreported claims.\n        - Constraints: Discount rate must be greater than -1, and all lists should be of equal length.\n        - Considerations: Ensures that the reserve accounts for reinsurance and discounts future liabilities.\n    \"\"\"\n    if discount_rate <= -1:\n        raise ValueError(\"Discount rate must be greater than -1.\")\n\n    if not (len(claim_amounts) == len(claim_paid_dates) == len(claim_settlement_expenses) == len(reinsurance_paid_claims) == len(reinsurance_paid_expenses)):\n        raise ValueError(\"All input lists must have the same length.\")\n\n    total_claims_net_of_reinsurance = sum(claim_amounts[i] - reinsurance_paid_claims[i] for i in range(len(claim_amounts)))\n    total_expenses_net_of_reinsurance = sum(claim_settlement_expenses[i] - reinsurance_paid_expenses[i] for i in range(len(claim_settlement_expenses)))\n    \n    total_net_liabilities = total_claims_net_of_reinsurance + total_expenses_net_of_reinsurance\n    ibnr_reserve = total_net_liabilities / ((1 + discount_rate) ** len(claim_amounts))  # Assuming uniform period for simplicity\n    \n    return ibnr_reserve"
        ],
        "usage": {
            "completion_tokens": 558,
            "prompt_tokens": 1012,
            "total_tokens": 1570,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-2743",
        "article_title": "What Is the Effective Interest Rate Method of Amortizing a Bond?",
        "function": "def amortize_bond_discount(purchase_price: float, face_value: float, num_periods: int, coupon_rate: float, market_rate: float) -> list:\n    \"\"\"\n    Amortize the bond discount using the effective interest rate method.\n\n    This function computes the amortization schedule of a bond discount over\n    its life using the effective interest rate method. The bond discount is\n    gradually expensed to interest, with each period's interest expense based\n    on the bond's book value at the start of the period.\n\n    Args:\n        purchase_price (float): The price at which the bond was originally purchased.\n        face_value (float): The face value or par value of the bond.\n        num_periods (int): The total number of periods (e.g., years) until maturity.\n        coupon_rate (float): The annual coupon rate of the bond as a percentage.\n        market_rate (float): The annual market interest rate during issuance as a percentage.\n\n    Returns:\n        amortization_schedule (list): A list of tuples representing each period's\n        interest payment, interest expense, and amortization amount.\n\n    Notes:\n        - Applicability: Useful for calculating interest expenses for bonds issued at a discount.\n        - Constraints: Assumes the bond has periodic, fixed coupon payments.\n        - Considerations: Ensure that coupon and market rates are expressed as percentages.\n    \"\"\"\n    amortization_schedule = []\n    book_value = purchase_price\n\n    for period in range(1, num_periods + 1):\n        coupon_payment = face_value * coupon_rate / 100\n        interest_expense = book_value * market_rate / 100\n        amortization = interest_expense - coupon_payment\n        book_value += amortization\n\n        amortization_schedule.append((coupon_payment, interest_expense, amortization))\n\n    return amortization_schedule",
        "statistics": {
            "number_statistics": {
                "args_numbers": 5,
                "question_numbers": 0,
                "context_numbers": 5,
                "total_numbers": 5
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 1,
                    "*": 2,
                    "/": 2,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 7
            },
            "code_statistics": {
                "lines": 9,
                "parentheses": 6
            }
        },
        "difficulty": 4.430816798843313,
        "context": "A company is considering purchasing a bond to add to its investment portfolio. The bond has a face value of $100,000, an annual coupon rate of 5%, and matures in 4 years. Due to the current market conditions, the bond is issued with a market interest rate (effective yield) of 6%, and the purchase price for this bond is $95,000. The company wants to understand the annual amortization of the bond discount using the effective interest rate method.",
        "question": "What is the total amortization of the bond discount over all periods? Answer to the nearest integer dollar.",
        "python_solution": "def solution():\n    # Given values\n    purchase_price = 95000\n    face_value = 100000\n    num_periods = 4\n    coupon_rate = 5.0\n    market_rate = 6.0\n    \n    # Initialize variables\n    amortization_schedule = []\n    book_value = purchase_price\n    total_amortization = 0\n\n    # Calculate each period's amortization details\n    for period in range(1, num_periods + 1):\n        coupon_payment = face_value * coupon_rate / 100\n        interest_expense = book_value * market_rate / 100\n        amortization = interest_expense - coupon_payment\n        book_value += amortization\n\n        # Add to the total amortization\n        total_amortization += amortization\n        amortization_schedule.append((coupon_payment, interest_expense, amortization))\n\n    # Return the total amortization rounded to the nearest integer\n    return round(total_amortization)",
        "ground_truth": 3062,
        "source": "FinanceReasoning-test-144",
        "question_id": "test-2056",
        "level": "hard",
        "output": [
            "First, let's break down the problem step by step and apply constraints (EC):\n\n### Step 1: Understand the constraints\n- The bond discount needs to be amortized using the **effective interest rate method**.\n- The **total amortization** over all periods needs to be calculated and returned.\n- Values are provided:  \n  - **Face Value**: $100,000  \n  - **Purchase Price (initial book value)**: $95,000  \n  - **Annual Coupon Rate**: 5%  \n  - **Market Interest Rate (Effective Yield)**: 6%  \n  - **Maturity**: 4 years  \n- **Output constraint**: Return the total amortization, rounded to the nearest integer.\n\n### Step 2: Plan the solution\n1. Use the **amortize_bond_discount** function to calculate the amortization expense for each period using the effective interest rate method.\n2. Pull the amortization amounts from each period's result.\n3. Use **calculate_total_amortization_expense** to sum the amortization amounts and ensure it is rounded to the nearest integer.\n\n### Step 3: Steps to calculate total amortization\n1. Calculate the coupon payment for each year:  \n   \\[\n   \\text{Coupon Payment} = \\text{Face Value} \\times \\text{Coupon Rate}\n   \\]\n2. Compute the interest expense for each year based on the book value at the start of that year:\n   \\[\n   \\text{Interest Expense} = \\text{Book Value} \\times \\text{Market Rate}\n   \\]\n3. Calculate the difference between the interest expense and coupon payment:\n   \\[\n   \\text{Amortization Amount} = \\text{Interest Expense} - \\text{Coupon Payment}\n   \\]\n4. Update the book value for the next year:\n   \\[\n   \\text{New Book Value} = \\text{Old Book Value} + \\text{Amortization}\n   \\]\n5. Sum the amortization amounts for all 4 years.\n\nNext, we implement the solution in Python:\n\n```python\ndef solution():\n    # Define variables\n    purchase_price = 95000       # Initial book value\n    face_value = 100000          # Par value of the bond\n    num_periods = 4              # Number of years to maturity\n    coupon_rate = 5              # Annual coupon rate (percent)\n    market_rate = 6              # Annual market yield (percent)\n    \n    # Step 1: Amortize bond discount\n    def amortize_bond_discount(purchase_price, face_value, num_periods, coupon_rate, market_rate):\n        amortization_schedule = []\n        book_value = purchase_price\n\n        for period in range(1, num_periods + 1):\n            coupon_payment = face_value * coupon_rate / 100\n            interest_expense = book_value * market_rate / 100\n            amortization = interest_expense - coupon_payment\n            book_value += amortization\n\n            amortization_schedule.append((coupon_payment, interest_expense, amortization))\n\n        return amortization_schedule\n    \n    # Step 2: Sum amortization expenses\n    def calculate_total_amortization_expense(expenses):\n        if not all(isinstance(expense, (int, float)) for expense in expenses):\n            raise ValueError(\"All expenses should be numbers.\")\n        return round(sum(expenses))\n\n    # Generate the amortization schedule\n    amortization_schedule = amortize_bond_discount(purchase_price, face_value, num_periods, coupon_rate, market_rate)\n    \n    # Extract amortization amounts\n    amortization_expenses = [period[2] for period in amortization_schedule]  # Take the third element (amortization)\n    \n    # Calculate total amortization\n    total_amortization = calculate_total_amortization_expense(amortization_expenses)\n    \n    # Return the result\n    return total_amortization\n```"
        ],
        "retrieval_query": "What is the total amortization of the bond discount over all periods? Answer to the nearest integer dollar.",
        "useful_functions": [
            "def amortize_bond_discount(purchase_price: float, face_value: float, num_periods: int, coupon_rate: float, market_rate: float) -> list:\n    \"\"\"\n    Amortize the bond discount using the effective interest rate method.\n\n    This function computes the amortization schedule of a bond discount over\n    its life using the effective interest rate method. The bond discount is\n    gradually expensed to interest, with each period's interest expense based\n    on the bond's book value at the start of the period.\n\n    Args:\n        purchase_price (float): The price at which the bond was originally purchased.\n        face_value (float): The face value or par value of the bond.\n        num_periods (int): The total number of periods (e.g., years) until maturity.\n        coupon_rate (float): The annual coupon rate of the bond as a percentage.\n        market_rate (float): The annual market interest rate during issuance as a percentage.\n\n    Returns:\n        amortization_schedule (list): A list of tuples representing each period's\n        interest payment, interest expense, and amortization amount.\n\n    Notes:\n        - Applicability: Useful for calculating interest expenses for bonds issued at a discount.\n        - Constraints: Assumes the bond has periodic, fixed coupon payments.\n        - Considerations: Ensure that coupon and market rates are expressed as percentages.\n    \"\"\"\n    amortization_schedule = []\n    book_value = purchase_price\n\n    for period in range(1, num_periods + 1):\n        coupon_payment = face_value * coupon_rate / 100\n        interest_expense = book_value * market_rate / 100\n        amortization = interest_expense - coupon_payment\n        book_value += amortization\n\n        amortization_schedule.append((coupon_payment, interest_expense, amortization))\n\n    return amortization_schedule",
            "def calculate_total_amortization_expense(expenses: list) -> int:\n    \"\"\"\n    Calculate the total amortization expense over a given period.\n\n    This function computes the total amortization expense for a series of years\n    using specified annual expenses provided in a list. It sums the values to\n    provide a total expense, rounded to the nearest integer.\n\n    Args:\n        expenses (list): A list of annual amortization expenses for the specified years.\n\n    Returns:\n        total_expense (int): The total amortization expense, rounded to the nearest integer.\n\n    Notes:\n        - This function is applicable to scenarios where annual amortization expenses\n          are known and need to be totaled for a specific analysis period.\n        - The expenses should be provided in a list corresponding to the years of interest.\n        - Ensure that the input values are appropriate, like positive numbers representing\n          monetary amounts in millions.\n    \"\"\"\n    if not all(isinstance(expense, (int, float)) for expense in expenses):\n        raise ValueError(\"All expenses should be numbers.\")\n\n    total_expense = round(sum(expenses))\n    \n    return total_expense"
        ],
        "usage": {
            "completion_tokens": 823,
            "prompt_tokens": 1067,
            "total_tokens": 1890,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-2551",
        "article_title": "Salvage Value",
        "function": "def calculate_sum_of_years_digits_depreciation(cost: float, salvage_value: float, useful_life: int) -> list:\n    \"\"\"\n    Calculate yearly depreciation expenses using the sum-of-years digits method.\n\n    This function calculates depreciation for each year using the sum-of-years digits method,\n    which allocates depreciation proportionally to the sum of the asset's useful life years,\n    resulting in a larger deduction in the initial years.\n\n    Args:\n        cost (float): The original cost of the asset.\n        salvage_value (float): The estimated salvage value of the asset.\n        useful_life (int): The useful life of the asset in years.\n\n    Returns:\n        List[float]: A list of depreciation expenses for each year of the asset's useful life.\n\n    Notes:\n        - Applicability: Suitable for situations requiring large early-year depreciation deductions.\n        - Constraints: Useful life must be positive and integers; cost should be greater than salvage value.\n        - Considerations: Useful life year summation provides a non-linear depreciation spread.\n    \"\"\"\n    if useful_life <= 0:\n        raise ValueError(\"Useful life must be a positive integer.\")\n    if cost <= salvage_value:\n        raise ValueError(\"Cost must be greater than salvage value.\")\n\n    depreciable_amount = cost - salvage_value\n    sum_of_years = useful_life * (useful_life + 1) / 2\n    depreciation_expenses = []\n    \n    for year in range(useful_life):\n        fraction = (useful_life - year) / sum_of_years\n        depreciation_expense = depreciable_amount * fraction\n        depreciation_expenses.append(depreciation_expense)\n        \n    return depreciation_expenses",
        "statistics": {
            "number_statistics": {
                "args_numbers": 3,
                "question_numbers": 0,
                "context_numbers": 3,
                "total_numbers": 3
            },
            "operator_statistics": {
                "operators": {
                    "+": 1,
                    "-": 2,
                    "*": 2,
                    "/": 2,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 7
            },
            "code_statistics": {
                "lines": 8,
                "parentheses": 8
            }
        },
        "difficulty": 4.430816798843313,
        "context": "A company purchases a new piece of industrial equipment for $120,000. The equipment is expected to have a useful life of 5 years, after which it will have a salvage value of $20,000. The accounting department decides to use the sum-of-years digits method to calculate the yearly depreciation expenses for tax purposes.",
        "question": "What will be the depreciation expense for the third year? Answer to the nearest dollar.",
        "python_solution": "def solution():\n    # Define variables from problem statement\n    cost = 120000\n    salvage_value = 20000\n    useful_life = 5\n\n    # Calculate depreciable amount\n    depreciable_amount = cost - salvage_value\n\n    # Calculate the sum of years\n    sum_of_years = useful_life * (useful_life + 1) / 2\n\n    # Calculate depreciation expense for each year using sum-of-years-digits method\n    depreciation_expenses = []\n\n    for year in range(useful_life):\n        fraction = (useful_life - year) / sum_of_years\n        depreciation_expense = depreciable_amount * fraction\n        depreciation_expenses.append(depreciation_expense)\n\n    # Find the depreciation expense for the third year\n    third_year_depreciation = depreciation_expenses[2]  # Index 2 corresponds to year 3\n\n    # Return the depreciation expense for the third year rounded to the nearest dollar\n    return round(third_year_depreciation)",
        "ground_truth": 20000,
        "source": "FinanceReasoning-test-192",
        "question_id": "test-2057",
        "level": "hard",
        "output": [
            "To determine the depreciation expense for the third year using the sum-of-years digits method, let us carefully work through the problem while adhering to constraints and using reasoning techniques:\n\n### Step-by-step Explanation:\n1. **Understand and Analyze Input Data**:\n    - Cost of the equipment: $120,000.\n    - Salvage value: $20,000.\n    - Useful life of the asset: 5 years.\n\n2. **Constraint Emphasis (EC)**:\n    - Ensuring the cost is greater than the salvage value.\n    - Useful life is a positive integer.\n    - The result must be rounded to the nearest dollar as requested.\n\n3. **Summing the Years**:\n   - In the sum-of-years digits method, the depreciation is spread proportionally to the inverse of the year's ranking, divided by the sum of integers from 1 to `useful_life`. \n   - The sum of the digits for a useful life of 5 years is:\n     \\[\n     \\text{Sum of Years} = 1 + 2 + 3 + 4 + 5 = \\frac{5 \\times (5 + 1)}{2} = 15.\n     \\]\n\n4. **Depreciable Amount**:\n   - Depreciable amount is the cost minus the salvage value:\n     \\[\n     \\text{Depreciable Amount} = 120,000 - 20,000 = 100,000.\n     \\]\n\n5. **Depreciation Expense for Each Year**:\n   - For each year `i`, the fraction of depreciation is:\n     \\[\n     \\text{Fraction} = \\frac{\\text{Useful Life} - (i - 1)}{\\text{Sum of Years}}.\n     \\]\n   - Multiply this fraction by the depreciable amount to get the yearly depreciation expense.\n\n6. **Focus on the Third Year Depreciation**:\n   - For the 3rd year, its fraction is:\n     \\[\n     \\frac{\\text{Useful Life} - (3 - 1)}{\\text{Sum of Years}} = \\frac{5 - 2}{15}.\n     \\]\n   - Then, the depreciation expense is:\n     \\[\n     \\text{Depreciation Expense} = \\text{Depreciable Amount} \\times \\text{Fraction}.\n     \\]\n\n### Solution Code:\nThe above logic will now be implemented in Python to calculate the depreciation expense for the third year, adhering to constraints and rules.\n\n```python\ndef solution():\n    # Define variables name and value\n    cost = 120000\n    salvage_value = 20000\n    useful_life = 5\n    \n    # Compute the depreciable amount\n    depreciable_amount = cost - salvage_value\n    \n    # Compute the sum of the years\n    sum_of_years = useful_life * (useful_life + 1) / 2\n    \n    # Compute the depreciation fraction for the third year\n    third_year_fraction = (useful_life - 3 + 1) / sum_of_years\n    \n    # Compute the depreciation expense for the third year\n    third_year_depreciation = depreciable_amount * third_year_fraction\n    \n    # Return the depreciation expense rounded to the nearest dollar\n    return round(third_year_depreciation)\n```"
        ],
        "retrieval_query": "What will be the depreciation expense for the third year? Answer to the nearest dollar.",
        "useful_functions": [
            "def calculate_sum_of_years_digits_depreciation(cost: float, salvage_value: float, useful_life: int) -> list:\n    \"\"\"\n    Calculate yearly depreciation expenses using the sum-of-years digits method.\n\n    This function calculates depreciation for each year using the sum-of-years digits method,\n    which allocates depreciation proportionally to the sum of the asset's useful life years,\n    resulting in a larger deduction in the initial years.\n\n    Args:\n        cost (float): The original cost of the asset.\n        salvage_value (float): The estimated salvage value of the asset.\n        useful_life (int): The useful life of the asset in years.\n\n    Returns:\n        List[float]: A list of depreciation expenses for each year of the asset's useful life.\n\n    Notes:\n        - Applicability: Suitable for situations requiring large early-year depreciation deductions.\n        - Constraints: Useful life must be positive and integers; cost should be greater than salvage value.\n        - Considerations: Useful life year summation provides a non-linear depreciation spread.\n    \"\"\"\n    if useful_life <= 0:\n        raise ValueError(\"Useful life must be a positive integer.\")\n    if cost <= salvage_value:\n        raise ValueError(\"Cost must be greater than salvage value.\")\n\n    depreciable_amount = cost - salvage_value\n    sum_of_years = useful_life * (useful_life + 1) / 2\n    depreciation_expenses = []\n    \n    for year in range(useful_life):\n        fraction = (useful_life - year) / sum_of_years\n        depreciation_expense = depreciable_amount * fraction\n        depreciation_expenses.append(depreciation_expense)\n        \n    return depreciation_expenses"
        ],
        "usage": {
            "completion_tokens": 685,
            "prompt_tokens": 768,
            "total_tokens": 1453,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-1774",
        "article_title": "Double Declining Balance Depreciation Method (DDB)",
        "function": "def calculate_doubling_declining_balance_depreciation(initial_book_value: float, salvage_value: float, useful_life_years: int, year: int) -> float:\n    \"\"\"\n    Calculate the depreciation expense using the Double-Declining Balance (DDB) method for a specific year.\n\n    This function calculates the depreciation expense for a given year using the double-declining balance method,\n    an accelerated depreciation method that calculates depreciation expense at double the rate of the straight-line method.\n\n    Args:\n        initial_book_value (float): The initial cost of the asset.\n        salvage_value (float): The value of the asset at the end of its useful life.\n        useful_life_years (int): The useful life of the asset in years.\n        year (int): The year for which to calculate the depreciation expense (starting from 1).\n\n    Returns:\n        depreciation_expense (float): The depreciation expense for the specified year.\n\n    Notes:\n        - Applicability: Use for assets that rapidly lose value or become obsolete, such as technology equipment.\n        - Constraints: The calculation stops once the book value reaches or falls below the salvage value.\n        - Considerations: Ensure the year parameter does not exceed the useful life of the asset.\n    \"\"\"\n    if year < 1 or year > useful_life_years:\n        raise ValueError(\"Year must be within the useful life of the asset\")\n\n    book_value = initial_book_value\n    straight_line_rate = 1 / useful_life_years\n    double_declining_rate = 2 * straight_line_rate\n\n    for current_year in range(1, year + 1):\n        depreciation_expense = book_value * double_declining_rate\n        book_value -= depreciation_expense\n\n        if book_value < salvage_value:\n            depreciation_expense = book_value + depreciation_expense - salvage_value\n            book_value = salvage_value\n\n    return max(0, depreciation_expense)",
        "statistics": {
            "number_statistics": {
                "args_numbers": 4,
                "question_numbers": 0,
                "context_numbers": 3,
                "total_numbers": 3
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 2,
                    "*": 2,
                    "/": 1,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 7
            },
            "code_statistics": {
                "lines": 10,
                "parentheses": 4
            }
        },
        "difficulty": 4.430816798843313,
        "context": "A tech company purchases a new piece of equipment for $120,000, which is needed for a project with a limited deadline. The asset is expected to have a useful life of 5 years, after which its value will have diminished to a salvage value of $10,000. The company wants to apply the Double-Declining Balance depreciation method to figure out the depreciation expense in the third year. This method fits well since technology equipment tends to lose value quickly. Understanding this depreciation will help the company with financial planning and budgeting for future projects.",
        "question": "Using the Double-Declining Balance method, what is the depreciation expense for the third year? Answer to the nearest integer.",
        "python_solution": "def solution():\n    # Define variables based on the context\n    initial_book_value = 120000  # Initial cost of the asset\n    salvage_value = 10000        # Salvage value at the end of useful life\n    useful_life_years = 5        # Useful life in years\n    target_year = 3              # The year for which we want to calculate depreciation\n\n    # Calculate necessary rates\n    straight_line_rate = 1 / useful_life_years\n    double_declining_rate = 2 * straight_line_rate\n\n    # Initialize book value and depreciation expense variables\n    book_value = initial_book_value\n    depreciation_expense = 0\n\n    # Calculate depreciation for each year until the target year\n    for current_year in range(1, target_year + 1):\n        # Calculate depreciation expense for the current year\n        depreciation_expense = book_value * double_declining_rate\n        # Reduce the book value by the depreciation expense\n        book_value -= depreciation_expense\n\n        # Ensure book value does not go below salvage value\n        if book_value < salvage_value:\n            depreciation_expense = book_value + depreciation_expense - salvage_value\n            book_value = salvage_value\n\n    # Return the depreciation expense for the target year, rounded to the nearest integer\n    return round(depreciation_expense)",
        "ground_truth": 17280,
        "source": "FinanceReasoning-test-221",
        "question_id": "test-2058",
        "level": "hard",
        "output": [
            "To solve the problem accurately using the Double-Declining Balance method with constraints adhered to, let's outline the solution step by step using Emphasizing Constraints (EC):\n\n### Step-by-Step Reasoning:\n1. **Understand the Method**:\n   - The Double-Declining Balance (DDB) method is an accelerated depreciation method.\n   - The depreciation rate is twice the straight-line rate: \\( \\text{Rate} = 2 \\times \\frac{1}{\\text{Useful Life in Years}} \\).\n   - This method rapidly reduces the book value of an asset in the earlier years.\n\n2. **Problem Constraints**:\n   - The initial book value (asset cost) is $120,000.\n   - The salvage value is $10,000 (the limit for depreciation - the book value cannot drop below this).\n   - Useful life is 5 years.\n   - Calculate the depreciation expense for Year 3.\n   - Ensure that the depreciation calculation does not breach the salvage value constraint.\n\n3. **Calculation Approach**:\n   - Start with the initial book value ($120,000).\n   - For each year, compute:\n     - Depreciation = \\( \\text{Book Value} \\times \\text{Depreciation Rate} \\).\n     - Update the book value: \\( \\text{Book Value} = \\text{Book Value} - \\text{Depreciation} \\).\n   - Stop and adjust depreciation if the book value is less than or equal to the salvage value.\n   - After computing for Year 3, return the depreciation expense in integer form (nearest integer).\n\nNow, let's translate this reasoning into a Python program:\n\n```python\ndef solution():\n    # Define variables: initial parameters of the problem\n    initial_book_value = 120000  # Initial cost of the equipment\n    salvage_value = 10000        # Estimated salvage value after 5 years\n    useful_life_years = 5        # Asset's useful life span in years\n    year_to_calculate = 3        # Year for which we need the depreciation expense\n\n    # Double-Declining Balance depreciation rate\n    depreciation_rate = 2 / useful_life_years\n    \n    # Initialize variables for calculation\n    book_value = initial_book_value\n    depreciation_expense = 0\n    \n    # Compute depreciation up to Year 3\n    for current_year in range(1, year_to_calculate + 1):\n        # Calculate depreciation for the current year\n        depreciation_expense = book_value * depreciation_rate\n        # Update book value after depreciation\n        book_value -= depreciation_expense\n        \n        # If book value falls below salvage value, adjust depreciation\n        if book_value < salvage_value:\n            # Adjust for salvage value constraint\n            depreciation_expense += book_value - salvage_value\n            book_value = salvage_value  # Set book value to salvage value\n            break  # No more depreciation is applied beyond this point\n\n    # Return the depreciation expense for Year 3 rounded to the nearest integer\n    return round(depreciation_expense)\n\n```"
        ],
        "retrieval_query": "Using the Double-Declining Balance method, what is the depreciation expense for the third year? Answer to the nearest integer.",
        "useful_functions": [
            "def calculate_doubling_declining_balance_depreciation(initial_book_value: float, salvage_value: float, useful_life_years: int, year: int) -> float:\n    \"\"\"\n    Calculate the depreciation expense using the Double-Declining Balance (DDB) method for a specific year.\n\n    This function calculates the depreciation expense for a given year using the double-declining balance method,\n    an accelerated depreciation method that calculates depreciation expense at double the rate of the straight-line method.\n\n    Args:\n        initial_book_value (float): The initial cost of the asset.\n        salvage_value (float): The value of the asset at the end of its useful life.\n        useful_life_years (int): The useful life of the asset in years.\n        year (int): The year for which to calculate the depreciation expense (starting from 1).\n\n    Returns:\n        depreciation_expense (float): The depreciation expense for the specified year.\n\n    Notes:\n        - Applicability: Use for assets that rapidly lose value or become obsolete, such as technology equipment.\n        - Constraints: The calculation stops once the book value reaches or falls below the salvage value.\n        - Considerations: Ensure the year parameter does not exceed the useful life of the asset.\n    \"\"\"\n    if year < 1 or year > useful_life_years:\n        raise ValueError(\"Year must be within the useful life of the asset\")\n\n    book_value = initial_book_value\n    straight_line_rate = 1 / useful_life_years\n    double_declining_rate = 2 * straight_line_rate\n\n    for current_year in range(1, year + 1):\n        depreciation_expense = book_value * double_declining_rate\n        book_value -= depreciation_expense\n\n        if book_value < salvage_value:\n            depreciation_expense = book_value + depreciation_expense - salvage_value\n            book_value = salvage_value\n\n    return max(0, depreciation_expense)",
            "def calculate_double_declining_balance_depreciation(asset_value: float, salvage_value: float, useful_life_years: int, year: int) -> float:\n    \"\"\"\n    Calculate annual accumulated depreciation using the double-declining balance method.\n\n    This function computes the double declining depreciation expense for a given year \n    by applying a doubled percentage rate based on the straight line rate.\n\n    Args:\n        asset_value (float): The initial purchase price of the asset.\n        salvage_value (float): The estimated value of the asset at the end of its useful life.\n        useful_life_years (int): The useful lifespan of the asset in years.\n        year (int): The specific year for which the depreciation is being calculated.\n\n    Returns:\n        annual_depreciation (float): The annual depreciation expense for the specified year.\n\n    Notes:\n        - Useful for assets that depreciate more aggressively in their early years.\n        - Year must be greater than 0 and within the useful life range.\n        - The calculated depreciation should not reduce the book value below salvage value.\n    \"\"\"\n    if year <= 0 or year > useful_life_years:\n        raise ValueError(\"Year must be within the useful life range and greater than 0.\")\n    rate = 2 / useful_life_years\n    current_book_value = asset_value\n    for _ in range(1, year):\n        current_depreciation = current_book_value * rate\n        current_book_value -= current_depreciation\n        if current_book_value < salvage_value:\n            current_book_value = salvage_value\n    annual_depreciation = current_book_value * rate\n    if current_book_value - annual_depreciation < salvage_value:\n        annual_depreciation = current_book_value - salvage_value\n    return annual_depreciation"
        ],
        "usage": {
            "completion_tokens": 631,
            "prompt_tokens": 1236,
            "total_tokens": 1867,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-2208",
        "article_title": "Luhn Algorithm",
        "function": "def validate_luhn_algorithm(number: str) -> bool:\n    \"\"\"\n    Validate a number using the Luhn algorithm.\n\n    The Luhn algorithm is used to check identification numbers such as credit\n    card numbers and Social Security numbers for validity. This function takes\n    a number as a string input and determines whether it is valid based on the\n    Luhn algorithm.\n\n    Args:\n        number (str): The identification number to be validated as a string,\n                      which should only contain digits.\n\n    Returns:\n        is_valid (bool): True if the number is valid according to the Luhn\n                         check, False otherwise.\n\n    Notes:\n        - Applicability: The function can be used for validating credit card\n          numbers, Social Security numbers, and similar sequences.\n        - Constraints: The input must be a string composed only of digit\n          characters.\n        - Considerations: The function assumes that the check digit is the last\n          digit of the input number.\n    \"\"\"\n    total = 0\n    num_digits = len(number)\n    parity = num_digits % 2\n\n    for i, digit in enumerate(number):\n        if not digit.isdigit():\n            raise ValueError(\"The input string must contain only digit characters.\")\n            \n        n = int(digit)\n        if i % 2 == parity:\n            n *= 2\n            if n > 9:\n                n -= 9\n        total += n\n\n    return total % 10 == 0",
        "statistics": {
            "number_statistics": {
                "args_numbers": 1,
                "question_numbers": 0,
                "context_numbers": 0,
                "total_numbers": 0
            },
            "operator_statistics": {
                "operators": {
                    "+": 1,
                    "-": 1,
                    "*": 1,
                    "/": 0,
                    "%": 3,
                    "**": 0
                },
                "total_operators": 6
            },
            "code_statistics": {
                "lines": 11,
                "parentheses": 6
            }
        },
        "difficulty": 4.430816798843313,
        "context": "A financial services company is reviewing customer records to ensure compliance with verification protocols. Part of this process includes validating credit card numbers using the Luhn algorithm to check for potential errors in data entry or fraudulent activity. One customer has a credit card number recorded as \"4532015112830365\". The company needs to determine if this number is valid according to the Luhn algorithm before proceeding with account approval.",
        "question": "Is the customer's credit card number \"4532015112830365\" valid according to the Luhn algorithm? Answer with 'True' for valid and 'False' for invalid.",
        "python_solution": "def solution():\n    # The credit card number to be validated\n    number = \"4532015112830365\"\n    \n    # Initialize variables for the Luhn algorithm\n    total = 0\n    num_digits = len(number)\n    parity = num_digits % 2\n\n    # Apply the Luhn algorithm\n    for i, digit in enumerate(number):\n        n = int(digit)\n        if i % 2 == parity:  # Double every second digit\n            n *= 2\n            if n > 9:         # Subtract 9 if the doubled number is greater than 9\n                n -= 9\n        total += n           # Sum all the transformed numbers\n\n    # A number is valid if the total modulo 10 is 0\n    is_valid = total % 10 == 0\n\n    # Return the validity as True or False\n    return is_valid",
        "ground_truth": false,
        "source": "FinanceReasoning-test-362",
        "question_id": "test-2059",
        "level": "hard",
        "output": [
            "### Step-by-Step Analysis with Emphasizing Constraints (EC)\n\n#### Step 1: Understand the Luhn Algorithm Constraints\n- The algorithm calculates the validity of a number by checking if the weighted sum of its digits, following specific weighting rules, is divisible by 10.\n- The input must be a string composed of digit characters only.\n- If the input contains invalid characters (anything other than digits), it is not a valid input.\n- The check digit (the final digit in the number) is verified against the calculated remainder to determine validity.\n\n#### Step 2: Problem Constraints\n- The input credit card number is `\"4532015112830365\"`, which is a valid string containing only digits.\n- We must pass this input into the Luhn algorithm to determine if it is valid.\n- The expected return value should be `True` for validity or `False` for invalidity.\n\n#### Step 3: Execution Plan\n1. Define the number `4532015112830365` as a string for the function.\n2. Properly implement the Luhn algorithm.\n3. Using the constraints and rules discussed, calculate if the number is valid.\n4. Return either `True` or `False` as the output.\n\n#### Step 4: Python Program to Determine Validity\nHere is the Python program to validate if the given number is correct based on the Luhn algorithm:\n\n```python\ndef solution():\n    # Define variables name and value\n    credit_card_number = \"4532015112830365\"\n    \n    # Perform Luhn Algorithm validation\n    def validate_luhn_algorithm(number):\n        total = 0\n        num_digits = len(number)\n        parity = num_digits % 2\n\n        for i, digit in enumerate(number):\n            if not digit.isdigit():\n                raise ValueError(\"The input string must contain only digit characters.\")\n                \n            n = int(digit)\n            if i % 2 == parity:\n                n *= 2\n                if n > 9:\n                    n -= 9\n            total += n\n\n        return total % 10 == 0\n\n    # Use the Luhn validation function to check the credit card number\n    return validate_luhn_algorithm(credit_card_number)\n```\n\nThe returned value of this `solution()` function will be `True` if the credit card number is valid, otherwise `False`."
        ],
        "retrieval_query": "Is the customer's credit card number \"4532015112830365\" valid according to the Luhn algorithm? Answer with 'True' for valid and 'False' for invalid.",
        "useful_functions": [
            "def validate_luhn_algorithm(number: str) -> bool:\n    \"\"\"\n    Validate a number using the Luhn algorithm.\n\n    The Luhn algorithm is used to check identification numbers such as credit\n    card numbers and Social Security numbers for validity. This function takes\n    a number as a string input and determines whether it is valid based on the\n    Luhn algorithm.\n\n    Args:\n        number (str): The identification number to be validated as a string,\n                      which should only contain digits.\n\n    Returns:\n        is_valid (bool): True if the number is valid according to the Luhn\n                         check, False otherwise.\n\n    Notes:\n        - Applicability: The function can be used for validating credit card\n          numbers, Social Security numbers, and similar sequences.\n        - Constraints: The input must be a string composed only of digit\n          characters.\n        - Considerations: The function assumes that the check digit is the last\n          digit of the input number.\n    \"\"\"\n    total = 0\n    num_digits = len(number)\n    parity = num_digits % 2\n\n    for i, digit in enumerate(number):\n        if not digit.isdigit():\n            raise ValueError(\"The input string must contain only digit characters.\")\n            \n        n = int(digit)\n        if i % 2 == parity:\n            n *= 2\n            if n > 9:\n                n -= 9\n        total += n\n\n    return total % 10 == 0"
        ],
        "usage": {
            "completion_tokens": 484,
            "prompt_tokens": 753,
            "total_tokens": 1237,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "The Smith family has an investment portfolio that is comprised of $500,000 in stocks and $330,000 in fixed income products. The Smiths also own a house valued at $350,000, with $175,000 still owed on the mortgage. The total present value of their earnings before they retire is estimated to be $980,000, and the future expected consumption is projected to be worth $870,000 at present. The Smiths have plans to cover their children's college tuition costs amounting to $150,000 at present value. They also wish to establish a family foundation in 25 years, projected to be worth $600,000 at present. Using the information provided, prepare an economic balance sheet for the Smith family. Determine their economic net worth. Answer to a single decimal place.",
        "python_solution": "def solution():\n    equity = 500000\n    fixed_income = 330000\n    residence = 350000\n    pre_retirement_earnings = 980000\n\n    mortgage_debt = 175000\n    consumption = 870000\n    tuition_fee = 150000\n    foundation = 600000\n\n    total_economic_assets = equity + fixed_income + residence + pre_retirement_earnings\n    total_economic_liabilities = mortgage_debt + consumption + tuition_fee + foundation\n    economic_net_worth = total_economic_assets - total_economic_liabilities\n    return economic_net_worth",
        "ground_truth": 365000.0,
        "topic": "Portfolio Management & Strategy",
        "statistics": {
            "number_statistics": {
                "args_numbers": 1,
                "question_numbers": 9,
                "context_numbers": 0,
                "total_numbers": 9
            },
            "operator_statistics": {
                "operators": {
                    "+": 6,
                    "-": 1,
                    "*": 0,
                    "/": 0,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 7
            },
            "code_statistics": {
                "lines": 12,
                "parentheses": 0
            }
        },
        "difficulty": 4.430816798843313,
        "source": "FinanceMath-validation-161",
        "context": "[]",
        "question_id": "test-2060",
        "level": "hard",
        "output": [
            "### Step-by-step Reasoning Using EC (Emphasizing Constraints):\n\n1. **Understanding Assets and Liabilities**:\n   - **Assets**:\n      - Stocks = $500,000\n      - Fixed Income Products = $330,000\n      - House (total value) = $350,000\n      - Present value of future earnings = $980,000\n   - **Liabilities**:\n      - Mortgage owed = $175,000\n      - Future consumption = $870,000\n      - Children's college tuition costs (present value) = $150,000\n      - Foundation establishment (present value) = $600,000\n\n2. **Economic Balance Sheet**:\n   - An economic balance sheet combines all current and projected assets minus total liabilities to determine the net worth.\n\n3. **Constraining the Calculation**:\n   - Ensure that only given values and constraints are used in the calculation.\n   - Provide a single decimal place for the economic net worth.\n\n4. **Formula for Economic Net Worth**:\n   - Economic Net Worth = (Total Assets) - (Total Liabilities)\n   - Total Assets = $500,000 (Stocks) + $330,000 (Fixed Income) + $350,000 (House value) + $980,000 (Present value of earnings)\n   - Total Liabilities = $175,000 (Mortgage) + $870,000 (Future consumption) + $150,000 (College tuition) + $600,000 (Foundation establishment)\n\n5. **Perform the Calculation**:\n   - Plug in the appropriate values to determine the economic net worth.\n\nNow, let's generate the Python solution:\n\n```python\ndef solution():\n    # Define variables for assets\n    stocks = 500000\n    fixed_income = 330000\n    house_value = 350000\n    present_value_earnings = 980000\n    \n    # Calculate total assets\n    total_assets = stocks + fixed_income + house_value + present_value_earnings\n    \n    # Define variables for liabilities\n    mortgage_owed = 175000\n    future_consumption = 870000\n    college_tuition = 150000\n    foundation_establishment = 600000\n    \n    # Calculate total liabilities\n    total_liabilities = mortgage_owed + future_consumption + college_tuition + foundation_establishment\n    \n    # Calculate economic net worth\n    economic_net_worth = total_assets - total_liabilities\n    \n    # Return the result rounded to one decimal place\n    return round(economic_net_worth, 1)\n```\n\nThis code will calculate the Smith family's economic net worth based on the provided data and constraints."
        ],
        "retrieval_query": "The Smith family has an investment portfolio that is comprised of $500,000 in stocks and $330,000 in fixed income products. The Smiths also own a house valued at $350,000, with $175,000 still owed on the mortgage. The total present value of their earnings before they retire is estimated to be $980,000, and the future expected consumption is projected to be worth $870,000 at present. The Smiths have plans to cover their children's college tuition costs amounting to $150,000 at present value. They also wish to establish a family foundation in 25 years, projected to be worth $600,000 at present. Using the information provided, prepare an economic balance sheet for the Smith family. Determine their economic net worth. Answer to a single decimal place.",
        "useful_functions": [],
        "usage": {
            "completion_tokens": 541,
            "prompt_tokens": 490,
            "total_tokens": 1031,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "Lillian, who is the portfolio manager for BC pension, has recently been considering the inclusion of QX Corp. (New York Stock Exchange:  QX) to her portfolio. After a thorough analysis of the company and its competitors, she is of the opinion that the company will witness exceptional growth for the next 4 years followed by normal growth. Therefore, she concludes that a two-stage DDM is the most suitable for assessing the stock's value. In 2017, the total dividends QX Corp. paid was $0.22. She anticipates a growth rate of 12 percent for the upcoming 4 years and 6 percent thereafter. The required return is projected to be 9 percent. What would be the terminal value of the stock according to this method? Answer to three decimal places.",
        "python_solution": "def solution():\n    D_0 = 0.22\n    g_short_term = 0.12\n    g_long_term = 0.06\n    r = 0.09\n    n = 4\n\n    D_n = D_0 * ((1 + g_short_term) ** n)\n    P_n = D_n * (1 + g_long_term) / (r - g_long_term)\n    \n    return P_n",
        "ground_truth": 12.231,
        "topic": "Asset Classes & Derivatives",
        "statistics": {
            "number_statistics": {
                "args_numbers": 5,
                "question_numbers": 6,
                "context_numbers": 0,
                "total_numbers": 6
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 1,
                    "*": 2,
                    "/": 1,
                    "%": 0,
                    "**": 1
                },
                "total_operators": 7
            },
            "code_statistics": {
                "lines": 8,
                "parentheses": 8
            }
        },
        "difficulty": 4.430816798843313,
        "source": "FinanceMath-validation-167",
        "context": "[]",
        "question_id": "test-2061",
        "level": "hard",
        "output": [
            "To solve this problem, I'll carefully reason through it step by step while adhering to the constraints of the given two-stage Dividend Discount Model (DDM). Here's the step-by-step reasoning:\n\n---\n### Step 1: Understand the problem and key constraints\n- **Initial dividend (`D0`)**: $0.22, paid in 2017.\n- **Short-term growth rate (`g_short`)**: 12% (expressed as 0.12).\n- **Long-term growth rate (`g_long`)**: 6% (expressed as 0.06).\n- **Required return (`r`)**: 9% (expressed as 0.09).\n- **High-growth period**: 4 years, after which the perpetual growth phase begins.\n- **The constraint on the `required return`:** It must be greater than the long-term growth rate, i.e., \\( r > g_{long} \\). This is satisfied here as \\( 0.09 > 0.06 \\).\n- **Output format**: The terminal value should be calculated with precision up to three decimal places.\n\n### Step 2: Compute the terminal value\nThe terminal value formula using the two-stage DDM is as follows:\n\\[\nTV = \\frac{D_{high-growth} \\cdot (1 + g_{long})}{r - g_{long}}\n\\]\nWhere:\n1. \\( D_{high-growth} \\): The dividend at the end of the high-growth phase, computed as:\n   \\[\n   D_{high-growth} = D_0 \\cdot (1 + g_{short})^{n}\n   \\]\n   Here \\( n \\) is the number of years in the high-growth period (4 years).\n\n2. The **first dividend** in the perpetual-growth phase is:\n   \\[\n   D_{perpetual} = D_{high-growth} \\cdot (1 + g_{long})\n   \\]\n\n3. The **terminal value** is calculated using:\n   \\[\n   TV = \\frac{D_{perpetual}}{r - g_{long}}\n   \\]\n\n### Step 3: Finalize calculation constraints\nEnsure that:\n- Growth rates are expressed as decimals (e.g., 12% \u2192 0.12).\n- All calculations adhere to precise arithmetic for accurate results to three decimal places.\n\n---\n### Step 4: Python program implementation\nWe will now implement the solution by defining variables and performing the necessary calculations.\n\n```python\ndef solution():\n    # Define variables\n    initial_dividend = 0.22  # D0\n    short_term_growth = 0.12  # g_short\n    long_term_growth = 0.06  # g_long\n    required_return = 0.09  # r\n    high_growth_years = 4  # n\n\n    # Step 1: Calculate the dividend at the end of the high-growth period (D_high-growth)\n    dividend_high_growth = initial_dividend * ((1 + short_term_growth) ** high_growth_years)\n    \n    # Step 2: Calculate the dividend at the start of perpetual growth phase (D_perpetual)\n    first_dividend_perpetual = dividend_high_growth * (1 + long_term_growth)\n    \n    # Step 3: Calculate the terminal value using the Gordon Growth Model (TV)\n    terminal_value = first_dividend_perpetual / (required_return - long_term_growth)\n    \n    # Return the terminal value rounded to three decimal places\n    return round(terminal_value, 3)\n```"
        ],
        "retrieval_query": "Lillian, who is the portfolio manager for BC pension, has recently been considering the inclusion of QX Corp. (New York Stock Exchange:  QX) to her portfolio. After a thorough analysis of the company and its competitors, she is of the opinion that the company will witness exceptional growth for the next 4 years followed by normal growth. Therefore, she concludes that a two-stage DDM is the most suitable for assessing the stock's value. In 2017, the total dividends QX Corp. paid was $0.22. She anticipates a growth rate of 12 percent for the upcoming 4 years and 6 percent thereafter. The required return is projected to be 9 percent. What would be the terminal value of the stock according to this method? Answer to three decimal places.",
        "useful_functions": [
            "def calculate_terminal_value(initial_dividend: float, short_term_growth: float, \n                             long_term_growth: float, required_return: float, \n                             high_growth_years: int) -> float:\n    \"\"\"\n    Calculate the terminal value of a stock using the two-stage Dividend Discount Model (DDM).\n\n    This function computes the terminal value at the end of the high-growth period\n    for a stock expected to have a period of high growth followed by perpetual growth\n    at a slower rate. The DDM is a popular valuation method for estimating the price\n    of a dividend-paying stock.\n\n    Args:\n        initial_dividend (float): The initial dividend amount at the start of the high-growth period.\n        short_term_growth (float): The growth rate during the high-growth period.\n        long_term_growth (float): The perpetual growth rate following the high-growth period.\n        required_return (float): The required rate of return for the investment.\n        high_growth_years (int): The number of years over which the stock experiences high growth.\n\n    Returns:\n        terminal_value (float): The terminal value of the stock at the end of the high-growth period.\n\n    Notes:\n        - Applicability: Suitable for stocks expected to have distinct high-growth and stable-growth phases.\n        - Constraints: The required return must be greater than the long-term growth rate to avoid division by zero.\n        - Considerations: Ensure growth rates and required return are expressed in decimals (e.g., 0.12 for 12%).\n    \"\"\"\n    if required_return <= long_term_growth:\n        raise ValueError(\"Required return must be greater than the long-term growth rate.\")\n\n    # Calculate the dividend at the end of the high-growth period\n    dividend_at_end_high_growth = initial_dividend * ((1 + short_term_growth) ** high_growth_years)\n    \n    # Calculate the first dividend in the perpetual growth phase\n    first_dividend_in_perpetuity = dividend_at_end_high_growth * (1 + long_term_growth)\n    \n    # Calculate the terminal value using the Gordon Growth Model\n    terminal_value = first_dividend_in_perpetuity / (required_return - long_term_growth)\n    \n    return terminal_value",
            "def calculate_dividend_growth_rate(current_price: float, last_dividend: float, expected_return: float) -> float:\n    \"\"\"\n    Calculate the dividend growth rate using the Gordon Growth Model.\n\n    This function calculates the implied dividend growth rate (g) for a stock given\n    the current stock price, the last dividend paid, and the expected return on equity.\n    It is based on the Gordon Growth Model, which assumes a constant growth rate in dividends\n    and is used for valuing perpetual growth stocks.\n\n    Args:\n        current_price (float): The current stock price.\n        last_dividend (float): The last dividend that was paid.\n        expected_return (float): The expected return on equity (as a decimal, e.g., 0.12 for 12%).\n\n    Returns:\n        growth_rate (float): The implied dividend growth rate as a decimal (e.g., 0.08 for 8%).\n\n    Notes:\n        - Applicability: Suitable for stocks assumed to grow dividends at a constant rate.\n        - Constraints: The function assumes the inputs make it possible for (expected_return - growth_rate) > 0.\n        - Considerations: The function does not handle cases where the calculated growth rate\n          is not feasible or realistic for a company's financial situation.\n    \"\"\"\n    if expected_return <= 0:\n        raise ValueError(\"Expected return must be greater than 0.\")\n\n    growth_rate = (last_dividend * (1 - expected_return)) / current_price\n\n    if expected_return - growth_rate <= 0:\n        raise ValueError(\"Calculated growth rate results in an invalid price equation.\")\n\n    return growth_rate"
        ],
        "usage": {
            "completion_tokens": 738,
            "prompt_tokens": 1284,
            "total_tokens": 2022,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "The small securities company's research department director, Brian, is in charge of a team that includes 2 junior analysts using the relative value approach to determine a company's worth. Brian informed the 2 junior analysts that using the earnings from the latest 4 quarters may not accurately reflect cyclical companies' long-term earning potential. Therefore, they may find significantly different P/E ratios even though the company's business outlook remains the same. Brian suggested using normalized EPS to solve this issue. Having gathered information about the company throughout the most recent complete cycle, the 2 junior analysts found that the company's balance sheet reveals total assets worth 2100 million and total liabilities of 1200 million. The value of the preferred equity is $120 million, and there are 32 million common shares outstanding. Given this information, what is the company's normalized EPS? Answer to three decimal places.",
        "python_solution": "def solution():\n    total_assets = 2100\n    total_liabilities = 1200\n    preferred_equity = 120\n    common_shares = 32\n    roe_values = [12.00, 13.10, 10.55, 11.20, 12.05]\n\n    average_roe = sum(roe_values) / len(roe_values)\n    total_shareholder_equity = total_assets - total_liabilities\n    common_equity_value = total_shareholder_equity - preferred_equity\n    bvps = common_equity_value / common_shares\n    normalized_eps = (average_roe / 100) * bvps\n\n    return normalized_eps",
        "ground_truth": 2.871,
        "topic": "Asset Classes & Derivatives",
        "statistics": {
            "number_statistics": {
                "args_numbers": 6,
                "question_numbers": 6,
                "context_numbers": 5,
                "total_numbers": 11
            },
            "operator_statistics": {
                "operators": {
                    "+": 0,
                    "-": 2,
                    "*": 1,
                    "/": 3,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 6
            },
            "code_statistics": {
                "lines": 11,
                "parentheses": 6
            }
        },
        "difficulty": 4.430816798843313,
        "source": "FinanceMath-validation-175",
        "context": "['| Year | ROE   |\\n|------|-------|\\n| 2013 | 12.00%|\\n| 2014 | 13.10%|\\n| 2015 | 10.55%|\\n| 2016 | 11.20%|\\n| 2017 | 12.05%|']",
        "question_id": "test-2062",
        "level": "hard",
        "output": [
            "To answer the question of determining the company's Normalized EPS, let's apply a step-by-step approach:\n\n### Step-by-step reasoning under \"Emphasizing Constraints (EC)\"\n1. **Understand the Formula**: \n   - We need to calculate normalized EPS based on the provided function:\n     - Normalize net income = (Average ROE / 100) \u00d7 Common Equity.\n     - Normalized EPS = Normalized Net Income / Common Shares Outstanding.\n   - ROE values are provided in percentages, hence we must convert them into decimals during calculation.\n   \n2. **Identify Constraints**:\n   - ROE values, total assets, total liabilities, preferred equity, and common shares outstanding are provided.\n   - Constraints include ensuring the percentages are correctly handled, calculating rounded Normalized EPS to three decimal places (as required), and ensuring positive numerical values.\n\n3. **Steps for Calculation**:\n   - Calculate **average ROE** from the provided percentages (cycle takes all 5 years of ROE data).\n   - Compute **total shareholder equity**: Total assets - Total liabilities.\n   - Calculate **common equity**: Total shareholder equity - Preferred equity.\n   - Use **average ROE** and calculated **common equity** to compute normalized net income.\n   - Finally, divide normalized net income by the number of common shares to obtain normalized EPS.\n\nGiven the above analysis, we can now compute the normalized EPS.\n\n---\n\n### Python Program Solution:\n```python\ndef solution():\n    # Define variables name and value (given in the problem statement)\n    roe_values = [12.00, 13.10, 10.55, 11.20, 12.05]  # ROE values in percentage\n    total_assets = 2100  # in million\n    total_liabilities = 1200  # in million\n    preferred_equity = 120  # in million\n    common_shares = 32  # in million\n    \n    # Step 1: Calculate average ROE\n    average_roe = sum(roe_values) / len(roe_values)\n    \n    # Step 2: Calculate total shareholder equity\n    total_shareholder_equity = total_assets - total_liabilities\n    \n    # Step 3: Calculate common equity\n    common_equity = total_shareholder_equity - preferred_equity\n    \n    # Step 4: Calculate normalized net income using average ROE\n    normalized_net_income = (average_roe / 100) * common_equity  # ROE converted into decimal form\n    \n    # Step 5: Calculate normalized EPS\n    normalized_eps = normalized_net_income / common_shares  # Divide by common shares\n    \n    # Step 6: Round normalized EPS to three decimal places\n    return round(normalized_eps, 3)\n```"
        ],
        "retrieval_query": "The small securities company's research department director, Brian, is in charge of a team that includes 2 junior analysts using the relative value approach to determine a company's worth. Brian informed the 2 junior analysts that using the earnings from the latest 4 quarters may not accurately reflect cyclical companies' long-term earning potential. Therefore, they may find significantly different P/E ratios even though the company's business outlook remains the same. Brian suggested using normalized EPS to solve this issue. Having gathered information about the company throughout the most recent complete cycle, the 2 junior analysts found that the company's balance sheet reveals total assets worth 2100 million and total liabilities of 1200 million. The value of the preferred equity is $120 million, and there are 32 million common shares outstanding. Given this information, what is the company's normalized EPS? Answer to three decimal places.",
        "useful_functions": [
            "def calculate_normalized_eps(roe_values: list, total_assets: float, total_liabilities: float, \n                             preferred_equity: float, common_shares: float) -> float:\n    \"\"\"\n    Calculate the normalized earnings per share (EPS) for a company over a business cycle.\n\n    This function computes the normalized EPS using the average return on equity (ROE) \n    over a given cycle, along with the company's balance sheet data. It helps in assessing\n    the long-term earning potential of cyclical companies by smoothing out fluctuations \n    in earnings and providing a more consistent metric.\n\n    Args:\n        roe_values (list): A list of ROE values (in percentages) over the cycle.\n        total_assets (float): The total assets of the company in monetary units.\n        total_liabilities (float): The total liabilities of the company in monetary units.\n        preferred_equity (float): The value of the preferred equity in monetary units.\n        common_shares (float): The number of common shares outstanding.\n\n    Returns:\n        normalized_eps (float): The normalized EPS, representing the per-share earnings \n                                based on the average ROE and the calculated common equity.\n\n    Notes:\n        - Applicable for cyclical companies where recent earnings may not reflect true \n          long-term potential.\n        - Assumes ROE values are provided in percentages and must be converted to decimals.\n        - Requires valid financial data inputs regarding assets, liabilities, and shares.\n        - The computed normalized EPS is the basic version and does not adjust for factors \n          like inflation, taxes, or share buybacks.\n    \"\"\"\n    if not roe_values or common_shares <= 0:\n        raise ValueError(\"ROE values must be provided and common shares must be greater than zero.\")\n\n    average_roe = sum(roe_values) / len(roe_values)\n    total_shareholder_equity = total_assets - total_liabilities\n    common_equity_value = total_shareholder_equity - preferred_equity\n    normalized_net_income = (average_roe / 100) * common_equity_value\n    normalized_eps = normalized_net_income / common_shares\n    \n    return round(normalized_eps, 3)"
        ],
        "usage": {
            "completion_tokens": 569,
            "prompt_tokens": 1029,
            "total_tokens": 1598,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "Ultra Co. uses a periodic inventory system. The following are inventory transactions for the month of January: 1/1 Beginning inventory 20000 units at $13 1/20 Purchase 30000 units at $15 1/23 Purchase 40000 units at $17 1/31 Sales at $20 per unit 50000 units Ultra uses the LIFO method to determine the value of its inventory. What amount should Ultra report as cost of goods sold on its income statement for the month of January? Answer to the nearest dollar.",
        "context": "",
        "statistics": {
            "number_statistics": {
                "question_numbers": 12,
                "context_numbers": 0,
                "total_numbers": 12
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 1,
                    "*": 3,
                    "/": 0,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 6
            },
            "code_statistics": {
                "lines": 12,
                "parentheses": 4
            }
        },
        "difficulty": 4.430816798843313,
        "ground_truth": 830000,
        "source": "FinCode-test-32",
        "python_solution": "beginning_inventory = 20000\nbeginning_inventory_cost = 13\npurchase_1 = 30000\npurchase_1_cost = 15\npurchase_2 = 40000\npurchase_2_cost = 17\nsales = 50000\nsales_price = 20\ninventory_costs = [beginning_inventory_cost] * beginning_inventory + [purchase_1_cost] * purchase_1 + [purchase_2_cost] * purchase_2\ncost_of_goods_sold = inventory_costs[-sales:]\ncost_of_goods_sold_amount = sum(cost_of_goods_sold)\nround(cost_of_goods_sold_amount)",
        "question_id": "test-2063",
        "level": "hard",
        "output": [
            "### Step-by-Step Solution:\n\n1. **Understand the Problem Details and Constraints**:\n    - **Inventory Method**: Ultra uses the LIFO (Last-In, First-Out) method.\n    - **Periodic System**: COGS calculation will be based on the inventory available at the end of the month, considering all purchases and the beginning inventory.\n    - **Constraints**: The transactions and details explicitly mention the units sold (50,000) and the cost values for each purchase. We need to calculate the value of the Cost of Goods Sold (COGS) to the nearest dollar under the LIFO method.\n\n2. **Inventory Details**:\n    - Beginning Inventory: 20,000 units at $13/unit.\n    - Purchase on 1/20: 30,000 units at $15/unit.\n    - Purchase on 1/23: 40,000 units at $17/unit.\n    - Total Units Available: \\( 20,000 + 30,000 + 40,000 = 90,000 \\) units.\n    - Units Sold: \\( 50,000 \\) units at $20/unit (sales price is irrelevant for COGS calculation, but good to know).\n\n3. **LIFO Method for COGS**:\n    - Under LIFO, we sell the latest inventory first. Starting from the most recent purchase (1/23), we will use up inventory until the total units sold (50,000) are covered. Remaining inventory would be reported as ending inventory.\n\n4. **COGS Calculation**:\n    - Start from the last purchase (1/23):\n        - From the 1/23 purchase, 40,000 units at $17/unit are sold.\n        - Remaining demand: \\( 50,000 - 40,000 = 10,000 \\) units.\n    - Then move to the next most recent inventory (1/20):\n        - From the 1/20 purchase, 10,000 units at $15/unit are sold.\n        - No remaining demand.\n    - Calculate the total COGS:\n        - COGS from 1/23: \\( 40,000 \\times 17 = 680,000 \\)\n        - COGS from 1/20: \\( 10,000 \\times 15 = 150,000 \\)\n        - Total COGS: \\( 680,000 + 150,000 = 830,000 \\).\n\n5. **Constraints**:\n    - Round the final COGS to the nearest dollar.\n    - Ensure only the LIFO method is used, adhering strictly to the given transaction details.\n\nWith this reasoning, we can now implement the Python program to compute the COGS.\n\n```python\ndef solution():\n    # Define variables for inventory and purchases\n    units_sold = 50000\n    purchases = [\n        (20000, 13),  # Beginning inventory\n        (30000, 15),  # Purchase on 1/20\n        (40000, 17)   # Purchase on 1/23\n    ]\n    \n    # Function to compute LIFO COGS\n    def calculate_lifo_cogs(units_sold, purchases):\n        total_units = 0\n        cogs = 0\n        for units, cost in reversed(purchases):  # Process from the latest purchase\n            if total_units + units <= units_sold:\n                cogs += units * cost\n                total_units += units\n            else:\n                remaining_units = units_sold - total_units\n                cogs += remaining_units * cost\n                break\n        return cogs\n    \n    # Calculate COGS\n    cogs = calculate_lifo_cogs(units_sold, purchases)\n    \n    # Return the answer rounded to the nearest dollar\n    return round(cogs)\n```"
        ],
        "retrieval_query": "Ultra Co. uses a periodic inventory system. The following are inventory transactions for the month of January: 1/1 Beginning inventory 20000 units at $13 1/20 Purchase 30000 units at $15 1/23 Purchase 40000 units at $17 1/31 Sales at $20 per unit 50000 units Ultra uses the LIFO method to determine the value of its inventory. What amount should Ultra report as cost of goods sold on its income statement for the month of January? Answer to the nearest dollar.",
        "useful_functions": [
            "def calculate_lifo_cogs(units_sold: int, purchases: list) -> float:\n    \"\"\"\n    Calculate the cost of goods sold using the LIFO method in a periodic inventory system.\n\n    This function determines the cost of goods sold (COGS) under the Last-In, First-Out (LIFO)\n    method, given the total units sold and a list of purchase transactions, where each purchase \n    contains the number of units and the cost per unit in tuple format.\n\n    Args:\n        units_sold (int): The total number of units sold during the period.\n        purchases (list): A list of tuples, each tuple containing the number of units purchased \n                          and the cost per unit, in the format (units_purchased, unit_cost).\n\n    Returns:\n        cogs (float): The cost of goods sold calculated using LIFO.\n\n    Notes:\n        - Purchases should be listed in chronological order.\n        - The function assumes that all units in purchases can cover the units sold.\n        - If units_sold exceeds the total units in the given purchases, the function may not \n          handle such cases.\n    \"\"\"\n    total_units = 0\n    cogs = 0\n    for units, cost in reversed(purchases):\n        if total_units + units <= units_sold:\n            cogs += units * cost\n            total_units += units\n        else:\n            remaining_units = units_sold - total_units\n            cogs += remaining_units * cost\n            break\n\n    return cogs"
        ],
        "usage": {
            "completion_tokens": 797,
            "prompt_tokens": 748,
            "total_tokens": 1545,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "In the year 2013, Time Corp. reports net income of \u20ac2.50 million and has 300,000 weighted average number of shares outstanding. At the beginning of the year the company had 30,000 options with an exercise price of \u20ac20. The company's market price averaged \u20ac30 per share over the fiscal year. What is Time Corp's diluted EPS based on the treasury stock method? Answer to the closest cent.",
        "context": "",
        "statistics": {
            "number_statistics": {
                "question_numbers": 5,
                "context_numbers": 0,
                "total_numbers": 5
            },
            "operator_statistics": {
                "operators": {
                    "+": 1,
                    "-": 1,
                    "*": 2,
                    "/": 2,
                    "%": 0,
                    "**": 1
                },
                "total_operators": 7
            },
            "code_statistics": {
                "lines": 11,
                "parentheses": 2
            }
        },
        "difficulty": 4.430816798843313,
        "ground_truth": 8.06,
        "source": "FinCode-test-43",
        "python_solution": "net_income = 2.5 * 10**6\ndiluted_shares = 300000.0\noptions = 30000.0\noption_strike_price = 20\nmarket_price = 30\nproceeds_from_option_exercise = options * option_strike_price\nrepurchase = proceeds_from_option_exercise / market_price\nnet_new_shares = options - repurchase\nnew_diluted_shares = diluted_shares + net_new_shares\ndiluted_eps = net_income / new_diluted_shares\nround(diluted_eps, 2)",
        "question_id": "test-2064",
        "level": "hard",
        "output": [
            "### **Step-by-Step Solution Using Advanced Reasoning Techniques**\n\n#### **Emphasizing Constraints (EC):**\n1. **Net Income Constraint:**\n    - We are given that the company has a net income of \u20ac2.50 million. This needs to be considered in calculating EPS.\n   \n2. **Weighted Average Shares Outstanding:**\n    - The company reports 300,000 weighted average shares outstanding. This is the base number of shares used in calculating the diluted EPS.\n   \n3. **Options Constraint:**\n    - There are 30,000 options outstanding with a strike (exercise) price of \u20ac20.\n    - For the options to be dilutive, the strike price (\u20ac20) must be less than the average market price (\u20ac30). This condition is satisfied here.\n\n4. **Treasury Stock Method:**\n    - When the outstanding options are exercised, the company will receive proceeds (based on the exercise price), which it uses to repurchase shares at the average market price:\n        \\[\n        \\text{Proceeds from Option Exercise} = \\text{Options Outstanding} \\times \\text{Strike Price}\n        \\]\n        \\[\n        \\text{Repurchased Shares} = \\frac{\\text{Proceeds from Option Exercise}}{\\text{Average Market Price}}\n        \\]\n    - The incremental shares added to the outstanding shares:\n        \\[\n        \\text{Incremental Shares} = \\text{Options Outstanding} - \\text{Repurchased Shares}\n        \\]\n    - The diluted shares are the original shares outstanding plus the incremental shares.\n\n5. **Diluted EPS Calculation:**\n    - Using the diluted shares outstanding:\n        \\[\n        \\text{Diluted EPS} = \\frac{\\text{Net Income}}{\\text{Diluted Shares Outstanding}}\n        \\]\n\n6. **Precision Constraint:**\n    - The solution requires the diluted EPS to be rounded **to the nearest cent**.\n\n#### **Implementation Plan:**\nWe will:\n1. Input the given values into the equations outlined.\n2. Calculate the proceeds and the repurchased shares.\n3. Derive the incremental shares and compute the diluted shares.\n4. Calculate and return the diluted EPS rounded to two decimal places.\n\n---\n\n### Python Code Implementation\n```python\ndef solution():\n    # Define variables name and value\n    net_income = 2_500_000  # \u20ac2.50 million\n    shares_outstanding = 300_000  # shares\n    options_outstanding = 30_000  # options\n    option_strike_price = 20.0  # \u20ac per option\n    average_market_price = 30.0  # \u20ac per share\n\n    # Step 1: Calculate proceeds from option exercise\n    proceeds_from_option_exercise = options_outstanding * option_strike_price\n\n    # Step 2: Calculate repurchased shares using proceeds at average market price\n    repurchased_shares = proceeds_from_option_exercise / average_market_price\n\n    # Step 3: Calculate incremental shares added to outstanding shares\n    incremental_shares = options_outstanding - repurchased_shares\n\n    # Step 4: Compute diluted shares outstanding\n    diluted_shares_outstanding = shares_outstanding + incremental_shares\n\n    # Step 5: Calculate diluted EPS\n    diluted_eps = net_income / diluted_shares_outstanding\n\n    # Return the diluted EPS rounded to the nearest cent\n    return round(diluted_eps, 2)\n```"
        ],
        "retrieval_query": "In the year 2013, Time Corp. reports net income of \u20ac2.50 million and has 300,000 weighted average number of shares outstanding. At the beginning of the year the company had 30,000 options with an exercise price of \u20ac20. The company's market price averaged \u20ac30 per share over the fiscal year. What is Time Corp's diluted EPS based on the treasury stock method? Answer to the closest cent.",
        "useful_functions": [
            "def calculate_diluted_eps_treasury_stock_method(net_income: float, shares_outstanding: int,\n                                                options_outstanding: int, option_strike_price: float,\n                                                average_market_price: float) -> float:\n    \"\"\"\n    Calculate the diluted earnings per share (EPS) using the treasury stock method.\n\n    This function computes the diluted EPS for a company by considering the potential dilution\n    from outstanding options using the treasury stock method. It accounts for the impact of\n    options being exercised, generating proceeds used to repurchase shares at the average\n    market price.\n\n    Args:\n        net_income (float): The net income of the company for the period.\n        shares_outstanding (int): The weighted average number of shares outstanding during the period.\n        options_outstanding (int): The number of options that could potentially dilute the EPS.\n        option_strike_price (float): The exercise price for the outstanding options.\n        average_market_price (float): The average market price of the stock during the period.\n\n    Returns:\n        diluted_eps (float): The diluted EPS, rounded to the nearest cent.\n\n    Notes:\n        - This function is applicable for calculating diluted EPS in scenarios with potential dilution from options.\n        - The treasury stock method assumes that options are exercised at the beginning of the period or at the date\n          of issuance if later.\n        - Important considerations include ensuring options are in-the-money (exercise price < market price) to have\n          a dilutive effect.\n    \"\"\"\n    proceeds_from_option_exercise = options_outstanding * option_strike_price\n    repurchased_shares = proceeds_from_option_exercise / average_market_price\n    incremental_shares = options_outstanding - repurchased_shares\n    diluted_shares_outstanding = shares_outstanding + incremental_shares\n    diluted_eps = net_income / diluted_shares_outstanding\n\n    return round(diluted_eps, 2)"
        ],
        "usage": {
            "completion_tokens": 709,
            "prompt_tokens": 802,
            "total_tokens": 1511,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-2334",
        "article_title": "Annuity",
        "function": "def calculate_future_value_annuity(payment: float, interest_rate: float, periods: int, annuity_due: bool = False) -> float:\n    \"\"\"\n    Calculate the future value of an annuity.\n\n    This function computes the future value of a series of equal payments made at regular intervals,\n    taking into account a specified interest rate. The calculation can accommodate payments made\n    at the beginning (annuity due) or at the end of each period (ordinary annuity).\n\n    Args:\n        payment (float): The payment amount per period.\n        interest_rate (float): The interest rate per period as a decimal (e.g., 0.05 for 5%).\n        periods (int): The total number of periods.\n        annuity_due (bool, optional): If True, calculates the future value for an annuity due (default is False).\n\n    Returns:\n        future_value (float): The future value of the annuity.\n\n    Notes:\n        - Suitable for scenarios involving regular payments with compounding interest.\n        - The interest rate should be specified per period, aligning with the periods of payment.\n        - Assumes consistent payment amounts and intervals throughout the annuity's term.\n        - Does not incorporate considerations such as taxes or variable interest rates.\n    \"\"\"\n    if interest_rate == 0:\n        future_value = payment * periods\n    else:\n        factor = (1 + interest_rate) ** periods\n        future_value = payment * (factor - 1) / interest_rate\n        if annuity_due:\n            future_value *= (1 + interest_rate)\n\n    return future_value",
        "statistics": {
            "number_statistics": {
                "args_numbers": 4,
                "question_numbers": 1,
                "context_numbers": 4,
                "total_numbers": 5
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 1,
                    "*": 3,
                    "/": 1,
                    "%": 0,
                    "**": 1
                },
                "total_operators": 8
            },
            "code_statistics": {
                "lines": 8,
                "parentheses": 6
            }
        },
        "difficulty": 4.477336814478207,
        "context": "Sarah is planning to save for her child's college education. She decides to make monthly contributions of $500 into a savings account that offers an annual interest rate of 6%, compounded monthly. She plans to save for 10 years, making her contributions at the beginning of each month (annuity due). She wants to know how much money will be in the account at the end of 10 years.",
        "question": "What is the future value of Sarah's savings after 10 years? Answer to the nearest dollar.",
        "python_solution": "def solution():\n    # Given values\n    payment = 500  # Monthly contribution\n    annual_interest_rate = 0.06  # 6% annual interest\n    periods_per_year = 12  # Monthly contributions\n    years = 10  # Saving for 10 years\n    \n    # Calculate monthly interest rate\n    interest_rate = annual_interest_rate / periods_per_year\n    \n    # Calculate total number of periods\n    periods = years * periods_per_year\n    \n    # Annuity due: contributions at the beginning of each period\n    annuity_due = True\n    \n    # Calculate the future value of the annuity\n    if interest_rate == 0:\n        future_value = payment * periods\n    else:\n        factor = (1 + interest_rate) ** periods\n        future_value = payment * (factor - 1) / interest_rate\n        if annuity_due:\n            future_value *= (1 + interest_rate)\n    \n    # Return the future value rounded to the nearest dollar\n    return round(future_value)\n\n# Example of calling the solution function\n# print(solution())",
        "ground_truth": 82349,
        "source": "FinanceReasoning-test-169",
        "question_id": "test-2065",
        "level": "hard",
        "output": [
            "Let's solve the problem step by step using the provided advanced reasoning technique, \"Emphasizing Constraints (EC)\":\n\n### Step-by-Step Reasoning\n\n1. **Understand the Problem**:\n   - Sarah makes regular monthly contributions (starting at the beginning of each month) to a savings account. This is an annuity due.\n   - The annual interest rate is 6%, compounded monthly.\n   - She contributes $500 and will save for 10 years.\n   - We need to compute the future value of this annuity and return the result rounded to the nearest dollar.\n\n2. **Key Formula for Future Value of an Annuity Due**:\n   The formula for the future value (FV) of an annuity due is:\n   \\[\n   FV = P \\times \\left(\\frac{(1 + r)^n - 1}{r}\\right) \\times (1 + r)\n   \\]\n   Where:\n   - \\(P\\): Payment per period ($500/month)\n   - \\(r\\): Interest rate per period (\\(\\frac{6\\%}{12} = 0.005\\) monthly rate)\n   - \\(n\\): Total number of periods (\\(12 \\times 10 = 120\\))\n\n3. **Constraints**:\n   - The interest rate \\(r\\) must be in decimal form and computed for the monthly period.\n   - The result should be rounded to the nearest dollar.\n   - Ensure all payments occur at the beginning of each period (annuity due factor \\((1 + r)\\) is applied).\n\n4. **Steps**:\n   - Convert the annual interest rate into a monthly rate.\n   - Calculate the total number of periods (\\(n = 10 \\times 12 = 120\\)).\n   - Use the formula above to compute the future value \\(FV\\).\n   - Round the result to the nearest dollar.\n\nNow, let\u2019s write the Python program:\n\n```python\ndef solution():\n    # Define variables name and value\n    P = 500  # Monthly payment in dollars\n    annual_rate = 0.06  # Annual interest rate (6%)\n    r = annual_rate / 12  # Monthly interest rate\n    years = 10\n    n = years * 12  # Total number of contributions (120)\n    \n    # Future Value of an Annuity Due formula\n    FV = P * (((1 + r)**n - 1) / r) * (1 + r)\n    \n    # Round to the nearest dollar and return the result\n    return round(FV)\n\n```\n\n### Explanation of the Program\n1. We defined key input values such as the monthly payment \\(P\\), the annual interest rate \\(r\\), and the total number of contributions \\(n\\).\n2. The formula for the future value of an annuity due is implemented, incorporating the adjustment for \"beginning of the period\" with \\((1 + r)\\).\n3. The result is rounded to the nearest dollar using the `round()` function and returned.\n\nThis program will calculate the future value of Sarah's savings after 10 years accurately and efficiently."
        ],
        "retrieval_query": "What is the future value of Sarah's savings after 10 years? Answer to the nearest dollar.",
        "useful_functions": [
            "def calculate_cash_used_for_stock_repurchase(shares_repurchased: int, price_per_share: float) -> float:\n    \"\"\"\n    Calculate the total cash used for stock repurchase in a specified period.\n\n    This function computes the total cash expended for buying back shares during\n    a specified period, given the number of shares repurchased and the average \n    price paid per share. It returns the value in millions for financial reporting.\n\n    Args:\n        shares_repurchased (int): The total number of shares repurchased.\n        price_per_share (float): The average price paid per share during repurchase.\n\n    Returns:\n        cash_used_millions (float): The total cash used in millions.\n\n    Notes:\n        - Applicability: Use this function for calculating cash outflows in share\n          repurchase programs.\n        - Constraints: Ensure that both inputs are non-negative. The number of shares\n          should be an integer, and the price per share should be a positive value.\n        - Considerations: Consider currency factors when computing international financials.\n    \"\"\"\n    cash_used = shares_repurchased * price_per_share\n    cash_used_millions = cash_used / 1_000_000\n\n    return cash_used_millions"
        ],
        "usage": {
            "completion_tokens": 646,
            "prompt_tokens": 689,
            "total_tokens": 1335,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-962",
        "article_title": "Moving Average (MA)",
        "function": "def calculate_exponential_moving_average(prices: list, period: int) -> list:\n    \"\"\"\n    Calculate the exponential moving average (EMA) of a list of prices over a specified period.\n\n    This function computes the exponential moving average, which gives greater weight to more \n    recent prices, making it more responsive to new information than the simple moving average.\n\n    Args:\n        prices (list): A list of prices (e.g., daily closing prices of a stock).\n        period (int): The number of periods over which to calculate the EMA.\n\n    Returns:\n        ema (list): A list of calculated EMA values corresponding to the input prices.\n\n    Notes:\n        - The period must be greater than 0 and less than or equal to the length of the prices list.\n        - The EMA calculation starts with the simple moving average for the first EMA value.\n        - The returned list will exclude the first (period - 1) elements because they are used to\n          initialize the calculation.\n        - The input list must contain numeric values.\n    \"\"\"\n    if period <= 0 or period > len(prices):\n        raise ValueError(\"Period must be greater than 0 and less than or equal to the length of the prices list.\")\n\n    smoothing_factor = 2 / (period + 1)\n    ema = [sum(prices[:period]) / period]  # Start with the SMA for the first value\n\n    for price in prices[period:]:\n        new_ema = (price * smoothing_factor) + ema[-1] * (1 - smoothing_factor)\n        ema.append(new_ema)\n    \n    return ema",
        "statistics": {
            "number_statistics": {
                "args_numbers": 2,
                "question_numbers": 1,
                "context_numbers": 12,
                "total_numbers": 13
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 2,
                    "*": 2,
                    "/": 2,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 8
            },
            "code_statistics": {
                "lines": 6,
                "parentheses": 10
            }
        },
        "difficulty": 4.477336814478207,
        "context": "A stock analyst is studying the price movement of a particular stock over a 10-day period and decides to apply an exponential moving average (EMA) to smooth the price data and identify trends. The analyst has the following recorded daily closing prices: [150, 152, 149, 153, 155, 157, 160, 162, 165, 167]. The analyst wishes to calculate the 5-day EMA starting from the sixth day, as it provides a more recent perspective of the stock's behavior.",
        "question": "Using the 5-day period, what is the exponential moving average (EMA) of the stock price on the 10th day? Answer to two decimal places.",
        "python_solution": "def solution():\n    # Define the list of prices and period for EMA calculation\n    prices = [150, 152, 149, 153, 155, 157, 160, 162, 165, 167]\n    period = 5\n\n    # Ensure valid period\n    if period <= 0 or period > len(prices):\n        raise ValueError(\"Period must be greater than 0 and less than or equal to the length of the prices list.\")\n\n    # Calculate the smoothing factor\n    smoothing_factor = 2 / (period + 1)\n\n    # Start computing EMA with the simple moving average for the initial period\n    sma_initial = sum(prices[:period]) / period\n    ema_values = [sma_initial]\n\n    # Compute the EMA for subsequent prices\n    for price in prices[period:]:\n        new_ema = (price * smoothing_factor) + ema_values[-1] * (1 - smoothing_factor)\n        ema_values.append(new_ema)\n\n    # The EMA value for the 10th day\n    ema_on_10th_day = ema_values[-1]\n\n    # Return the EMA value rounded to two decimal places\n    return round(ema_on_10th_day, 2)",
        "ground_truth": 162.46,
        "source": "FinanceReasoning-test-235",
        "question_id": "test-2066",
        "level": "hard",
        "output": [
            "### Step-by-Step Solution Using Advanced Reasoning Techniques\n\n#### 1. Emphasizing Constraints (EC)\n- **Constraint 1: Closing prices**:\n  The calculation must start with the given daily closing prices `[150, 152, 149, 153, 155, 157, 160, 162, 165, 167]`.\n  \n- **Constraint 2: EMA Period**:\n  The period for the EMA calculation is 5 days.\n\n- **Constraint 3: Result Precision**:\n  The answer must be provided to **two decimal places**.\n\n- **Constraint 4: Starting the EMA**:\n  The calculation must start on the **6th day**, as stated in the problem, using the first 5 days to calculate the initial Simple Moving Average (SMA).\n\n#### 2. Key Details for EMA Calculation\n- **Initial SMA for EMA**:\n  Use the average of the first 5 closing prices to define the starting EMA.\n  \\[\n  \\text{SMA} = \\frac{\\text{Sum of first 5 prices}}{5}\n  \\]\n\n- **Multiplier for EMA**:\n  The smoothing multiplier for a 5-day EMA is calculated as:\n  \\[\n  \\text{Multiplier} = \\frac{2}{\\text{Period} + 1} = \\frac{2}{5 + 1} = 0.3333\n  \\]\n\n- **EMA Formula**:\n  For subsequent days:\n  \\[\n  \\text{EMA(current)} = \\left(\\text{Price} - \\text{EMA(previous)}\\right) \\times \\text{Multiplier} + \\text{EMA(previous)}\n  \\]\n\n- **Calculation Goal**:\n  We need to calculate the 5-day EMA up to the **10th day** (last day in the dataset).\n\n---\n\n#### Plan for Implementation\n1. Calculate the SMA for the first 5 days (i.e., `[150, 152, 149, 153, 155]`).\n2. Use the SMA as the initial EMA.\n3. Iteratively calculate the EMA for days 6 through 10 using the series formula.\n4. Return the EMA value on the 10th day rounded to two decimal places.\n\n---\n\nHere is the implemented Python program:\n\n```python\ndef solution():\n    # Define variables: list of closing prices and the EMA period\n    closing_prices = [150, 152, 149, 153, 155, 157, 160, 162, 165, 167]\n    period = 5  # 5-day EMA\n    \n    # Step 1: Calculate the initial SMA for the first 5 days\n    initial_sma = sum(closing_prices[:period]) / period  # SMA over the first 5 prices\n    \n    # Step 2: Calculate the EMA multiplier\n    multiplier = 2 / (period + 1)\n    \n    # Step 3: Initialize the first EMA value with the SMA\n    ema = initial_sma\n    \n    # Step 4: Calculate EMA from the 6th day onward\n    for price in closing_prices[period:]:\n        ema = (price - ema) * multiplier + ema  # EMA formula\n    \n    # Step 5: Return the EMA value for the 10th day, rounded to two decimal places\n    return round(ema, 2)\n```\n\nThis code calculates the 5-day EMA for the stock's 10th day, conforming to all specified constraints."
        ],
        "retrieval_query": "Using the 5-day period, what is the exponential moving average (EMA) of the stock price on the 10th day? Answer to two decimal places.",
        "useful_functions": [
            "def calculate_ema(close_prices: list, n_periods: int) -> float:\n    \"\"\"\n    Calculate the Exponential Moving Average (EMA) for a given number of periods.\n\n    The EMA helps to smooth out price data and capture the current trend by giving\n    more weight to recent prices. It is used in technical analysis to anticipate\n    potential breakouts or identify current trends.\n\n    Args:\n        close_prices (list): A list of closing prices in chronological order.\n        n_periods (int): The number of periods over which to calculate the EMA.\n\n    Returns:\n        ema (float): The calculated exponential moving average.\n\n    Notes:\n        - Applicability: Useful for trend analysis in financial time series data.\n        - Constraints: The list of closing prices must contain at least `n_periods` values.\n        - Considerations: The first EMA value is calculated using a Simple Moving Average (SMA).\n    \"\"\"\n    # Calculate the initial SMA\n    if len(close_prices) < n_periods:\n        raise ValueError(\"The number of close prices must be at least equal to the number of periods.\")\n    \n    sma = sum(close_prices[:n_periods]) / n_periods\n\n    # Calculate the multiplier for weighting the EMA\n    multiplier = 2 / (n_periods + 1)\n    \n    # Calculate the initial EMA using the SMA\n    ema = sma\n\n    # Calculate the EMA for the rest of the periods\n    for price in close_prices[n_periods:]:\n        ema = (price - ema) * multiplier + ema\n    \n    return ema",
            "def calculate_exponential_moving_average(prices: list, period: int) -> list:\n    \"\"\"\n    Calculate the exponential moving average (EMA) of a list of prices over a specified period.\n\n    This function computes the exponential moving average, which gives greater weight to more \n    recent prices, making it more responsive to new information than the simple moving average.\n\n    Args:\n        prices (list): A list of prices (e.g., daily closing prices of a stock).\n        period (int): The number of periods over which to calculate the EMA.\n\n    Returns:\n        ema (list): A list of calculated EMA values corresponding to the input prices.\n\n    Notes:\n        - The period must be greater than 0 and less than or equal to the length of the prices list.\n        - The EMA calculation starts with the simple moving average for the first EMA value.\n        - The returned list will exclude the first (period - 1) elements because they are used to\n          initialize the calculation.\n        - The input list must contain numeric values.\n    \"\"\"\n    if period <= 0 or period > len(prices):\n        raise ValueError(\"Period must be greater than 0 and less than or equal to the length of the prices list.\")\n\n    smoothing_factor = 2 / (period + 1)\n    ema = [sum(prices[:period]) / period]  # Start with the SMA for the first value\n\n    for price in prices[period:]:\n        new_ema = (price * smoothing_factor) + ema[-1] * (1 - smoothing_factor)\n        ema.append(new_ema)\n    \n    return ema",
            "def calculate_exponential_moving_average(prices: list, smoothing: float = 2, days: int = 20) -> list:\n    \"\"\"\n    Calculate the Exponential Moving Average (EMA) of a list of prices.\n\n    This function computes the EMA, which emphasizes the latest price data more heavily \n    by using an exponentially decreasing weight for past observations. It is used in \n    financial markets to analyze data points like stock prices.\n\n    Args:\n        prices (list): A list of prices in chronological order, where each element\n                       represents the price for a given day.\n        smoothing (float): The smoothing factor typically used as 2. It determines how\n                           much weight is applied to the most recent prices. Default is 2.\n        days (int): The number of periods (days) to calculate the EMA for. Typically a \n                    10, 20, 50, or similar period is used. Default is 20.\n\n    Returns:\n        ema_values (list): A list of EMA values calculated for each price in the input list\n                           starting from the (days+1)th day. The first (days) entries will \n                           be None to indicate insufficient data to compute the EMA.\n\n    Notes:\n        - Applicability: Useful in financial analysis for smoothing out price data to \n          identify trends.\n        - Constraints: Requires at least `days` number of price entries to start calculating EMAs.\n        - Considerations: Different periods may result in different trend sensitivities;\n          shorter EMAs react quicker to price changes than longer ones.\n    \"\"\"\n    if len(prices) < days:\n        raise ValueError(\"Number of prices should be at least equal to the 'days' parameter.\")\n\n    multiplier = smoothing / (1 + days)\n    ema_values = [None] * (days - 1)\n    sma = sum(prices[:days]) / days\n    ema_values.append(sma)\n\n    for price in prices[days:]:\n        new_ema = (price - ema_values[-1]) * multiplier + ema_values[-1]\n        ema_values.append(new_ema)\n\n    return ema_values"
        ],
        "usage": {
            "completion_tokens": 731,
            "prompt_tokens": 1571,
            "total_tokens": 2302,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-125",
        "article_title": "Commercial Paper",
        "function": "def calculate_days_to_maturity(issuance_date: str, maturity_date: str) -> int:\n    \"\"\"\n    Calculate the number of days to maturity of a commercial paper from its issuance date.\n\n    This function determines the duration of investment in commercial paper, which is essential for\n    computing associated financial metrics like discount rate and yield.\n\n    Args:\n        issuance_date (str): The issuance date in the 'YYYY-MM-DD' format.\n        maturity_date (str): The maturity date in the 'YYYY-MM-DD' format.\n\n    Returns:\n        days_to_maturity (int): The number of days until maturity.\n\n    Notes:\n        - Applicability: Use for computing financial metrics which require duration as an input.\n        - Constraints: Requires valid date inputs formatted as 'YYYY-MM-DD'.\n        - Considerations: Assumes that the issuance and maturity dates are valid and in chronological order.\n    \"\"\"\n    from datetime import datetime\n\n    issuance_date_obj = datetime.strptime(issuance_date, '%Y-%m-%d')\n    maturity_date_obj = datetime.strptime(maturity_date, '%Y-%m-%d')\n\n    if maturity_date_obj <= issuance_date_obj:\n        raise ValueError(\"Maturity date must be after issuance date.\")\n\n    days_to_maturity = (maturity_date_obj - issuance_date_obj).days\n\n    return days_to_maturity",
        "statistics": {
            "number_statistics": {
                "args_numbers": 2,
                "question_numbers": 0,
                "context_numbers": 2,
                "total_numbers": 2
            },
            "operator_statistics": {
                "operators": {
                    "+": 0,
                    "-": 5,
                    "*": 0,
                    "/": 0,
                    "%": 6,
                    "**": 0
                },
                "total_operators": 11
            },
            "code_statistics": {
                "lines": 5,
                "parentheses": 6
            }
        },
        "difficulty": 4.477336814478207,
        "context": "A financial analyst is evaluating a batch of commercial papers issued by a company for liquidity management. One specific commercial paper was issued on March 15, 2023, with a maturity date of September 12, 2023. Understanding the duration of this commercial paper is crucial for determining interest rates and yields applicable to such short-term debt instruments.",
        "question": "How many days are there until maturity for this commercial paper? Provide your answer as an integer.",
        "python_solution": "def solution():\n    from datetime import datetime\n\n    # Define the issuance and maturity dates\n    issuance_date_str = \"2023-03-15\"\n    maturity_date_str = \"2023-09-12\"\n\n    # Convert string dates to datetime objects\n    issuance_date = datetime.strptime(issuance_date_str, '%Y-%m-%d')\n    maturity_date = datetime.strptime(maturity_date_str, '%Y-%m-%d')\n\n    # Calculate the number of days to maturity\n    days_to_maturity = (maturity_date - issuance_date).days\n\n    # Return the calculated result as an integer\n    return days_to_maturity",
        "ground_truth": 181,
        "source": "FinanceReasoning-test-276",
        "question_id": "test-2067",
        "level": "hard",
        "output": [
            "### Step-by-Step Analysis using Emphasizing Constraints (EC):\n\n1. **Constraints Review**:\n   - Input dates are provided in `YYYY-MM-DD` format: `\"2023-03-15\"` (issuance date) and `\"2023-09-12\"` (maturity date).\n   - The calculation must determine the number of days between issuance and maturity.\n   - The maturity date (`2023-09-12`) is strictly after issuance date (`2023-03-15`), as stated in the problem.\n\n2. **Validation of Input Format**:\n   - The format `YYYY-MM-DD` is standard and conforms to ISO format for working with dates in Python. No additional transformation is needed.\n\n3. **Use of Python Libraries**:\n   - The `datetime` module will be used to convert date strings into datetime objects and calculate the difference (in days) between them.\n\n4. **Edge Cases**:\n   - Since the dates provided are valid and in a proper sequence, no exceptions are expected.\n\n### Plan:\n- Parse the input dates into datetime objects.\n- Calculate the difference in days between the maturity date and the issuance date using simple subtraction.\n- Return the resulting number of days as an integer.\n\nHere is the Python program:\n\n```python\ndef solution():\n    # Define variables name and value\n    issuance_date = \"2023-03-15\"\n    maturity_date = \"2023-09-12\"\n    \n    # Import datetime module to work with dates\n    from datetime import datetime\n    \n    # Convert input strings to datetime objects\n    issuance_date_obj = datetime.strptime(issuance_date, '%Y-%m-%d')\n    maturity_date_obj = datetime.strptime(maturity_date, '%Y-%m-%d')\n    \n    # Ensure maturity date is after issuance date (already given in the problem context)\n    if maturity_date_obj <= issuance_date_obj:\n        raise ValueError(\"Maturity date must be after issuance date.\")\n    \n    # Calculate the difference in days\n    days_to_maturity = (maturity_date_obj - issuance_date_obj).days\n    \n    # Return the calculated number of days as an integer\n    return days_to_maturity\n```"
        ],
        "retrieval_query": "How many days are there until maturity for this commercial paper? Provide your answer as an integer.",
        "useful_functions": [
            "def calculate_days_to_maturity(issuance_date: str, maturity_date: str) -> int:\n    \"\"\"\n    Calculate the number of days to maturity of a commercial paper from its issuance date.\n\n    This function determines the duration of investment in commercial paper, which is essential for\n    computing associated financial metrics like discount rate and yield.\n\n    Args:\n        issuance_date (str): The issuance date in the 'YYYY-MM-DD' format.\n        maturity_date (str): The maturity date in the 'YYYY-MM-DD' format.\n\n    Returns:\n        days_to_maturity (int): The number of days until maturity.\n\n    Notes:\n        - Applicability: Use for computing financial metrics which require duration as an input.\n        - Constraints: Requires valid date inputs formatted as 'YYYY-MM-DD'.\n        - Considerations: Assumes that the issuance and maturity dates are valid and in chronological order.\n    \"\"\"\n    from datetime import datetime\n\n    issuance_date_obj = datetime.strptime(issuance_date, '%Y-%m-%d')\n    maturity_date_obj = datetime.strptime(maturity_date, '%Y-%m-%d')\n\n    if maturity_date_obj <= issuance_date_obj:\n        raise ValueError(\"Maturity date must be after issuance date.\")\n\n    days_to_maturity = (maturity_date_obj - issuance_date_obj).days\n\n    return days_to_maturity"
        ],
        "usage": {
            "completion_tokens": 448,
            "prompt_tokens": 697,
            "total_tokens": 1145,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "What is the present value (PV) of an investment that provides \u20ac300 yearly for five years, starting from this very moment, when discounted at an annual rate of 4%? Answer to three decimal places.",
        "python_solution": "def solution():\n    A = 300\n    r = 0.04\n    N = 5\n    PV = A*((1-(1/((1+r)**N)))/r)*(1+r)\n    return PV",
        "ground_truth": 1388.969,
        "topic": "Quantitative Analysis & Valuation",
        "statistics": {
            "number_statistics": {
                "args_numbers": 2,
                "question_numbers": 2,
                "context_numbers": 0,
                "total_numbers": 2
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 1,
                    "*": 2,
                    "/": 2,
                    "%": 0,
                    "**": 1
                },
                "total_operators": 8
            },
            "code_statistics": {
                "lines": 5,
                "parentheses": 12
            }
        },
        "difficulty": 4.477336814478207,
        "source": "FinanceMath-validation-39",
        "context": "[]",
        "question_id": "test-2068",
        "level": "hard",
        "output": [
            "To solve the problem, I'll compute the present value (PV) of an annuity due based on the given parameters. I will use the formula provided in the Python function `calculate_present_value_annuity_due`.\n\n### Step-by-Step Reasoning Using Emphasizing Constraints (EC):\n1. **Understand and Define Inputs:**  \n   - **Payment (\u20ac300):** This is the fixed annual cash inflow for 5 years.\n   - **Discount Rate (4%):** This is equivalent to 0.04 in decimal form.\n   - **Periods (5 years):** The investment provides payments for a total of 5 years.\n\n2. **Constraints and Use:**  \n   - **Discount Rate in Decimal Form:** Since the discount rate is provided as 4%, we will input it as 0.04 for computation.\n   - **Precision:** The answer must be rounded to three decimal places because the problem explicitly requires precision up to this level.\n   - **Use of an Annuity Due Formula:** Payments occur at the beginning of each period, so an annuity due is appropriate. \n\n3. **Calculation:**  \n   Using the function `calculate_present_value_annuity_due`, I will:\n   - Substitute the payment (\u20ac300), discount rate (0.04), and periods (5).\n   - Compute the annuity factor.\n   - Use the annuity due formula to calculate the present value of the investment.\n   - Finally, round the result to three decimal places for accuracy.\n\nBelow is the implementation for solving this problem.\n\n```python\ndef solution():\n    # Define the function to calculate PV of an annuity due\n    def calculate_present_value_annuity_due(payment: float, discount_rate: float, periods: int) -> float:\n        if discount_rate <= -1:\n            raise ValueError(\"Discount rate must be greater than -1.\")\n        \n        # Calculate annuity factor\n        annuity_factor = (1 - (1 / ((1 + discount_rate) ** periods))) / discount_rate\n        \n        # Calculate present value\n        present_value = payment * annuity_factor * (1 + discount_rate)\n        \n        return present_value\n\n    # Define variables name and value\n    payment = 300  # Fixed payment amount per year\n    discount_rate = 0.04  # Annual discount rate in decimal (4%)\n    periods = 5  # Number of payment periods (5 years)\n\n    # Do math calculation to get the answer\n    present_value = calculate_present_value_annuity_due(payment, discount_rate, periods)\n    \n    # Round the result to three decimal places\n    answer = round(present_value, 3)\n    \n    # Return the answer\n    return answer\n```"
        ],
        "retrieval_query": "What is the present value (PV) of an investment that provides \u20ac300 yearly for five years, starting from this very moment, when discounted at an annual rate of 4%? Answer to three decimal places.",
        "useful_functions": [
            "def calculate_present_value_annuity_due(payment: float, discount_rate: float, periods: int) -> float:\n    \"\"\"\n    Calculate the present value of an annuity due.\n\n    This function computes the present value (PV) of an annuity due, where payments\n    occur at the beginning of each period, using a specified discount rate. This is\n    commonly used in financial calculations to determine the value of investment\n    cash flows that occur at the start of each period.\n\n    Args:\n        payment (float): The fixed payment amount received at the beginning of each period.\n        discount_rate (float): The annual discount rate expressed as a decimal (e.g., 0.04 for 4%).\n        periods (int): The total number of periods over which the annuity is received.\n\n    Returns:\n        present_value (float): The present value of the annuity due.\n\n    Notes:\n        - This function assumes payments occur at the beginning of each period, i.e., an annuity due.\n        - The discount rate must be greater than -1 to ensure a valid result.\n        - The function is applicable for fixed, equal payments over each period.\n        - The function does not account for taxes, inflation, or other economic variances.\n    \"\"\"\n    if discount_rate <= -1:\n        raise ValueError(\"Discount rate must be greater than -1.\")\n\n    annuity_factor = (1 - (1 / ((1 + discount_rate) ** periods))) / discount_rate\n    present_value = payment * annuity_factor * (1 + discount_rate)\n\n    return present_value"
        ],
        "usage": {
            "completion_tokens": 554,
            "prompt_tokens": 705,
            "total_tokens": 1259,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "An investment manager has a collection of options on XYZ, a stock that doesn't pay dividends. The collection consists of 5,000 deep in-the-money call options on XYZ and 20,000 deep out-of-the-money call options on XYZ. The portfolio also holds 10,000 future contracts on XYZ. Currently, XYZ is trading at USD 52. Given that there are 252 trading days annually, the volatility of XYZ is 12% per year, and each of the option and future contracts represents one share of XYZ, what is the 1-day 99% VaR of the portfolio (where the Z-score corresponding to the 99% confidence level is 2.326)? Answer to three decimal places.",
        "python_solution": "def solution():\n    position_delta = 1*5000 + 0*20000 + 1*10000\n    price_per_share = 52\n    volatility = 0.12\n    confidence_level = 2.326\n    trading_days = 252\n\n    var = confidence_level * price_per_share * position_delta * volatility * (1/trading_days)**0.5\n\n    return var",
        "ground_truth": 13714.668,
        "topic": "Risk Management",
        "statistics": {
            "number_statistics": {
                "args_numbers": 4,
                "question_numbers": 10,
                "context_numbers": 0,
                "total_numbers": 10
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 0,
                    "*": 7,
                    "/": 1,
                    "%": 0,
                    "**": 1
                },
                "total_operators": 11
            },
            "code_statistics": {
                "lines": 7,
                "parentheses": 2
            }
        },
        "difficulty": 4.477336814478207,
        "source": "FinanceMath-validation-172",
        "context": "[]",
        "question_id": "test-2069",
        "level": "hard",
        "output": [
            "To solve the problem step by step, let's emphasize the constraints and thoroughly break it down using the \"Emphasizing Constraints (EC)\" reasoning technique:\n\n1. **Step 1: Portfolio Summary**\n   - The portfolio holds:\n     - 5,000 deep in-the-money call options on XYZ stock.\n     - 20,000 deep out-of-the-money call options on XYZ stock.\n     - 10,000 futures contracts on XYZ stock.\n   - Each option or future represents one share, so:\n     - 5,000 * 52 = USD 260,000 effectively exposed via in-the-money calls.\n     - 10,000 * 52 = USD 520,000 exposed via futures contracts.\n     - Deep out-of-the-money call options (20,000) contribute nothing to delta because they are unlikely to be exercised.\n   - Therefore, the effective exposure of the portfolio is the sum of the in-the-money options and futures exposures.\n\n2. **Step 2: Portfolio Delta**\n   - In deep in-the-money calls, delta \u2248 1 (acts as if fully exposed to stock price movements).\n   - Delta for deep out-of-the-money calls \u2248 0.\n   - Futures contracts have a delta of 1.\n   - Total portfolio delta = (5,000 * 1) + (10,000 * 1) = 15,000.\n\n3. **Step 3: 1-Day Portfolio Value at Risk (VaR)**\n   - The formula for VaR is:\n     \\[\n     \\text{VaR} = \\text{Z-Score} \\times \\text{Portfolio Value} \\times \\text{Volatility of XYZ (1-day)}\n     \\]\n   - 1-day volatility can be calculated as:\n     \\[\n     \\text{1-day Volatility} = \\text{Annual Volatility} \\div \\sqrt{\\text{Trading Days per Year}}\n     \\]\n   - Here, the Z-Score for a 99% confidence level is 2.326.\n\n4. **Step 4: Emphasize Constraints**\n   - Ensure correct units (USD for monetary values).\n   - Convert annual volatility to daily volatility.\n   - Include only securities with non-zero delta.\n   - Round the final result to three decimal places.\n\nWith these steps, let's write the Python program:\n\n```python\ndef solution():\n    # Define variable inputs\n    current_price = 52  # Current price of XYZ stock in USD\n    in_the_money_calls = 5000  # Deep in-the-money call options (delta \u2248 1)\n    futures = 10000  # Futures contracts (delta = 1)\n    out_of_the_money_calls = 20000  # Deep out-of-the-money call options (delta \u2248 0)\n    \n    annual_volatility = 0.12  # Annual volatility (12% per year)\n    trading_days_per_year = 252  # Number of trading days per year\n    z_score_99_percent = 2.326  # Z-Score corresponding to 99% confidence level\n    \n    # Step 1: Calculate total delta exposure\n    total_delta = (in_the_money_calls * 1) + (futures * 1)  # Only ITM calls and futures contribute\n    \n    # Step 2: Calculate 1-day volatility\n    daily_volatility = annual_volatility / (trading_days_per_year ** 0.5)\n    \n    # Step 3: Calculate total portfolio value (exposure to XYZ)\n    portfolio_value = total_delta * current_price  # Delta-weighted exposure\n    \n    # Step 4: Calculate 1-day 99% VaR\n    var_1_day_99 = z_score_99_percent * portfolio_value * daily_volatility\n    \n    # Step 5: Return final result rounded to 3 decimal places\n    return round(var_1_day_99, 3)\n```"
        ],
        "retrieval_query": "An investment manager has a collection of options on XYZ, a stock that doesn't pay dividends. The collection consists of 5,000 deep in-the-money call options on XYZ and 20,000 deep out-of-the-money call options on XYZ. The portfolio also holds 10,000 future contracts on XYZ. Currently, XYZ is trading at USD 52. Given that there are 252 trading days annually, the volatility of XYZ is 12% per year, and each of the option and future contracts represents one share of XYZ, what is the 1-day 99% VaR of the portfolio (where the Z-score corresponding to the 99% confidence level is 2.326)? Answer to three decimal places.",
        "useful_functions": [],
        "usage": {
            "completion_tokens": 816,
            "prompt_tokens": 473,
            "total_tokens": 1289,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "Gabrielle Hope invests $250,000 in Bacca Fund, a fund of hedge funds with 4 and 12\" fee structure. Management and incentive fees are calculated independently at the end of each year. One of Bracca Fund's investments is the Torp fund, which has generated a fund value of $320,000 at the end of the first year. What is the annual return to an investor in Bacca Answer as a percentage with a single decimal place.",
        "context": "",
        "statistics": {
            "number_statistics": {
                "question_numbers": 4,
                "context_numbers": 0,
                "total_numbers": 4
            },
            "operator_statistics": {
                "operators": {
                    "+": 1,
                    "-": 3,
                    "*": 3,
                    "/": 1,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 8
            },
            "code_statistics": {
                "lines": 7,
                "parentheses": 8
            }
        },
        "difficulty": 4.477336814478207,
        "ground_truth": 19.5,
        "source": "FinCode-test-12",
        "python_solution": "investment = 250000\nfund_value = 320000\nfees = lambda x: 0.04 * x + 0.12 * (x - 250000)\nfee_amount = fees(fund_value)\nnet_return = fund_value - fee_amount\nannual_return = (net_return / investment) - 1\nround(annual_return * 100, 1)",
        "question_id": "test-2070",
        "level": "hard",
        "output": [
            "To solve the problem step by step:\n\n### Step 1: Understand the Fee Structure\n- **4 and 12% fee structure**:\n  - **Management fee**: 4% of the fund's value is deducted as a management fee.\n  - **Incentive (performance) fee**: 12% of the profits earned during the year is deducted as an incentive fee.\n  - Both fees are computed separately.\n\n### Step 2: Define the Required Formula\nGabrielle Hope's investment generates a return, which is influenced by fund fees:\n1. The initial investment amount is $250,000.\n2. At the end of the first year, the fund's value grows to $320,000.\n3. To find her net return after fees, compute:\n   - Management Fee = 4% of $320,000.\n   - Profit = $320,000 - $250,000 (ending fund value - initial investment).\n   - Incentive Fee = 12% of the profit ($70,000 in this case).\n4. Subtract the computed fees from the ending fund value to compute the investor's net value.\n5. Compute the percentage return on the amount ($250,000).\n\n### Step 3: Adhere to Constraints\n- Return value should be in percentage form, rounded to one decimal place.\n\n### Step 4: Create the Solution Program\nUsing the above reasoning, we can now calculate the net return. Here's the Python program:\n\n```python\ndef solution():\n    # Define variables name and value\n    initial_investment = 250000  # Initial investment in dollars\n    ending_fund_value = 320000  # Fund's value at the end of the year in dollars\n    management_fee_rate = 0.04  # 4% management fee\n    incentive_fee_rate = 0.12  # 12% incentive fee\n\n    # Step 1: Calculate the profit\n    profit = ending_fund_value - initial_investment\n\n    # Step 2: Calculate the management fee\n    management_fee = ending_fund_value * management_fee_rate\n\n    # Step 3: Calculate the incentive fee\n    incentive_fee = profit * incentive_fee_rate\n\n    # Step 4: Calculate the net value after fees\n    net_value_after_fees = ending_fund_value - management_fee - incentive_fee\n\n    # Step 5: Calculate the net return percentage\n    net_return_percentage = ((net_value_after_fees - initial_investment) / initial_investment) * 100\n\n    # Return the answer rounded to one decimal place\n    return round(net_return_percentage, 1)\n```"
        ],
        "retrieval_query": "Gabrielle Hope invests $250,000 in Bacca Fund, a fund of hedge funds with 4 and 12\" fee structure. Management and incentive fees are calculated independently at the end of each year. One of Bracca Fund's investments is the Torp fund, which has generated a fund value of $320,000 at the end of the first year. What is the annual return to an investor in Bacca Answer as a percentage with a single decimal place.",
        "useful_functions": [
            "def calculate_ending_capital_position(initial_assets: float, last_year_return: float, \n                                      current_fund_value: float, management_fee_rate: float, \n                                      incentive_fee_rate: float) -> float:\n    \"\"\"\n    Calculate the ending capital position of a hedge fund after applying management and incentive fees.\n\n    This function computes the ending capital position of a hedge fund given its initial assets, \n    last year's return, current fund value, and specified fee structure. The management fee is calculated \n    based on the current fund value and the incentive fee is applicable only if the current fund value \n    exceeds the high water mark established from the previous year.\n\n    Args:\n        initial_assets (float): The assets under management at the start of the previous year.\n        last_year_return (float): The return rate achieved by the fund last year.\n        current_fund_value (float): The value of the fund at the end of the current year before any fees \n                                    are deducted.\n        management_fee_rate (float): The rate at which management fees are calculated (e.g., 0.02 for 2%).\n        incentive_fee_rate (float): The rate at which incentive fees are calculated on profits exceeding \n                                    the high water mark (e.g., 0.3 for 30%).\n\n    Returns:\n        ending_capital (float): The ending capital position after applying relevant fees.\n\n    Notes:\n        - Applicability: This function is applicable for hedge funds with a specified fee structure \n                         involving management and incentive fees.\n        - Constraints: The incentive fee is only applied if the fund's current value exceeds the high water mark.\n        - Considerations: Ensure the rates are provided in decimal form (e.g., 0.02 for 2%).\n    \"\"\"\n    profit = initial_assets * last_year_return\n    total_after_profit = initial_assets + profit\n    management_fee_last_year = total_after_profit * management_fee_rate\n    incentive_fee_last_year = profit * incentive_fee_rate\n    high_water_mark = total_after_profit - (management_fee_last_year + incentive_fee_last_year)\n    \n    current_management_fee = current_fund_value * management_fee_rate\n    current_incentive_fee = 0\n    if current_fund_value > high_water_mark:\n        current_incentive_fee = (current_fund_value - high_water_mark) * incentive_fee_rate\n    \n    ending_capital = current_fund_value - current_management_fee - current_incentive_fee\n    return round(ending_capital / 10**6, 1)",
            "def calculate_investor_net_return(aum_end_of_year: float, high_water_mark: float, \n                                  management_fee_rate: float, previous_assets_value: float, \n                                  incentive_fee_rate: float, hurdle_rate: float) -> float:\n    \"\"\"\n    Calculate the net return for an investor under a \"2 and 20\" fee arrangement.\n\n    This function determines the net return for an investor, given the end-of-year\n    assets under management (AUM), a high-water mark, management and incentive fee rates, \n    a hurdle rate, and the initial value of assets. It accounts for management fees and \n    calculates incentive fees only if the AUM surpasses the high-water mark adjusted by the hurdle rate.\n\n    Args:\n        aum_end_of_year (float): The assets under management at the end of the year.\n        high_water_mark (float): The benchmark value of assets before fees can be collected.\n        management_fee_rate (float): The rate applied to AUM for management fees.\n        previous_assets_value (float): The value of assets at the start of the year.\n        incentive_fee_rate (float): The rate applied to returns above the high-water mark.\n        hurdle_rate (float): The minimum rate of return required before incentive fees apply.\n\n    Returns:\n        net_return_percentage (float): The net return for the investor, expressed as a percentage.\n\n    Notes:\n        - Applicability: Suitable for investment firms using \"2 and 20\" fee structures.\n        - Constraints: Assumes positive values for all inputs.\n        - Considerations: Always round the final result to three decimal places for percentage representation.\n    \"\"\"\n    management_fee = aum_end_of_year * management_fee_rate\n    \n    if aum_end_of_year < high_water_mark * (1 + hurdle_rate):\n        total_fee = management_fee\n    else:\n        total_fee = management_fee + (aum_end_of_year - high_water_mark * (1 + hurdle_rate)) * incentive_fee_rate\n\n    net_return = (aum_end_of_year - total_fee) / previous_assets_value - 1\n\n    return round(net_return * 100, 3)",
            "def calculate_hedge_fund_net_return(initial_investment: float, growth_rate: float, \n                                    management_fee_rate: float, incentive_rate: float, \n                                    hurdle_rate: float) -> float:\n    \"\"\"\n    Calculate the net return for an investor in a hedge fund given various parameters.\n\n    This function computes the net return for an investor in a hedge fund with specified\n    initial investment, growth rate, fee structure, and hurdle rate. It factors in both\n    the management and incentive fees to determine the investor's net return.\n\n    Args:\n        initial_investment (float): The initial amount invested in the hedge fund.\n        growth_rate (float): The percentage increase in assets by the end of the year.\n        management_fee_rate (float): The management fee rate applied to year-end assets.\n        incentive_rate (float): The incentive fee rate on returns exceeding the hurdle rate.\n        hurdle_rate (float): The minimum acceptable return rate before incentive fees apply.\n\n    Returns:\n        net_return (float): The net return for the investor after fees, in millions.\n\n    Notes:\n        - This calculation assumes that the management fee is based on year-end assets \n          and the incentive fee is based on returns above the hurdle rate after management fees.\n        - All rates should be provided as decimals (e.g., 0.35 for 35%).\n        - Make sure that initial_investment and all rates are realistic and positive values.\n    \"\"\"\n    end_year_aum = initial_investment * (1 + growth_rate)\n    management_fee = end_year_aum * management_fee_rate\n    net_year_end = end_year_aum - management_fee\n    \n    hurdle_amount = initial_investment * (1 + hurdle_rate)\n    if net_year_end > hurdle_amount:\n        incentive_fee = (net_year_end - hurdle_amount) * incentive_rate\n    else:\n        incentive_fee = 0\n    \n    total_fees = management_fee + incentive_fee\n    net_return = end_year_aum - total_fees - initial_investment\n    \n    return round(net_return, 2)"
        ],
        "usage": {
            "completion_tokens": 550,
            "prompt_tokens": 1810,
            "total_tokens": 2360,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-1095",
        "article_title": "Hurdle Rate",
        "function": "def calculate_wacc(equity_value: float, equity_cost: float, debt_value: float, debt_cost: float, preferred_value: float = 0.0, preferred_cost: float = 0.0) -> float:\n    \"\"\"\n    Calculate the Weighted Average Cost of Capital (WACC).\n\n    This function calculates the WACC, which is the average rate of return a company must earn on its\n    investments to satisfy its stakeholders (equity, debt, and optionally preferred stock).\n\n    Args:\n        equity_value (float): The market value of the company's equity.\n        equity_cost (float): The cost of equity (expected return).\n        debt_value (float): The market value of the company's debt.\n        debt_cost (float): The cost of debt (interest rate).\n        preferred_value (float, optional): The market value of preferred stock. Defaults to 0.0.\n        preferred_cost (float, optional): The cost of preferred stock (dividend rate). Defaults to 0.0.\n\n    Returns:\n        wacc (float): The weighted average cost of capital.\n\n    Notes:\n        - Applicability: This function is applicable for companies looking to calculate their WACC as a benchmark\n          for investment evaluation.\n        - Constraints: Assumes all values provided are non-negative and that the sum of equity_value, debt_value,\n          and preferred_value is greater than zero.\n        - Considerations: The costs used should reflect market conditions and expectations; tax shields are not\n          considered in this basic version.\n    \"\"\"\n    total_value = equity_value + debt_value + preferred_value\n    if total_value == 0:\n        raise ValueError(\"The sum of equity, debt, and preferred stock values must be greater than zero.\")\n\n    weight_equity = equity_value / total_value\n    weight_debt = debt_value / total_value\n    weight_preferred = preferred_value / total_value\n\n    wacc = (weight_equity * equity_cost) + (weight_debt * debt_cost) + (weight_preferred * preferred_cost)\n    \n    return wacc",
        "statistics": {
            "number_statistics": {
                "args_numbers": 6,
                "question_numbers": 0,
                "context_numbers": 6,
                "total_numbers": 6
            },
            "operator_statistics": {
                "operators": {
                    "+": 4,
                    "-": 0,
                    "*": 3,
                    "/": 3,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 10
            },
            "code_statistics": {
                "lines": 6,
                "parentheses": 6
            }
        },
        "difficulty": 4.499809670330265,
        "context": "A technology company named TechInnovate is evaluating its cost of capital to assess future investments. The company has raised capital in different forms: $150 million from equity investors, $100 million through loans, and it has issued $50 million in preferred stock. The cost of equity is assessed to be 12%, the cost of the debt is 5%, and the cost of the preferred stock is 8%. TechInnovate wants to compute its Weighted Average Cost of Capital (WACC) to determine the minimum return rate it should aim for in its investment projects.",
        "question": "What is TechInnovate's Weighted Average Cost of Capital (WACC)? Provide your answer as a percentage rounded to two decimal places.",
        "python_solution": "def solution():\n    # Define the given market values and costs\n    equity_value = 150_000_000  # Equity capital in dollars\n    equity_cost = 0.12  # Cost of equity expressed as a decimal\n    debt_value = 100_000_000  # Debt capital in dollars\n    debt_cost = 0.05  # Cost of debt expressed as a decimal\n    preferred_value = 50_000_000  # Preferred stock value in dollars\n    preferred_cost = 0.08  # Cost of preferred stock expressed as a decimal\n\n    # Calculate the total market value of all capital\n    total_value = equity_value + debt_value + preferred_value\n\n    # Compute the weights for each component\n    weight_equity = equity_value / total_value\n    weight_debt = debt_value / total_value\n    weight_preferred = preferred_value / total_value\n\n    # Calculate WACC\n    wacc = (weight_equity * equity_cost) + (weight_debt * debt_cost) + (weight_preferred * preferred_cost)\n\n    # Return WACC rounded to two decimal places as a percentage\n    return round(wacc * 100, 2)",
        "ground_truth": 9.0,
        "source": "FinanceReasoning-test-125",
        "question_id": "test-2071",
        "level": "hard",
        "output": [
            "To calculate TechInnovate's Weighted Average Cost of Capital (WACC), we will compute the weighted average cost of its equity, debt, and preferred stock. The formula for WACC is as follows:\n\n\\[\n\\text{WACC} = \\left(\\frac{\\text{Equity Value}}{\\text{Total Capital}}\\right) \\times \\text{Cost of Equity} + \\left(\\frac{\\text{Debt Value}}{\\text{Total Capital}}\\right) \\times \\text{Cost of Debt} \\times (1 - \\text{Tax Rate}) + \\left(\\frac{\\text{Preferred Value}}{\\text{Total Capital}}\\right) \\times \\text{Cost of Preferred Stock}\n\\]\n\n### Step-by-step approach:\n1. **Understand the constraints**:\n   - All monetary values provided are non-negative.\n   - WACC is expressed as a percentage to two decimal places.\n   - The tax rate is not provided in the problem, which implies that debt costs are considered pre-tax. Thus, we do not apply tax adjustments to the debt cost.\n\n2. **Define the inputs**:\n   - Equity Value = $150 million\n   - Debt Value = $100 million\n   - Preferred Value = $50 million\n   - Cost of Equity = 12% or 0.12\n   - Cost of Debt = 5% or 0.05 (pre-tax since no tax rate is provided)\n   - Cost of Preferred Stock = 8% or 0.08\n\n3. **Compute the total capital**:\n   - Total Capital = Equity Value + Debt Value + Preferred Value\n   \n4. **Compute the weights for each component**:\n   - Weight of Equity = Equity Value / Total Capital\n   - Weight of Debt = Debt Value / Total Capital\n   - Weight of Preferred Stock = Preferred Value / Total Capital\n   \n5. **Calculate weighted contributions to WACC**:\n   - Contribution from equity = Weight of Equity \u00d7 Cost of Equity\n   - Contribution from debt = Weight of Debt \u00d7 Cost of Debt\n   - Contribution from preferred stock = Weight of Preferred Stock \u00d7 Cost of Preferred Stock\n   \n6. **Sum the weighted contributions to compute WACC**.\n\n7. **Round the resulting WACC to two decimal places** as specified.\n\nHere is the Python program implementing this approach:\n\n```python\ndef solution():\n    # Define variables name and value\n    equity_value = 150  # in million USD\n    debt_value = 100    # in million USD\n    preferred_value = 50  # in million USD\n    cost_of_equity = 0.12  # 12% cost of equity\n    cost_of_debt = 0.05    # 5% cost of debt (pre-tax as no tax rate provided)\n    cost_of_preferred = 0.08  # 8% cost of preferred stock\n    \n    # Calculate total capital\n    total_value = equity_value + debt_value + preferred_value\n    \n    # Calculate weights\n    weight_equity = equity_value / total_value\n    weight_debt = debt_value / total_value\n    weight_preferred = preferred_value / total_value\n    \n    # Calculate WACC (Weighted Average Cost of Capital)\n    wacc = (weight_equity * cost_of_equity) + (weight_debt * cost_of_debt) + (weight_preferred * cost_of_preferred)\n    \n    # Round to two decimal places and return as percentage\n    return round(wacc * 100, 2)\n```"
        ],
        "retrieval_query": "What is TechInnovate's Weighted Average Cost of Capital (WACC)? Provide your answer as a percentage rounded to two decimal places.",
        "useful_functions": [
            "def calculate_weighted_average_cost_of_capital(equity_cost: float, debt_cost: float, \n                                               equity_value: float, debt_value: float, \n                                               tax_rate: float) -> float:\n    \"\"\"\n    Calculate the Weighted Average Cost of Capital (WACC) for a company.\n\n    This function computes the WACC, which is a measure of a company's cost of \n    capital from all sources, including debt and equity. It is widely used in \n    corporate finance to evaluate investment opportunities and financial \n    strategies.\n\n    Args:\n        equity_cost (float): The cost of equity capital, often derived from \n                             models like CAPM.\n        debt_cost (float): The after-tax cost of debt.\n        equity_value (float): The market value of the company's equity.\n        debt_value (float): The market value of the company's debt.\n        tax_rate (float): The corporate tax rate applicable to the company.\n\n    Returns:\n        wacc (float): The weighted average cost of capital.\n\n    Notes:\n        - Applicability: Applies to companies with both debt and equity financing.\n        - Constraints: Assumes market values are available and tax rate is constant.\n        - Considerations: Accurate cost estimates and market values are critical.\n    \"\"\"\n    total_value = equity_value + debt_value\n    wacc = ((equity_value / total_value) * equity_cost) + \\\n           ((debt_value / total_value) * debt_cost * (1 - tax_rate))\n    return wacc",
            "def calculate_wacc(equity_market_value: float, debt_market_value: float, cost_of_equity: float, \n                   cost_of_debt: float, tax_rate: float) -> float:\n    \"\"\"\n    Calculate the Weighted Average Cost of Capital (WACC) for a company.\n\n    This function computes the WACC, which represents a company's average after-tax\n    cost of capital from all sources, including equity and debt. It combines the cost \n    of both equity and debt, weighted by their respective proportions in the total \n    capital used by the company.\n\n    Args:\n        equity_market_value (float): Market value of the firm's equity.\n        debt_market_value (float): Market value of the firm's debt.\n        cost_of_equity (float): Cost of equity, representing the required rate \n                                of return for equity investors.\n        cost_of_debt (float): Cost of debt, representing the effective rate paid \n                              on the company's issued debt.\n        tax_rate (float): Corporate tax rate, used to calculate the after-tax cost of debt.\n\n    Returns:\n        wacc (float): The calculated Weighted Average Cost of Capital (WACC).\n\n    Notes:\n        - Applicability: Useful for assessing the cost of capital for businesses \n          that use both equity and debt financing.\n        - Constraints: The equity and debt market values should be positive and \n          represent the total financing. The tax rate should be between 0 and 1.\n        - Considerations: It assumes taxes are constant and ignores complications \n          such as different classes of equity with different costs.\n    \"\"\"\n    total_value = equity_market_value + debt_market_value\n    equity_weight = equity_market_value / total_value\n    debt_weight = debt_market_value / total_value\n    after_tax_cost_of_debt = cost_of_debt * (1 - tax_rate)\n\n    wacc = (equity_weight * cost_of_equity) + (debt_weight * after_tax_cost_of_debt)\n    \n    return wacc",
            "def calculate_wacc(equity_value: float, equity_cost: float, debt_value: float, debt_cost: float, preferred_value: float = 0.0, preferred_cost: float = 0.0) -> float:\n    \"\"\"\n    Calculate the Weighted Average Cost of Capital (WACC).\n\n    This function calculates the WACC, which is the average rate of return a company must earn on its\n    investments to satisfy its stakeholders (equity, debt, and optionally preferred stock).\n\n    Args:\n        equity_value (float): The market value of the company's equity.\n        equity_cost (float): The cost of equity (expected return).\n        debt_value (float): The market value of the company's debt.\n        debt_cost (float): The cost of debt (interest rate).\n        preferred_value (float, optional): The market value of preferred stock. Defaults to 0.0.\n        preferred_cost (float, optional): The cost of preferred stock (dividend rate). Defaults to 0.0.\n\n    Returns:\n        wacc (float): The weighted average cost of capital.\n\n    Notes:\n        - Applicability: This function is applicable for companies looking to calculate their WACC as a benchmark\n          for investment evaluation.\n        - Constraints: Assumes all values provided are non-negative and that the sum of equity_value, debt_value,\n          and preferred_value is greater than zero.\n        - Considerations: The costs used should reflect market conditions and expectations; tax shields are not\n          considered in this basic version.\n    \"\"\"\n    total_value = equity_value + debt_value + preferred_value\n    if total_value == 0:\n        raise ValueError(\"The sum of equity, debt, and preferred stock values must be greater than zero.\")\n\n    weight_equity = equity_value / total_value\n    weight_debt = debt_value / total_value\n    weight_preferred = preferred_value / total_value\n\n    wacc = (weight_equity * equity_cost) + (weight_debt * debt_cost) + (weight_preferred * preferred_cost)\n    \n    return wacc"
        ],
        "usage": {
            "completion_tokens": 724,
            "prompt_tokens": 1619,
            "total_tokens": 2343,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-313",
        "article_title": "Vertical Equity",
        "function": "def calculate_progressive_tax(income: float, brackets: list, rates: list) -> float:\n    \"\"\"\n    Calculate the tax liability using a progressive tax system.\n\n    This function computes the tax liability for a given income based on a \n    progressive tax system, where the tax rate increases with income brackets.\n\n    Args:\n        income (float): The total income subject to taxation.\n        brackets (list): A sorted list of income thresholds for tax brackets.\n        rates (list): A list of tax rates corresponding to each bracket.\n\n    Returns:\n        tax_liability (float): The calculated tax liability.\n\n    Notes:\n        - Applicability: Suitable for tax systems using progressive rates.\n        - Constraints: The brackets list should be sorted in ascending order, \n          with a rate for each bracket.\n        - Considerations: The function assumes brackets and rates are aligned, \n          with each rate applicable to income above the previous bracket and \n          up to the current bracket.\n    \"\"\"\n    if len(brackets) != len(rates):\n        raise ValueError(\"The number of brackets must match the number of rates.\")\n\n    tax_liability = 0.0\n    previous_bracket_limit = 0.0\n\n    for i, (bracket, rate) in enumerate(zip(brackets, rates)):\n        if income > bracket:\n            tax_liability += (bracket - previous_bracket_limit) * rate\n            previous_bracket_limit = bracket\n        else:\n            tax_liability += (income - previous_bracket_limit) * rate\n            break\n    \n    return tax_liability",
        "statistics": {
            "number_statistics": {
                "args_numbers": 3,
                "question_numbers": 0,
                "context_numbers": 9,
                "total_numbers": 9
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 2,
                    "*": 2,
                    "/": 0,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 6
            },
            "code_statistics": {
                "lines": 10,
                "parentheses": 10
            }
        },
        "difficulty": 4.499809670330265,
        "context": "John has an annual taxable income of $75,000. The government uses a progressive tax system with the following income brackets and corresponding rates: \n- 10% for income up to $20,000\n- 15% for income from $20,001 to $50,000\n- 20% for income from $50,001 to $100,000\n\nUsing the given progressive tax system, calculate the total tax liability for John's income.",
        "question": "What is John's total tax liability? Answer to the nearest dollar.",
        "python_solution": "def solution():\n    # Taxable income\n    income = 75000\n    \n    # Define tax brackets and rates\n    brackets = [20000, 50000, 100000]  # Upper limit of each bracket\n    rates = [0.10, 0.15, 0.20]         # Tax rates corresponding to brackets\n\n    # Initialize the tax liability and the previous bracket's upper limit\n    tax_liability = 0.0\n    previous_bracket_limit = 0.0\n\n    # Iterate through each tax bracket\n    for bracket, rate in zip(brackets, rates):\n        if income > bracket:\n            # Calculate tax for the full bracket\n            tax_liability += (bracket - previous_bracket_limit) * rate\n            previous_bracket_limit = bracket\n        else:\n            # Calculate tax for the part of the bracket that includes the remaining income\n            tax_liability += (income - previous_bracket_limit) * rate\n            break\n    \n    # Return the final tax liability, rounded to the nearest dollar\n    return round(tax_liability)\n\n# Running the solution function will compute the required answer\nprint(solution())",
        "ground_truth": 11500,
        "source": "FinanceReasoning-test-150",
        "question_id": "test-2072",
        "level": "hard",
        "output": [
            "### Step-by-Step Solution using Emphasizing Constraints (EC)\n\n1. **Understanding the Progressive Tax System:**\n   - Income is divided into brackets, with each bracket taxed at a specific rate.\n   - If income lies in a particular bracket, it will be taxed up to that bracket limit, and the remaining income spills over to the next bracket.\n   - We need to ensure correctness by strictly adhering to the progressive tax system's constraints.\n\n2. **Constraints:**\n   - The tax brackets and rates are:\n     - 10% for income up to $20,000\n     - 15% for income from $20,001 to $50,000\n     - 20% for income from $50,001 to $100,000\n   - Tax brackets are represented as boundaries for the taxed portions.\n   - Ensure the taxable income of $75,000 respects these brackets (i.e., split calculations across the correct ranges).\n   - Rounding the final tax liability to the nearest dollar is a precision constraint mentioned in the problem.\n   - Ensure calculations are performed in dollars, not percentages; percentages need to be converted to decimals for calculations.\n\n3. **Plan and Formula for Calculation:**\n   - Tax liability is calculated progressively:\n     1. Calculate tax for the first bracket (0 \u2013 $20,000) at 10%.\n     2. Calculate tax for the second bracket ($20,001 \u2013 $50,000) at 15%.\n     3. Calculate tax for the portion of income ($50,001 \u2013 $75,000) at 20%.\n   - Sum these tax amounts to find the total tax liability.\n\n4. **Implementation:**\n   - Use simple arithmetic to calculate the tax for each bracket.\n   - Implement the logic using a conditional flow to account for progressive brackets.\n   - Return the result after rounding it to the nearest dollar.\n\n### Python Program\nWith the above analysis, the below program calculates John's total tax liability:\n\n```python\ndef solution():\n    # Define variables name and value\n    taxable_income = 75000\n    \n    # Define the tax brackets and rates\n    brackets = [20000, 50000, 100000]  # Upper bounds of the brackets\n    rates = [0.10, 0.15, 0.20]        # Tax rates for the respective brackets\n    \n    # Initialize tax liability to 0\n    tax_liability = 0.0\n    \n    # Tax calculation for the first bracket (0 - $20,000)\n    if taxable_income > brackets[0]:\n        tax_liability += (brackets[0] - 0) * rates[0]\n    else:\n        tax_liability += taxable_income * rates[0]\n        return round(tax_liability)\n    \n    # Tax calculation for the second bracket ($20,001 - $50,000)\n    if taxable_income > brackets[1]:\n        tax_liability += (brackets[1] - brackets[0]) * rates[1]\n    else:\n        tax_liability += (taxable_income - brackets[0]) * rates[1]\n        return round(tax_liability)\n    \n    # Tax calculation for the third bracket ($50,001 - $75,000)\n    if taxable_income > brackets[2]:\n        tax_liability += (brackets[2] - brackets[1]) * rates[2]\n    else:\n        tax_liability += (taxable_income - brackets[1]) * rates[2]\n    \n    # Return the final tax liability, rounded to the nearest dollar\n    return round(tax_liability)\n```\n\n### Explanation of Program Logic:\n1. The input taxable income is divided into portions that correspond to each tax bracket.\n2. The program sequentially calculates the tax liability for each bracket:\n    - For the first bracket, it taxes income between $0 and $20,000 at 10%.\n    - For the second bracket, it taxes income between $20,001 and $50,000 at 15%.\n    - For the third bracket, it taxes income between $50,001 and $75,000 at 20%.\n3. Only the income falling into the corresponding bracket is taxed at the applicable rate.\n4. The total tax liability is rounded to the nearest dollar and returned."
        ],
        "retrieval_query": "What is John's total tax liability? Answer to the nearest dollar.",
        "useful_functions": [
            "def calculate_tax_liability(taxable_income: float, tax_brackets: list, tax_rates: list) -> float:\n    \"\"\"\n    Calculate the tax liability based on taxable income and tax brackets.\n\n    This function calculates the tax liability using a progressive tax system,\n    where different portions of income are taxed at different rates.\n\n    Args:\n        taxable_income (float): The taxable income on which taxes are to be calculated.\n        tax_brackets (list): The income thresholds for each tax rate.\n        tax_rates (list): The tax rates corresponding to each tax bracket.\n\n    Returns:\n        tax_liability (float): The total tax liability.\n\n    Notes:\n        - Applicability: Useful for determining taxes using U.S.-style progressive tax systems.\n        - Constraints: Tax brackets and tax rates should have the same length.\n        - Considerations: Ensure that tax brackets are ordered in ascending order.\n    \"\"\"\n    if len(tax_brackets) != len(tax_rates):\n        raise ValueError(\"Tax brackets and tax rates must have the same length.\")\n    \n    tax_liability = 0.0\n    for i, rate in enumerate(tax_rates):\n        if i == 0:\n            lower_bound = 0\n        else:\n            lower_bound = tax_brackets[i-1]\n        \n        upper_bound = tax_brackets[i]\n        \n        if taxable_income > lower_bound:\n            amount_to_tax = min(taxable_income, upper_bound) - lower_bound\n            tax_liability += amount_to_tax * rate\n    \n    if taxable_income > tax_brackets[-1]:\n        tax_liability += (taxable_income - tax_brackets[-1]) * tax_rates[-1]\n    \n    return tax_liability",
            "def apply_marginal_tax_rate(income: float, tax_brackets: list) -> float:\n    \"\"\"\n    Calculate tax liability using marginal tax rates.\n\n    This function applies the appropriate marginal tax rates to calculate the total\n    tax liability for a given income based on provided tax brackets.\n\n    Args:\n        income (float): The total income to be taxed.\n        tax_brackets (list): A list of tuples where each tuple contains the income limit\n                             and the tax rate (e.g., [(limit1, rate1), (limit2, rate2), ...]).\n\n    Returns:\n        tax_liability (float): The total tax liability based on the income and tax brackets.\n\n    Notes:\n        - Applicability: Useful for calculating taxes for individuals and businesses.\n        - Constraints: Ensure the tax brackets are sorted in ascending order of income limits.\n        - Considerations: This does not account for tax deductions or credits.\n    \"\"\"\n    tax_liability = 0.0\n    previous_limit = 0.0\n\n    for limit, rate in tax_brackets:\n        if income > limit:\n            tax_liability += (limit - previous_limit) * rate\n            previous_limit = limit\n        else:\n            tax_liability += (income - previous_limit) * rate\n            break\n\n    return tax_liability"
        ],
        "usage": {
            "completion_tokens": 885,
            "prompt_tokens": 1066,
            "total_tokens": 1951,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-2346",
        "article_title": "Arc Elasticity",
        "function": "def calculate_arc_elasticity_of_demand(initial_quantity: float, final_quantity: float, initial_price: float, final_price: float) -> float:\n    \"\"\"\n    Calculate the arc elasticity of demand.\n\n    This function computes the arc elasticity of demand which measures the elasticity\n    at the midpoint between two points on the demand curve.\n\n    Args:\n        initial_quantity (float): The initial quantity demanded.\n        final_quantity (float): The final quantity demanded.\n        initial_price (float): The initial price of the good or service.\n        final_price (float): The final price of the good or service.\n\n    Returns:\n        arc_elasticity (float): The arc elasticity value, indicating the average\n                                elasticity over the price and quantity range.\n\n    Notes:\n        - Arc elasticity provides a more accurate elasticity measure when the changes\n          in price and quantity are significant.\n        - The midpoint method eliminates the directional bias encountered in the basic\n          price elasticity calculation.\n        - Applicable for analyzing changes over a range rather than at a single point.\n    \"\"\"\n    midpoint_quantity = (initial_quantity + final_quantity) / 2\n    midpoint_price = (initial_price + final_price) / 2\n    \n    percent_change_in_quantity = (final_quantity - initial_quantity) / midpoint_quantity\n    percent_change_in_price = (final_price - initial_price) / midpoint_price\n    \n    arc_elasticity = percent_change_in_quantity / percent_change_in_price\n    \n    return arc_elasticity",
        "statistics": {
            "number_statistics": {
                "args_numbers": 4,
                "question_numbers": 2,
                "context_numbers": 4,
                "total_numbers": 6
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 2,
                    "*": 0,
                    "/": 5,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 9
            },
            "code_statistics": {
                "lines": 6,
                "parentheses": 8
            }
        },
        "difficulty": 4.499809670330265,
        "context": "A local popcorn vendor is studying the response of popcorn sales to changes in price at a summer festival. Initially, he sold popcorn at $5 per bag and observed that he could sell 150 bags on a typical day. To attract more customers and compete with other vendors, he reduced the price to $4 per bag. As a result, his sales increased to 200 bags per day.",
        "question": "What is the arc elasticity of demand for popcorn when the price changes from $5 to $4 per bag? Provide the answer as a decimal to two decimal places.",
        "python_solution": "def solution():\n    # Define initial and final quantities and prices\n    initial_quantity = 150  # Initial quantity demanded\n    final_quantity = 200    # Final quantity demanded\n    initial_price = 5.0     # Initial price per bag\n    final_price = 4.0       # Final price per bag\n\n    # Calculate midpoint values\n    midpoint_quantity = (initial_quantity + final_quantity) / 2\n    midpoint_price = (initial_price + final_price) / 2\n\n    # Calculate percentage changes\n    percent_change_in_quantity = (final_quantity - initial_quantity) / midpoint_quantity\n    percent_change_in_price = (final_price - initial_price) / midpoint_price\n\n    # Calculate arc elasticity of demand\n    arc_elasticity = percent_change_in_quantity / percent_change_in_price\n\n    # Return the arc elasticity rounded to two decimal places\n    return round(arc_elasticity, 2)\n\n# Execute the solution function to get the result\nsolution()",
        "ground_truth": -1.29,
        "source": "FinanceReasoning-test-153",
        "question_id": "test-2073",
        "level": "hard",
        "output": [
            "To solve the problem, we need to calculate the arc elasticity of demand. Arc elasticity of demand is given by the formula:\n\n\\[\n\\text{Arc Elasticity} = \\left(\\frac{\\Delta Q}{Q_{\\text{avg}}}\\right) / \\left(\\frac{\\Delta P}{P_{\\text{avg}}}\\right)\n\\]\n\nWhere:\n1. \\(\\Delta Q\\): Change in quantity demanded (\\(Q_{2} - Q_{1}\\)).\n2. \\(Q_{\\text{avg}}\\): Average quantity demanded (\\(\\frac{Q_{1} + Q_{2}}{2}\\)).\n3. \\(\\Delta P\\): Change in price (\\(P_{2} - P_{1}\\)).\n4. \\(P_{\\text{avg}}\\): Average price (\\(\\frac{P_{1} + P_{2}}{2}\\)).\n\n### Plan:\n1. Incorporate the constraints, which require providing the result as a decimal rounded to two decimal places.\n2. Apply the given values:\n   - \\(P_{1} = 5\\), \\(P_{2} = 4\\),\n   - \\(Q_{1} = 150\\), \\(Q_{2} = 200\\).\n3. Compute \\(\\Delta Q\\), \\(Q_{\\text{avg}}\\), \\(\\Delta P\\), and \\(P_{\\text{avg}}\\).\n4. Plug the computed values into the formula to determine the arc elasticity.\n5. Return the result rounded to two decimal places.\n\nNow, I will implement this in Python.\n\n```python\ndef solution():\n    # Define variables name and value\n    P1, P2 = 5, 4  # Initial and subsequent prices\n    Q1, Q2 = 150, 200  # Initial and subsequent quantities\n    \n    # Compute the required components\n    delta_Q = Q2 - Q1  # Change in quantity demanded\n    Q_avg = (Q1 + Q2) / 2  # Average quantity demanded\n    delta_P = P2 - P1  # Change in price\n    P_avg = (P1 + P2) / 2  # Average price\n    \n    # Arc elasticity formula\n    arc_elasticity = (delta_Q / Q_avg) / (delta_P / P_avg)\n    \n    # Return the result rounded to two decimal places\n    return round(arc_elasticity, 2)\n```"
        ],
        "retrieval_query": "What is the arc elasticity of demand for popcorn when the price changes from $5 to $4 per bag? Provide the answer as a decimal to two decimal places.",
        "useful_functions": [],
        "usage": {
            "completion_tokens": 505,
            "prompt_tokens": 436,
            "total_tokens": 941,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-2968",
        "article_title": "Nominal Value",
        "function": "def calculate_bond_price(face_value: float, coupon_rate: float, market_yield: float, years: int) -> float:\n    \"\"\"\n    Calculate the market price of a bond given its face value, coupon rate, market yield, and number of years to maturity.\n\n    This function computes the price of a bond based on its face value, coupon rate, market yield, and the number of\n    years until maturity. The bond price is calculated using the formula for the present value of future cash flows.\n\n    Args:\n        face_value (float): The face value (nominal value) of the bond, which is the amount repaid at maturity.\n        coupon_rate (float): The annual coupon rate as a decimal (e.g., 0.10 for 10%).\n        market_yield (float): The market yield (yield to maturity) as a decimal (e.g., 0.12 for 12%).\n        years (int): The number of years until the bond matures.\n\n    Returns:\n        bond_price (float): The calculated market price of the bond.\n\n    Notes:\n        - This function assumes annual coupon payments.\n        - The market yield must be greater than -1 to ensure meaningful results.\n        - The bond price is sensitive to changes in market yield and coupon rate.\n    \"\"\"\n    if market_yield <= -1:\n        raise ValueError(\"Market yield must be greater than -1.\")\n\n    annual_coupon = face_value * coupon_rate\n    bond_price = sum(annual_coupon / ((1 + market_yield) ** i) for i in range(1, years + 1))\n    bond_price += face_value / ((1 + market_yield) ** years)\n\n    return bond_price",
        "statistics": {
            "number_statistics": {
                "args_numbers": 4,
                "question_numbers": 0,
                "context_numbers": 4,
                "total_numbers": 4
            },
            "operator_statistics": {
                "operators": {
                    "+": 4,
                    "-": 0,
                    "*": 1,
                    "/": 2,
                    "%": 0,
                    "**": 2
                },
                "total_operators": 9
            },
            "code_statistics": {
                "lines": 4,
                "parentheses": 12
            }
        },
        "difficulty": 4.499809670330265,
        "context": "A company issued a 15-year bond with a face value of $1,000 and an annual coupon rate of 5%. Currently, the market yield has risen to 7% due to inflation concerns. As a result, bondholders are interested in understanding the current price of the bond given this change in interest rates. The bond pays coupons annually.",
        "question": "What is the current market price of the bond? Answer to two decimal places.",
        "python_solution": "def solution():\n    # Define variables and their values\n    face_value = 1000\n    coupon_rate = 0.05\n    market_yield = 0.07\n    years = 15\n\n    # Calculate annual coupon payment\n    annual_coupon = face_value * coupon_rate\n\n    # Calculate the market price of the bond\n    bond_price = sum(annual_coupon / ((1 + market_yield) ** i) for i in range(1, years + 1))\n    bond_price += face_value / ((1 + market_yield) ** years)\n\n    # Return the final answer rounded to two decimal places\n    return round(bond_price, 2)\n\n# Depending on the environment, to see the result in a standalone script, you may add:\n# print(solution())",
        "ground_truth": 817.84,
        "source": "FinanceReasoning-test-155",
        "question_id": "test-2074",
        "level": "hard",
        "output": [
            "To solve for the current market price of the bond, let's approach the problem step by step using the \"Emphasizing Constraints (EC)\" methodology:\n\n### Step-by-Step Thoughts:\n1. **Understanding Bond Pricing Formula**:\n    - The price of a bond is the sum of the present values of the future coupon payments and the discounted face value (principal).\n    - Formula:  \n      \\( \\text{Price} = \\sum_{t=1}^{N} \\frac{C}{(1 + r)^t} + \\frac{FV}{(1 + r)^N} \\)  \n      Where:  \n      \\( C \\) = annual coupon payment = \\( \\text{coupon rate} \\times \\text{face value} \\)  \n      \\( FV \\) = face value of the bond  \n      \\( r \\) = market interest rate (or yield)  \n      \\( N \\) = number of years (remaining time to maturity)\n\n2. **Key Inputs**:\n    - Coupon Payment (\\( C \\)) = 5% of $1,000 = $50 per year.\n    - Face Value (\\( FV \\)) = $1,000.\n    - Market Yield (\\( r \\)) = 7% = 0.07.\n    - Number of Years to Maturity (\\( N \\)) = 15.\n\n3. **Constraints**:\n    - Ensure the calculation respects the following constraints:  \n      a. The present value is calculated precisely.  \n      b. Answer is rounded to **two decimal places**.\n\n4. **Plan**:\n    - Compute the present value of all future coupon payments (\\( \\sum \\frac{C}{(1 + r)^t} \\)).\n    - Compute the present value of the face value (\\( \\frac{FV}{(1 + r)^N} \\)).\n    - Sum both present values to get the bond's price.\n\n### Python Program:\nThe code will implement the above logic and compute the current price of the bond.\n\n```python\ndef solution():\n    # Define variables name and value\n    face_value = 1000  # Bond face value\n    annual_coupon_rate = 0.05  # Annual coupon rate (5%)\n    market_yield = 0.07  # Market yield (7%)\n    years_to_maturity = 15  # Number of years to maturity\n    \n    # Calculate annual coupon payment\n    coupon_payment = face_value * annual_coupon_rate  # C = FV * r_coupon\n    \n    # Initialize price of the bond\n    bond_price = 0.0\n    \n    # Calculate present value of coupon payments\n    for t in range(1, years_to_maturity + 1):\n        bond_price += coupon_payment / ((1 + market_yield) ** t)\n    \n    # Add the present value of the face value\n    bond_price += face_value / ((1 + market_yield) ** years_to_maturity)\n    \n    # Return the bond price rounded to two decimal places\n    return round(bond_price, 2)\n``` \n\nLet me know if there is any additional clarification or constraints that need checking!"
        ],
        "retrieval_query": "What is the current market price of the bond? Answer to two decimal places.",
        "useful_functions": [
            "def calculate_average_effective_spread(trade_prices: list, prevailing_bids: list, prevailing_offers: list) -> float:\n    \"\"\"\n    Calculate the average effective spread of a series of trades.\n\n    This function computes the average effective spread for multiple trades. \n    The effective spread for each trade is determined using the formula:\n    Effective Spread = 2 \u00d7 |Trade Price - Midpoint|, where Midpoint = (Prevailing Bid + Prevailing Offer) / 2.\n\n    Args:\n        trade_prices (list): A list of prices at which trades were executed.\n        prevailing_bids (list): A list of prevailing bid prices corresponding to each trade.\n        prevailing_offers (list): A list of prevailing offer prices corresponding to each trade.\n\n    Returns:\n        float: The average effective spread of the trades.\n\n    Notes:\n        - This function assumes that the input lists have the same length, with each index representing data for a corresponding trade.\n        - It is important to ensure that trade prices, bids, and offers are all positive values.\n        - Any imbalances or incorrect data entries should be validated before invoking this function to ensure accurate results.\n    \"\"\"\n    if not (len(trade_prices) == len(prevailing_bids) == len(prevailing_offers)):\n        raise ValueError(\"Input lists must have the same length.\")\n\n    effective_spreads = []\n    for trade_price, bid, offer in zip(trade_prices, prevailing_bids, prevailing_offers):\n        midpoint = (bid + offer) / 2\n        effective_spread = 2 * abs(trade_price - midpoint)\n        effective_spreads.append(effective_spread)\n    \n    average_effective_spread = sum(effective_spreads) / len(effective_spreads)\n    \n    return average_effective_spread"
        ],
        "usage": {
            "completion_tokens": 646,
            "prompt_tokens": 792,
            "total_tokens": 1438,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-898",
        "article_title": "McClellan Oscillator",
        "function": "def calculate_adjusted_mcclellan_oscillator(ana: float, prior_19_day_ema: float, prior_39_day_ema: float) -> float:\n    \"\"\"\n    Calculate the Adjusted McClellan Oscillator using Adjusted Net Advances (ANA).\n\n    This version of the McClellan Oscillator adjusts for changes in the number of \n    stocks listed by using ANA instead of raw advances/declines, offering a more \n    reliable long-term indicator.\n\n    Args:\n        ana (float): Adjusted Net Advances, a normalized measure of market breadth.\n        prior_19_day_ema (float): The previous day's 19-day EMA of ANA.\n        prior_39_day_ema (float): The previous day's 39-day EMA of ANA.\n\n    Returns:\n        adjusted_mcclellan_oscillator (float): The value of the adjusted McClellan Oscillator.\n\n    Notes:\n        - This version provides consistency across periods with varying numbers of listed stocks.\n        - Ensure prior EMA values are initialized based on historical 19- and 39-day averages.\n        - Reflects the overall trend direction in the market adjusted for breadth.\n    \"\"\"\n    ema_19_day = (ana * 0.10) + (prior_19_day_ema * (1 - 0.10))\n    ema_39_day = (ana * 0.05) + (prior_39_day_ema * (1 - 0.05))\n    adjusted_mcclellan_oscillator = ema_19_day - ema_39_day\n    \n    return adjusted_mcclellan_oscillator",
        "statistics": {
            "number_statistics": {
                "args_numbers": 3,
                "question_numbers": 0,
                "context_numbers": 5,
                "total_numbers": 5
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 3,
                    "*": 4,
                    "/": 0,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 9
            },
            "code_statistics": {
                "lines": 4,
                "parentheses": 12
            }
        },
        "difficulty": 4.499809670330265,
        "context": "XYZ Financial Advisors tracks market trends using the Adjusted McClellan Oscillator. They believe this oscillator offers a reliable indication of market momentum by adjusting for the varying number of stocks. For a more refined analysis, they use Adjusted Net Advances (ANA). \n\nOn a particular trading day, they observe an ANA of 550. The 19-day EMA of ANA from the previous day was recorded at 528, and the 39-day EMA was 530. \n\nXYZ Financial Advisors needs to determine the current value of the adjusted McClellan Oscillator to decide on any necessary changes in their investment strategies.",
        "question": "What is the value of the adjusted McClellan Oscillator for XYZ Financial Advisors on this trading day? Answer to two decimal places.",
        "python_solution": "def solution():\n    # Define variables with given values\n    ana = 550\n    prior_19_day_ema = 528\n    prior_39_day_ema = 530\n\n    # Calculate the 19-day EMA for the current day\n    ema_19_day = (ana * 0.10) + (prior_19_day_ema * (1 - 0.10))\n\n    # Calculate the 39-day EMA for the current day\n    ema_39_day = (ana * 0.05) + (prior_39_day_ema * (1 - 0.05))\n\n    # Calculate the adjusted McClellan Oscillator\n    adjusted_mcclellan_oscillator = ema_19_day - ema_39_day\n\n    # Return the value rounded to two decimal places\n    return round(adjusted_mcclellan_oscillator, 2)",
        "ground_truth": -0.8,
        "source": "FinanceReasoning-test-194",
        "question_id": "test-2075",
        "level": "hard",
        "output": [
            "To determine the value of the adjusted McClellan Oscillator step by step, let's follow these considerations:\n\n### Step-by-Step Analysis:\n1. **Understanding the Adjusted McClellan Oscillator Formula**:\n    - The adjusted McClellan Oscillator is calculated as the difference between the short-term EMA (19-day EMA) and the long-term EMA (39-day EMA) of ANA (Adjusted Net Advances).\n    - Formula:  \n      **Adjusted McClellan Oscillator = (19-day EMA) - (39-day EMA)**\n\n2. **Extract Given Information**:\n    - Adjusted Net Advances (ANA) = 550 (for the current trading day)\n    - 19-day EMA from the previous day = 528\n    - 39-day EMA from the previous day = 530\n\n3. **Calculating the EMAs for the Current Day**:\n    - The EMA formula for the current day incorporates the previous day's EMA and the current day's value:\n      \\[\n      \\text{New EMA} = \\left(\\text{Current Value} \\times \\text{Smoothing Factor}\\right) + \\left(\\text{Previous EMA} \\times (1 - \\text{Smoothing Factor})\\right)\n      \\]\n    where the smoothing factor is calculated as:\n      \\[\n      \\text{Smoothing Factor} = \\frac{2}{\\text{Number of Periods} + 1}\n      \\]\n    - For the 19-day EMA:\n      \\[\n      \\text{Smoothing Factor} = \\frac{2}{19 + 1} = 0.1\n      \\]\n      \\[\n      \\text{New 19-day EMA} = (550 \\times 0.1) + (528 \\times 0.9)\n      \\]\n    - For the 39-day EMA:\n      \\[\n      \\text{Smoothing Factor} = \\frac{2}{39 + 1} = 0.05\n      \\]\n      \\[\n      \\text{New 39-day EMA} = (550 \\times 0.05) + (530 \\times 0.95)\n      \\]\n\n4. **Calculating the Adjusted McClellan Oscillator**:\n    - Using the newly calculated EMAs:\n      \\[\n      \\text{Adjusted McClellan Oscillator} = (\\text{New 19-day EMA}) - (\\text{New 39-day EMA})\n      \\]\n\n5. **Constraints**:\n    - Answer to two decimal places is required.\n\nNow we generate a Python program to compute the value.\n\n```python\ndef solution():\n    # Define variables name and value\n    ANA = 550\n    prev_19_day_EMA = 528\n    prev_39_day_EMA = 530\n    \n    # Smoothing factors\n    smoothing_19 = 2 / (19 + 1)\n    smoothing_39 = 2 / (39 + 1)\n    \n    # Calculate new EMAs\n    new_19_day_EMA = (ANA * smoothing_19) + (prev_19_day_EMA * (1 - smoothing_19))\n    new_39_day_EMA = (ANA * smoothing_39) + (prev_39_day_EMA * (1 - smoothing_39))\n    \n    # Calculate the adjusted McClellan Oscillator\n    adjusted_mcclellan_oscillator = new_19_day_EMA - new_39_day_EMA\n    \n    # Return the value rounded to 2 decimal places\n    return round(adjusted_mcclellan_oscillator, 2)\n```\n\nThis program will calculate the required value of the adjusted McClellan Oscillator."
        ],
        "retrieval_query": "What is the value of the adjusted McClellan Oscillator for XYZ Financial Advisors on this trading day? Answer to two decimal places.",
        "useful_functions": [],
        "usage": {
            "completion_tokens": 776,
            "prompt_tokens": 478,
            "total_tokens": 1254,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-2308",
        "article_title": "Amortization Schedule",
        "function": "def calculate_monthly_payment(loan_amount: float, annual_interest_rate: float, number_of_payments: int) -> float:\n    \"\"\"\n    Calculate the total monthly payment for an amortized loan.\n\n    This function computes the monthly payment required to fully amortize a loan\n    over a specified term, given the loan's amount, the annual interest rate,\n    and the number of payments. It uses the standard amortization formula for loans.\n\n    Args:\n        loan_amount (float): The total amount of the loan.\n        annual_interest_rate (float): The annual interest rate as a decimal (e.g., 0.03 for 3%).\n        number_of_payments (int): The total number of payments over the life of the loan.\n\n    Returns:\n        total_payment (float): The calculated total monthly payment.\n\n    Notes:\n        - Applicability: Use this function to calculate monthly payments for fixed-rate loans.\n        - Constraints: The annual_interest_rate should be divided by 12 for monthly rate calculation.\n        - Considerations: Ensure the interest rate and number of payments are greater than zero.\n    \"\"\"\n    monthly_rate = annual_interest_rate / 12\n    if monthly_rate == 0:\n        return loan_amount / number_of_payments\n    total_payment = loan_amount * (monthly_rate * (1 + monthly_rate) ** number_of_payments) / ((1 + monthly_rate) ** number_of_payments - 1)\n    \n    return total_payment",
        "statistics": {
            "number_statistics": {
                "args_numbers": 3,
                "question_numbers": 0,
                "context_numbers": 3,
                "total_numbers": 3
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 1,
                    "*": 2,
                    "/": 3,
                    "%": 0,
                    "**": 2
                },
                "total_operators": 10
            },
            "code_statistics": {
                "lines": 5,
                "parentheses": 8
            }
        },
        "difficulty": 4.499809670330265,
        "context": "John is planning to buy a new car and needs a loan to cover the purchase. He is considering taking a loan of $25,000. The annual interest rate offered by the bank is 5%, and he plans to repay the loan over a period of 5 years with monthly payments.",
        "question": "What will be John's monthly payment for the car loan? Provide your answer rounded to the nearest cent.",
        "python_solution": "def solution():\n    # Define the loan parameters\n    loan_amount = 25000  # The total amount of the loan\n    annual_interest_rate = 0.05  # The annual interest rate as a decimal\n    number_of_payments = 5 * 12  # Number of monthly payments over 5 years\n\n    # Calculate the monthly interest rate\n    monthly_rate = annual_interest_rate / 12\n\n    # Use the amortization formula for monthly payment calculation\n    if monthly_rate == 0:\n        total_payment = loan_amount / number_of_payments\n    else:\n        total_payment = loan_amount * (monthly_rate * (1 + monthly_rate) ** number_of_payments) / ((1 + monthly_rate) ** number_of_payments - 1)\n    \n    # Return the calculated monthly payment, rounded to the nearest cent\n    return round(total_payment, 2)",
        "ground_truth": 471.78,
        "source": "FinanceReasoning-test-209",
        "question_id": "test-2076",
        "level": "hard",
        "output": [
            "**Step-by-step Reasoning using EC (Emphasizing Constraints):**\n\n1. **Understand the Problem:**\n   - John wants to compute his monthly car loan payment.\n   - Input details include:\n      - Loan Amount (Principal = $25,000),\n      - Annual Interest Rate (5% or 0.05),\n      - Loan Term (5 years or 60 months since payments are monthly).\n\n2. **Identify Constraints:**\n   - The answer must be computed using the loan amortization formula for fixed monthly payments:\n     \\[\n     M = P \\times \\frac{r(1 + r)^n}{(1 + r)^n - 1}\n     \\]\n     - \\( M \\): monthly payment\n     - \\( P \\): loan principal or amount borrowed ($25,000)\n     - \\( r \\): monthly interest rate (annual rate / 12)\n     - \\( n \\): total number of monthly payments (years * 12)\n   - The result should be rounded to the nearest cent.\n\n3. **Calculation Preparation:**\n   - \\( r = \\frac{0.05}{12} = 0.0041667 \\) (monthly interest rate).\n   - \\( n = 5 \\times 12 = 60 \\) payments.\n   - Use the formula and ensure all numerical calculations adhere to the defined constraints.\n\n4. **Output Requirements:**\n   - The final answer should be the amount of John's fixed monthly payment, rounded to 2 decimal places, to meet the \"nearest cent\" requirement.\n\n**Python Code Solution:**\n```python\ndef solution():\n    # Define variables name and value\n    principal = 25000  # Loan Amount in dollars\n    annual_interest_rate = 0.05  # Annual interest rate as a decimal\n    loan_term_years = 5  # Loan term in years\n    \n    # Calculate monthly interest rate and total number of payments\n    monthly_rate = annual_interest_rate / 12\n    total_payments = loan_term_years * 12\n    \n    # Compute the fixed monthly payment using the loan amortization formula\n    monthly_payment = principal * (monthly_rate * (1 + monthly_rate) ** total_payments) / ((1 + monthly_rate) ** total_payments - 1)\n    \n    # Round the result to the nearest cent\n    answer = round(monthly_payment, 2)\n    \n    # Return the calculated monthly payment\n    return answer\n```\n\nThis program follows the constraints and instructions, ensuring an accurate and efficient solution."
        ],
        "retrieval_query": "What will be John's monthly payment for the car loan? Provide your answer rounded to the nearest cent.",
        "useful_functions": [
            "def calculate_doubtful_account_percentage(allowances: float, receivables: float) -> float:\n    \"\"\"\n    Calculate the percentage of allowances for doubtful accounts.\n\n    This function computes the percentage of allowances for doubtful accounts\n    relative to the total trade and other accounts receivable. It is a useful\n    measure in financial analysis to evaluate the adequacy of allowances set aside \n    for potential credit losses.\n\n    Args:\n        allowances (float): The amount of allowances for doubtful accounts, typically \n                            in the same currency as receivables.\n        receivables (float): The gross amount of trade and other accounts receivable, \n                             before deducting any allowances, in the same currency.\n\n    Returns:\n        percentage (float): The percentage of allowances for doubtful accounts, \n                            expressed as a percentage with three decimal precision.\n\n    Notes:\n        - Applicability: Primarily used in financial statement analysis to assess\n                         credit risk and the reasonableness of provisioning for \n                         bad debts.\n        - Constraints: Receivables should be greater than zero to avoid division errors.\n        - Considerations: Ensure that both allowances and receivables are provided\n                          in consistent units and currency. Be aware of the \n                          accounting period context as financial statements are \n                          often point-in-time representations.\n    \"\"\"\n    if receivables <= 0:\n        raise ValueError(\"Receivables must be greater than zero.\")\n\n    percentage = (allowances / receivables) * 100\n    return round(percentage, 3)",
            "def calculate_new_payment(principal: float, old_interest_rate: float, new_interest_rate: float, remaining_term_years: int) -> float:\n    \"\"\"\n    Calculate the new monthly payment after refinancing a loan at a new interest rate.\n\n    This function computes the new monthly payment for a loan when refinancing into\n    a new interest rate while maintaining the original principal and taking into account\n    the remaining loan term. It is useful for understanding the impact of reduced interest\n    rates on monthly repayments.\n\n    Args:\n        principal (float): The outstanding principal of the loan to be refinanced.\n        old_interest_rate (float): The initial annual interest rate before refinancing (as a decimal).\n        new_interest_rate (float): The new annual interest rate after refinancing (as a decimal).\n        remaining_term_years (int): The number of years remaining on the original loan term.\n\n    Returns:\n        new_payment (float): The new estimated monthly payment after refinancing.\n\n    Notes:\n        - This calculation assumes fixed-rate loans with monthly compounding.\n        - Interest rates should be provided as decimal values (e.g., 4% as 0.04).\n        - The remaining loan term is considered in years and converted to months.\n        - This does not account for potential refinancing fees or other costs.\n    \"\"\"\n    monthly_rate = new_interest_rate / 12\n    total_payments = remaining_term_years * 12\n\n    new_payment = principal * (monthly_rate * (1 + monthly_rate) ** total_payments) / ((1 + monthly_rate) ** total_payments - 1)\n    \n    return new_payment"
        ],
        "usage": {
            "completion_tokens": 523,
            "prompt_tokens": 1060,
            "total_tokens": 1583,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-369",
        "article_title": "Income Annuity",
        "function": "def calculate_annuity_monthly_payment(premium: float, annual_interest_rate: float, years: int) -> float:\n    \"\"\"\n    Calculate the monthly payment for an immediate annuity.\n\n    This function computes the monthly payment for an income annuity given an upfront\n    lump sum payment (premium), an annual interest rate, and the number of years for \n    which the payments will be made.\n\n    Args:\n        premium (float): The initial lump sum payment for the annuity.\n        annual_interest_rate (float): The annual interest rate in decimal form (e.g., 0.05 for 5%).\n        years (int): The number of years the annuity is expected to pay out.\n\n    Returns:\n        monthly_payment (float): The calculated monthly payment from the annuity.\n\n    Notes:\n        - Applicability: This function is applicable for immediate annuities where payments\n          start promptly after the premium is paid.\n        - Constraints: The annual interest rate should be non-negative. The number of years\n          must be positive.\n        - Considerations: This function assumes a constant annual interest rate and does not\n          account for inflation or taxes, which can affect the real value of payments over time.\n    \"\"\"\n    if annual_interest_rate < 0:\n        raise ValueError(\"Annual interest rate must be non-negative.\")\n    if years <= 0:\n        raise ValueError(\"Number of years must be positive.\")\n\n    monthly_interest_rate = annual_interest_rate / 12\n    total_periods = years * 12\n    if monthly_interest_rate == 0:\n        monthly_payment = premium / total_periods\n    else:\n        monthly_payment = (premium * monthly_interest_rate) / (1 - (1 + monthly_interest_rate) ** -total_periods)\n\n    return monthly_payment",
        "statistics": {
            "number_statistics": {
                "args_numbers": 3,
                "question_numbers": 0,
                "context_numbers": 3,
                "total_numbers": 3
            },
            "operator_statistics": {
                "operators": {
                    "+": 1,
                    "-": 2,
                    "*": 2,
                    "/": 3,
                    "%": 0,
                    "**": 1
                },
                "total_operators": 9
            },
            "code_statistics": {
                "lines": 7,
                "parentheses": 6
            }
        },
        "difficulty": 4.499809670330265,
        "context": "An investor is planning for retirement and decides to purchase an immediate annuity with a lump sum premium of $200,000. The insurance company offering the annuity has an annual interest rate of 4%. The investor wishes to spread the payments from this annuity evenly over 20 years. The investor is interested in knowing the monthly payment amount they would receive from this annuity.",
        "question": "What is the monthly payment amount the investor will receive from the annuity? Answer the amount in dollars to the nearest cent.",
        "python_solution": "def solution():\n    # Define variables for the annuity calculation\n    premium = 200000  # The initial lump sum payment in dollars\n    annual_interest_rate = 0.04  # Annual interest rate as a decimal\n    years = 20  # Number of years of payout\n\n    # Calculate the monthly interest rate\n    monthly_interest_rate = annual_interest_rate / 12\n\n    # Calculate the total number of monthly periods\n    total_periods = years * 12\n\n    # Calculate the monthly payment\n    # Formula for annuity calculation when the interest rate is non-zero\n    if monthly_interest_rate == 0:\n        monthly_payment = premium / total_periods\n    else:\n        monthly_payment = (premium * monthly_interest_rate) / (1 - (1 + monthly_interest_rate) ** -total_periods)\n\n    # Return the monthly payment amount, rounded to the nearest cent\n    return round(monthly_payment, 2)",
        "ground_truth": 1211.96,
        "source": "FinanceReasoning-test-215",
        "question_id": "test-2077",
        "level": "hard",
        "output": [
            "### Step-by-Step Solution and Reasoning:\n\n#### 1. Emphasizing Constraints (EC):\n- **Principal**: The investor has a lump sum investment of $200,000.\n- **Annual Interest Rate**: The insurance company offers an annual interest rate of 4%, which needs to be divided by 12 to compute the monthly rate.\n    - Constraint: Interest rate needs to be converted into decimals (4% = 0.04), and only the periodic monthly rate (i.e., `0.04 / 12`) should be used.\n- **Number of Periods**: The investor wants the payments spread evenly over 20 years, which must be expressed as the total number of months (i.e., `20 * 12`).\n    - Constraint: Periods must be a positive integer for the calculations.\n- **Result Format**: The monthly payment amount must be computed to **the nearest cent** and returned in dollars.\n\n#### 2. Approach:\n- Utilize the already provided `calculate_annuity_payout` function for computation.\n- Integrate the principal, periodic interest rate, and number of periods into the function to compute the payout.\n- Format the final answer to two decimal places, as the result must be expressed in dollars and cents.\n\n#### 3. Python Program:\nBelow is the Python code to calculate the monthly payment.\n\n```python\ndef solution():\n    # Define variables name and value\n    principal = 200000  # Lump sum amount in dollars\n    annual_interest_rate = 0.04  # Annual interest rate as a decimal\n    monthly_interest_rate = annual_interest_rate / 12  # Monthly interest rate\n    number_of_periods = 20 * 12  # Total number of payments (20 years * 12 months)\n    \n    # Function to calculate periodic annuity payout\n    def calculate_annuity_payout(principal: float, interest_rate: float, periods: int) -> float:\n        if interest_rate <= -1:\n            raise ValueError(\"Interest rate must be greater than -1.\")\n        if periods <= 0:\n            raise ValueError(\"Periods must be a positive integer.\")\n        \n        if interest_rate == 0:\n            payout = principal / periods\n        else:\n            payout = principal * (interest_rate * (1 + interest_rate) ** periods) / ((1 + interest_rate) ** periods - 1)\n        \n        return payout\n    \n    # Calculate the monthly payment using the provided function\n    monthly_payment = calculate_annuity_payout(principal, monthly_interest_rate, number_of_periods)\n    \n    # Return the answer rounded to two decimal places\n    return round(monthly_payment, 2)\n```"
        ],
        "retrieval_query": "What is the monthly payment amount the investor will receive from the annuity? Answer the amount in dollars to the nearest cent.",
        "useful_functions": [
            "def calculate_annuity_payout(principal: float, interest_rate: float, periods: int) -> float:\n    \"\"\"\n    Calculate the periodic annuity payout for a years certain annuity.\n\n    This function computes the regular payment amount for a fixed period annuity\n    given the initial principal, the periodic interest rate, and the number of periods.\n\n    Args:\n        principal (float): The initial amount of money invested in the annuity.\n        interest_rate (float): The interest rate per period as a decimal (e.g., 0.05 for 5%).\n        periods (int): The number of periods (e.g., months or years) over which payments are made.\n\n    Returns:\n        payout (float): The amount of each periodic payment.\n\n    Notes:\n        - Applicability: This function is applicable for fixed period or years certain annuities.\n        - Constraints: Interest rate must be greater than -1, and periods must be a positive integer.\n        - Considerations: Payments are assumed to be made at the end of each period.\n    \"\"\"\n    if interest_rate <= -1:\n        raise ValueError(\"Interest rate must be greater than -1.\")\n    if periods <= 0:\n        raise ValueError(\"Periods must be a positive integer.\")\n    \n    if interest_rate == 0:\n        payout = principal / periods\n    else:\n        payout = principal * (interest_rate * (1 + interest_rate) ** periods) / ((1 + interest_rate) ** periods - 1)\n    \n    return payout"
        ],
        "usage": {
            "completion_tokens": 552,
            "prompt_tokens": 750,
            "total_tokens": 1302,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-1781",
        "article_title": "Down Payment",
        "function": "def calculate_monthly_payment(loan_amount: float, annual_interest_rate: float, loan_term_years: int) -> float:\n    \"\"\"\n    Calculate the monthly payment for a loan based on the loan amount, annual interest rate, and term.\n\n    This function estimates the fixed monthly payment required to pay off a loan\n    under specified conditions using the formula for an amortizing loan.\n\n    Args:\n        loan_amount (float): The total amount of the loan.\n        annual_interest_rate (float): The annual interest rate as a decimal (e.g., 0.05 for 5%).\n        loan_term_years (int): The total number of years over which the loan will be repaid.\n\n    Returns:\n        monthly_payment (float): The calculated fixed monthly payment for the loan.\n\n    Notes:\n        - Applicability: Useful for estimating monthly payments in financial planning.\n        - Constraints: The annual interest rate should be greater than 0.\n        - Considerations: Payments do not include additional fees like taxes or insurance.\n    \"\"\"\n    monthly_interest_rate = annual_interest_rate / 12\n    number_of_payments = loan_term_years * 12\n    \n    if annual_interest_rate == 0:\n        monthly_payment = loan_amount / number_of_payments\n    else:\n        monthly_payment = (loan_amount * monthly_interest_rate) / (1 - (1 + monthly_interest_rate) ** -number_of_payments)\n    \n    return monthly_payment",
        "statistics": {
            "number_statistics": {
                "args_numbers": 3,
                "question_numbers": 0,
                "context_numbers": 3,
                "total_numbers": 3
            },
            "operator_statistics": {
                "operators": {
                    "+": 1,
                    "-": 2,
                    "*": 2,
                    "/": 3,
                    "%": 0,
                    "**": 1
                },
                "total_operators": 9
            },
            "code_statistics": {
                "lines": 7,
                "parentheses": 6
            }
        },
        "difficulty": 4.499809670330265,
        "context": "John is planning to buy a new car and has decided to finance it with a loan from his bank. He wants to borrow a total of $25,000. The bank offers him an annual interest rate of 4.5% on a loan that he plans to repay over a period of 5 years. John wants to know what his fixed monthly payment will be in order to manage his budget more effectively.",
        "question": "What will be John's fixed monthly payment for the car loan? Answer to the nearest cent.",
        "python_solution": "def solution():\n    # Define variables and their values\n    loan_amount = 25000  # The total amount of the loan in dollars\n    annual_interest_rate = 0.045  # The annual interest rate as a decimal\n    loan_term_years = 5  # The loan term in years\n\n    # Calculate the monthly interest rate\n    monthly_interest_rate = annual_interest_rate / 12\n    \n    # Calculate the total number of payments\n    number_of_payments = loan_term_years * 12\n    \n    # Calculate the monthly payment using the formula for an amortizing loan\n    if annual_interest_rate == 0:\n        monthly_payment = loan_amount / number_of_payments\n    else:\n        monthly_payment = (loan_amount * monthly_interest_rate) / (1 - (1 + monthly_interest_rate) ** -number_of_payments)\n    \n    # Return the final answer\n    return round(monthly_payment, 2)",
        "ground_truth": 466.08,
        "source": "FinanceReasoning-test-216",
        "question_id": "test-2078",
        "level": "hard",
        "output": [
            "### Step-by-Step Reasoning\n\n#### Step 1: Understand the Problem and Identify the Key Variables\nJohn is borrowing $25,000, the annual interest rate is 4.5%, and the loan term is 5 years. He wants to know what his fixed monthly payment will be. \n\nThe key variables are:\n- Principal amount: $25,000.\n- Annual interest rate: 4.5% (converted to a decimal: 0.045).\n- Loan term: 5 years.\n\n#### Step 2: Emphasizing Constraints (EC)\nHighlight and adhere to the constraints:\n1. The annual interest rate is positive.\n2. The loan term is a positive integer.\n3. The fixed monthly payment must be accurate to the nearest cent.\n4. Proper handling of the monthly interest rate and number of payments:\n   - Annual interest rate should be divided by 12 to compute the monthly interest rate.\n   - Loan term in years should be multiplied by 12 to calculate the total number of payments.\n\n#### Step 3: Formulate the Equation for Monthly Payment Calculation\nThe monthly payment for an amortizing loan can be calculated using the annuity formula:\n\n\\[\nM = \\frac{P \\cdot r \\cdot (1 + r)^n}{(1 + r)^n - 1}\n\\]\n\nWhere:\n- \\(M\\) = Monthly payment\n- \\(P\\) = Loan amount (Principal)\n- \\(r\\) = Monthly interest rate (Annual interest rate / 12)\n- \\(n\\) = Total number of payments (Loan term * 12)\n\n#### Step 4: Write the Python Program\nWe will implement the math using Python, ensuring the result is returned to the nearest cent.\n\n---\n\n### Python Program\n```python\ndef solution():\n    # Define variables name and value\n    principal = 25000  # Loan amount in dollars\n    annual_interest_rate = 4.5  # Annual interest rate as a percentage\n    years = 5  # Loan term in years\n\n    # Calculate monthly interest rate as a decimal\n    monthly_interest_rate = annual_interest_rate / 100 / 12\n    \n    # Calculate total number of payments\n    number_of_payments = years * 12\n\n    # Apply the annuity formula to calculate the fixed monthly payment\n    monthly_payment = (principal * monthly_interest_rate * (1 + monthly_interest_rate) ** number_of_payments) / \\\n                      ((1 + monthly_interest_rate) ** number_of_payments - 1)\n\n    # Return the result rounded to the nearest cent\n    return round(monthly_payment, 2)\n```"
        ],
        "retrieval_query": "What will be John's fixed monthly payment for the car loan? Answer to the nearest cent.",
        "useful_functions": [
            "def calculate_monthly_payment(principal: float, annual_interest_rate: float, years: int) -> float:\n    \"\"\"\n    Calculate the monthly payment required to fully repay a loan over a specified time period\n    using a fixed interest rate.\n\n    This calculation is applicable for fixed-rate loans including standard repayment plans for\n    student loans or mortgages.\n\n    Args:\n        principal (float): The initial amount of the loan.\n        annual_interest_rate (float): The annual interest rate as a percentage.\n        years (int): The total time in years over which the loan is to be repaid.\n\n    Returns:\n        monthly_payment (float): The amount to be paid monthly to repay the loan in full.\n\n    Notes:\n        - Applicability: Use for fixed-rate loans.\n        - Constraints: Interest rate should be greater than 0; years should be a positive integer.\n        - Considerations: This does not account for fees, taxes, or insurance that may also be part\n                          of monthly payments.\n    \"\"\"\n    if annual_interest_rate <= 0:\n        raise ValueError(\"Interest rate must be greater than zero.\")\n    if years <= 0:\n        raise ValueError(\"Years must be a positive integer.\")\n\n    monthly_interest_rate = annual_interest_rate / 100 / 12\n    number_of_payments = years * 12\n\n    monthly_payment = (principal * monthly_interest_rate) / \\\n                      (1 - (1 + monthly_interest_rate) ** -number_of_payments)\n\n    return monthly_payment",
            "def calculate_fixed_rate_payment(principal: float, annual_interest_rate: float, years: int) -> float:\n    \"\"\"\n    Calculate the monthly payment for a fixed-rate loan.\n\n    This function computes the fixed monthly payment required to fully amortize\n    a loan over a specified number of years, given the loan principal and an\n    annual interest rate.\n\n    Args:\n        principal (float): The initial amount of the loan.\n        annual_interest_rate (float): The annual interest rate as a decimal (e.g., 0.045 for 4.5%).\n        years (int): The term of the loan in years.\n\n    Returns:\n        monthly_payment (float): The monthly payment required to fully amortize\n                                 the loan over the specified term.\n\n    Notes:\n        - The monthly interest rate is calculated from the annual interest rate.\n        - The function uses the annuity formula for calculating the payment.\n        - Applicability: This function is applicable for fixed-rate loans.\n        - Constraints: The annual interest rate must be non-negative.\n        - Considerations: Ensure the principal and years are positive values.\n    \"\"\"\n    if annual_interest_rate < 0:\n        raise ValueError(\"Annual interest rate must be non-negative.\")\n    \n    monthly_interest_rate = annual_interest_rate / 12\n    number_of_payments = years * 12\n    \n    if monthly_interest_rate == 0:  # Special case for zero interest\n        return principal / number_of_payments\n    \n    monthly_payment = (principal * monthly_interest_rate) / (1 - (1 + monthly_interest_rate) ** -number_of_payments)\n    \n    return monthly_payment",
            "def calculate_monthly_payment(loan_amount: float, annual_interest_rate: float, loan_term_years: int) -> float:\n    \"\"\"\n    Calculate the monthly payment for an amortizing loan.\n\n    This function computes the total monthly payment required to repay a loan amount\n    over a specified term with a given annual interest rate. It is commonly used in\n    creating amortization schedules for loans such as mortgages or car loans.\n\n    Args:\n        loan_amount (float): The principal amount of the loan.\n        annual_interest_rate (float): The annual interest rate as a decimal (e.g., 0.03 for 3%).\n        loan_term_years (int): The term of the loan in years.\n\n    Returns:\n        monthly_payment (float): The monthly payment amount.\n\n    Notes:\n        - The annual interest rate is divided by 12 to obtain the monthly rate.\n        - The loan term in years is multiplied by 12 to obtain the total number of payments.\n        - Not applicable for non-amortizing or interest-only loans.\n    \"\"\"\n    monthly_interest_rate = annual_interest_rate / 12\n    number_of_payments = loan_term_years * 12\n    monthly_payment = loan_amount * (monthly_interest_rate * (1 + monthly_interest_rate) ** number_of_payments) / (\n        (1 + monthly_interest_rate) ** number_of_payments - 1)\n    \n    return monthly_payment\n\ndef calculate_amortization_schedule(loan_amount: float, annual_interest_rate: float, loan_term_years: int) -> list:\n    \"\"\"\n    Generate an amortization schedule showing the breakdown of payments over the loan term.\n\n    This function returns a list of dictionaries where each dictionary represents a payment period,\n    detailing the beginning balance, total payment, interest payment, principal payment, and ending balance.\n\n    Args:\n        loan_amount (float): The principal amount of the loan.\n        annual_interest_rate (float): The annual interest rate as a decimal (e.g., 0.03 for 3%).\n        loan_term_years (int): The term of the loan in years.\n\n    Returns:\n        schedule (list): A list of dictionaries, each containing:\n                         - 'Period': The period number.\n                         - 'Beginning Balance': Loan balance at the start of the period.\n                         - 'Payment': The total payment for the period.\n                         - 'Interest': The interest component of the payment.\n                         - 'Principal': The principal component of the payment.\n                         - 'Ending Balance': Loan balance at the end of the period.\n\n    Notes:\n        - Assumes a fixed interest and principal repayment schedule.\n        - Intends to provide a complete loan amortization overview.\n        - Suitable for traditional fully-amortizing loans.\n    \"\"\"\n    monthly_payment = calculate_monthly_payment(loan_amount, annual_interest_rate, loan_term_years)\n    monthly_interest_rate = annual_interest_rate / 12\n    number_of_payments = loan_term_years * 12\n\n    schedule = []\n    beginning_balance = loan_amount\n\n    for period in range(1, number_of_payments + 1):\n        interest_payment = beginning_balance * monthly_interest_rate\n        principal_payment = monthly_payment - interest_payment\n        ending_balance = beginning_balance - principal_payment\n\n        schedule.append({\n            'Period': period,\n            'Beginning Balance': beginning_balance,\n            'Payment': monthly_payment,\n            'Interest': interest_payment,\n            'Principal': principal_payment,\n            'Ending Balance': ending_balance\n        })\n\n        beginning_balance = ending_balance\n\n    return schedule"
        ],
        "usage": {
            "completion_tokens": 543,
            "prompt_tokens": 1810,
            "total_tokens": 2353,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-2851",
        "article_title": "Nanny Tax",
        "function": "def calculate_nanny_tax(wages: float) -> float:\n    \"\"\"\n    Calculate the total nanny tax including Social Security, Medicare, and federal unemployment taxes.\n\n    This function calculates the total amounts an employer must withhold for Social Security and\n    Medicare and pay for federal unemployment tax based on the wages for a household employee.\n\n    Args:\n        wages (float): The total cash wages paid to a household employee in a year.\n\n    Returns:\n        total_tax (float): The total nanny tax amount, including both the employer and employee shares\n                           of Social Security and Medicare taxes and the federal unemployment tax.\n\n    Notes:\n        - Social Security tax rate: 6.2% up to the applicable wage base.\n        - Medicare tax rate: 1.45% on all wages (there may be additional Medicare taxes over a certain threshold).\n        - Federal unemployment tax (FUTA) rate is typically 6% on the first $7,000 of wages.\n        - Both the employer and employee must pay 7.65% each for Social Security and Medicare taxes.\n        - This function does not account for state-level unemployment taxes which may also apply.\n    \"\"\"\n    social_security_rate = 0.062\n    medicare_rate = 0.0145\n    unemployment_wage_base = 7000\n    futa_rate = 0.06\n\n    def calculate_social_security_medicare_taxes(wages):\n        return wages * (social_security_rate + medicare_rate)\n\n    def calculate_futa_tax(wages):\n        return min(wages, unemployment_wage_base) * futa_rate\n\n    ss_medicare_tax = calculate_social_security_medicare_taxes(wages) * 2 # Employer and Employee share\n    futa_tax = calculate_futa_tax(wages)\n    \n    total_tax = ss_medicare_tax + futa_tax\n\n    return total_tax",
        "statistics": {
            "number_statistics": {
                "args_numbers": 1,
                "question_numbers": 0,
                "context_numbers": 4,
                "total_numbers": 4
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 0,
                    "*": 3,
                    "/": 0,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 5
            },
            "code_statistics": {
                "lines": 12,
                "parentheses": 12
            }
        },
        "difficulty": 4.499809670330265,
        "context": "Sarah employs a nanny to take care of her children. In 2023, she paid the nanny a total of $25,000 in wages. Sarah wants to ensure she complies with federal tax requirements concerning Social Security, Medicare, and federal unemployment taxes for her nanny. Both Sarah and her nanny are responsible for paying Social Security and Medicare taxes at a combined rate of 7.65% each. Additionally, Sarah is responsible for paying federal unemployment tax at a rate of 6% on the first $7,000 of wages paid. State taxes are not applicable in this scenario.",
        "question": "What is the total nanny tax amount Sarah must handle for her nanny in 2023? Calculate the answer to the nearest dollar.",
        "python_solution": "def solution():\n    # Define variables and their values\n    wages = 25000\n    social_security_rate = 0.062\n    medicare_rate = 0.0145\n    unemployment_wage_base = 7000\n    futa_rate = 0.06\n    \n    # Calculate Social Security and Medicare taxes\n    ss_medicare_tax_rate = social_security_rate + medicare_rate\n    ss_medicare_tax = wages * ss_medicare_tax_rate * 2  # Both employer and employee share\n\n    # Calculate FUTA tax\n    futa_tax = min(wages, unemployment_wage_base) * futa_rate\n\n    # Total nanny tax\n    total_tax = ss_medicare_tax + futa_tax\n\n    # Return the total tax rounded to the nearest dollar\n    return round(total_tax)",
        "ground_truth": 4245,
        "source": "FinanceReasoning-test-269",
        "question_id": "test-2079",
        "level": "hard",
        "output": [
            "### Step-by-Step Analysis:\n\nWe need to calculate the total nanny tax amount Sarah must handle for her nanny in 2023. Let's break this down systematically using the **Emphasizing Constraints (EC)** reasoning technique. Constraints will ensure accuracy in calculations.\n\n#### **Step 1: Understand the Tax Components**\n1. **Social Security and Medicare Tax:**  \n   Both the employer (Sarah) and the employee (nanny) are responsible for paying 7.65% each (6.2% for Social Security and 1.45% for Medicare). Hence, the total effective tax rate for these two combined is:  \n   *7.65% (Sarah) + 7.65% (Nanny) = 15.3%.*\n   \n2. **Federal Unemployment Tax (FUTA):**  \n   Only Sarah (the employer) is responsible for covering this tax, at a rate of **6%** on the first **$7,000** of wages paid.  \n   FUTA Tax = 6% \u00d7 min(wages, $7,000).\n\n#### **Step 2: Apply Constraints**\n1. **Wages Paid:** The total wages paid by Sarah to her nanny in 2023 are $25,000.\n2. **Social Security/Medicare:** These taxes apply to the entire $25,000 of wages.\n3. **FUTA:** Only the first $7,000 of wages is taxed, so we\u2019ll cap that portion at $7,000.\n\n#### **Step 3: Perform Calculations**\n1. Compute Sarah's share of Social Security and Medicare taxes:\n   - **Rate:** 7.65% of $25,000.\n2. Compute the nanny's share of Social Security and Medicare taxes:\n   - **Rate:** 7.65% of $25,000.\n3. Compute FUTA:\n   - **Rate:** 6% of $7,000.\n4. Add the totals for both Sarah's obligations (her share of Social Security/Medicare and FUTA) and the nanny's share (Sarah must handle withholding this).\n\n#### **Step 4: Round to the Nearest Dollar**\nThe final answer should be rounded to the nearest dollar as per the problem statement.\n\nNow, let\u2019s write the Python solution.\n\n```python\ndef solution():\n    # Define variables name and value\n    wages = 25000  # Total wages paid by Sarah\n    social_security_rate = 0.062  # Social Security Tax rate\n    medicare_rate = 0.0145  # Medicare Tax rate\n    futa_rate = 0.06  # FUTA rate\n    unemployment_wage_base = 7000  # Wage cap for federal unemployment tax (FUTA)\n    \n    # Calculate Social Security and Medicare (Employer + Employee)\n    ss_medicare_tax_rate = social_security_rate + medicare_rate  # Combined rate for Social Security and Medicare\n    ss_medicare_total_tax = wages * (2 * ss_medicare_tax_rate)  # Both employer and employee portions\n    \n    # Calculate FUTA Tax (Employer only, up to first $7,000 wages)\n    futa_tax = min(wages, unemployment_wage_base) * futa_rate\n    \n    # Calculate total nanny tax (including both employer & employee portions)\n    total_tax = ss_medicare_total_tax + futa_tax\n    \n    # Return total tax rounded to nearest dollar\n    return round(total_tax)\n```"
        ],
        "retrieval_query": "What is the total nanny tax amount Sarah must handle for her nanny in 2023? Calculate the answer to the nearest dollar.",
        "useful_functions": [
            "def calculate_nanny_tax(wages: float) -> float:\n    \"\"\"\n    Calculate the total nanny tax including Social Security, Medicare, and federal unemployment taxes.\n\n    This function calculates the total amounts an employer must withhold for Social Security and\n    Medicare and pay for federal unemployment tax based on the wages for a household employee.\n\n    Args:\n        wages (float): The total cash wages paid to a household employee in a year.\n\n    Returns:\n        total_tax (float): The total nanny tax amount, including both the employer and employee shares\n                           of Social Security and Medicare taxes and the federal unemployment tax.\n\n    Notes:\n        - Social Security tax rate: 6.2% up to the applicable wage base.\n        - Medicare tax rate: 1.45% on all wages (there may be additional Medicare taxes over a certain threshold).\n        - Federal unemployment tax (FUTA) rate is typically 6% on the first $7,000 of wages.\n        - Both the employer and employee must pay 7.65% each for Social Security and Medicare taxes.\n        - This function does not account for state-level unemployment taxes which may also apply.\n    \"\"\"\n    social_security_rate = 0.062\n    medicare_rate = 0.0145\n    unemployment_wage_base = 7000\n    futa_rate = 0.06\n\n    def calculate_social_security_medicare_taxes(wages):\n        return wages * (social_security_rate + medicare_rate)\n\n    def calculate_futa_tax(wages):\n        return min(wages, unemployment_wage_base) * futa_rate\n\n    ss_medicare_tax = calculate_social_security_medicare_taxes(wages) * 2 # Employer and Employee share\n    futa_tax = calculate_futa_tax(wages)\n    \n    total_tax = ss_medicare_tax + futa_tax\n\n    return total_tax"
        ],
        "usage": {
            "completion_tokens": 717,
            "prompt_tokens": 867,
            "total_tokens": 1584,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-334",
        "article_title": "Volume Weighted Average Price (VWAP)",
        "function": "def calculate_vwap(high_prices: list, low_prices: list, closing_prices: list, volumes: list) -> list:\n    \"\"\"\n    Calculate the Volume-Weighted Average Price (VWAP) for a given trading session.\n\n    The VWAP is a technical analysis indicator that represents the average price a security\n    has traded at throughout the day, based on both volume and price. It is typically used\n    by traders to assess price trends and the value of a security within a single trading session.\n\n    Args:\n        high_prices (list): A list of high prices for each intraday period.\n        low_prices (list): A list of low prices for each intraday period.\n        closing_prices (list): A list of closing prices for each intraday period.\n        volumes (list): A list of trading volumes for each intraday period.\n\n    Returns:\n        vwap (list): A list of VWAP values for each period, representing the cumulative value\n                     from the start of the session to the end of that period.\n\n    Notes:\n        - Applicability: This function is applicable for calculating VWAP on intraday data.\n          It resets with each new trading session.\n        - Constraints: Input lists must all be of the same length and correspond to the same\n          time periods.\n        - Considerations: VWAP is a lagging indicator and should be used with other indicators\n          for comprehensive trading decisions. It provides historical data rather than predictive data.\n    \"\"\"\n    if not (len(high_prices) == len(low_prices) == len(closing_prices) == len(volumes)):\n        raise ValueError(\"All input lists must have the same length.\")\n    \n    typical_prices = [(h + l + c) / 3 for h, l, c in zip(high_prices, low_prices, closing_prices)]\n    cumulative_pv = 0\n    cumulative_volume = 0\n    vwap = []\n    \n    for tp, vol in zip(typical_prices, volumes):\n        cumulative_pv += tp * vol\n        cumulative_volume += vol\n        vwap.append(cumulative_pv / cumulative_volume)\n    \n    return vwap",
        "statistics": {
            "number_statistics": {
                "args_numbers": 4,
                "question_numbers": 0,
                "context_numbers": 12,
                "total_numbers": 12
            },
            "operator_statistics": {
                "operators": {
                    "+": 4,
                    "-": 0,
                    "*": 1,
                    "/": 2,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 7
            },
            "code_statistics": {
                "lines": 9,
                "parentheses": 8
            }
        },
        "difficulty": 4.51085950651685,
        "context": "A trader is analyzing the Volume-Weighted Average Price (VWAP) of a particular stock during a single trading day to assess their trading strategy. Throughout the day, the stock had three distinct trading sessions with the following data:\n\n- Session 1: \n  - High price: $150, \n  - Low price: $145, \n  - Closing price: $148, \n  - Volume: 2000 shares\n\n- Session 2: \n  - High price: $152, \n  - Low price: $148, \n  - Closing price: $150, \n  - Volume: 3500 shares\n\n- Session 3: \n  - High price: $153, \n  - Low price: $149, \n  - Closing price: $151, \n  - Volume: 5000 shares\n\nThe trader wants to compute the VWAP after each session to better understand the average price level weighted by volume throughout the day.",
        "question": "What is the Volume-Weighted Average Price (VWAP) after the third session? Provide the answer rounded to two decimal places.",
        "python_solution": "def solution():\n    # Define values for the prices and volumes of each session\n    high_prices = [150, 152, 153]\n    low_prices = [145, 148, 149]\n    closing_prices = [148, 150, 151]\n    volumes = [2000, 3500, 5000]\n\n    # Calculate typical prices for each session\n    typical_prices = [(high + low + close) / 3 for high, low, close in zip(high_prices, low_prices, closing_prices)]\n\n    # Initialize cumulative price-volume and cumulative volume\n    cumulative_pv = 0\n    cumulative_volume = 0\n\n    # VWAP calculation for each session\n    vwap = []\n    for tp, vol in zip(typical_prices, volumes):\n        cumulative_pv += tp * vol\n        cumulative_volume += vol\n        vwap.append(cumulative_pv / cumulative_volume)\n\n    # Return the VWAP after the third session, rounded to two decimal places\n    return round(vwap[-1], 2)",
        "ground_truth": 150.03,
        "source": "FinanceReasoning-test-136",
        "question_id": "test-2080",
        "level": "hard",
        "output": [
            "To compute the Volume-Weighted Average Price (VWAP) after the third trading session, we need to follow systematic steps while adhering to the problem constraints.\n\n### Constraints & Key Steps:\n1. **Input Constraints**\n   - Each list (high prices, low prices, closing prices, and volumes) must have the same length since they correspond to the same sessions.\n   - We are to compute cumulative VWAP after each session.\n\n2. **VWAP Formula**\n   - For each session, the **typical price** (TP) is calculated as:\n     \\[\n     TP = \\frac{High \\, Price + Low \\, Price + Closing \\, Price}{3}\n     \\]\n   - The **cumulative price-volume** (PV) is updated at each session as:\n     \\[\n     cumulative\\_PV += TP \\times Volume\n     \\]\n   - Similarly, the **cumulative volume** is:\n     \\[\n     cumulative\\_Volume += Volume\n     \\]\n   - The VWAP at any session is then:\n     \\[\n     VWAP = \\frac{cumulative\\_PV}{cumulative\\_Volume}\n     \\]\n\n3. **Cumulative Calculation**\n   - We calculate the VWAP after each session iteratively, ensuring data from prior sessions integrates accurately.\n\n4. **Round Final Result**\n   - The computed VWAP after the third session must be rounded to **two decimal places**.\n\nGiven the shared context, terms, and formula for VWAP computation, let's proceed with the implementation.\n\n### Implementation:\nThe program will define the necessary variables, compute VWAP values iteratively, and return the VWAP after the third session.\n\n```python\ndef solution():\n    # Define variables for three trading sessions\n    high_prices = [150, 152, 153]\n    low_prices = [145, 148, 149]\n    closing_prices = [148, 150, 151]\n    volumes = [2000, 3500, 5000]\n    \n    # Check constraints: All lists must have the same length\n    if not (len(high_prices) == len(low_prices) == len(closing_prices) == len(volumes)):\n        raise ValueError(\"All input lists must have the same length.\")\n    \n    # Step-by-step VWAP calculation\n    cumulative_pv = 0  # cumulative price-volume\n    cumulative_volume = 0  # cumulative volume\n    typical_prices = [(h + l + c) / 3 for h, l, c in zip(high_prices, low_prices, closing_prices)]  # Typical price calculation\n    \n    for tp, vol in zip(typical_prices, volumes):\n        cumulative_pv += tp * vol  # Updating cumulative price-volume\n        cumulative_volume += vol  # Updating cumulative volume\n    \n    # Final VWAP after third session\n    vwap_after_third_session = cumulative_pv / cumulative_volume\n    \n    # Return the VWAP rounded to two decimal places\n    return round(vwap_after_third_session, 2)\n```"
        ],
        "retrieval_query": "What is the Volume-Weighted Average Price (VWAP) after the third session? Provide the answer rounded to two decimal places.",
        "useful_functions": [
            "def calculate_vwap(high_prices: list, low_prices: list, closing_prices: list, volumes: list) -> list:\n    \"\"\"\n    Calculate the Volume-Weighted Average Price (VWAP) for a given trading session.\n\n    The VWAP is a technical analysis indicator that represents the average price a security\n    has traded at throughout the day, based on both volume and price. It is typically used\n    by traders to assess price trends and the value of a security within a single trading session.\n\n    Args:\n        high_prices (list): A list of high prices for each intraday period.\n        low_prices (list): A list of low prices for each intraday period.\n        closing_prices (list): A list of closing prices for each intraday period.\n        volumes (list): A list of trading volumes for each intraday period.\n\n    Returns:\n        vwap (list): A list of VWAP values for each period, representing the cumulative value\n                     from the start of the session to the end of that period.\n\n    Notes:\n        - Applicability: This function is applicable for calculating VWAP on intraday data.\n          It resets with each new trading session.\n        - Constraints: Input lists must all be of the same length and correspond to the same\n          time periods.\n        - Considerations: VWAP is a lagging indicator and should be used with other indicators\n          for comprehensive trading decisions. It provides historical data rather than predictive data.\n    \"\"\"\n    if not (len(high_prices) == len(low_prices) == len(closing_prices) == len(volumes)):\n        raise ValueError(\"All input lists must have the same length.\")\n    \n    typical_prices = [(h + l + c) / 3 for h, l, c in zip(high_prices, low_prices, closing_prices)]\n    cumulative_pv = 0\n    cumulative_volume = 0\n    vwap = []\n    \n    for tp, vol in zip(typical_prices, volumes):\n        cumulative_pv += tp * vol\n        cumulative_volume += vol\n        vwap.append(cumulative_pv / cumulative_volume)\n    \n    return vwap"
        ],
        "usage": {
            "completion_tokens": 625,
            "prompt_tokens": 995,
            "total_tokens": 1620,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-2440",
        "article_title": "Wealth Tax",
        "function": "def calculate_progressive_wealth_tax(net_worth: float, tax_brackets: list, residency_factor: float = 1.0) -> float:\n    \"\"\"\n    Calculate the progressive wealth tax based on a taxpayer's net worth and specified tax brackets.\n\n    This function computes the wealth tax liability for an individual using a progressive\n    tax system with multiple tax brackets. Each segment of net worth is taxed at a different\n    rate, and a residency factor may be applied if necessary.\n\n    Args:\n        net_worth (float): The net worth of the taxpayer, representing the total value\n                           of all assets minus liabilities.\n        tax_brackets (list): A list of tuples, where each tuple contains a threshold value and\n                             the tax rate for the segment above the previous threshold.\n                             Example format: [(threshold1, rate1), (threshold2, rate2), ...]\n        residency_factor (float, optional): A factor to account for residency status,\n                                            typically 1.0 for residents and less for\n                                            non-residents. Default is 1.0.\n\n    Returns:\n        total_tax_liability (float): The calculated wealth tax liability based on progressive rates.\n\n    Notes:\n        - Applicability: This function is suitable for calculating wealth taxes in systems that\n          employ a progressive tax structure, similar to income tax brackets.\n        - Constraints: Net worth should be non-negative. Tax brackets should be sorted by\n          threshold, and rates should be non-negative. Residency factor must be between 0 and 1.\n        - Considerations: Ensure the input tax brackets cover the entire range of net worths being\n          considered. Verify calculations align with the jurisdiction's tax laws, including residency\n          considerations.\n    \"\"\"\n    if net_worth < 0 or not all(rate >= 0 for _, rate in tax_brackets) or not (0 <= residency_factor <= 1):\n        raise ValueError(\"Net worth must be non-negative, tax rates non-negative, and residency factor between 0 and 1.\")\n\n    total_tax_liability = 0\n    previous_threshold = 0\n\n    for threshold, rate in tax_brackets:\n        if net_worth > threshold:\n            total_tax_liability += (threshold - previous_threshold) * rate\n            previous_threshold = threshold\n        else:\n            total_tax_liability += (net_worth - previous_threshold) * rate\n            break\n\n    total_tax_liability *= residency_factor\n    return total_tax_liability",
        "statistics": {
            "number_statistics": {
                "args_numbers": 4,
                "question_numbers": 0,
                "context_numbers": 9,
                "total_numbers": 9
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 2,
                    "*": 3,
                    "/": 0,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 7
            },
            "code_statistics": {
                "lines": 11,
                "parentheses": 4
            }
        },
        "difficulty": 4.51085950651685,
        "context": "Emily is considering moving to a country with a progressive wealth tax system. Upon arrival, her net worth is assessed at 1,200,000. The country utilizes a wealth tax with the following brackets: for net worth up to 500,000, the tax rate is 0%; for net worth over 500,000 up to 1,000,000, the tax rate is 2%; and for any amount over 1,000,000, the tax rate is 4%. As a new resident, Emily is subject to a residency adjustment factor of 0.9 applied to the calculated tax. She wants to know what her total wealth tax liability will be with these considerations.",
        "question": "What is Emily's total wealth tax liability, adjusted for residency? Answer to the nearest integer.",
        "python_solution": "def solution():\n    # Emily's financial details and tax parameters\n    net_worth = 1200000\n    tax_brackets = [\n        (500000, 0.00),  # No tax for the first 500,000\n        (1000000, 0.02), # 2% tax for the next segment up to 1,000,000\n        (float('inf'), 0.04)  # 4% tax on any amount over 1,000,000\n    ]\n    residency_factor = 0.9\n\n    # Initialize the total tax liability calculation\n    total_tax_liability = 0\n    previous_threshold = 0\n\n    # Calculate tax liability in each bracket\n    for threshold, rate in tax_brackets:\n        if net_worth > threshold:\n            tax_for_bracket = (threshold - previous_threshold) * rate\n            total_tax_liability += tax_for_bracket\n            previous_threshold = threshold\n        else:\n            tax_for_bracket = (net_worth - previous_threshold) * rate\n            total_tax_liability += tax_for_bracket\n            break\n\n    # Apply residency factor\n    total_tax_liability *= residency_factor\n\n    # Return the result rounded to the nearest integer\n    return round(total_tax_liability)",
        "ground_truth": 16200,
        "source": "FinanceReasoning-test-203",
        "question_id": "test-2081",
        "level": "hard",
        "output": [
            "Certainly! Let's break this problem step by step using constraints and reasoning:\n\n### Step 1: Constraints Analysis\nThe main constraints for this problem involve:\n1. **Net Worth Segmentation**:\n    - The first $500,000 is taxed at 0%.\n    - The next $500,000 (from $500,000 to $1,000,000) is taxed at 2%.\n    - Any amount above $1,000,000 is taxed at 4%.\n2. **Residency Adjustment**:\n    - A residency factor of 0.9 applies to the calculated tax liability, providing a reduction for Emily.\n\n### Step 2: Tax Calculation in Brackets\nThe progressive tax requires calculating tax liability separately for each segment:\n1. Net worth up to $500,000 will incur $0 tax.\n2. Net worth from $500,001 to $1,000,000 will incur a 2% tax.\n3. Net worth above $1,000,000 will incur a 4% tax.\n\nEmily's net worth is $1,200,000, so:\n- Tax for the first $500,000 = $0.\n- Tax for the next $500,000 at 2% = $500,000 \u00d7 0.02 = $10,000.\n- Tax for the next $200,000 at 4% = $200,000 \u00d7 0.04 = $8,000.\n\n**Total Pre-adjustment Tax**:\n$10,000 + $8,000 = $18,000.\n\n### Step 3: Adjust Tax Based on Residency\nThe residency factor of 0.9 is applied to the pre-adjusted tax to determine Emily's final liability.\n\n**Final Tax Liability**:\n$18,000 \u00d7 0.9 = $16,200.\n\n### Step 4: Result Formatting\nThe result should be rounded to the nearest integer, so the answer is: **16,200**.\n\nNow let's implement this explanation into a Python solution:\n\n```python\ndef solution():\n    # Define variables\n    net_worth = 1200000  # Emily's net worth\n    tax_brackets = [\n        (500000, 0.00),  # 0% for up to $500,000\n        (1000000, 0.02),  # 2% for the next $500,000\n        (float('inf'), 0.04)  # 4% for amounts over $1,000,000\n    ]\n    residency_factor = 0.9  # Adjustment for residency\n    \n    # Calculate wealth tax\n    total_tax_liability = 0\n    previous_threshold = 0\n    \n    for threshold, rate in tax_brackets:\n        if net_worth > threshold:\n            total_tax_liability += (threshold - previous_threshold) * rate\n            previous_threshold = threshold\n        else:\n            total_tax_liability += (net_worth - previous_threshold) * rate\n            break\n    \n    # Apply residency adjustment\n    total_tax_liability *= residency_factor\n    \n    # Return the final tax liability rounded to nearest integer\n    return round(total_tax_liability)\n```"
        ],
        "retrieval_query": "What is Emily's total wealth tax liability, adjusted for residency? Answer to the nearest integer.",
        "useful_functions": [
            "def calculate_progressive_wealth_tax(net_worth: float, tax_brackets: list, residency_factor: float = 1.0) -> float:\n    \"\"\"\n    Calculate the progressive wealth tax based on a taxpayer's net worth and specified tax brackets.\n\n    This function computes the wealth tax liability for an individual using a progressive\n    tax system with multiple tax brackets. Each segment of net worth is taxed at a different\n    rate, and a residency factor may be applied if necessary.\n\n    Args:\n        net_worth (float): The net worth of the taxpayer, representing the total value\n                           of all assets minus liabilities.\n        tax_brackets (list): A list of tuples, where each tuple contains a threshold value and\n                             the tax rate for the segment above the previous threshold.\n                             Example format: [(threshold1, rate1), (threshold2, rate2), ...]\n        residency_factor (float, optional): A factor to account for residency status,\n                                            typically 1.0 for residents and less for\n                                            non-residents. Default is 1.0.\n\n    Returns:\n        total_tax_liability (float): The calculated wealth tax liability based on progressive rates.\n\n    Notes:\n        - Applicability: This function is suitable for calculating wealth taxes in systems that\n          employ a progressive tax structure, similar to income tax brackets.\n        - Constraints: Net worth should be non-negative. Tax brackets should be sorted by\n          threshold, and rates should be non-negative. Residency factor must be between 0 and 1.\n        - Considerations: Ensure the input tax brackets cover the entire range of net worths being\n          considered. Verify calculations align with the jurisdiction's tax laws, including residency\n          considerations.\n    \"\"\"\n    if net_worth < 0 or not all(rate >= 0 for _, rate in tax_brackets) or not (0 <= residency_factor <= 1):\n        raise ValueError(\"Net worth must be non-negative, tax rates non-negative, and residency factor between 0 and 1.\")\n\n    total_tax_liability = 0\n    previous_threshold = 0\n\n    for threshold, rate in tax_brackets:\n        if net_worth > threshold:\n            total_tax_liability += (threshold - previous_threshold) * rate\n            previous_threshold = threshold\n        else:\n            total_tax_liability += (net_worth - previous_threshold) * rate\n            break\n\n    total_tax_liability *= residency_factor\n    return total_tax_liability",
            "def calculate_seca_tax(net_earnings: float, additional_medicare_threshold: float, filing_status: str = 'single') -> float:\n    \"\"\"\n    Calculate the Self-Employed Contributions Act (SECA) tax for a given amount of net earnings.\n\n    This function computes the SECA tax for self-employed individuals based on their net earnings,\n    considering Social Security and Medicare taxes. It also accounts for the additional Medicare Tax\n    if the earnings exceed certain thresholds based on filing status.\n\n    Args:\n        net_earnings (float): The net earnings from self-employment.\n        additional_medicare_threshold (float): The threshold for the additional Medicare tax, based on filing status.\n        filing_status (str, optional): The filing status of the individual. Defaults to 'single'. Options are\n                                       'single', 'married_jointly', 'married_separately'.\n\n    Returns:\n        total_seca_tax (float): The total SECA tax owed based on the net earnings.\n\n    Notes:\n        - This function assumes the tax rates are 12.4% for Social Security and 2.9% for Medicare.\n        - The Social Security tax applies only to earnings up to $160,200 for 2023.\n        - The additional 0.9% Medicare Tax applies to earnings above $200,000 for 'single',\n          $250,000 for 'married_jointly', and $125,000 for 'married_separately'.\n        - Adjustments are necessary if thresholds or rates change in future tax years.\n        - This function does not consider reductions from deductions or tax credits.\n\n    Constraints:\n        - Net earnings must be a positive number. Below $400, no SECA tax is applicable.\n    \"\"\"\n    social_security_tax_rate = 0.124\n    medicare_tax_rate = 0.029\n    additional_medicare_tax_rate = 0.009\n    social_security_cap = 160200\n\n    if net_earnings < 400:\n        return 0.0\n\n    social_security_taxable = min(net_earnings, social_security_cap)\n    social_security_tax = social_security_taxable * social_security_tax_rate\n    medicare_tax = net_earnings * medicare_tax_rate\n\n    additional_medicare_thresholds = {\n        'single': 200000,\n        'married_jointly': 250000,\n        'married_separately': 125000\n    }\n    \n    additional_medicare_threshold = additional_medicare_thresholds.get(filing_status, 200000)\n    additional_medicare_tax = 0.0\n\n    if net_earnings > additional_medicare_threshold:\n        additional_medicare_tax = (net_earnings - additional_medicare_threshold) * additional_medicare_tax_rate\n\n    total_seca_tax = social_security_tax + medicare_tax + additional_medicare_tax\n    return total_seca_tax"
        ],
        "usage": {
            "completion_tokens": 656,
            "prompt_tokens": 1617,
            "total_tokens": 2273,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-1492",
        "article_title": "Relative Strength",
        "function": "def calculate_relative_strength(price_changes: list) -> float:\n    \"\"\"\n    Calculate the Relative Strength Index (RSI) based on recent price changes.\n\n    This function computes the RSI, a momentum indicator that measures the \n    magnitude of recent price changes to evaluate overbought or oversold \n    conditions in the price of an asset. RSI values range from 0 to 100.\n\n    Args:\n        price_changes (list): A list of recent price changes, where positive\n                              values indicate price increases and negative values\n                              indicate price decreases.\n\n    Returns:\n        rsi (float): The calculated RSI value.\n\n    Notes:\n        - Applicability: This function is applicable in technical analysis of stocks\n          or other assets to determine overbought or oversold conditions.\n        - Constraints: The list of price changes should not be empty.\n        - Considerations: Traditional interpretations are that RSI values >= 70 indicate\n          overbought conditions, and values <= 30 indicate oversold conditions.\n    \"\"\"\n    if not price_changes:\n        raise ValueError(\"Price changes list cannot be empty.\")\n    \n    gain = sum(change for change in price_changes if change > 0) / len(price_changes)\n    loss = -sum(change for change in price_changes if change < 0) / len(price_changes)\n    \n    if loss == 0:\n        return 100.0  # Return maximum RSI value if no losses\n\n    rs = gain / loss\n    rsi = 100 - (100 / (1 + rs))\n    \n    return rsi",
        "statistics": {
            "number_statistics": {
                "args_numbers": 1,
                "question_numbers": 0,
                "context_numbers": 16,
                "total_numbers": 16
            },
            "operator_statistics": {
                "operators": {
                    "+": 1,
                    "-": 2,
                    "*": 0,
                    "/": 4,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 7
            },
            "code_statistics": {
                "lines": 7,
                "parentheses": 12
            }
        },
        "difficulty": 4.51085950651685,
        "context": "A day trader is analyzing the stock performance of TechCorp Inc. over the past 14 trading days to determine if the stock is in an overbought or oversold condition. The trader has recorded the daily price changes of TechCorp Inc.'s stock as follows: [+1.2, -0.8, +0.5, +2.3, -1.0, -0.4, +1.8, +0.6, -1.5, +3.0, -0.2, -0.9, +2.1, +0.7]. The trader wants to calculate the Relative Strength Index (RSI) for these 14 days.",
        "question": "What is the RSI of TechCorp Inc.'s stock based on the given price changes? Answer as a percentage to two decimal places.",
        "python_solution": "def solution():\n    # List of recent price changes\n    price_changes = [+1.2, -0.8, +0.5, +2.3, -1.0, -0.4, +1.8, +0.6, -1.5, +3.0, -0.2, -0.9, +2.1, +0.7]\n\n    # Calculate the average gain and loss\n    total_gain = sum(change for change in price_changes if change > 0)\n    total_loss = -sum(change for change in price_changes if change < 0)\n    \n    # Number of periods (total number of price changes)\n    num_periods = len(price_changes)\n    \n    # Average gain and average loss\n    average_gain = total_gain / num_periods\n    average_loss = total_loss / num_periods\n    \n    # Check if there were no losses\n    if average_loss == 0:\n        return 100.0  # RSI is 100 if no losses occurred\n\n    # Calculate relative strength and RSI\n    relative_strength = average_gain / average_loss\n    rsi = 100 - (100 / (1 + relative_strength))\n    \n    # Return the RSI rounded to two decimal places\n    return round(rsi, 2)",
        "ground_truth": 71.76,
        "source": "FinanceReasoning-test-293",
        "question_id": "test-2082",
        "level": "hard",
        "output": [
            "To calculate the Relative Strength Index (RSI) for TechCorp Inc.'s stock based on the price changes, we need to use the given formula for RSI. Here's the step-by-step breakdown:\n\n1. **Input Data**:\n   The daily price changes are provided in a list: `[+1.2, -0.8, +0.5, +2.3, -1.0, -0.4, +1.8, +0.6, -1.5, +3.0, -0.2, -0.9, +2.1, +0.7]`.\n\n2. **Constraints and Validations (EC)**:\n   - The RSI is typically calculated over a 14-period window for consistency with the given problem.\n   - RSI calculation requires separation of gains (positive values) and losses (negative values).\n   - At least 14 values are required since the period equals 14.\n   - We will compute the RSI based on the initial period of these 14 trading days.\n\n3. **Calculation Outline**:\n   - Separate the gains and losses from the price changes: Gains will be the positive values, while losses will be the absolute values of the negative ones.\n   - Compute the average gain and average loss over the 14 days.\n   - Use those averages to calculate the Relative Strength (RS):\n     \\[\n     RS = \\frac{\\text{Average Gain}}{\\text{Average Loss}}\n     \\]\n   - Compute the RSI using the formula:\n     \\[\n     RSI = 100 - \\left(\\frac{100}{1 + RS}\\right)\n     \\]\n\n4. **Implementation Details**:\n   - Gains are calculated as `max(0, change)`.\n   - Losses are calculated as `max(0, -change)` to make the negative values positive.\n   - Apply the formula only for this single period and calculate the RSI to two decimal places.\n\nLet\u2019s now compute the RSI for the given price changes.\n\nHere's the Python solution:\n\n```python\ndef solution():\n    # Define variables name and value\n    price_changes = [+1.2, -0.8, +0.5, +2.3, -1.0, -0.4, +1.8, +0.6, -1.5, +3.0, -0.2, -0.9, +2.1, +0.7]\n    period = 14  # Period is 14 days\n\n    # Split gains and losses over the period\n    gains = [max(0, change) for change in price_changes]\n    losses = [max(0, -change) for change in price_changes]\n\n    # Calculate average gain and average loss\n    avg_gain = sum(gains[:period]) / period\n    avg_loss = sum(losses[:period]) / period\n\n    # Calculate the Relative Strength (RS) and RSI\n    if avg_loss == 0:  # Avoid division by zero\n        rsi = 100.0\n    else:\n        rs = avg_gain / avg_loss\n        rsi = 100 - (100 / (1 + rs))\n\n    # Return the RSI rounded to two decimal places\n    return round(rsi, 2)\n```"
        ],
        "retrieval_query": "What is the RSI of TechCorp Inc.'s stock based on the given price changes? Answer as a percentage to two decimal places.",
        "useful_functions": [
            "def calculate_rsi(prices: list, period: int) -> list:\n    \"\"\"\n    Calculate the Relative Strength Index (RSI) for a given list of prices.\n\n    The RSI is a momentum oscillator that measures the speed and change of price movements.\n    It oscillates between 0 and 100 and is typically used to identify overbought or oversold \n    conditions in a traded security.\n\n    Args:\n        prices (list): A list of historical prices of a security.\n        period (int): The number of periods to calculate the RSI over. Common values are 14.\n\n    Returns:\n        rsi_values (list): A list of RSI values, corresponding to the input prices.\n\n    Notes:\n        - Applicability: Can be used to evaluate the momentum of a security across various\n          asset classes including stocks, commodities, and forex.\n        - Constraints: Requires at least `period + 1` price data points to start calculating RSI.\n        - Considerations: The RSI might be more reliable in markets that are trending or volatile.\n    \"\"\"\n    if period <= 0:\n        raise ValueError(\"Period must be a positive integer.\")\n    if len(prices) <= period:\n        raise ValueError(\"Prices list must be longer than the period.\")\n\n    gains = []\n    losses = []\n\n    for i in range(1, len(prices)):\n        change = prices[i] - prices[i - 1]\n        if change > 0:\n            gains.append(change)\n            losses.append(0)\n        else:\n            gains.append(0)\n            losses.append(abs(change))\n\n    avg_gain = sum(gains[:period]) / period\n    avg_loss = sum(losses[:period]) / period\n\n    rsi_values = []\n    if avg_loss == 0:\n        rsi_values.append(100)\n    else:\n        rs = avg_gain / avg_loss\n        rsi_values.append(100 - (100 / (1 + rs)))\n\n    for i in range(period, len(prices) - 1):\n        change = prices[i + 1] - prices[i]\n        gain = max(change, 0)\n        loss = max(-change, 0)\n\n        avg_gain = (avg_gain * (period - 1) + gain) / period\n        avg_loss = (avg_loss * (period - 1) + loss) / period\n\n        if avg_loss == 0:\n            rsi_values.append(100)\n        else:\n            rs = avg_gain / avg_loss\n            rsi_values.append(100 - (100 / (1 + rs)))\n\n    return rsi_values",
            "def calculate_rsi(price_changes: list, period: int = 14) -> float:\n    \"\"\"\n    Calculate the Relative Strength Index (RSI) for a series of price changes.\n\n    The RSI is a momentum oscillator that measures the speed and change of price\n    movements. It helps identify overbought or oversold conditions in a traded\n    security by comparing the magnitude of recent gains to recent losses.\n\n    Args:\n        price_changes (list): A list of sequential price changes (positive or negative).\n        period (int): The number of time periods to use for the RSI calculation,\n                      typically 14.\n\n    Returns:\n        rsi (float): The calculated RSI value, ranging from 0 to 100.\n\n    Notes:\n        - Applicability: Use this function to identify potential overbought (RSI > 70)\n          or oversold (RSI < 30) conditions.\n        - Constraints: The length of price_changes must be greater than or equal to\n          the specified period to calculate an RSI value.\n        - Considerations: Ensure that the input data is in chronological order.\n          The initial RSI calculations may be less reliable due to insufficient data points.\n    \"\"\"\n    if len(price_changes) < period:\n        raise ValueError(\"price_changes must contain at least 'period' number of data points.\")\n\n    gains = [max(change, 0) for change in price_changes]\n    losses = [abs(min(change, 0)) for change in price_changes]\n\n    avg_gain = sum(gains[:period]) / period\n    avg_loss = sum(losses[:period]) / period\n\n    if avg_loss == 0:\n        return 100.0\n\n    rs = avg_gain / avg_loss\n    rsi = 100 - (100 / (1 + rs))\n    \n    return rsi",
            "def calculate_relative_strength(price_changes: list) -> float:\n    \"\"\"\n    Calculate the Relative Strength Index (RSI) based on recent price changes.\n\n    This function computes the RSI, a momentum indicator that measures the \n    magnitude of recent price changes to evaluate overbought or oversold \n    conditions in the price of an asset. RSI values range from 0 to 100.\n\n    Args:\n        price_changes (list): A list of recent price changes, where positive\n                              values indicate price increases and negative values\n                              indicate price decreases.\n\n    Returns:\n        rsi (float): The calculated RSI value.\n\n    Notes:\n        - Applicability: This function is applicable in technical analysis of stocks\n          or other assets to determine overbought or oversold conditions.\n        - Constraints: The list of price changes should not be empty.\n        - Considerations: Traditional interpretations are that RSI values >= 70 indicate\n          overbought conditions, and values <= 30 indicate oversold conditions.\n    \"\"\"\n    if not price_changes:\n        raise ValueError(\"Price changes list cannot be empty.\")\n    \n    gain = sum(change for change in price_changes if change > 0) / len(price_changes)\n    loss = -sum(change for change in price_changes if change < 0) / len(price_changes)\n    \n    if loss == 0:\n        return 100.0  # Return maximum RSI value if no losses\n\n    rs = gain / loss\n    rsi = 100 - (100 / (1 + rs))\n    \n    return rsi"
        ],
        "usage": {
            "completion_tokens": 680,
            "prompt_tokens": 1737,
            "total_tokens": 2417,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-1433",
        "article_title": "Zeta Model",
        "function": "def calculate_zeta_score(working_capital: float, total_assets: float, \n                         retained_earnings: float, earnings_before_interest_and_tax: float, \n                         market_value_of_equity: float, total_liabilities: float, \n                         sales: float) -> float:\n    \"\"\"\n    Calculate the Z-score to estimate the likelihood of a company going bankrupt within two years.\n\n    This function computes the Z-score for a company, which is a financial metric used\n    to evaluate the probability of bankruptcy. The Z-score is derived using various\n    balance sheet values relative to total assets and debt.\n\n    Args:\n        working_capital (float): The working capital of the company.\n        total_assets (float): The total assets of the company.\n        retained_earnings (float): The retained earnings of the company.\n        earnings_before_interest_and_tax (float): The earnings before interest and taxes.\n        market_value_of_equity (float): The market value of the company's equity.\n        total_liabilities (float): The total liabilities of the company.\n        sales (float): The sales of the company.\n\n    Returns:\n        z_score (float): The calculated Z-score of the company.\n\n    Notes:\n        - Applicability: This function is applicable for publicly traded manufacturing companies.\n        - The function works by converting financial ratios into a weighted sum called the Z-score.\n        - Constraints: Assumes valid non-zero denominators for division to avoid arithmetic errors.\n        - Considerations: The model was originally designed for manufacturing firms; results may vary for other types.\n    \"\"\"\n    A = working_capital / total_assets\n    B = retained_earnings / total_assets\n    C = earnings_before_interest_and_tax / total_assets\n    D = market_value_of_equity / total_liabilities\n    E = sales / total_assets\n    \n    z_score = 1.2 * A + 1.4 * B + 3.3 * C + 0.6 * D + E\n    \n    return z_score",
        "statistics": {
            "number_statistics": {
                "args_numbers": 7,
                "question_numbers": 0,
                "context_numbers": 7,
                "total_numbers": 7
            },
            "operator_statistics": {
                "operators": {
                    "+": 4,
                    "-": 0,
                    "*": 4,
                    "/": 5,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 13
            },
            "code_statistics": {
                "lines": 7,
                "parentheses": 0
            }
        },
        "difficulty": 4.51085950651685,
        "context": "XYZ Manufacturing Inc. is a publicly traded company that wants to evaluate its financial health using the Z-score model to estimate the likelihood of bankruptcy. The company has the following financial data at the end of the fiscal year:\n\n- Working Capital: $240,000\n- Total Assets: $1,200,000\n- Retained Earnings: $350,000\n- Earnings Before Interest and Tax (EBIT): $150,000\n- Market Value of Equity: $850,000\n- Total Liabilities: $600,000\n- Sales: $750,000\n\nUtilizing this financial data, XYZ Manufacturing Inc. wishes to determine its Z-score as a measure to estimate the probability of facing bankruptcy within the next two years.",
        "question": "What is the Z-score for XYZ Manufacturing Inc. using the provided financial metrics? Round your answer to two decimal places.",
        "python_solution": "def solution():\n    # Define the financial variables with their values\n    working_capital = 240000\n    total_assets = 1200000\n    retained_earnings = 350000\n    earnings_before_interest_and_tax = 150000\n    market_value_of_equity = 850000\n    total_liabilities = 600000\n    sales = 750000\n\n    # Calculate the individual components of the Z-score\n    A = working_capital / total_assets\n    B = retained_earnings / total_assets\n    C = earnings_before_interest_and_tax / total_assets\n    D = market_value_of_equity / total_liabilities\n    E = sales / total_assets\n\n    # Compute the Z-score using the weights\n    z_score = 1.2 * A + 1.4 * B + 3.3 * C + 0.6 * D + E\n\n    # Return the Z-score, rounded to two decimal places\n    return round(z_score, 2)\n\n# Call the solution function to compute the result\nz_score_result = solution()\nz_score_result",
        "ground_truth": 2.54,
        "source": "FinanceReasoning-test-377",
        "question_id": "test-2083",
        "level": "hard",
        "output": [
            "To calculate the Z-score for XYZ Manufacturing Inc., the Altman Z-score model is used which combines financial ratios into a weighted formula:\n\n1. **Emphasizing Constraints (EC)**:\n   - The inputs are non-zero values for all financial metrics to avoid division by zero errors.\n   - The Z-score coefficients are specific for manufacturing sector companies.\n   - The formula must be strictly adhered to: \\( Z = 1.2A + 1.4B + 3.3C + 0.6D + 1.0E \\).\n   - The Z-score should be rounded to two decimal places as explicitly stated.\n\n2. **Step-by-step Calculation**:\n   - Calculate \\(A = \\frac{\\text{Working Capital}}{\\text{Total Assets}}\\).\n   - Calculate \\(B = \\frac{\\text{Retained Earnings}}{\\text{Total Assets}}\\).\n   - Calculate \\(C = \\frac{\\text{EBIT}}{\\text{Total Assets}}\\).\n   - Calculate \\(D = \\frac{\\text{Market Value of Equity}}{\\text{Total Liabilities}}\\).\n   - Calculate \\(E = \\frac{\\text{Sales}}{\\text{Total Assets}}\\).\n   - Plug values of \\(A, B, C, D, E\\) into the formula and compute \\(Z\\).\n\nHere is the Python program:\n\n```python\ndef solution():\n    # Define variables name and value\n    working_capital = 240000\n    total_assets = 1200000\n    retained_earnings = 350000\n    ebit = 150000\n    market_value_of_equity = 850000\n    total_liabilities = 600000\n    sales = 750000\n    \n    # Calculate each ratio\n    A = working_capital / total_assets\n    B = retained_earnings / total_assets\n    C = ebit / total_assets\n    D = market_value_of_equity / total_liabilities\n    E = sales / total_assets\n    \n    # Calculate Z-score based on the formula\n    z_score = 1.2 * A + 1.4 * B + 3.3 * C + 0.6 * D + 1.0 * E\n    \n    # Round to two decimal places\n    return round(z_score, 2)\n```"
        ],
        "retrieval_query": "What is the Z-score for XYZ Manufacturing Inc. using the provided financial metrics? Round your answer to two decimal places.",
        "useful_functions": [
            "def calculate_zeta_score(working_capital: float, total_assets: float, \n                         retained_earnings: float, earnings_before_interest_and_tax: float, \n                         market_value_of_equity: float, total_liabilities: float, \n                         sales: float) -> float:\n    \"\"\"\n    Calculate the Z-score to estimate the likelihood of a company going bankrupt within two years.\n\n    This function computes the Z-score for a company, which is a financial metric used\n    to evaluate the probability of bankruptcy. The Z-score is derived using various\n    balance sheet values relative to total assets and debt.\n\n    Args:\n        working_capital (float): The working capital of the company.\n        total_assets (float): The total assets of the company.\n        retained_earnings (float): The retained earnings of the company.\n        earnings_before_interest_and_tax (float): The earnings before interest and taxes.\n        market_value_of_equity (float): The market value of the company's equity.\n        total_liabilities (float): The total liabilities of the company.\n        sales (float): The sales of the company.\n\n    Returns:\n        z_score (float): The calculated Z-score of the company.\n\n    Notes:\n        - Applicability: This function is applicable for publicly traded manufacturing companies.\n        - The function works by converting financial ratios into a weighted sum called the Z-score.\n        - Constraints: Assumes valid non-zero denominators for division to avoid arithmetic errors.\n        - Considerations: The model was originally designed for manufacturing firms; results may vary for other types.\n    \"\"\"\n    A = working_capital / total_assets\n    B = retained_earnings / total_assets\n    C = earnings_before_interest_and_tax / total_assets\n    D = market_value_of_equity / total_liabilities\n    E = sales / total_assets\n    \n    z_score = 1.2 * A + 1.4 * B + 3.3 * C + 0.6 * D + E\n    \n    return z_score",
            "def calculate_altman_z_score(working_capital: float, total_assets: float, \n                             retained_earnings: float, ebit: float, \n                             market_value_of_equity: float, \n                             total_liabilities: float, \n                             sales: float) -> float:\n    \"\"\"\n    Calculate the Altman Z-score for assessing the bankruptcy risk of a manufacturing company.\n\n    The Altman Z-score is a financial model used to predict the likelihood of bankruptcy\n    of a publicly traded manufacturing company. It combines several financial ratios\n    to evaluate the financial health of the company.\n\n    Args:\n        working_capital (float): The working capital of the company.\n        total_assets (float): The total assets of the company.\n        retained_earnings (float): The retained earnings of the company.\n        ebit (float): The earnings before interest and tax of the company.\n        market_value_of_equity (float): The market value of the company's equity.\n        total_liabilities (float): The total liabilities of the company.\n        sales (float): The total sales of the company.\n\n    Returns:\n        z_score (float): The Altman Z-score which indicates the likelihood of bankruptcy.\n                         A higher score indicates lower probability of bankruptcy.\n\n    Notes:\n        - Applicability: This function is particularly suited for publicly traded companies\n                         in the manufacturing sector.\n        - Constraints: Not suitable for non-manufacturing companies, financial firms, or\n                       private companies without adjustments.\n        - Considerations: A Z-score below 1.8 suggests possible bankruptcy, while a score\n                          above 3 suggests financial stability. Recent adjustments may be\n                          needed for different economic contexts.\n    \"\"\"\n    a = working_capital / total_assets\n    b = retained_earnings / total_assets\n    c = ebit / total_assets\n    d = market_value_of_equity / total_liabilities\n    e = sales / total_assets\n    \n    z_score = 1.2 * a + 1.4 * b + 3.3 * c + 0.6 * d + 1.0 * e\n    \n    return z_score"
        ],
        "usage": {
            "completion_tokens": 481,
            "prompt_tokens": 1364,
            "total_tokens": 1845,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "According to the table providing necessary details about four bonds in an investment collection, what is the price value of a basis point for this collection? Answer to a single decimal place.",
        "python_solution": "def solution():\n    bond_weights = [0.25, 0.25, 0.2, 0.3]\n    bond_prices = [105, 100, 95, 87]\n    bond_durations = [7.9, 8.5, 6.3, 10.2]\n\n    portfolio_price = sum([bond_weights[i] * bond_prices[i] for i in range(len(bond_weights))])\n   \n    portfolio_duration = sum([bond_weights[i] * bond_prices[i] * bond_durations[i] for i in range(len(bond_weights))]) / portfolio_price\n\n    price_value_basis_point = portfolio_duration * 0.0001 * portfolio_price * 1000000\n\n    return price_value_basis_point",
        "ground_truth": 80579.5,
        "topic": "Quantitative Analysis & Valuation",
        "statistics": {
            "number_statistics": {
                "args_numbers": 7,
                "question_numbers": 0,
                "context_numbers": 20,
                "total_numbers": 20
            },
            "operator_statistics": {
                "operators": {
                    "+": 0,
                    "-": 0,
                    "*": 6,
                    "/": 1,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 7
            },
            "code_statistics": {
                "lines": 7,
                "parentheses": 12
            }
        },
        "difficulty": 4.51085950651685,
        "source": "FinanceMath-validation-86",
        "context": "['| Par Value | Bond Price | Coupon | Modified Duration | Effective Duration | Convexity |\\n| --------- | ---------- | ------ | ----------------- | ------------------ | --------- |\\n| $25million | 105 | 8% | 7.9 | 8 | 122 |\\n| $25million | 100 | 7% | 8.5 | 8.5 | 154 |\\n| $20million | 95 | 5% | 6.3 | 2 | 87 |\\n| $30million | 87 | 0% | 10.2 | 10.2 | 32 |']",
        "question_id": "test-2084",
        "level": "hard",
        "output": [
            "### Step-by-Step Analysis using \"Emphasizing Constraints\" Technique:\n\n#### Understanding the Problem:\n- The task is to compute the \"Price Value of a Basis Point\" (PVBP) for the given bond portfolio.\n- PVBP quantifies the change in the price of a bond or portfolio due to a 1 basis point (0.01%) change in yield.\n  \n#### Key Formulas:\n1. **PVBP for a Single Bond**:\n   The change in price of a bond due to 1 basis point is:\n   \\[\n   PVBP = (Price \\times Par \\, Value \\times Modified\\, Duration) / 10,000\n   \\]\n   - This formula accounts for the impact of duration on bond price for small yield changes.\n\n2. **Portfolio PVBP**:\n   The PVBP of a portfolio is the sum of the PVBP of all individual bonds.\n\n#### Constraints from the Problem:\n1. All calculations should respect financial accuracy, especially the factor of 10,000 for basis point changes.\n2. For bonds with a given `Price`, `Par Value`, and `Modified Duration`, compute PVBP precisely and sum them up for the entire collection.\n3. Round the final result to a single decimal place as specified.\n\n#### Bond Data Parsing from Context:\n- **Bond 1**: Par Value = $25M, Price = 105, Modified Duration = 7.9\n- **Bond 2**: Par Value = $25M, Price = 100, Modified Duration = 8.5\n- **Bond 3**: Par Value = $20M, Price = 95, Modified Duration = 6.3\n- **Bond 4**: Par Value = $30M, Price = 87, Modified Duration = 10.2\n\n#### Plan of Solution:\n1. Parse the values of `Par Value`, `Price`, and `Modified Duration` for each bond.\n2. Use the PVBP formula for each bond to calculate its contribution.\n3. Sum up the individual PVBPs to find the portfolio PVBP.\n4. Round the final result to a single decimal place as specified.\n\nNow let's translate these steps into Python code.\n\n```python\ndef solution():\n    # Defining bond data\n    bonds = [\n        {\"par_value\": 25_000_000, \"price\": 105, \"modified_duration\": 7.9},\n        {\"par_value\": 25_000_000, \"price\": 100, \"modified_duration\": 8.5},\n        {\"par_value\": 20_000_000, \"price\": 95, \"modified_duration\": 6.3},\n        {\"par_value\": 30_000_000, \"price\": 87, \"modified_duration\": 10.2},\n    ]\n    \n    # Initialize total PVBP for the portfolio\n    total_pvbp = 0\n    \n    # Compute PVBP for each bond and add to total\n    for bond in bonds:\n        pvbp = (bond[\"price\"] * bond[\"par_value\"] * bond[\"modified_duration\"]) / 10_000\n        total_pvbp += pvbp\n    \n    # Round the total PVBP to a single decimal place\n    return round(total_pvbp, 1)\n```"
        ],
        "retrieval_query": "According to the table providing necessary details about four bonds in an investment collection, what is the price value of a basis point for this collection? Answer to a single decimal place.",
        "useful_functions": [
            "def calculate_relative_total_return(reference_return: float, comparison_return: float) -> float:\n    \"\"\"\n    Calculate the relative total return between two investment options.\n\n    This function computes how much greater the total return of one investment\n    option is compared to another, expressed as a percentage of the second option.\n    It is useful for comparing the performance of different investment indices or stocks.\n\n    Args:\n        reference_return (float): The total return of the reference investment or index.\n        comparison_return (float): The total return of the comparison investment or index.\n\n    Returns:\n        relative_return (float): The relative total return expressed as a percentage.\n\n    Notes:\n        - Applicable for comparing the performance between two investments over the same period.\n        - Both inputs must be non-negative and typically represent cumulative return values.\n        - This function assumes that both returns are calculated over the same time frame.\n        - Be cautious when interpreting percentage return if comparison_return is close to zero.\n    \"\"\"\n    if comparison_return == 0:\n        raise ValueError(\"Comparison return must not be zero to avoid division by zero error.\")\n\n    relative_return = reference_return / comparison_return * 100\n    \n    return relative_return"
        ],
        "usage": {
            "completion_tokens": 681,
            "prompt_tokens": 750,
            "total_tokens": 1431,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "If an $100 million retirement fund has 80% in equity with a beta of 1.2, how many stock index futures would need to be purchased to change the allocation to 60% in equity? This assumes a stock index value of 1,200, a multiplier of $250, and a beta of 0.95. Answer to three decimal places.",
        "python_solution": "def solution():\n    target_equity = 0.60\n    initial_equity = 0.80\n    portfolio_value = 100000000\n    futures_value = 1200 * 250\n    beta_stock = 1.2\n    beta_future = 0.95\n    delta_equity = (target_equity - initial_equity) * portfolio_value\n    delta_beta = (0 - beta_stock)/beta_future\n    futures_contracts = delta_beta * (delta_equity/futures_value)\n    return futures_contracts",
        "ground_truth": 84.211,
        "topic": "Asset Classes & Derivatives",
        "statistics": {
            "number_statistics": {
                "args_numbers": 5,
                "question_numbers": 7,
                "context_numbers": 0,
                "total_numbers": 7
            },
            "operator_statistics": {
                "operators": {
                    "+": 0,
                    "-": 2,
                    "*": 3,
                    "/": 2,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 7
            },
            "code_statistics": {
                "lines": 10,
                "parentheses": 6
            }
        },
        "difficulty": 4.51085950651685,
        "source": "FinanceMath-validation-136",
        "context": "[]",
        "question_id": "test-2085",
        "level": "hard",
        "output": [
            "Let's break down the problem step by step to ensure clarity and accuracy:\n\n### Step-by-step solution:\n\n1. **Understanding the Problem**:\n   - Current fund size: $100 million.\n   - Current equity allocation: 80%, with a beta of 1.2.\n   - Target equity allocation: 60%, with a beta of 0.95.\n   - Stock index futures multiplier: $250.\n   - Stock index value: 1200.\n   - The question asks for the **number of stock index futures needed to achieve this reallocation**.\n\n2. **Constraints**:\n   - The final answer should be accurate to **three decimal places**.\n   - Ensure beta differences and allocations are properly incorporated into the calculation.\n   - The calculation of futures should consider the stock index value and multiplier.\n\n3. **Steps to Solve**:\n   - Calculate the dollar amount of adjustment needed for the equity allocation. \n     - Initial equity investment = $100M \u00d7 80%.\n     - Target equity investment = $100M \u00d7 60%.\n     - Adjustment = Initial equity - Target equity.\n   - Adjust the portfolio beta:\n     - Calculate the effective beta change using the formula: \\( \\text{Dollar Adjustment} \u00d7 (\\text{Old Beta} - \\text{Target Beta}) \\).\n   - Compute the notional value of one stock index future:\n     - Notional value = Stock index value \u00d7 Future multiplier.\n   - Finally, determine the number of futures needed:\n     - \\( \\text{Futures Needed} = \\frac{\\text{Effective Beta Change}}{\\text{Notional Value of One Future}} \\).\n\nBy implementing this reasoning in Python, we can program a robust solution while adhering to the above constraints.\n\nHere is the Python program:\n\n```python\ndef solution():\n    # Define variables name and value\n    fund_size = 100_000_000  # $100M\n    current_equity_allocation = 0.8  # 80%\n    target_equity_allocation = 0.6  # 60%\n    beta_current = 1.2\n    beta_target = 0.95\n    stock_index_value = 1200\n    multiplier = 250\n    \n    # Calculate current and target equity allocation in dollars\n    current_equity = fund_size * current_equity_allocation\n    target_equity = fund_size * target_equity_allocation\n    \n    # Calculate the dollar adjustment for equity reallocation\n    dollar_adjustment = current_equity - target_equity\n    \n    # Calculate effective beta change for reallocation\n    effective_beta_change = dollar_adjustment * (beta_current - beta_target)\n    \n    # Calculate the notional value of one stock index future\n    future_notional_value = stock_index_value * multiplier\n    \n    # Calculate the number of futures needed (accurate to 3 decimal places)\n    futures_needed = effective_beta_change / future_notional_value\n    \n    # Return answer rounded to three decimal places\n    return round(futures_needed, 3)\n```"
        ],
        "retrieval_query": "If an $100 million retirement fund has 80% in equity with a beta of 1.2, how many stock index futures would need to be purchased to change the allocation to 60% in equity? This assumes a stock index value of 1,200, a multiplier of $250, and a beta of 0.95. Answer to three decimal places.",
        "useful_functions": [],
        "usage": {
            "completion_tokens": 622,
            "prompt_tokens": 403,
            "total_tokens": 1025,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "Business B announced and distributed cash dividends worth $8 million and an impairment expense of $12 million in 2017. They categorized the dividend payment as a financing activity. What is the value of Business B's operating cash flow for 2017 (in $ millions)? Answer to a single decimal place.",
        "python_solution": "def solution():\n    REB = 0\n    NI = 23\n    Div = 0\n    REE = 0\n    impairment = 12\n    AR_change = (48-45)\n    Inv_change = (20-24)\n    AP_change = (33-30)\n    CFO = NI + impairment - AR_change - Inv_change + AP_change\n    return CFO",
        "ground_truth": 39.0,
        "topic": "Accounting",
        "statistics": {
            "number_statistics": {
                "args_numbers": 1,
                "question_numbers": 2,
                "context_numbers": 9,
                "total_numbers": 11
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 5,
                    "*": 0,
                    "/": 0,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 7
            },
            "code_statistics": {
                "lines": 10,
                "parentheses": 6
            }
        },
        "difficulty": 4.51085950651685,
        "source": "FinanceMath-validation-157",
        "context": "['| Balances as of Year Ended 31 December | 2016 | 2017 |\\n| --- | --- | --- |\\n| Retained earnings | 110 | 125 |\\n| Accounts receivable | 45 | 48 |\\n| Inventory | 24 | 20 |\\n| Accounts payable | 30 | 33 |']",
        "question_id": "test-2086",
        "level": "hard",
        "output": [
            "To calculate Business B's operating cash flow for 2017, we need to follow the steps below:\n\n### Step-by-Step Solution:\n1. **Understand Operating Cash Flow (OCF)**:\n   - OCF is calculated starting with Net Income and then adjusting for non-cash expenses and changes in working capital.\n\n2. **Constraints (Emphasizing Constraints - EC)**:\n   - Ensure the result is in $ millions and rounded to a single decimal place.\n   - Factors to consider:\n     - Net income is obtained from changes in retained earnings after accounting for dividends declared.\n     - Add back any non-cash charges, e.g., impairment expense.\n     - Adjust the changes in working capital:\n       - \\( \\Delta Accounts~Receivable \\): A decrease is added, and an increase is subtracted.\n       - \\( \\Delta Inventory \\): A decrease is added, and an increase is subtracted.\n       - \\( \\Delta Accounts~Payable \\): An increase is added, and a decrease is subtracted.\n\n3. **Data Parameters**:\n   - From the table:\n     - Retained earnings (RE) for 2016 = $110 million, 2017 = $125 million.\n     - Accounts receivable (AR): $45 million (2016), $48 million (2017).\n     - Inventory (INV): $24 million (2016), $20 million (2017).\n     - Accounts payable (AP): $30 million (2016), $33 million (2017).\n   - Dividends declared = $8 million.\n   - Impairment expense = $12 million (non-cash).\n\n4. **Key Formulas**:\n   - Compute Net Income:\n     \\( \\text{Net Income} = \\Delta RE + \\text{Dividends Declared} \\).\n   - Adjust for changes in working capital:\n     - \\( \\Delta AR = AR_{2017} - AR_{2016} \\).\n     - \\( \\Delta INV = INV_{2017} - INV_{2016} \\).\n     - \\( \\Delta AP = AP_{2017} - AP_{2016} \\).\n   - Compute OCF:\n     \\( \\text{OCF} = \\text{Net Income} + \\text{Non-cash expenses} - \\Delta AR + \\Delta INV + \\Delta AP \\).\n\n5. **Substitute Values and Solve**:\n   - Use the formulas above step-by-step to calculate OCF.\n\nNow, let's generate the Python program to compute the result:\n\n```python\ndef solution():\n    # Define balance sheet and additional values\n    retained_earnings_2016 = 110\n    retained_earnings_2017 = 125\n    accounts_receivable_2016 = 45\n    accounts_receivable_2017 = 48\n    inventory_2016 = 24\n    inventory_2017 = 20\n    accounts_payable_2016 = 30\n    accounts_payable_2017 = 33\n    dividends_declared = 8\n    impairment_expense = 12  # Non-cash expense\n\n    # Compute net income\n    net_income = (retained_earnings_2017 - retained_earnings_2016) + dividends_declared\n\n    # Compute changes in working capital\n    delta_accounts_receivable = accounts_receivable_2017 - accounts_receivable_2016\n    delta_inventory = inventory_2017 - inventory_2016\n    delta_accounts_payable = accounts_payable_2017 - accounts_payable_2016\n\n    # Compute operating cash flow\n    operating_cash_flow = (net_income + \n                           impairment_expense - \n                           delta_accounts_receivable +\n                           delta_inventory +\n                           delta_accounts_payable)\n\n    # Return result rounded to one decimal place\n    return round(operating_cash_flow, 1)\n```"
        ],
        "retrieval_query": "Business B announced and distributed cash dividends worth $8 million and an impairment expense of $12 million in 2017. They categorized the dividend payment as a financing activity. What is the value of Business B's operating cash flow for 2017 (in $ millions)? Answer to a single decimal place.",
        "useful_functions": [
            "def calculate_relative_strength(price_changes: list) -> float:\n    \"\"\"\n    Calculate the Relative Strength Index (RSI) based on recent price changes.\n\n    This function computes the RSI, a momentum indicator that measures the \n    magnitude of recent price changes to evaluate overbought or oversold \n    conditions in the price of an asset. RSI values range from 0 to 100.\n\n    Args:\n        price_changes (list): A list of recent price changes, where positive\n                              values indicate price increases and negative values\n                              indicate price decreases.\n\n    Returns:\n        rsi (float): The calculated RSI value.\n\n    Notes:\n        - Applicability: This function is applicable in technical analysis of stocks\n          or other assets to determine overbought or oversold conditions.\n        - Constraints: The list of price changes should not be empty.\n        - Considerations: Traditional interpretations are that RSI values >= 70 indicate\n          overbought conditions, and values <= 30 indicate oversold conditions.\n    \"\"\"\n    if not price_changes:\n        raise ValueError(\"Price changes list cannot be empty.\")\n    \n    gain = sum(change for change in price_changes if change > 0) / len(price_changes)\n    loss = -sum(change for change in price_changes if change < 0) / len(price_changes)\n    \n    if loss == 0:\n        return 100.0  # Return maximum RSI value if no losses\n\n    rs = gain / loss\n    rsi = 100 - (100 / (1 + rs))\n    \n    return rsi"
        ],
        "usage": {
            "completion_tokens": 802,
            "prompt_tokens": 791,
            "total_tokens": 1593,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "Based on Exhibit 1, what is the average effective spread of the three trades when Smith talks about a market buy order for 5,000 shares of a thinly traded stock? Answer to two decimal places.",
        "python_solution": "def solution():\n    # trades prices\n    trade_prices = [25.20, 25.22, 25.27]\n    # bid and ask prices for each trade\n    bid_ask_prices = [(25.20, 25.17), (25.22, 25.19), (25.26, 25.22)]\n    \n    # calculate the effective spread for each trade\n    effective_spreads = [2 * (trade_price - ((ask + bid) / 2)) for trade_price, (ask, bid) in zip(trade_prices, bid_ask_prices)]\n    \n    # calculate the average effective spread\n    average_effective_spread = sum(effective_spreads) / len(effective_spreads)\n    \n    return average_effective_spread",
        "ground_truth": 0.04,
        "topic": "Portfolio Management & Strategy",
        "statistics": {
            "number_statistics": {
                "args_numbers": 7,
                "question_numbers": 2,
                "context_numbers": 18,
                "total_numbers": 20
            },
            "operator_statistics": {
                "operators": {
                    "+": 1,
                    "-": 1,
                    "*": 1,
                    "/": 2,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 5
            },
            "code_statistics": {
                "lines": 9,
                "parentheses": 20
            }
        },
        "difficulty": 4.553876891600541,
        "source": "FinanceMath-validation-176",
        "context": "['| Trade # | Time     | Trade Price | Trade Size | Bid Price | Ask Price |\\n|---------|----------|-------------|------------|-----------|-----------|\\n| 1       | 9.45 a.m.| $25.20      | 1,200      | $25.17    | $25.20    |\\n| 2       | 9.55 a.m.| $25.22      | 1,300      | $25.19    | $25.22    |\\n| 3       | 11.30 a.m.| $25.27     | 2,500      | $25.22    | $25.26    |']",
        "question_id": "test-2087",
        "level": "hard",
        "output": [
            "### Step-by-Step Reasoning:\n\n1. **Understand the Problem**:  \n   - The problem is to calculate the **average effective spread** for three trades given the trade price, bid price, and ask price data for each trade.\n   - The formula for effective spread is:  \n     \\[\n     \\text{Effective Spread} = 2 \\times \\lvert \\text{Trade Price} - \\text{Midpoint} \\rvert\n     \\]\n     where:\n     \\[\n     \\text{Midpoint} = \\frac{\\text{Bid Price} + \\text{Ask Price}}{2}\n     \\]\n   - The average effective spread is the arithmetic mean of the effective spreads for the given trades.\n\n2. **Constraints**:\n   - **Accuracy**: The final result should be rounded to two decimal places.\n   - **Input Validation**: Ensure that all prices (trade, bid, ask) are valid and positive. Each input list for trade prices, bid prices, and ask prices must have the same length.\n\n3. **Step-by-Step Execution**:\n   - a) For each trade, calculate the midpoint of the bid and ask prices.\n   - b) Calculate the effective spread using the formula above.\n   - c) Compute the average of the effective spreads.\n   - d) Ensure the final result is rounded to two decimal places.\n\n4. **Input Data**:\n   - **Trade Prices**: [25.20, 25.22, 25.27]\n   - **Bid Prices**: [25.17, 25.19, 25.22]\n   - **Ask Prices**: [25.20, 25.22, 25.26]\n\n5. **Implementation**: The Python function will calculate the average effective spread based on these steps.\n\n---\n\n### Python Code Implementation:\n```python\ndef solution():\n    # Define input data\n    trade_prices = [25.20, 25.22, 25.27]\n    bid_prices = [25.17, 25.19, 25.22]\n    ask_prices = [25.20, 25.22, 25.26]\n    \n    # Calculate effective spreads for each trade\n    effective_spreads = []\n    for trade_price, bid_price, ask_price in zip(trade_prices, bid_prices, ask_prices):\n        midpoint = (bid_price + ask_price) / 2  # Calculate midpoint\n        effective_spread = 2 * abs(trade_price - midpoint)  # Effective spread formula\n        effective_spreads.append(effective_spread)\n    \n    # Calculate average effective spread\n    average_effective_spread = sum(effective_spreads) / len(effective_spreads)\n    \n    # Round to two decimal places as per constraint\n    return round(average_effective_spread, 2)\n```\n\nWhen run, this function computes the average effective spread based on the provided data."
        ],
        "retrieval_query": "Based on Exhibit 1, what is the average effective spread of the three trades when Smith talks about a market buy order for 5,000 shares of a thinly traded stock? Answer to two decimal places.",
        "useful_functions": [
            "def calculate_average_effective_spread(trade_prices: list, prevailing_bids: list, prevailing_offers: list) -> float:\n    \"\"\"\n    Calculate the average effective spread of a series of trades.\n\n    This function computes the average effective spread for multiple trades. \n    The effective spread for each trade is determined using the formula:\n    Effective Spread = 2 \u00d7 |Trade Price - Midpoint|, where Midpoint = (Prevailing Bid + Prevailing Offer) / 2.\n\n    Args:\n        trade_prices (list): A list of prices at which trades were executed.\n        prevailing_bids (list): A list of prevailing bid prices corresponding to each trade.\n        prevailing_offers (list): A list of prevailing offer prices corresponding to each trade.\n\n    Returns:\n        float: The average effective spread of the trades.\n\n    Notes:\n        - This function assumes that the input lists have the same length, with each index representing data for a corresponding trade.\n        - It is important to ensure that trade prices, bids, and offers are all positive values.\n        - Any imbalances or incorrect data entries should be validated before invoking this function to ensure accurate results.\n    \"\"\"\n    if not (len(trade_prices) == len(prevailing_bids) == len(prevailing_offers)):\n        raise ValueError(\"Input lists must have the same length.\")\n\n    effective_spreads = []\n    for trade_price, bid, offer in zip(trade_prices, prevailing_bids, prevailing_offers):\n        midpoint = (bid + offer) / 2\n        effective_spread = 2 * abs(trade_price - midpoint)\n        effective_spreads.append(effective_spread)\n    \n    average_effective_spread = sum(effective_spreads) / len(effective_spreads)\n    \n    return average_effective_spread",
            "def calculate_average_effective_spread(trade_prices: list, bid_ask_prices: list) -> float:\n    \"\"\"\n    Calculate the average effective spread for a series of trades.\n\n    This function computes the average effective spread for a series of trades, \n    where each trade has a corresponding bid and ask price. The effective spread \n    is calculated as twice the difference between the trade price and the midpoint \n    of the bid and ask prices, averaged over all trades.\n\n    Args:\n        trade_prices (list): A list of trade prices for each trade.\n        bid_ask_prices (list): A list of tuples, where each tuple contains the\n                               ask and bid prices for the corresponding trade.\n\n    Returns:\n        float: The average effective spread of the trades.\n\n    Notes:\n        - Applicability: This function is applicable for calculating effective \n          spreads in financial markets, especially for evaluating trading costs.\n        - Constraints: The lengths of trade_prices and bid_ask_prices lists must \n          be the same.\n        - Considerations: This function assumes that all inputs are provided in a\n          consistent order and format.\n    \"\"\"\n    if len(trade_prices) != len(bid_ask_prices):\n        raise ValueError(\"trade_prices and bid_ask_prices must have the same length.\")\n\n    effective_spreads = [\n        2 * (trade_price - ((ask + bid) / 2)) \n        for trade_price, (ask, bid) in zip(trade_prices, bid_ask_prices)\n    ]\n\n    average_effective_spread = sum(effective_spreads) / len(effective_spreads)\n    \n    return average_effective_spread"
        ],
        "usage": {
            "completion_tokens": 609,
            "prompt_tokens": 1235,
            "total_tokens": 1844,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-922",
        "article_title": "Modern Portfolio Theory (MPT)",
        "function": "def calculate_portfolio_risk(weights: list, variances: list, correlations: list) -> float:\n    \"\"\"\n    Calculate the risk of a portfolio based on asset variances and correlations.\n\n    This function computes the overall risk (standard deviation) of a portfolio\n    using the variances of individual assets and their correlations. The risk is\n    calculated according to the principles of Modern Portfolio Theory (MPT).\n\n    Args:\n        weights (list): A list of weights representing the proportion of the total\n                        portfolio value that is invested in each asset.\n        variances (list): A list of variances for each asset in the portfolio.\n        correlations (list): A list of lists representing the correlation matrix\n                             of the assets. Each sublist should contain the correlation\n                             values for one asset with all other assets.\n\n    Returns:\n        portfolio_risk (float): The standard deviation of the portfolio, representing its risk.\n\n    Notes:\n        - Applicability: Relevant for forming a diversified portfolio with balanced risk and return.\n        - Constraints: The correlation matrix must be symmetric and the diagonal should contain ones.\n        - Considerations: Ensure that weights, variances, and correlation matrix dimensions match.\n    \"\"\"\n    num_assets = len(weights)\n    if len(variances) != num_assets or len(correlations) != num_assets or any(len(row) != num_assets for row in correlations):\n        raise ValueError(\"The dimensions of weights, variances, and correlations must be consistent.\")\n\n    portfolio_variance = 0.0\n    for i in range(num_assets):\n        for j in range(num_assets):\n            portfolio_variance += weights[i] * weights[j] * correlations[i][j] * (variances[i] ** 0.5) * (variances[j] ** 0.5)\n\n    portfolio_risk = portfolio_variance ** 0.5\n    \n    return portfolio_risk",
        "statistics": {
            "number_statistics": {
                "args_numbers": 3,
                "question_numbers": 0,
                "context_numbers": 10,
                "total_numbers": 10
            },
            "operator_statistics": {
                "operators": {
                    "+": 1,
                    "-": 0,
                    "*": 4,
                    "/": 0,
                    "%": 0,
                    "**": 3
                },
                "total_operators": 8
            },
            "code_statistics": {
                "lines": 7,
                "parentheses": 10
            }
        },
        "difficulty": 4.564348191467836,
        "context": "An investment firm is evaluating the risk of a new portfolio they are managing. The portfolio consists of three different assets. The firm has allocated 40% of the portfolio to Asset A, 35% to Asset B, and 25% to Asset C. The variances associated with these assets are 0.0225, 0.0156, and 0.0304. The assets have the following correlation matrix:\n\n- Asset A and Asset B: 0.8\n- Asset A and Asset C: 0.4\n- Asset B and Asset C: 0.6\n\nThe diagonal of the correlation matrix (which indicates the correlation of each asset with itself) is 1 for all assets. The firm wants to calculate the overall risk of the portfolio to understand its volatility. \n\nAssume that this firm classifies the departures in the variances and correlations due to market fluctuations correctly to enhance their risk estimations.",
        "question": "What is the standard deviation of the portfolio, representing its risk? Answer to four decimal places.",
        "python_solution": "def solution():\n    # Portfolio weights for Asset A, Asset B, and Asset C\n    weights = [0.4, 0.35, 0.25]\n    \n    # Variances for Asset A, Asset B, and Asset C\n    variances = [0.0225, 0.0156, 0.0304]\n    \n    # Correlation matrix for the assets\n    correlations = [\n        [1, 0.8, 0.4],\n        [0.8, 1, 0.6],\n        [0.4, 0.6, 1]\n    ]\n    \n    # Calculate the portfolio variance\n    num_assets = len(weights)\n    portfolio_variance = 0.0\n    \n    for i in range(num_assets):\n        for j in range(num_assets):\n            portfolio_variance += weights[i] * weights[j] * correlations[i][j] * (variances[i] ** 0.5) * (variances[j] ** 0.5)\n    \n    # Calculate the portfolio risk (standard deviation)\n    portfolio_risk = portfolio_variance ** 0.5\n    \n    # Return the answer rounded to four decimal places\n    return round(portfolio_risk, 4)",
        "ground_truth": 0.1264,
        "source": "FinanceReasoning-test-157",
        "question_id": "test-2088",
        "level": "hard",
        "output": [
            "To calculate the overall risk of the portfolio, we need to compute its standard deviation. Here\u2019s a detailed step-by-step reasoning process for solving this problem:\n\n### Step-by-Step Reasoning:\n\n#### 1. Portfolio Variance Formula\nThe variance of a portfolio is given by the formula:\n\\[\n\\sigma_p^2 = \\sum_{i=1}^n \\sum_{j=1}^n w_i w_j \\sigma_i \\sigma_j \\rho_{ij}\n\\]\nWhere:\n- \\(w_i\\) and \\(w_j\\) are the weights of assets \\(i\\) and \\(j\\).\n- \\(\\sigma_i^2\\) is the variance of asset \\(i\\).\n- \\(\\sigma_i\\) and \\(\\sigma_j\\) are the standard deviations of asset \\(i\\) and \\(j\\), respectively.\n- \\(\\rho_{ij}\\) is the correlation between the returns of assets \\(i\\) and \\(j\\).\n\nThe off-diagonal terms (when \\(i \\neq j\\)) represent the covariances, while the diagonal terms (when \\(i = j\\)) represent the variances.\n\n#### 2. Constraints\n- All weights are provided: 40% (\\(w_A = 0.4\\)), 35% (\\(w_B = 0.35\\)), and 25% (\\(w_C = 0.25\\)).\n- Variances of assets are given: 0.0225 (\\(\\sigma_A^2\\)), 0.0156 (\\(\\sigma_B^2\\)), and 0.0304 (\\(\\sigma_C^2\\)).\n- Correlation coefficients between assets are also defined, including \\(\\rho_{ij}\\):\n    - \\(\\rho_{AB} = 0.8\\)\n    - \\(\\rho_{AC} = 0.4\\)\n    - \\(\\rho_{BC} = 0.6\\)\n\nWe must adhere to these constraints and use them in our computations. The final answer (standard deviation) must be accurate to **four decimal places**.\n\n#### 3. Standard Deviation of Portfolio\nThe standard deviation of the portfolio is obtained by taking the square root of the variance:\n\\[\n\\sigma_p = \\sqrt{\\sigma_p^2}\n\\]\n\n#### 4. Calculation Plan\nUsing the formula for portfolio variance step-by-step:\n1. Extract the weights, variances (converted to standard deviations), and correlations for each term.\n2. Calculate diagonal elements (\\(w_i^2 \\cdot \\sigma_i^2\\)).\n3. Calculate off-diagonal elements \\(2 \\cdot w_i \\cdot w_j \\cdot \\sigma_i \\cdot \\sigma_j \\cdot \\rho_{ij}\\).\n4. Sum all terms to get \\(\\sigma_p^2\\).\n5. Take the square root to get the standard deviation.\n\nNow, let\u2019s write the Python program to compute the portfolio standard deviation.\n\n```python\ndef solution():\n    # Define the weights\n    w_A = 0.4\n    w_B = 0.35\n    w_C = 0.25\n    \n    # Define the variances and calculate standard deviations\n    var_A = 0.0225  # Variance of Asset A\n    var_B = 0.0156  # Variance of Asset B\n    var_C = 0.0304  # Variance of Asset C\n    std_A = var_A**0.5\n    std_B = var_B**0.5\n    std_C = var_C**0.5\n\n    # Define the correlations\n    rho_AB = 0.8\n    rho_AC = 0.4\n    rho_BC = 0.6\n\n    # Calculate portfolio variance using the formula\n    # Diagonal terms (variances of individual assets scaled by weights)\n    var_p = (w_A**2 * var_A) + (w_B**2 * var_B) + (w_C**2 * var_C)\n    \n    # Off-diagonal terms (covariances scaled by weights and correlations)\n    var_p += 2 * w_A * w_B * std_A * std_B * rho_AB\n    var_p += 2 * w_A * w_C * std_A * std_C * rho_AC\n    var_p += 2 * w_B * w_C * std_B * std_C * rho_BC\n\n    # Calculate the standard deviation of the portfolio\n    std_p = var_p**0.5\n\n    # Return the answer rounded to four decimal places\n    return round(std_p, 4)\n\n```"
        ],
        "retrieval_query": "What is the standard deviation of the portfolio, representing its risk? Answer to four decimal places.",
        "useful_functions": [],
        "usage": {
            "completion_tokens": 971,
            "prompt_tokens": 535,
            "total_tokens": 1506,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-741",
        "article_title": "Bond Valuation",
        "function": "def calculate_bond_value(cash_flows: list, face_value: float, discount_rate: float) -> float:\n    \"\"\"\n    Calculate the present value of a bond's expected future coupon payments and its face value.\n\n    This function computes the theoretical fair value of a bond by calculating\n    the present value of its expected future coupon payments and the present\n    value of its face value at maturity using a specified discount rate.\n\n    Args:\n        cash_flows (list): A list of future cash flows representing coupon payments.\n        face_value (float): The face value of the bond to be paid back at maturity.\n        discount_rate (float): The discount rate used for calculating present value, \n                               often the yield to maturity. It must be greater than -1.\n\n    Returns:\n        bond_value (float): The calculated present value of the bond.\n\n    Notes:\n        - Assumes that cash flows occur at regular intervals.\n        - Discount rate must be greater than -1.\n        - Cash flows should be provided in chronological order.\n        - This function is useful for evaluating bond investments by understanding\n          their intrinsic value based on cash flows and interest rates.\n    \"\"\"\n    if discount_rate <= -1:\n        raise ValueError(\"Discount rate must be greater than -1.\")\n    \n    pv_coupons = sum(cf / ((1 + discount_rate) ** (i + 1)) for i, cf in enumerate(cash_flows))\n    pv_face_value = face_value / ((1 + discount_rate) ** len(cash_flows))\n    \n    bond_value = pv_coupons + pv_face_value\n    \n    return bond_value",
        "statistics": {
            "number_statistics": {
                "args_numbers": 3,
                "question_numbers": 0,
                "context_numbers": 4,
                "total_numbers": 4
            },
            "operator_statistics": {
                "operators": {
                    "+": 4,
                    "-": 0,
                    "*": 0,
                    "/": 2,
                    "%": 0,
                    "**": 2
                },
                "total_operators": 8
            },
            "code_statistics": {
                "lines": 4,
                "parentheses": 16
            }
        },
        "difficulty": 4.564348191467836,
        "context": "A corporate bond investor is evaluating a bond investment opportunity. The bond has an annual coupon rate of 5% and a face value of $10,000. The bond pays annual coupons and will mature in 5 years. Currently, the yield to maturity (YTM), which serves as the discount rate for this bond, is 4%. The investor wants to determine the fair value of this bond to decide if it's an attractive investment.",
        "question": "What is the present value of this bond, including all expected future coupon payments and the face value at maturity, using the given yield to maturity? Answer to the nearest integer.",
        "python_solution": "def solution():\n    # Define bond parameters\n    face_value = 10000\n    annual_coupon_rate = 0.05\n    years_to_maturity = 5\n    discount_rate = 0.04\n\n    # Calculate annual coupon payment\n    annual_coupon_payment = face_value * annual_coupon_rate\n    \n    # Generate a list of cash flows (all coupon payments are identical)\n    cash_flows = [annual_coupon_payment] * years_to_maturity\n    \n    # Calculate present value of coupon payments\n    pv_coupons = sum(cf / ((1 + discount_rate) ** (i + 1)) for i, cf in enumerate(cash_flows))\n    \n    # Calculate present value of face value\n    pv_face_value = face_value / ((1 + discount_rate) ** years_to_maturity)\n    \n    # Calculate total bond value as the sum of pv coupons and pv face value\n    bond_value = pv_coupons + pv_face_value\n    \n    # Return the final answer, rounded to the nearest integer\n    return round(bond_value)",
        "ground_truth": 10445,
        "source": "FinanceReasoning-test-168",
        "question_id": "test-2089",
        "level": "hard",
        "output": [
            "To determine the fair value of the bond, I will adhere to any constraints provided in the problem:\n\n### Step-by-step reasoning (Emphasizing Constraints):\n1. **Problem Constraints**:\n    - **Coupon Rate**: The bond has a 5% annual coupon rate, and the face value is $10,000. This implies annual coupon payments of `5% * $10,000 = $500`.\n    - **Annual Coupons**: The bond pays annual coupons, meaning no adjustments are necessary for semiannual or other payment frequencies.\n    - **Maturity**: The bond will mature in **5 years**.\n    - **Discount Rate (Yield to Maturity)**: The YTM is given as **4%** and serves as the rate to discount all future cash flows.\n\n2. **Required Calculation**:\n    - The present value (PV) is determined by summing the discounted values of all future cash flows:\n        - **Coupon Payments (annually)**: $500 received each year for 5 years, discounted by YTM at 4% annually.\n        - **Face Value Payment**: The face value of $10,000 at the end of 5 years, discounted by the same 4% rate.\n\n3. **Formula to Use**:\n    Since we are adhering to annual coupon payments:\n    - **PV of Coupons** = \\( \\sum \\frac{500}{{(1 + 0.04)}^t} \\)  for \\( t = 1 \\) to \\( t = 5 \\).\n    - **PV of Face Value** = \\(\\frac{10,000}{{(1 + 0.04)}^5}\\).\n    - **Bond Price** = PV of Coupons + PV of Face Value.\n\n4. **Precision**:\n    - We are instructed to calculate the bond price to the nearest integer.\n\nLet\u2019s generate the Python program to compute the result.\n\n```python\ndef solution():\n    # Define the bond parameters\n    face_value = 10000  # Face value of the bond\n    coupon_rate = 0.05  # Annual coupon rate as a decimal\n    years_to_maturity = 5  # Number of years until maturity\n    yield_to_maturity = 0.04  # Annual yield to maturity as a decimal\n\n    # Calculate annual coupon payment\n    annual_coupon = face_value * coupon_rate\n\n    # Calculate the present value of coupon payments\n    pv_coupons = sum(annual_coupon / ((1 + yield_to_maturity) ** t) for t in range(1, years_to_maturity + 1))\n    \n    # Calculate the present value of the face value payment\n    pv_face_value = face_value / ((1 + yield_to_maturity) ** years_to_maturity)\n    \n    # Calculate the total bond price\n    bond_price = pv_coupons + pv_face_value\n    \n    # Round to the nearest integer and return the answer\n    return round(bond_price)\n```"
        ],
        "retrieval_query": "What is the present value of this bond, including all expected future coupon payments and the face value at maturity, using the given yield to maturity? Answer to the nearest integer.",
        "useful_functions": [
            "def calculate_bond_price(coupon_rate: float, periods_per_year: int, years_to_maturity: int, \n                         required_rate: float, par_value: float) -> float:\n    \"\"\"\n    Calculate the price of a bond given its parameters.\n\n    This function calculates the present value of a bond's future cash flows, which include\n    periodic coupon payments and the repayment of the par value at maturity. The present value is\n    obtained by discounting these cash flows at the bond's required rate of return.\n\n    Args:\n        coupon_rate (float): The annual coupon rate of the bond as a percentage (e.g., 3 for 3%).\n        periods_per_year (int): Number of coupon payments per year (e.g., 2 for semiannual).\n        years_to_maturity (int): The number of years until the bond matures.\n        required_rate (float): The annual required rate of return as a percentage (e.g., 5 for 5%).\n        par_value (float): The par value of the bond.\n\n    Returns:\n        bond_price (float): The calculated price of the bond.\n\n    Notes:\n        - Applicability: Use this function to calculate the price of fixed-rate bonds with \n          periodic coupon payments.\n        - Constraints: \n          - `coupon_rate`, `required_rate` should be input as percentages (e.g., 5 for 5%).\n          - `periods_per_year` should reflect how many times coupon payments occur in a year.\n        - Considerations: Make sure interest rates and periods are in consistent units (e.g., \n          semiannual periods require halving the annual rates).\n    \"\"\"\n    # Convert annual rates to per period rates\n    period_rate = (required_rate / 100) / periods_per_year\n    period_coupon = (coupon_rate / 100) * par_value / periods_per_year\n    total_periods = periods_per_year * years_to_maturity\n    \n    # Calculate the present value of coupons\n    pv_coupons = sum(period_coupon / ((1 + period_rate) ** i) for i in range(1, total_periods + 1))\n    \n    # Calculate the present value of the par value\n    pv_par_value = par_value / ((1 + period_rate) ** total_periods)\n    \n    # Calculate total bond price\n    bond_price = pv_coupons + pv_par_value\n    \n    return round(bond_price, 3)",
            "def calculate_bond_value(cash_flows: list, face_value: float, discount_rate: float) -> float:\n    \"\"\"\n    Calculate the present value of a bond's expected future coupon payments and its face value.\n\n    This function computes the theoretical fair value of a bond by calculating\n    the present value of its expected future coupon payments and the present\n    value of its face value at maturity using a specified discount rate.\n\n    Args:\n        cash_flows (list): A list of future cash flows representing coupon payments.\n        face_value (float): The face value of the bond to be paid back at maturity.\n        discount_rate (float): The discount rate used for calculating present value, \n                               often the yield to maturity. It must be greater than -1.\n\n    Returns:\n        bond_value (float): The calculated present value of the bond.\n\n    Notes:\n        - Assumes that cash flows occur at regular intervals.\n        - Discount rate must be greater than -1.\n        - Cash flows should be provided in chronological order.\n        - This function is useful for evaluating bond investments by understanding\n          their intrinsic value based on cash flows and interest rates.\n    \"\"\"\n    if discount_rate <= -1:\n        raise ValueError(\"Discount rate must be greater than -1.\")\n    \n    pv_coupons = sum(cf / ((1 + discount_rate) ** (i + 1)) for i, cf in enumerate(cash_flows))\n    pv_face_value = face_value / ((1 + discount_rate) ** len(cash_flows))\n    \n    bond_value = pv_coupons + pv_face_value\n    \n    return bond_value",
            "def calculate_bond_price(face_value: float, coupon_rate: float, market_yield: float, years: int) -> float:\n    \"\"\"\n    Calculate the market price of a bond given its face value, coupon rate, market yield, and number of years to maturity.\n\n    This function computes the price of a bond based on its face value, coupon rate, market yield, and the number of\n    years until maturity. The bond price is calculated using the formula for the present value of future cash flows.\n\n    Args:\n        face_value (float): The face value (nominal value) of the bond, which is the amount repaid at maturity.\n        coupon_rate (float): The annual coupon rate as a decimal (e.g., 0.10 for 10%).\n        market_yield (float): The market yield (yield to maturity) as a decimal (e.g., 0.12 for 12%).\n        years (int): The number of years until the bond matures.\n\n    Returns:\n        bond_price (float): The calculated market price of the bond.\n\n    Notes:\n        - This function assumes annual coupon payments.\n        - The market yield must be greater than -1 to ensure meaningful results.\n        - The bond price is sensitive to changes in market yield and coupon rate.\n    \"\"\"\n    if market_yield <= -1:\n        raise ValueError(\"Market yield must be greater than -1.\")\n\n    annual_coupon = face_value * coupon_rate\n    bond_price = sum(annual_coupon / ((1 + market_yield) ** i) for i in range(1, years + 1))\n    bond_price += face_value / ((1 + market_yield) ** years)\n\n    return bond_price"
        ],
        "usage": {
            "completion_tokens": 619,
            "prompt_tokens": 1652,
            "total_tokens": 2271,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-3112",
        "article_title": "Overbought",
        "function": "def calculate_rsi(price_changes: list, period: int = 14) -> float:\n    \"\"\"\n    Calculate the Relative Strength Index (RSI) for a series of price changes.\n\n    The RSI is a momentum oscillator that measures the speed and change of price\n    movements. It helps identify overbought or oversold conditions in a traded\n    security by comparing the magnitude of recent gains to recent losses.\n\n    Args:\n        price_changes (list): A list of sequential price changes (positive or negative).\n        period (int): The number of time periods to use for the RSI calculation,\n                      typically 14.\n\n    Returns:\n        rsi (float): The calculated RSI value, ranging from 0 to 100.\n\n    Notes:\n        - Applicability: Use this function to identify potential overbought (RSI > 70)\n          or oversold (RSI < 30) conditions.\n        - Constraints: The length of price_changes must be greater than or equal to\n          the specified period to calculate an RSI value.\n        - Considerations: Ensure that the input data is in chronological order.\n          The initial RSI calculations may be less reliable due to insufficient data points.\n    \"\"\"\n    if len(price_changes) < period:\n        raise ValueError(\"price_changes must contain at least 'period' number of data points.\")\n\n    gains = [max(change, 0) for change in price_changes]\n    losses = [abs(min(change, 0)) for change in price_changes]\n\n    avg_gain = sum(gains[:period]) / period\n    avg_loss = sum(losses[:period]) / period\n\n    if avg_loss == 0:\n        return 100.0\n\n    rs = avg_gain / avg_loss\n    rsi = 100 - (100 / (1 + rs))\n    \n    return rsi",
        "statistics": {
            "number_statistics": {
                "args_numbers": 2,
                "question_numbers": 1,
                "context_numbers": 16,
                "total_numbers": 17
            },
            "operator_statistics": {
                "operators": {
                    "+": 1,
                    "-": 1,
                    "*": 0,
                    "/": 4,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 6
            },
            "code_statistics": {
                "lines": 9,
                "parentheses": 14
            }
        },
        "difficulty": 4.564348191467836,
        "context": "A financial analyst is assessing the trading performance of a tech stock over the past two weeks. She wants to determine if the stock is currently overbought or oversold using the Relative Strength Index (RSI), which relies on the stock's daily price changes. For this assessment, she has collected the following daily price changes for the last 14 trading days (in USD): [2.5, -1.3, 2.8, 3.1, -0.5, -2.2, 1.0, 1.5, 1.7, -1.8, 2.9, -0.4, -0.9, 0.8]. She will apply the standard 14-day period for her RSI calculation.",
        "question": "Calculate the RSI for the stock over the past 14 trading days. Provide the answer as a percentage to two decimal places.",
        "python_solution": "def solution():\n    # List of daily price changes over the past 14 days\n    price_changes = [2.5, -1.3, 2.8, 3.1, -0.5, -2.2, 1.0, 1.5, 1.7, -1.8, 2.9, -0.4, -0.9, 0.8]\n    period = 14\n\n    # Calculate the gains and losses\n    gains = [max(change, 0) for change in price_changes]\n    losses = [abs(min(change, 0)) for change in price_changes]\n\n    # Calculate the average gains and losses over the period\n    avg_gain = sum(gains) / period\n    avg_loss = sum(losses) / period\n\n    # Avoid division by zero\n    if avg_loss == 0:\n        return 100.0\n\n    # Calculate the relative strength (RS)\n    rs = avg_gain / avg_loss\n\n    # Calculate the RSI\n    rsi = 100 - (100 / (1 + rs))\n    \n    # Return the RSI value rounded to two decimal places\n    return round(rsi, 2)\n\n# Execute the solution function\nsolution()",
        "ground_truth": 69.66,
        "source": "FinanceReasoning-test-172",
        "question_id": "test-2090",
        "level": "hard",
        "output": [
            "Step-by-step approach using constraints (EC):\n\n1. **Constraints Identification**:\n   - The list should cover 14 trading days (this is mentioned in the problem).\n   - We need to calculate the RSI based on these 14 days, which is the standard calculation period.\n   - The answer must be provided as a percentage to two decimal places.\n\n2. **Understanding the RSI Calculation**:\n   - RSI is calculated as:\n     \\[\n     RSI = 100 - \\left( \\frac{100}{1 + RS} \\right)\n     \\]\n     where \\( RS = \\frac{\\text{Average Gain}}{\\text{Average Loss}} \\)\n     - **Average Gain**: The average of all positive price changes over the period.\n     - **Average Loss**: The average of all absolute values of negative price changes over the period.\n   - If there were no losses, RSI would be 100. Similarly, if there were no gains, RSI would be 0.\n\n3. **Plan based on input**:\n   - Filter positive and negative price changes from the given data.\n   - Calculate the average gain and average loss over the period.\n   - Compute \\( RS \\) and then the RSI.\n\n4. **Adhere to constraints**:\n   - Ensure the list has exactly 14 elements since it matches the calculation period.\n   - Format the final RSI value as a percentage rounded to two decimal places.\n\n5. **Implementation**:\n   - Write Python code to perform the calculation and return the RSI value.\n\nHere is the Python implementation:\n\n```python\ndef solution():\n    # Define variables name and value\n    price_changes = [2.5, -1.3, 2.8, 3.1, -0.5, -2.2, 1.0, 1.5, 1.7, -1.8, 2.9, -0.4, -0.9, 0.8]\n    period = 14\n    \n    # Ensure the list of price changes matches the period\n    if len(price_changes) != period:\n        raise ValueError(\"The list of price changes must contain exactly 14 elements.\")\n    \n    # Calculate gains and losses\n    gains = [max(change, 0) for change in price_changes]\n    losses = [abs(min(change, 0)) for change in price_changes]\n    \n    # Compute average gain and average loss\n    avg_gain = sum(gains) / period\n    avg_loss = sum(losses) / period\n    \n    # Calculate RSI\n    if avg_loss == 0:\n        return 100.0  # RSI is 100 if there are no losses\n    \n    rs = avg_gain / avg_loss\n    rsi = 100 - (100 / (1 + rs))\n    \n    # Return RSI as a percentage rounded to two decimal places\n    return round(rsi, 2)\n\n```"
        ],
        "retrieval_query": "Calculate the RSI for the stock over the past 14 trading days. Provide the answer as a percentage to two decimal places.",
        "useful_functions": [
            "def calculate_relative_strength(price_changes: list) -> float:\n    \"\"\"\n    Calculate the Relative Strength Index (RSI) based on recent price changes.\n\n    This function computes the RSI, a momentum indicator that measures the \n    magnitude of recent price changes to evaluate overbought or oversold \n    conditions in the price of an asset. RSI values range from 0 to 100.\n\n    Args:\n        price_changes (list): A list of recent price changes, where positive\n                              values indicate price increases and negative values\n                              indicate price decreases.\n\n    Returns:\n        rsi (float): The calculated RSI value.\n\n    Notes:\n        - Applicability: This function is applicable in technical analysis of stocks\n          or other assets to determine overbought or oversold conditions.\n        - Constraints: The list of price changes should not be empty.\n        - Considerations: Traditional interpretations are that RSI values >= 70 indicate\n          overbought conditions, and values <= 30 indicate oversold conditions.\n    \"\"\"\n    if not price_changes:\n        raise ValueError(\"Price changes list cannot be empty.\")\n    \n    gain = sum(change for change in price_changes if change > 0) / len(price_changes)\n    loss = -sum(change for change in price_changes if change < 0) / len(price_changes)\n    \n    if loss == 0:\n        return 100.0  # Return maximum RSI value if no losses\n\n    rs = gain / loss\n    rsi = 100 - (100 / (1 + rs))\n    \n    return rsi",
            "def calculate_rsi(price_changes: list, period: int = 14) -> float:\n    \"\"\"\n    Calculate the Relative Strength Index (RSI) for a series of price changes.\n\n    The RSI is a momentum oscillator that measures the speed and change of price\n    movements. It helps identify overbought or oversold conditions in a traded\n    security by comparing the magnitude of recent gains to recent losses.\n\n    Args:\n        price_changes (list): A list of sequential price changes (positive or negative).\n        period (int): The number of time periods to use for the RSI calculation,\n                      typically 14.\n\n    Returns:\n        rsi (float): The calculated RSI value, ranging from 0 to 100.\n\n    Notes:\n        - Applicability: Use this function to identify potential overbought (RSI > 70)\n          or oversold (RSI < 30) conditions.\n        - Constraints: The length of price_changes must be greater than or equal to\n          the specified period to calculate an RSI value.\n        - Considerations: Ensure that the input data is in chronological order.\n          The initial RSI calculations may be less reliable due to insufficient data points.\n    \"\"\"\n    if len(price_changes) < period:\n        raise ValueError(\"price_changes must contain at least 'period' number of data points.\")\n\n    gains = [max(change, 0) for change in price_changes]\n    losses = [abs(min(change, 0)) for change in price_changes]\n\n    avg_gain = sum(gains[:period]) / period\n    avg_loss = sum(losses[:period]) / period\n\n    if avg_loss == 0:\n        return 100.0\n\n    rs = avg_gain / avg_loss\n    rsi = 100 - (100 / (1 + rs))\n    \n    return rsi"
        ],
        "usage": {
            "completion_tokens": 603,
            "prompt_tokens": 1214,
            "total_tokens": 1817,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-2076",
        "article_title": "Uptrend",
        "function": "def identify_uptrend(prices: list, window: int) -> bool:\n    \"\"\"\n    Identify if an uptrend exists in a series of price data.\n\n    This function checks for an uptrend in a list of price data by ensuring that\n    each successive set of prices over the specified window forms higher highs\n    and higher lows.\n\n    Args:\n        prices (list): A list of floats representing the price data, ordered\n                       from oldest to most recent.\n        window (int): The number of periods to look back to establish highs\n                      and lows. Must be a positive integer.\n\n    Returns:\n        is_uptrend (bool): Returns True if prices exhibit an uptrend, otherwise\n                           False.\n\n    Notes:\n        - Applicability: Useful for traders and analysts seeking to determine \n          market trends in technical analysis.\n        - Constraints: The window size must be smaller than the length of the \n          price data for valid comparisons.\n        - Considerations: Ensure that the prices list contains only numerical \n          values and is sorted chronologically from past to present.\n    \"\"\"\n    if window >= len(prices) or window <= 0:\n        raise ValueError(\"Window size must be smaller than the length of price data and positive.\")\n\n    previous_high = max(prices[:window])\n    previous_low = min(prices[:window])\n\n    for i in range(window, len(prices)):\n        current_high = max(prices[i - window + 1:i + 1])\n        current_low = min(prices[i - window + 1:i + 1])\n\n        if current_high <= previous_high or current_low <= previous_low:\n            return False\n        \n        previous_high = current_high\n        previous_low = current_low\n    \n    return True",
        "statistics": {
            "number_statistics": {
                "args_numbers": 2,
                "question_numbers": 1,
                "context_numbers": 17,
                "total_numbers": 18
            },
            "operator_statistics": {
                "operators": {
                    "+": 4,
                    "-": 2,
                    "*": 0,
                    "/": 0,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 6
            },
            "code_statistics": {
                "lines": 10,
                "parentheses": 12
            }
        },
        "difficulty": 4.564348191467836,
        "context": "A financial analyst is reviewing the recent price movements of a tech company's stock to determine if the stock is currently in an uptrend. The analyst has gathered daily closing prices for the past 15 days: [150, 152, 153, 155, 156, 158, 160, 162, 163, 165, 166, 168, 170, 172, 173]. The analyst decides to use a 5-day window to establish higher highs and higher lows to validate an uptrend.",
        "question": "Using the 5-day window, does the series of daily closing prices exhibit an uptrend? Answer as \"True\" if there is an uptrend and \"False\" otherwise.",
        "python_solution": "def solution():\n    # Define the list of prices and the window size\n    prices = [150, 152, 153, 155, 156, 158, 160, 162, 163, 165, 166, 168, 170, 172, 173]\n    window = 5\n\n    # Initialize the previous high and low using the first window\n    previous_high = max(prices[:window])\n    previous_low = min(prices[:window])\n\n    # Iterate over the rest of the price data\n    for i in range(window, len(prices)):\n        # Determine the current high and low over the window\n        current_high = max(prices[i - window + 1:i + 1])\n        current_low = min(prices[i - window + 1:i + 1])\n        \n        # Check if there is no uptrend (i.e., current high not higher or current low not higher)\n        if current_high <= previous_high or current_low <= previous_low:\n            return False\n        \n        # Update the previous high and low\n        previous_high = current_high\n        previous_low = current_low\n    \n    # If we complete the loop without returning False, there is an uptrend\n    return True",
        "ground_truth": true,
        "source": "FinanceReasoning-test-176",
        "question_id": "test-2091",
        "level": "hard",
        "output": [
            "### Step-by-step Reasoning Using **Emphasizing Constraints (EC)**:\n\n1. **Understand the Problem**:\n   - We are analyzing the series of daily closing stock prices: `[150, 152, 153, 155, 156, 158, 160, 162, 163, 165, 166, 168, 170, 172, 173]`.\n   - Using a **5-day window**, we must determine whether the stock exhibits an **uptrend**, which requires consistently higher **highs** and **lows** over each 5-day rolling window.\n\n2. **Requirements for Uptrend**:\n   - A financial uptrend exists if:\n     - Each 5-day window exhibits a **higher high** (maximum price in the window is increasing compared to the previous window).\n     - Each 5-day window exhibits a **higher low** (minimum price in the window is increasing compared to the previous window).\n\n3. **Constraints**:\n   - The input is a fixed list of prices.\n   - The analysis proceeds in rolling 5-day windows, requiring at least two windows for comparison.\n   - The comparison must ensure each 5-day segment is validated for both higher highs and higher lows.\n\n4. **Approach**:\n   - Sliding through the prices with a 5-day window, calculate the **high** (max) and **low** (min) for each window.\n   - Compare the **highs** and **lows** of adjacent 5-day windows. If any window fails the higher-high or higher-low condition, the stock does not exhibit an uptrend.\n   - If all windows meet the criteria, we confirm an uptrend.\n\n5. **Implementation**:\n   - Use a loop to calculate highs and lows for all 5-day windows.\n   - Validate conditions for higher highs and higher lows.\n   - Return `True` if the uptrend is confirmed, otherwise return `False`.\n\n---\n\n### Python Program:\n```python\ndef solution():\n    # Define variables: the daily closing prices and window size\n    closing_prices = [150, 152, 153, 155, 156, 158, 160, 162, 163, 165, 166, 168, 170, 172, 173]\n    window_size = 5\n    \n    # Calculate highs and lows for each 5-day window\n    highs = []\n    lows = []\n    \n    for i in range(len(closing_prices) - window_size + 1):\n        window = closing_prices[i:i + window_size]\n        highs.append(max(window))\n        lows.append(min(window))\n    \n    # Check for uptrend by comparing adjacent windows\n    for j in range(len(highs) - 1):\n        if highs[j + 1] <= highs[j] or lows[j + 1] <= lows[j]:\n            return False  # If any condition fails, it's not an uptrend\n    \n    # If all windows meet the criteria, it is an uptrend\n    return True\n```"
        ],
        "retrieval_query": "Using the 5-day window, does the series of daily closing prices exhibit an uptrend? Answer as \"True\" if there is an uptrend and \"False\" otherwise.",
        "useful_functions": [
            "def calculate_make_whole_call_price(remaining_payments: list, principal: float, treasury_yield: float, spread: float) -> float:\n    \"\"\"\n    Calculate the make-whole call price for a bond.\n\n    This function computes the make-whole call price, which is the present value of\n    the remaining scheduled payments (both interest and principal) of a bond, discounted\n    at a rate derived from the Treasury yield and a specified spread. It is used to determine\n    the payout an issuer must make to call a bond early with a make-whole provision.\n\n    Args:\n        remaining_payments (list): A list of remaining coupon payments.\n        principal (float): The principal amount of the bond to be paid at maturity.\n        treasury_yield (float): The yield of a comparable Treasury security used as a basis\n                                for discounting future cash flows (expressed as a decimal).\n        spread (float): The additional spread over the Treasury yield used for discounting\n                        (expressed as a decimal).\n\n    Returns:\n        make_whole_price (float): The present value of the bond's remaining cash flows including\n                                  the principal, representing the make-whole call price.\n\n    Notes:\n        - Applicability: This function is applicable in the context of make-whole call provisions\n          for bonds when calculating the early redemption price.\n        - Constraints: Ensure all interest rates are provided as decimals (e.g., 2% should be 0.02).\n        - Considerations: Consider the possibility of changes in interest rates affecting the discount rate.\n                          This function assumes cash flows occur at the end of each period.\n    \"\"\"\n    discount_rate = treasury_yield + spread\n    make_whole_price = sum(cf / ((1 + discount_rate) ** (i + 1)) for i, cf in enumerate(remaining_payments))\n    make_whole_price += principal / ((1 + discount_rate) ** len(remaining_payments))\n\n    return make_whole_price"
        ],
        "usage": {
            "completion_tokens": 629,
            "prompt_tokens": 888,
            "total_tokens": 1517,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-452",
        "article_title": "Interest Rate Risk",
        "function": "def calculate_bond_duration(cash_flows: list, discount_rate: float) -> float:\n    \"\"\"\n    Calculate the Macaulay Duration of a bond given its cash flows and discount rate.\n\n    This function computes the weighted average time for a bond to receive its cash flows,\n    providing a measure of interest rate sensitivity.\n\n    Args:\n        cash_flows (list): A list of cash flows from the bond, including coupon payments and the face value.\n                           Cash flows should be ordered by their respective time periods.\n        discount_rate (float): The discount rate (e.g., yield to maturity) used to discount cash flows. Must be positive.\n\n    Returns:\n        duration (float): The Macaulay Duration, representing the weighted average time to receive the bond's cash flows.\n\n    Notes:\n        - This function assumes that cash flows occur annually.\n        - The discount rate must be positive to ensure a valid result.\n        - Duration is typically used to assess a bond's sensitivity to interest rate changes.\n    \"\"\"\n    if discount_rate <= 0:\n        raise ValueError(\"Discount rate must be positive.\")\n\n    total_present_value = sum(cf / ((1 + discount_rate) ** t) for t, cf in enumerate(cash_flows, 1))\n    duration = sum(t * (cf / ((1 + discount_rate) ** t)) / total_present_value for t, cf in enumerate(cash_flows, 1))\n\n    return duration",
        "statistics": {
            "number_statistics": {
                "args_numbers": 2,
                "question_numbers": 0,
                "context_numbers": 4,
                "total_numbers": 4
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 0,
                    "*": 1,
                    "/": 3,
                    "%": 0,
                    "**": 2
                },
                "total_operators": 8
            },
            "code_statistics": {
                "lines": 3,
                "parentheses": 18
            }
        },
        "difficulty": 4.564348191467836,
        "context": "A corporation issues a bond with the following details: The bond has a term of 5 years, and it pays an annual coupon of $50 each year. At maturity, the bond will also pay the face value of $1,000 in addition to the last coupon payment. The yield to maturity on the bond is 4% per annum.",
        "question": "What is the Macaulay Duration of this bond? Answer to two decimal places.",
        "python_solution": "def solution():\n    # Define the cash flows and discount rate\n    cash_flows = [50, 50, 50, 50, 1050]  # Annual coupons and face value at maturity\n    discount_rate = 0.04  # Yield to maturity expressed as a decimal\n\n    # Calculate total present value of the bond\n    total_present_value = sum(cf / ((1 + discount_rate) ** t) for t, cf in enumerate(cash_flows, 1))\n\n    # Calculate Macaulay Duration\n    duration = sum(t * (cf / ((1 + discount_rate) ** t)) / total_present_value for t, cf in enumerate(cash_flows, 1))\n\n    # Return the result rounded to two decimal places\n    return round(duration, 2)",
        "ground_truth": 4.56,
        "source": "FinanceReasoning-test-242",
        "question_id": "test-2092",
        "level": "hard",
        "output": [
            "### Step-by-Step Solution using Emphasizing Constraints (EC):\n\n1. **Understand Constraints and Input Requirements**:\n   - The bond has consistent *annual* cash flows for 5 years.\n   - We calculate a Macaulay Duration, which evaluates the weighted average time to receive bond payments.\n   - The yield to maturity (YTM) is 4%, which needs to be expressed as a decimal (0.04).\n   - Cash flows include annual coupon payments of $50 for 5 years and an additional $1,000 as face value in the final year. Therefore, cash flows are $50, $50, $50, $50, and $1,050 for year 1-5.\n\n2. **Focus on the Financial Formula**:\n   - Use the formula provided (`calculate_bond_duration`) to compute the duration of the bond:\n     1. Compute the present value of all cash flows using the provided yield (discount rate).\n     2. Weight each cash flow using its respective time period.\n     3. Normalize weights to obtain the weighted average time-to-payment (duration).\n\n3. **Ensure Adherence to Decimal Precision**:\n   - The answer must be rounded to two decimal places as per the requirements.\n\n4. **Evaluate Provided Function**:\n   - Using the `calculate_bond_duration` function with the appropriate inputs will directly return the desired Macaulay Duration.\n\n5. **Summary of Inputs**:\n   - Cash flows: [50, 50, 50, 50, 1050]\n   - Discount rate (YTM): 0.04\n\nNow, let\u2019s implement the solution as per the above reasoning.\n\n```python\ndef solution():\n    # Define the calculate_bond_duration function\n    def calculate_bond_duration(cash_flows: list, discount_rate: float) -> float:\n        if discount_rate <= 0:\n            raise ValueError(\"Discount rate must be positive.\")\n\n        # Sum present value of all cash flows\n        total_present_value = sum(cf / ((1 + discount_rate) ** t) for t, cf in enumerate(cash_flows, 1))\n        \n        # Calculate duration as a weighted average\n        duration = sum(t * (cf / ((1 + discount_rate) ** t)) / total_present_value for t, cf in enumerate(cash_flows, 1))\n\n        return duration\n\n    # Define variables\n    cash_flows = [50, 50, 50, 50, 1050]  # List of cash flows (annual coupons + face value in year 5)\n    discount_rate = 0.04                 # Yield to maturity (4% as a decimal)\n    \n    # Calculate Macaulay Duration using the function\n    duration = calculate_bond_duration(cash_flows, discount_rate)\n    \n    # Return the result rounded to two decimal places\n    return round(duration, 2)\n```"
        ],
        "retrieval_query": "What is the Macaulay Duration of this bond? Answer to two decimal places.",
        "useful_functions": [
            "def calculate_bond_duration(cash_flows: list, discount_rate: float) -> float:\n    \"\"\"\n    Calculate the Macaulay Duration of a bond given its cash flows and discount rate.\n\n    This function computes the weighted average time for a bond to receive its cash flows,\n    providing a measure of interest rate sensitivity.\n\n    Args:\n        cash_flows (list): A list of cash flows from the bond, including coupon payments and the face value.\n                           Cash flows should be ordered by their respective time periods.\n        discount_rate (float): The discount rate (e.g., yield to maturity) used to discount cash flows. Must be positive.\n\n    Returns:\n        duration (float): The Macaulay Duration, representing the weighted average time to receive the bond's cash flows.\n\n    Notes:\n        - This function assumes that cash flows occur annually.\n        - The discount rate must be positive to ensure a valid result.\n        - Duration is typically used to assess a bond's sensitivity to interest rate changes.\n    \"\"\"\n    if discount_rate <= 0:\n        raise ValueError(\"Discount rate must be positive.\")\n\n    total_present_value = sum(cf / ((1 + discount_rate) ** t) for t, cf in enumerate(cash_flows, 1))\n    duration = sum(t * (cf / ((1 + discount_rate) ** t)) / total_present_value for t, cf in enumerate(cash_flows, 1))\n\n    return duration"
        ],
        "usage": {
            "completion_tokens": 601,
            "prompt_tokens": 718,
            "total_tokens": 1319,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-853",
        "article_title": "Market Breadth",
        "function": "def calculate_on_balance_volume(prices: list, volumes: list) -> list:\n    \"\"\"\n    Calculate the On-Balance Volume (OBV) indicator.\n\n    This function computes the On-Balance Volume indicator, a technical analysis\n    tool that uses volume flow to predict changes in stock price. OBV is used to\n    confirm price trends.\n\n    Args:\n        prices (list): A list of stock prices from previous days.\n        volumes (list): A list of trading volumes corresponding to the price list.\n\n    Returns:\n        obv (list): A list of OBV values for each day.\n\n    Notes:\n        - Applicability: Useful for confirming price trends with volume data.\n        - Constraints: Prices and volumes lists must be of equal length and contain at least two elements.\n        - Considerations: Sudden volume spikes can affect OBV calculations.\n    \"\"\"\n    if len(prices) != len(volumes):\n        raise ValueError(\"Prices and volumes lists must have the same length.\")\n    if len(prices) < 2:\n        raise ValueError(\"At least two price points are required to calculate OBV.\")\n\n    obv = [0]  # Initial OBV is zero\n    for i in range(1, len(prices)):\n        if prices[i] > prices[i - 1]:\n            obv.append(obv[-1] + volumes[i])\n        elif prices[i] < prices[i - 1]:\n            obv.append(obv[-1] - volumes[i])\n        else:\n            obv.append(obv[-1])\n    \n    return obv",
        "statistics": {
            "number_statistics": {
                "args_numbers": 2,
                "question_numbers": 0,
                "context_numbers": 10,
                "total_numbers": 10
            },
            "operator_statistics": {
                "operators": {
                    "+": 1,
                    "-": 6,
                    "*": 0,
                    "/": 0,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 7
            },
            "code_statistics": {
                "lines": 9,
                "parentheses": 10
            }
        },
        "difficulty": 4.584967478670571,
        "context": "An investor is tracking Stock A over a period of five days to analyze its trend using the On-Balance Volume (OBV) indicator. The closing prices of the stock over these five days are [150, 152, 151, 153, 154] and the corresponding trading volumes in thousands of shares are [200, 220, 210, 230, 240]. The investor wants to understand how the OBV changes each day to gain insights into market sentiment.",
        "question": "What is the On-Balance Volume (OBV) on the fifth day? Answer in the unit of thousands of shares.",
        "python_solution": "def solution():\n    # Define variables for prices and volumes\n    prices = [150, 152, 151, 153, 154]\n    volumes = [200, 220, 210, 230, 240]\n    \n    # Initialize OBV list starting with zero\n    obv = [0]\n    \n    # Calculate the OBV for each day\n    for i in range(1, len(prices)):\n        if prices[i] > prices[i - 1]:\n            obv.append(obv[-1] + volumes[i])\n        elif prices[i] < prices[i - 1]:\n            obv.append(obv[-1] - volumes[i])\n        else:\n            obv.append(obv[-1])\n    \n    # Return the OBV on the fifth day\n    return obv[-1]\n\n# Call and print the solution\nprint(solution())",
        "ground_truth": 480,
        "source": "FinanceReasoning-test-200",
        "question_id": "test-2093",
        "level": "hard",
        "output": [
            "To solve the problem, I will use the given financial function `calculate_on_balance_volume` to compute the On-Balance Volume (OBV) for the five days. Here is the step-by-step reasoning using \"Emphasizing Constraints (EC)\":\n\n1. **Constraints Analysis**:\n   - The length of `closing_prices` and `volumes` must be the same.\n   - Data must be in chronological order for accurate OBV calculations.\n   - OBV is calculated based on trends in closing prices:\n     - If today's closing price is higher than yesterday's, today's volume is added to the OBV.\n     - If today's closing price is lower than yesterday's, today's volume is subtracted from the OBV.\n     - If today's closing price is equal to yesterday's, OBV remains unchanged.\n\n2. **Step-by-Step Approach**:\n   - Use the provided `calculate_on_balance_volume` function.\n   - Input the `closing_prices` and `volumes` datasets.\n   - Compute the OBV series (list) using the function.\n   - Extract the OBV value for the fifth day, which corresponds to the last value in the OBV series.\n\n3. **Result Interpretation**:\n   - The OBV for the fifth day signifies the cumulative indication of market sentiment, considering the stock's price movement trends and trading volumes over the five days.\n\nNow, I will implement the solution in Python:\n\n```python\ndef solution():\n    # Define variables name and value\n    closing_prices = [150, 152, 151, 153, 154]\n    volumes = [200, 220, 210, 230, 240]\n    \n    # This function is provided in the question\n    def calculate_on_balance_volume(closing_prices: list, volumes: list) -> list:\n        if len(closing_prices) != len(volumes):\n            raise ValueError(\"The lengths of closing_prices and volumes must be the same.\")\n        obv_list = [0]  # Start with an OBV of 0 for the first day.\n        for i in range(1, len(closing_prices)):\n            if closing_prices[i] > closing_prices[i - 1]:\n                obv_list.append(obv_list[-1] + volumes[i])\n            elif closing_prices[i] < closing_prices[i - 1]:\n                obv_list.append(obv_list[-1] - volumes[i])\n            else:\n                obv_list.append(obv_list[-1])\n        return obv_list\n    \n    # Calculate OBV for the given closing_prices and volumes\n    obv_list = calculate_on_balance_volume(closing_prices, volumes)\n    \n    # The OBV on the fifth day (index 4)\n    answer = obv_list[-1]\n    \n    # Return the answer\n    return answer\n```"
        ],
        "retrieval_query": "What is the On-Balance Volume (OBV) on the fifth day? Answer in the unit of thousands of shares.",
        "useful_functions": [
            "def calculate_on_balance_volume(closing_prices: list, volumes: list) -> list:\n    \"\"\"\n    Calculate the On-Balance Volume (OBV) for a series of closing prices and volumes.\n\n    This function computes the On-Balance Volume, a momentum indicator that uses volume flow\n    to predict changes in stock prices. The OBV is calculated as a running total, adding or\n    subtracting the day's volume based on the change in closing prices.\n\n    Args:\n        closing_prices (list): A list of closing prices for consecutive trading days.\n        volumes (list): A list of trading volumes corresponding to each closing price.\n\n    Returns:\n        obv_list (list): A list of OBV values for each day.\n\n    Notes:\n        - Applicability: This function is applicable for analyzing stock market trends using OBV.\n        - Constraints: The length of closing_prices and volumes must be the same.\n        - Considerations: Ensure that the input data is chronologically ordered by trading days.\n                          OBV calculations do not rely on the absolute value, but rather on the trend.\n    \"\"\"\n    if len(closing_prices) != len(volumes):\n        raise ValueError(\"The lengths of closing_prices and volumes must be the same.\")\n\n    obv_list = [0]  # Start with an OBV of 0 for the first day.\n    \n    for i in range(1, len(closing_prices)):\n        if closing_prices[i] > closing_prices[i - 1]:\n            obv_list.append(obv_list[-1] + volumes[i])\n        elif closing_prices[i] < closing_prices[i - 1]:\n            obv_list.append(obv_list[-1] - volumes[i])\n        else:\n            obv_list.append(obv_list[-1])\n    \n    return obv_list"
        ],
        "usage": {
            "completion_tokens": 577,
            "prompt_tokens": 826,
            "total_tokens": 1403,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-3014",
        "article_title": "On-Balance Volume (OBV)",
        "function": "def calculate_on_balance_volume(closing_prices: list, volumes: list) -> list:\n    \"\"\"\n    Calculate the On-Balance Volume (OBV) for a series of closing prices and volumes.\n\n    This function computes the On-Balance Volume, a momentum indicator that uses volume flow\n    to predict changes in stock prices. The OBV is calculated as a running total, adding or\n    subtracting the day's volume based on the change in closing prices.\n\n    Args:\n        closing_prices (list): A list of closing prices for consecutive trading days.\n        volumes (list): A list of trading volumes corresponding to each closing price.\n\n    Returns:\n        obv_list (list): A list of OBV values for each day.\n\n    Notes:\n        - Applicability: This function is applicable for analyzing stock market trends using OBV.\n        - Constraints: The length of closing_prices and volumes must be the same.\n        - Considerations: Ensure that the input data is chronologically ordered by trading days.\n                          OBV calculations do not rely on the absolute value, but rather on the trend.\n    \"\"\"\n    if len(closing_prices) != len(volumes):\n        raise ValueError(\"The lengths of closing_prices and volumes must be the same.\")\n\n    obv_list = [0]  # Start with an OBV of 0 for the first day.\n    \n    for i in range(1, len(closing_prices)):\n        if closing_prices[i] > closing_prices[i - 1]:\n            obv_list.append(obv_list[-1] + volumes[i])\n        elif closing_prices[i] < closing_prices[i - 1]:\n            obv_list.append(obv_list[-1] - volumes[i])\n        else:\n            obv_list.append(obv_list[-1])\n    \n    return obv_list",
        "statistics": {
            "number_statistics": {
                "args_numbers": 2,
                "question_numbers": 0,
                "context_numbers": 5,
                "total_numbers": 5
            },
            "operator_statistics": {
                "operators": {
                    "+": 1,
                    "-": 6,
                    "*": 0,
                    "/": 0,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 7
            },
            "code_statistics": {
                "lines": 9,
                "parentheses": 10
            }
        },
        "difficulty": 4.584967478670571,
        "context": "An investor is analyzing the trend of a particular stock over a recent five-day trading period to make informed investment decisions. The stock's daily closing prices and corresponding trading volumes are recorded for these days. The closing prices for the five days are as follows: [150, 155, 153, 157, 160], and the respective trading volumes in shares are [1000, 1500, 1200, 1800, 2000]. The investor uses the On-Balance Volume (OBV) indicator to determine the momentum and potential future movement of the stock.",
        "question": "Calculate the On-Balance Volume (OBV) for the stock at the end of the five-day period. Report the final OBV value as an integer.",
        "python_solution": "def solution():\n    # Initialize variables for closing prices and volumes\n    closing_prices = [150, 155, 153, 157, 160]\n    volumes = [1000, 1500, 1200, 1800, 2000]\n    \n    # Initialize the OBV list starting with a value of 0\n    obv_list = [0]\n    \n    # Calculate the OBV based on the provided prices and volumes\n    for i in range(1, len(closing_prices)):\n        if closing_prices[i] > closing_prices[i - 1]:\n            obv_list.append(obv_list[-1] + volumes[i])\n        elif closing_prices[i] < closing_prices[i - 1]:\n            obv_list.append(obv_list[-1] - volumes[i])\n        else:\n            obv_list.append(obv_list[-1])\n    \n    # Return the OBV at the end of the five-day period\n    return obv_list[-1]\n\n# Output the solution\nsolution()",
        "ground_truth": 4100,
        "source": "FinanceReasoning-test-202",
        "question_id": "test-2094",
        "level": "hard",
        "output": [
            "To calculate the On-Balance Volume (OBV) for the stock at the end of the five-day period:\n\n1. Emphasizing Constraints (EC):\n   - Starting value of OBV is always initialized at `0`.\n   - OBV is calculated by comparing the closing price of the current day to the previous day's closing price:\n     1. If the price increases, then add the current day's volume to the OBV.\n     2. If the price decreases, then subtract the current day's volume from the OBV.\n     3. If the price remains the same, the OBV is unchanged.\n   - The final OBV value must be reported as an integer.\n\n2. Steps to solve the problem:\n   - Initialize OBV to `0`.\n   - Iterate through the five-day data, starting from day 2 (index 1), as day 1 does not have a previous day to compare against.\n   - For each day, compare its price to the previous day's price. Based on the comparison, adjust the OBV by adding or subtracting the current day's trading volume.\n   - Return the final OBV after processing all five days.\n\nWith this structured approach, here is the Python program:\n\n```python\ndef solution():\n    # Define variables for closing prices and trading volumes\n    closing_prices = [150, 155, 153, 157, 160]\n    trading_volumes = [1000, 1500, 1200, 1800, 2000]\n    \n    # Initialize OBV\n    obv = 0\n    \n    # Loop through prices from the second day\n    for i in range(1, len(closing_prices)):\n        if closing_prices[i] > closing_prices[i - 1]:  # Price increased\n            obv += trading_volumes[i]\n        elif closing_prices[i] < closing_prices[i - 1]:  # Price decreased\n            obv -= trading_volumes[i]\n        # If prices are the same, OBV remains unchanged\n    \n    # Return the final OBV value\n    return obv\n```"
        ],
        "retrieval_query": "Calculate the On-Balance Volume (OBV) for the stock at the end of the five-day period. Report the final OBV value as an integer.",
        "useful_functions": [],
        "usage": {
            "completion_tokens": 431,
            "prompt_tokens": 475,
            "total_tokens": 906,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-213",
        "article_title": "Covariance",
        "function": "def calculate_covariance(returns_x: list, returns_y: list) -> float:\n    \"\"\"\n    Calculate the covariance between two sets of asset returns.\n\n    This function computes the covariance between the returns of two assets.\n    Covariance measures the directional relationship between these two asset returns.\n\n    Args:\n        returns_x (list): A list of returns for the first asset (e.g., stock ABC).\n        returns_y (list): A list of returns for the second asset (e.g., stock XYZ).\n                          Must be the same length as returns_x.\n\n    Returns:\n        covariance (float): The calculated covariance value, indicating\n                            the directional relationship between the two assets.\n\n    Notes:\n        - Applicability: Used in finance to assess how two assets move together or inversely.\n        - Constraints: Both lists must be of the same length; otherwise, a ValueError is raised.\n        - Considerations: A positive covariance indicates that the assets generally move in the same direction,\n                          whereas a negative covariance indicates they move inversely.\n    \"\"\"\n    if len(returns_x) != len(returns_y):\n        raise ValueError(\"The lists of returns must have the same length.\")\n\n    mean_x = sum(returns_x) / len(returns_x)\n    mean_y = sum(returns_y) / len(returns_y)\n    \n    covariance = sum((x - mean_x) * (y - mean_y) for x, y in zip(returns_x, returns_y)) / (len(returns_x) - 1)\n    \n    return covariance",
        "statistics": {
            "number_statistics": {
                "args_numbers": 2,
                "question_numbers": 0,
                "context_numbers": 8,
                "total_numbers": 8
            },
            "operator_statistics": {
                "operators": {
                    "+": 0,
                    "-": 3,
                    "*": 1,
                    "/": 3,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 7
            },
            "code_statistics": {
                "lines": 4,
                "parentheses": 20
            }
        },
        "difficulty": 4.584967478670571,
        "context": "A financial analyst is evaluating the performance of two mutual funds, Fund A and Fund B, to determine their relationship in terms of returns over a set period. The returns for Fund A over four consecutive quarters are 0.05, 0.02, -0.03, and 0.04. Meanwhile, the returns for Fund B during the same quarters are 0.06, 0.01, -0.02, and 0.03. The analyst wants to calculate the covariance of returns between these two funds to understand how they move in relation to each other.",
        "question": "What is the covariance of the returns between Fund A and Fund B? Answer as a float to three decimal places.",
        "python_solution": "def solution():\n    # Returns for Fund A and Fund B\n    returns_a = [0.05, 0.02, -0.03, 0.04]\n    returns_b = [0.06, 0.01, -0.02, 0.03]\n\n    # Calculate means of returns for both funds\n    mean_a = sum(returns_a) / len(returns_a)\n    mean_b = sum(returns_b) / len(returns_b)\n\n    # Calculate covariance\n    covariance = sum((a - mean_a) * (b - mean_b) for a, b in zip(returns_a, returns_b)) / (len(returns_a) - 1)\n\n    # Return the covariance rounded to three decimal places\n    return round(covariance, 3)",
        "ground_truth": 0.001,
        "source": "FinanceReasoning-test-218",
        "question_id": "test-2095",
        "level": "hard",
        "output": [
            "To solve this problem, let's work step by step:\n\n---\n\n**Step 1: Understand the problem and constraints.**\n1. The problem requires calculating the covariance of quarterly returns between Fund A and Fund B.\n2. Follow the formula for covariance:\n   \\[\n   \\text{Cov(X, Y)} = \\frac{\\sum_{i=1}^{n}{(X_i - \\bar{X}) (Y_i - \\bar{Y})}}{n}\n   \\]\n   - \\( X_i \\) and \\( Y_i \\) are the quarterly returns of Fund A and Fund B, respectively.\n   - \\( \\bar{X} \\) and \\( \\bar{Y} \\) are the mean (average) returns for Fund A and Fund B, respectively.\n   - \\( n \\) is the number of observations, which is 4 quarters in this case.\n\n**Constraints to emphasize:**\n1. Explicitly compute to **three decimal places** for the covariance result.\n2. Perform calculations with **floating-point precision** to ensure an accurate covariance value.\n\n---\n\n**Step 2: Compute the solution step by step.**\n1. Calculate the mean return for Fund A: \\( \\bar{X} \\).\n2. Calculate the mean return for Fund B: \\( \\bar{Y} \\).\n3. Subtract the mean from each return (center the data) for both Fund A and Fund B.\n4. Compute the product of the deviations for each quarter and sum the products.\n5. Divide the sum by the number of observations (4) to get the covariance.\n\n---\n\n**Step 3: Implement the calculations in Python.**\nWe will now write a Python program to calculate the covariance of returns using the steps above.\n\n```python\ndef solution():\n    # Define the returns for Fund A and Fund B\n    returns_a = [0.05, 0.02, -0.03, 0.04]\n    returns_b = [0.06, 0.01, -0.02, 0.03]\n    \n    # Number of quarters (observations)\n    n = len(returns_a)\n    \n    # Step 1: Calculate the mean of each fund's returns\n    mean_a = sum(returns_a) / n\n    mean_b = sum(returns_b) / n\n    \n    # Step 2: Calculate the deviations and their products\n    covariance_sum = 0\n    for i in range(n):\n        deviation_a = returns_a[i] - mean_a\n        deviation_b = returns_b[i] - mean_b\n        covariance_sum += deviation_a * deviation_b\n    \n    # Step 3: Compute covariance\n    covariance = covariance_sum / n\n    \n    # Return the covariance rounded to three decimal points\n    return round(covariance, 3)\n```"
        ],
        "retrieval_query": "What is the covariance of the returns between Fund A and Fund B? Answer as a float to three decimal places.",
        "useful_functions": [],
        "usage": {
            "completion_tokens": 582,
            "prompt_tokens": 467,
            "total_tokens": 1049,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-2305",
        "article_title": "Altman Z-Score",
        "function": "def calculate_altman_z_score(working_capital: float, total_assets: float, \n                             retained_earnings: float, ebit: float, \n                             market_value_of_equity: float, \n                             total_liabilities: float, \n                             sales: float) -> float:\n    \"\"\"\n    Calculate the Altman Z-score for assessing the bankruptcy risk of a manufacturing company.\n\n    The Altman Z-score is a financial model used to predict the likelihood of bankruptcy\n    of a publicly traded manufacturing company. It combines several financial ratios\n    to evaluate the financial health of the company.\n\n    Args:\n        working_capital (float): The working capital of the company.\n        total_assets (float): The total assets of the company.\n        retained_earnings (float): The retained earnings of the company.\n        ebit (float): The earnings before interest and tax of the company.\n        market_value_of_equity (float): The market value of the company's equity.\n        total_liabilities (float): The total liabilities of the company.\n        sales (float): The total sales of the company.\n\n    Returns:\n        z_score (float): The Altman Z-score which indicates the likelihood of bankruptcy.\n                         A higher score indicates lower probability of bankruptcy.\n\n    Notes:\n        - Applicability: This function is particularly suited for publicly traded companies\n                         in the manufacturing sector.\n        - Constraints: Not suitable for non-manufacturing companies, financial firms, or\n                       private companies without adjustments.\n        - Considerations: A Z-score below 1.8 suggests possible bankruptcy, while a score\n                          above 3 suggests financial stability. Recent adjustments may be\n                          needed for different economic contexts.\n    \"\"\"\n    a = working_capital / total_assets\n    b = retained_earnings / total_assets\n    c = ebit / total_assets\n    d = market_value_of_equity / total_liabilities\n    e = sales / total_assets\n    \n    z_score = 1.2 * a + 1.4 * b + 3.3 * c + 0.6 * d + 1.0 * e\n    \n    return z_score",
        "statistics": {
            "number_statistics": {
                "args_numbers": 7,
                "question_numbers": 0,
                "context_numbers": 7,
                "total_numbers": 7
            },
            "operator_statistics": {
                "operators": {
                    "+": 4,
                    "-": 0,
                    "*": 5,
                    "/": 5,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 14
            },
            "code_statistics": {
                "lines": 7,
                "parentheses": 0
            }
        },
        "difficulty": 4.584967478670571,
        "context": "A publicly traded manufacturing company is evaluating its financial health to determine the likelihood of bankruptcy. The company's current financial details are as follows: working capital is $2,500,000, total assets are $15,000,000, retained earnings amount to $1,200,000, earnings before interest and taxes (EBIT) are $900,000, the market value of equity is $4,500,000, total liabilities are $3,000,000, and total sales are $10,000,000. The management wants to calculate the Altman Z-score to assess the company's financial stability.",
        "question": "What is the Altman Z-score for the company? Answer to two decimal places.",
        "python_solution": "def solution():\n    # Define the company's financial values\n    working_capital = 2500000\n    total_assets = 15000000\n    retained_earnings = 1200000\n    ebit = 900000\n    market_value_of_equity = 4500000\n    total_liabilities = 3000000\n    sales = 10000000\n\n    # Calculate the components of the Altman Z-score\n    a = working_capital / total_assets\n    b = retained_earnings / total_assets\n    c = ebit / total_assets\n    d = market_value_of_equity / total_liabilities\n    e = sales / total_assets\n\n    # Compute the Altman Z-score using the given formula\n    z_score = 1.2 * a + 1.4 * b + 3.3 * c + 0.6 * d + 1.0 * e\n\n    # Return the Z-score rounded to two decimal places\n    return round(z_score, 2)\n\nprint(solution())",
        "ground_truth": 2.08,
        "source": "FinanceReasoning-test-363",
        "question_id": "test-2096",
        "level": "hard",
        "output": [
            "### Step-by-Step Reasoning:\n\n1. **Understanding the Problem and Formula**:  \n   The Altman Z-score is a widely-used formula to assess the financial health of a manufacturing company and its likelihood of bankruptcy. The formula for the Altman Z-score is:\n   \\[\n   Z = 1.2(A) + 1.4(B) + 3.3(C) + 0.6(D) + 1.0(E)\n   \\]\n   where:\n   - \\( A \\) = Working Capital / Total Assets\n   - \\( B \\) = Retained Earnings / Total Assets\n   - \\( C \\) = EBIT / Total Assets\n   - \\( D \\) = Market Value of Equity / Total Liabilities\n   - \\( E \\) = Sales / Total Assets\n\n2. **Given Financial Data for the Company**:  \n   - Working Capital = $2,500,000  \n   - Total Assets = $15,000,000  \n   - Retained Earnings = $1,200,000  \n   - EBIT = $900,000  \n   - Market Value of Equity = $4,500,000  \n   - Total Liabilities = $3,000,000  \n   - Total Sales = $10,000,000  \n\n3. **Emphasizing Constraints (EC)**:\n   - Ensure all calculations are done to two decimal places for the final result.  \n   - Division operations (like Total Liabilities or Total Assets) must avoid unit mismatches, and variables should be defined clearly.\n\n4. **Plan**:\n   - Calculate each component of the Z-score: \\( A, B, C, D, E \\).\n   - Substitute calculated values into the Z-score formula.\n   - Return the Z-score rounded to two decimal places to meet accuracy requirements.\n\nNow, let\u2019s proceed to implement the solution in Python.\n\n```python\ndef solution():\n    # Define variables name and value\n    working_capital = 2500000.0  # Working Capital\n    total_assets = 15000000.0    # Total Assets\n    retained_earnings = 1200000.0  # Retained Earnings\n    ebit = 900000.0              # EBIT\n    market_value_of_equity = 4500000.0  # Market Value of Equity\n    total_liabilities = 3000000.0  # Total Liabilities\n    sales = 10000000.0            # Sales\n    \n    # Calculate Z-score components\n    A = working_capital / total_assets\n    B = retained_earnings / total_assets\n    C = ebit / total_assets\n    D = market_value_of_equity / total_liabilities\n    E = sales / total_assets\n    \n    # Apply the Altman Z-score formula\n    z_score = 1.2 * A + 1.4 * B + 3.3 * C + 0.6 * D + 1.0 * E\n    \n    # Return Z-score rounded to 2 decimal places\n    return round(z_score, 2)\n```"
        ],
        "retrieval_query": "What is the Altman Z-score for the company? Answer to two decimal places.",
        "useful_functions": [
            "def calculate_altman_z_score(working_capital: float, total_assets: float, \n                             retained_earnings: float, ebit: float, \n                             market_value_of_equity: float, \n                             total_liabilities: float, \n                             sales: float) -> float:\n    \"\"\"\n    Calculate the Altman Z-score for assessing the bankruptcy risk of a manufacturing company.\n\n    The Altman Z-score is a financial model used to predict the likelihood of bankruptcy\n    of a publicly traded manufacturing company. It combines several financial ratios\n    to evaluate the financial health of the company.\n\n    Args:\n        working_capital (float): The working capital of the company.\n        total_assets (float): The total assets of the company.\n        retained_earnings (float): The retained earnings of the company.\n        ebit (float): The earnings before interest and tax of the company.\n        market_value_of_equity (float): The market value of the company's equity.\n        total_liabilities (float): The total liabilities of the company.\n        sales (float): The total sales of the company.\n\n    Returns:\n        z_score (float): The Altman Z-score which indicates the likelihood of bankruptcy.\n                         A higher score indicates lower probability of bankruptcy.\n\n    Notes:\n        - Applicability: This function is particularly suited for publicly traded companies\n                         in the manufacturing sector.\n        - Constraints: Not suitable for non-manufacturing companies, financial firms, or\n                       private companies without adjustments.\n        - Considerations: A Z-score below 1.8 suggests possible bankruptcy, while a score\n                          above 3 suggests financial stability. Recent adjustments may be\n                          needed for different economic contexts.\n    \"\"\"\n    a = working_capital / total_assets\n    b = retained_earnings / total_assets\n    c = ebit / total_assets\n    d = market_value_of_equity / total_liabilities\n    e = sales / total_assets\n    \n    z_score = 1.2 * a + 1.4 * b + 3.3 * c + 0.6 * d + 1.0 * e\n    \n    return z_score"
        ],
        "usage": {
            "completion_tokens": 641,
            "prompt_tokens": 916,
            "total_tokens": 1557,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-1831",
        "article_title": "Tax-Free Savings Account (TFSA)",
        "function": "def calculate_over_contributions(contributions: list, annual_limits: list) -> float:\n    \"\"\"\n    Calculate the over-contributions made to a TFSA and apply tax penalties.\n\n    This function calculates the amount of over-contributions to a TFSA and the corresponding tax penalties \n    based on a monthly 1% rate on the excess amount.\n\n    Args:\n        contributions (list): A list of tuples where each tuple contains the year, month, and contribution made in that period.\n        annual_limits (list): A list of the annual contribution limits from 2009 to the current year.\n\n    Returns:\n        total_penalty (float): The total penalty in Canadian dollars for the over-contributions.\n\n    Notes:\n        - Contributions are expected to be in Canadian dollars (CAD).\n        - The annual_limits should cover every year present in the contributions list.\n        - The CRA imposes a 1% per month penalty on excess contributions until they are withdrawn.\n    \"\"\"\n    total_penalty = 0.0\n    yearly_contributions = {}\n\n    for year, month, contribution in contributions:\n        if year not in yearly_contributions:\n            yearly_contributions[year] = 0.0\n        yearly_contributions[year] += contribution\n\n    for year, total_contribution in yearly_contributions.items():\n        if total_contribution > annual_limits[year - 2009]:\n            over_contribution = total_contribution - annual_limits[year - 2009]\n            # Assuming penalties accrue for a full year, hence multiply by 12 months\n            annual_penalty = over_contribution * 0.01 * 12\n            total_penalty += annual_penalty\n\n    return total_penalty",
        "statistics": {
            "number_statistics": {
                "args_numbers": 2,
                "question_numbers": 0,
                "context_numbers": 7,
                "total_numbers": 7
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 3,
                    "*": 2,
                    "/": 0,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 7
            },
            "code_statistics": {
                "lines": 13,
                "parentheses": 2
            }
        },
        "difficulty": 4.584967478670571,
        "context": "Emma has been contributing to her Tax-Free Savings Account (TFSA) over several years. However, due to a miscalculation, she exceeded her contribution limits in some years. The Canadian Revenue Agency (CRA) imposes a 1% monthly tax penalty on any over-contributions. The following details Emma's contributions in CAD over the years:\n\n- 2015: 6,000 CAD\n- 2016: 7,500 CAD\n- 2017: 6,000 CAD\n\nThe annual contribution limits for each year are as follows:\n\n- 2015: 5,500 CAD\n- 2016: 5,500 CAD\n- 2017: 5,500 CAD\n\nCalculate the total tax penalties Emma incurs due to her over-contributions, assuming penalties apply for a full year on any over-contributions within the year they were made.",
        "question": "What is the total tax penalty Emma incurs on her TFSA over-contributions? Provide your answer in Canadian dollars, rounded to two decimal places.",
        "python_solution": "def solution():\n    # Define the contributions and annual limits\n    contributions_by_year = {\n        2015: 6000,\n        2016: 7500,\n        2017: 6000\n    }\n    annual_limits = {\n        2015: 5500,\n        2016: 5500,\n        2017: 5500\n    }\n\n    # Calculate the total penalty\n    total_penalty = 0.0\n    for year, contribution in contributions_by_year.items():\n        limit = annual_limits[year]\n        if contribution > limit:\n            over_contribution = contribution - limit\n            # Calculate the penalty at 1% per month for a full year\n            monthly_penalty_rate = 0.01\n            months_in_year = 12\n            annual_penalty = over_contribution * monthly_penalty_rate * months_in_year\n            total_penalty += annual_penalty\n\n    # Round the result to two decimal places\n    return round(total_penalty, 2)\n\nsolution()",
        "ground_truth": 360.0,
        "source": "FinanceReasoning-test-378",
        "question_id": "test-2097",
        "level": "hard",
        "output": [
            "### Step-by-Step Analysis:\n\n#### 1. Identify Over-Contributions:\nFor each year, subtract the annual contribution limit from Emma's actual contribution. If the result is positive, it is an over-contribution.\n\n- **2015:**\n  - Contribution = 6,000 CAD\n  - Limit = 5,500 CAD\n  - Over-Contribution = \\( 6,000 - 5,500 = 500 \\) CAD\n\n- **2016:**\n  - Contribution = 7,500 CAD\n  - Limit = 5,500 CAD\n  - Over-Contribution = \\( 7,500 - 5,500 = 2,000 \\) CAD\n\n- **2017:**\n  - Contribution = 6,000 CAD\n  - Limit = 5,500 CAD\n  - Over-Contribution = \\( 6,000 - 5,500 = 500 \\) CAD\n\n#### 2. Calculate Tax Penalty for Each Year:\nThe CRA applies a 1% monthly tax penalty for over-contributions. To calculate the penalty for a full year, multiply the over-contribution by \\( 1\\% \\) and by \\( 12 \\) months. This can be expressed as \\( \\text{Tax Penalty} = \\text{Over-Contribution} \\times 0.01 \\times 12 \\).\n\n- **2015:**\n  \\( \\text{Tax Penalty} = 500 \\times 0.01 \\times 12 = 60 \\) CAD\n\n- **2016:**\n  \\( \\text{Tax Penalty} = 2,000 \\times 0.01 \\times 12 = 240 \\) CAD\n\n- **2017:**\n  \\( \\text{Tax Penalty} = 500 \\times 0.01 \\times 12 = 60 \\) CAD\n\n#### 3. Total Tax Penalty:\nSum up the tax penalties for all years:\n\\( \\text{Total Tax Penalty} = 60 + 240 + 60 = 360 \\) CAD.\n\n#### 4. Constraints:\n- Answer should be in Canadian dollars.\n- Round to two decimal places if necessary (in this case, no rounding is required).\n\n### Python Program:\n```python\ndef solution():\n    # Define variables for contributions and limits across years\n    contributions = {\n        2015: 6000,\n        2016: 7500,\n        2017: 6000\n    }\n    limits = {\n        2015: 5500,\n        2016: 5500,\n        2017: 5500\n    }\n    \n    # Calculate the total tax penalty\n    total_penalty = 0\n    for year in contributions:\n        over_contribution = max(0, contributions[year] - limits[year])  # Over-contribution cannot be negative\n        annual_penalty = over_contribution * 0.01 * 12  # 1% monthly penalty for 12 months\n        total_penalty += annual_penalty\n    \n    # Return the answer rounded to two decimal places\n    return round(total_penalty, 2)\n```\n\nThis program will compute the total tax penalty Emma incurs due to her TFSA over-contributions, following all relevant constraints."
        ],
        "retrieval_query": "What is the total tax penalty Emma incurs on her TFSA over-contributions? Provide your answer in Canadian dollars, rounded to two decimal places.",
        "useful_functions": [],
        "usage": {
            "completion_tokens": 687,
            "prompt_tokens": 535,
            "total_tokens": 1222,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-2286",
        "article_title": "Adjusted Present Value (APV)",
        "function": "def calculate_apv(unlevered_firm_value: float, tax_rate: float, debt: float, interest_rate: float, periods: int) -> float:\n    \"\"\"\n    Calculate the Adjusted Present Value (APV) of a project or firm.\n\n    This function calculates the APV by summing the unlevered firm value (value assuming all-equity financing) \n    with the present value of the tax shield from debt financing.\n\n    Args:\n        unlevered_firm_value (float): The value of the firm if financed entirely by equity (base case NPV).\n        tax_rate (float): The corporate tax rate applicable to the firm.\n        debt (float): The total amount of debt financing used by the firm or project.\n        interest_rate (float): The interest rate on the debt financing.\n        periods (int): The number of years over which the tax shield applies.\n\n    Returns:\n        apv (float): The adjusted present value, incorporating the benefits of the tax shield.\n\n    Notes:\n        - Applicability: Useful for projects or firms with significant debt financing and varying capital structures.\n        - Constraints: Assumes a constant interest rate and tax rate over the specified periods.\n        - Considerations: Does not account for potential costs of financial distress or complex financing effects.\n    \"\"\"\n    # Calculate annual interest and tax shield\n    annual_interest = debt * interest_rate\n    annual_tax_shield = annual_interest * tax_rate\n    \n    # Calculate the PV of the tax shield\n    pv_tax_shield = annual_tax_shield * (1 - (1 / (1 + interest_rate) ** periods)) / interest_rate\n\n    # Calculate APV\n    apv = unlevered_firm_value + pv_tax_shield\n    \n    return apv",
        "statistics": {
            "number_statistics": {
                "args_numbers": 5,
                "question_numbers": 0,
                "context_numbers": 5,
                "total_numbers": 5
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 1,
                    "*": 3,
                    "/": 2,
                    "%": 0,
                    "**": 1
                },
                "total_operators": 9
            },
            "code_statistics": {
                "lines": 8,
                "parentheses": 6
            }
        },
        "difficulty": 4.595119850134591,
        "context": "A company is evaluating its capital structure and wants to understand the impact of using debt financing on its overall valuation. The company's value, assuming it is entirely equity-financed, is estimated to be 800,000 USD. They plan to take on 300,000 USD in debt at an interest rate of 5% for a period of 5 years. The corporate tax rate is 28%. They seek to determine the project's adjusted present value (APV) to include the benefit of the tax shield afforded by the debt financing.",
        "question": "What is the Adjusted Present Value (APV) of the company? Provide your answer in USD, rounded to the nearest integer.",
        "python_solution": "def solution():\n    # Define the given values\n    unlevered_firm_value = 800000  # USD\n    tax_rate = 0.28  # 28%\n    debt = 300000  # USD\n    interest_rate = 0.05  # 5%\n    periods = 5  # years\n\n    # Calculate the annual interest and tax shield\n    annual_interest = debt * interest_rate\n    annual_tax_shield = annual_interest * tax_rate\n\n    # Calculate the present value of the tax shield\n    pv_tax_shield = annual_tax_shield * (1 - (1 / (1 + interest_rate) ** periods)) / interest_rate\n\n    # Calculate the Adjusted Present Value (APV)\n    apv = unlevered_firm_value + pv_tax_shield\n\n    # Return the final answer rounded to the nearest integer\n    return round(apv)\n\n# Execute the solution function and print the result\nprint(solution())",
        "ground_truth": 818184,
        "source": "FinanceReasoning-test-128",
        "question_id": "test-2098",
        "level": "hard",
        "output": [
            "Let's reason through the problem step by step using the \"Emphasizing Constraints (EC)\" approach to ensure that all required inputs and computations are accurate and align with the constraints provided.\n\n### Step-by-Step Reasoning:\n1. **Understand the Given Data**: \n   - The unlevered firm value (equity-financed value) = 800,000 USD.\n   - Debt to be taken = 300,000 USD.\n   - Interest rate on the debt = 5% or 0.05 (as a decimal).\n   - Corporate tax rate = 28% or 0.28 (as a decimal).\n   - Debt duration = 5 years.\n   \n2. **Identify Constraints**:\n   - The interest rate and tax rate must be represented as decimals in calculations.\n   - The PV of the tax shield must be calculated as the present value of the yearly tax savings due to the interest deductions over 5 years. (Formula: \\( PV_{TaxShield} = \\text{Annual Tax Shield} \\times \\frac{1 - (1 / (1 + r)^n)}{r} \\)).\n   - The APV is the sum of the unlevered firm value and the PV of the tax shield.\n\n3. **Break the Solution into Steps**:\n   - Calculate the annual interest on the debt: \\( \\text{Annual Interest} = \\text{Debt} \\times \\text{Interest Rate} \\).\n   - Calculate the annual tax shield: \\( \\text{Tax Shield per year} = \\text{Annual Interest} \\times \\text{Tax Rate} \\).\n   - Compute the PV of the tax shield using the present value formula for an annuity.\n   - Calculate the APV: \\( APV = \\text{Unlevered Firm Value} + PV_{TaxShield} \\).\n\n4. **Rounding Rules and Units**:\n   - The final output (APV) must be rounded to the nearest integer and be in USD.\n\nNow, let's generate a Python program to compute the Adjusted Present Value (APV):\n\n```python\ndef solution():\n    # Define variables name and value\n    unlevered_firm_value = 800000  # USD\n    debt = 300000  # USD\n    interest_rate = 0.05  # 5%\n    tax_rate = 0.28  # 28%\n    periods = 5  # 5 years\n\n    # Step 1: Calculate the annual interest and annual tax shield\n    annual_interest = debt * interest_rate\n    annual_tax_shield = annual_interest * tax_rate\n\n    # Step 2: Calculate the PV of the tax shield using PV annuity formula\n    pv_tax_shield = annual_tax_shield * (1 - (1 / (1 + interest_rate) ** periods)) / interest_rate\n\n    # Step 3: Calculate the Adjusted Present Value (APV)\n    apv = unlevered_firm_value + pv_tax_shield\n\n    # Step 4: Round the APV to the nearest integer\n    answer = round(apv)\n    \n    # Return the rounded APV as the answer\n    return answer\n```"
        ],
        "retrieval_query": "What is the Adjusted Present Value (APV) of the company? Provide your answer in USD, rounded to the nearest integer.",
        "useful_functions": [
            "def calculate_apv(unlevered_firm_value: float, tax_rate: float, debt: float, interest_rate: float, periods: int) -> float:\n    \"\"\"\n    Calculate the Adjusted Present Value (APV) of a project or firm.\n\n    This function calculates the APV by summing the unlevered firm value (value assuming all-equity financing) \n    with the present value of the tax shield from debt financing.\n\n    Args:\n        unlevered_firm_value (float): The value of the firm if financed entirely by equity (base case NPV).\n        tax_rate (float): The corporate tax rate applicable to the firm.\n        debt (float): The total amount of debt financing used by the firm or project.\n        interest_rate (float): The interest rate on the debt financing.\n        periods (int): The number of years over which the tax shield applies.\n\n    Returns:\n        apv (float): The adjusted present value, incorporating the benefits of the tax shield.\n\n    Notes:\n        - Applicability: Useful for projects or firms with significant debt financing and varying capital structures.\n        - Constraints: Assumes a constant interest rate and tax rate over the specified periods.\n        - Considerations: Does not account for potential costs of financial distress or complex financing effects.\n    \"\"\"\n    # Calculate annual interest and tax shield\n    annual_interest = debt * interest_rate\n    annual_tax_shield = annual_interest * tax_rate\n    \n    # Calculate the PV of the tax shield\n    pv_tax_shield = annual_tax_shield * (1 - (1 / (1 + interest_rate) ** periods)) / interest_rate\n\n    # Calculate APV\n    apv = unlevered_firm_value + pv_tax_shield\n    \n    return apv"
        ],
        "usage": {
            "completion_tokens": 659,
            "prompt_tokens": 832,
            "total_tokens": 1491,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "According to Exhibits 1 and 2, what is the FCFF ($ millions) of the Johnson Company for the fiscal year ending on December 31, 2012? Answer to three decimal places.",
        "python_solution": "def solution():\n    NI = 626\n    NCC = 243\n    Int = 186\n    Tax_rate = 0.32\n    FCInv = 535\n    WCInvNet = (1290 - 1199) - (2783 - 2678)\n    FCFF = NI + NCC + Int*(1 - Tax_rate) - FCInv - WCInvNet\n    return FCFF",
        "ground_truth": 474.48,
        "topic": "Asset Classes & Derivatives",
        "statistics": {
            "number_statistics": {
                "args_numbers": 2,
                "question_numbers": 3,
                "context_numbers": 35,
                "total_numbers": 38
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 6,
                    "*": 1,
                    "/": 0,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 9
            },
            "code_statistics": {
                "lines": 8,
                "parentheses": 6
            }
        },
        "difficulty": 4.595119850134591,
        "source": "FinanceMath-validation-13",
        "context": "['| For Year Ending 31 December | 2012 |\\n| --------------------------- | ---- |\\n| Revenues                   | $6,456 |\\n| Earnings before interest,taxes, depreciation, and amortization (EBITDA) | 1,349 |\\n| Depreciation expense | 243 |\\n| Operating income     | 1,106 |\\n| Interest expense     | 186 |\\n| Pretax income        | 920 |\\n| Income tax (32%)     | 294 |\\n| Net income           | $626 |\\n|                           |      |\\n| Number of outstanding shares (millions) | 411 |\\n| 2012 earnings per share     | $1.52 |\\n| 2012 dividends paid (millions) | 148 |\\n| 2012 dividends per share    | 0.36 |\\n| 2012 fixed capital investment (millions) | 535 |\\n|                           |      |\\n| Cost of equity           | 12.0% |\\n| Weighted average cost of capital (WACC) | 9.0% |', \"| Assets                      | 2012  | 2011  |\\n|-----------------------------|-------|-------|\\n| Cash and cash equivalents   | $32   | $21   |\\n| Accounts receivable         | 413   | 417   |\\n| Inventories                 | 709   | 638   |\\n| Other current assets        | 136   | 123   |\\n| **Total current assets**    | $1,290| $1,199|\\n|                             |       |       |\\n| Current liabilities         | $2,783| $2,678|\\n| Long-term debt              | 2,249 | 2,449 |\\n| Common stockholders' equity | 1,072 | 594   |\\n| **Total liabilities and stockholders' equity**| $6,104| $5,721|\"]",
        "question_id": "test-2099",
        "level": "hard",
        "output": [
            "To calculate the Free Cash Flow to the Firm (FCFF) for the Johnson Company, we will follow the provided formula and inputs. First, we will carefully extract the required data from Exhibits 1 and 2 and compute the FCFF step-by-step while applying constraints to ensure accuracy.\n\n---\n\n### Step-by-step breakdown:\n\n1. **Understand the formula:**\n   \\[\n   FCFF = Net\\ Income + Non\\ Cash\\ Charges + Interest\\ Expense \\cdot (1 - Tax\\ Rate) - Fixed\\ Capital\\ Investment - Net\\ Working\\ Capital\\ Change\n   \\]\n\n2. **Variables needed:**\n   - **Net Income:** Provided in Exhibit 1 as $626 million.\n   - **Non-Cash Charges:** Depreciation expense provided in Exhibit 1 as $243 million.\n   - **Interest Expense:** Provided in Exhibit 1 as $186 million.\n   - **Tax Rate:** Provided in Exhibit 1 as 32% (convert to decimal: 0.32).\n   - **Fixed Capital Investment:** Provided in Exhibit 1 as $535 million.\n   - **Changes in Net Working Capital (NWC):**\n     - NWC is calculated as `(Current Assets - Current Liabilities)`.\n     - Use beginning and ending balances provided in Exhibit 2:\n       - **Beginning NWC (2011):** $1,199 million - $2,678 million = -$1,479 million.\n       - **Ending NWC (2012):** $1,290 million - $2,783 million = -$1,493 million.\n       - Change in NWC = Ending NWC - Beginning NWC = -$1,493 million - (-$1,479 million) = -$14 million.\n\n3. **Emphasizing Constraints (EC):**\n   - Tax rate must be between 0 and 1: The input tax rate (32% or 0.32) adheres to this constraint.\n   - Ensure all inputs (like net income, depreciation, and others) have consistent monetary units (in millions).\n   - Ensure we compute the NWC change accurately considering signs (increases decrease cash flow while decreases increase cash flow).\n\n4. Compute the FCFF using the provided formula and the gathered data.\n\n---\n\nNow, the Python program that implements this calculation:\n\n```python\ndef solution():\n    # Define variables\n    net_income = 626  # in $ millions\n    non_cash_charges = 243  # Depreciation in $ millions\n    interest_expense = 186  # in $ millions\n    tax_rate = 0.32  # 32%\n    fixed_capital_investment = 535  # in $ millions\n    beginning_working_capital = -1479  # 2011 NWC = Current Assets - Current Liabilities\n    ending_working_capital = -1493  # 2012 NWC = Current Assets - Current Liabilities\n    \n    # Compute change in net working capital\n    nwc_change = ending_working_capital - beginning_working_capital\n    \n    # Compute FCFF using the formula\n    fcff = (\n        net_income \n        + non_cash_charges \n        + interest_expense * (1 - tax_rate) \n        - fixed_capital_investment \n        - nwc_change\n    )\n    \n    # Return result rounded to 3 decimal places (as asked in the question)\n    return round(fcff, 3)\n```\n\nThis program ensures accurate computation consistent with the constraints and inputs."
        ],
        "retrieval_query": "According to Exhibits 1 and 2, what is the FCFF ($ millions) of the Johnson Company for the fiscal year ending on December 31, 2012? Answer to three decimal places.",
        "useful_functions": [
            "def calculate_fcff(net_income: float, non_cash_charges: float, interest_expense: float, \n                   tax_rate: float, fixed_capital_investment: float, \n                   beginning_working_capital: float, ending_working_capital: float, \n                   beginning_current_liabilities: float, ending_current_liabilities: float) -> float:\n    \"\"\"\n    Calculate the Free Cash Flow to the Firm (FCFF).\n\n    This function computes the Free Cash Flow to the Firm (FCFF) by taking into account \n    net income, non-cash charges, interest expense, tax rate, fixed capital investments, \n    and changes in working capital. FCFF is used to understand the cash available to all \n    investors, both equity and debt holders.\n\n    Args:\n        net_income (float): Net income of the company.\n        non_cash_charges (float): Non-cash charges such as depreciation and amortization.\n        interest_expense (float): Interest expense incurred by the company.\n        tax_rate (float): Corporate tax rate.\n        fixed_capital_investment (float): Investments made in fixed capital.\n        beginning_working_capital (float): Beginning value of working capital.\n        ending_working_capital (float): Ending value of working capital.\n        beginning_current_liabilities (float): Beginning value of current liabilities.\n        ending_current_liabilities (float): Ending value of current liabilities.\n\n    Returns:\n        fcff (float): The Free Cash Flow to the Firm in monetary units.\n\n    Notes:\n        - Applicability: This function is applicable to analyze the cash flows available\n          to all investors in the firm after investment in fixed capital and net changes\n          in working capital.\n        - Constraints: Tax rate should be between 0 and 1.\n        - Considerations: Ensure the values provided for working capital and current \n          liabilities are accurate and consistent with the defined period.\n    \"\"\"\n    net_working_capital_change = (ending_working_capital - beginning_working_capital) - (ending_current_liabilities - beginning_current_liabilities)\n    fcff = net_income + non_cash_charges + interest_expense * (1 - tax_rate) - fixed_capital_investment - net_working_capital_change\n    \n    return fcff"
        ],
        "usage": {
            "completion_tokens": 733,
            "prompt_tokens": 1264,
            "total_tokens": 1997,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "Three months ago, a supervisor initiated a receive-fixed and pay-equity swap. The annualized fixed interest is 3% and the equity index was at 100 at the time of the swap. The expiry of the swap is one year with a quarterly reset, and the nominal amount is valued at $100 million. The present spot rates are as stated: At what equity index level would this equity swap value stand at zero? Answer to three decimal places.",
        "python_solution": "def solution():\n    fixed_rate = 0.03\n    nominal_amount = 100000000\n    current_spot_rates = [0.997506, 0.992556, 0.985222]\n    number_of_days = 90\n    denominator = 360\n\n    value_fixed_leg = fixed_rate * (number_of_days / denominator) * nominal_amount * sum(current_spot_rates) + (nominal_amount * current_spot_rates[-1])\n\n    equity_index_price = value_fixed_leg / nominal_amount * 100\n    return equity_index_price",
        "ground_truth": 100.754,
        "topic": "Asset Classes & Derivatives",
        "statistics": {
            "number_statistics": {
                "args_numbers": 5,
                "question_numbers": 3,
                "context_numbers": 8,
                "total_numbers": 11
            },
            "operator_statistics": {
                "operators": {
                    "+": 1,
                    "-": 1,
                    "*": 5,
                    "/": 2,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 9
            },
            "code_statistics": {
                "lines": 8,
                "parentheses": 6
            }
        },
        "difficulty": 4.595119850134591,
        "source": "FinanceMath-validation-92",
        "context": "['| Years to maturity | Present Value Factor |\\n|-------------------|----------------------|\\n| 0.25              | 0.997506             |\\n| 0.5               | 0.992556             |\\n| 0.75              | 0.985222             |\\n| 1                 | 0.975610             |']",
        "question_id": "test-2100",
        "level": "hard",
        "output": [
            "To solve the problem, we proceed as follows:\n\n### Step-by-step Analysis\n\n#### 1. Understanding the components of the question:\n   - **Receive-Fixed Leg**:\n     - The fixed interest rate is 3% annualized, or \\(0.03\\) as a decimal.\n     - It has quarterly resets (every 0.25 years).\n     - We calculate the value of the fixed leg using the provided spot rates and formulas.\n   - **Pay-Equity Leg**:\n     - The equity index level will be determined such that the value of the swap equals zero.\n   - **Constraints**:\n     - The nominal amount of the swap is $100 million.\n     - The final value of the swap is zero, meaning the value of the receive-fixed leg equals the value of the pay-equity leg.\n     - Answer must be to **three decimal places** as per the prompt.\n\n#### 2. Using provided spot rates:\n   - Spot rates for 0.25 years, 0.5 years, 0.75 years, and 1 year are given.\n   - These are used to discount the fixed leg payments.\n\n#### 3. Formula for the value of the **Fixed Leg**:\n   The present value of the fixed leg is based on:\n   - Quarterly payments using the fixed rate and nominal amount.\n   - The present value of the final principal payment using the last spot rate.\n   - Formula:\n     \\[\n     PV_{\\text{Fixed Leg}} = \\text{Fixed Rate} \\times \\frac{\\text{Days in Period}}{\\text{Period Denominator}} \\times \\text{Nominal Amount} \\times \\sum(\\text{Spot Rates}) + (\\text{Nominal Amount} \\times \\text{Last Spot Rate})\n     \\]\n\n#### 4. Solving for the **Equity Index Level**:\n   - The value of the equity leg is proportional to the equity index level.\n   - To make the swap value zero, this means:\n     \\[\n     PV_{\\text{Fixed Leg}} = \\text{Equity Index Level} \\times \\frac{\\text{Nominal Amount}}{100}\n     \\]\n     Rearrange to solve for the Equity Index Level:\n     \\[\n     \\text{Equity Index Level} = \\frac{PV_{\\text{Fixed Leg}}}{\\text{Nominal Amount}} \\times 100\n     \\]\n\n#### 5. Precision Constraints:\n   - The final answer must be calculated to **three decimal places**.\n\nWith these steps outlined, we can now proceed to encode the solution.\n\n```python\ndef solution():\n    # Define variables\n    fixed_rate = 0.03  # Annualized fixed rate\n    nominal_amount = 100_000_000  # $100 million\n    spot_rates = [0.997506, 0.992556, 0.985222, 0.975610]  # Discount factors for periods\n    days_in_period = 90  # Quarterly reset = 90 days assumed\n    period_denominator = 360  # Yearly denominator for annualized rate\n\n    # Calculate the value of the fixed leg\n    value_fixed_leg = (fixed_rate * (days_in_period / period_denominator) * nominal_amount * sum(spot_rates) +\n                       (nominal_amount * spot_rates[-1]))\n    \n    # Calculate the equity index level\n    equity_index_level = (value_fixed_leg / nominal_amount) * 100\n\n    # Return the result rounded to 3 decimal places\n    return round(equity_index_level, 3)\n```"
        ],
        "retrieval_query": "Three months ago, a supervisor initiated a receive-fixed and pay-equity swap. The annualized fixed interest is 3% and the equity index was at 100 at the time of the swap. The expiry of the swap is one year with a quarterly reset, and the nominal amount is valued at $100 million. The present spot rates are as stated: At what equity index level would this equity swap value stand at zero? Answer to three decimal places.",
        "useful_functions": [
            "def calculate_equity_index_for_zero_swap_value(fixed_rate: float, nominal_amount: float, spot_rates: list, days_in_period: int, period_denominator: int) -> float:\n    \"\"\"\n    Calculate the equity index level where the equity swap value equals zero.\n\n    This function determines the equity index level at which the total value of a receive-fixed \n    and pay-equity swap reaches zero. It considers the fixed interest rate, nominal amount, \n    and spot rates over the swap's duration with periodic resets.\n\n    Args:\n        fixed_rate (float): The annualized fixed interest rate as a decimal (e.g., 0.03 for 3%).\n        nominal_amount (float): The nominal amount of the swap in currency (e.g., 100000000 for $100 million).\n        spot_rates (list): A list of present value factors (spot rates) for each reset period.\n        days_in_period (int): The number of days in each reset period.\n        period_denominator (int): The denominator used for annualizing the fixed rate (e.g., 360 or 365).\n\n    Returns:\n        equity_index_level (float): The equity index level at which the swap's value is zero.\n\n    Notes:\n        - This function assumes that the swap lasts one year with periodic resets corresponding to the length of the spot_rates list.\n        - The spot_rates list should be provided in order of increasing time to maturity.\n        - The function does not account for transaction costs or other potential market adjustments.\n    \"\"\"\n    value_fixed_leg = fixed_rate * (days_in_period / period_denominator) * nominal_amount * sum(spot_rates) + (nominal_amount * spot_rates[-1])\n    \n    equity_index_level = value_fixed_leg / nominal_amount * 100\n    \n    return equity_index_level"
        ],
        "usage": {
            "completion_tokens": 748,
            "prompt_tokens": 877,
            "total_tokens": 1625,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "Compute the equal-weighted index value for these three shares, assuming the starting index value is 121. Answer to three decimal places.",
        "python_solution": "def solution():\n    starting_index = 121\n    shares = [(20/15-1), (30/20-1), (25/30-1)]\n    average_share = sum(shares) / len(shares)\n    new_index = starting_index * (1 + average_share)\n    return new_index",
        "ground_truth": 147.889,
        "topic": "Asset Classes & Derivatives",
        "statistics": {
            "number_statistics": {
                "args_numbers": 1,
                "question_numbers": 1,
                "context_numbers": 16,
                "total_numbers": 17
            },
            "operator_statistics": {
                "operators": {
                    "+": 1,
                    "-": 3,
                    "*": 1,
                    "/": 4,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 9
            },
            "code_statistics": {
                "lines": 5,
                "parentheses": 12
            }
        },
        "difficulty": 4.595119850134591,
        "source": "FinanceMath-validation-166",
        "context": "['|          | March 31, 20X7 Share Price | March 31, 20X7 Number of Shares Outstanding (thousands) | April 30, 20X7 Share Price | April 30, 20X7 Number of Shares Outstanding (thousands) |\\n|----------|---------------------------|-----------------------------------------------------|----------------------------|--------------------------------------------------------|\\n| Stock X  | $15                       | 100                                                 | $20                        | 100                                                    |\\n| Stock Y  | $20                       | 1,000                                               | $30                        | 1,000                                                  |\\n| Stock Z  | $30                       | 2,000                                               | $25                        | 2,000                                                  |']",
        "question_id": "test-2101",
        "level": "hard",
        "output": [
            "To solve this problem, let's break it down step-by-step while adhering to the provided constraints:\n\n**Step 1 (Emphasizing Constraints):**\n- The starting index value is given as 121.\n- We need to calculate the equal-weighted index value for three stocks at April 30, 20X7.\n- We should calculate the index based on the formula for an equal-weighted index, which involves taking the arithmetic mean of percentage price changes and applying them to the starting index value.\n- Percentage price change for each stock is calculated as:  \n  `(New Price - Old Price) / Old Price`.\n- The index value should ultimately be rounded to three decimal places.\n\n---\n\n**Step 2 (Plan the Calculation):**\n1. Retrieve the stock prices for Stock X, Stock Y, and Stock Z on March 31 and April 30.\n2. Calculate the percentage price changes for each stock.\n3. Compute the equal-weighted average of these percentage changes.\n4. Adjust the starting index value using this average percentage change to find the ending index value.\n5. Round the result to three decimal places.\n\n---\n\n**Step 3 (Using Python Code):**\nWe'll implement the above steps in a program to solve the problem.\n\n```python\ndef solution():\n    # Define variables for stock prices at two time points (March 31 and April 30)\n    price_start_X, price_end_X = 15, 20\n    price_start_Y, price_end_Y = 20, 30\n    price_start_Z, price_end_Z = 30, 25\n    \n    # Starting index value\n    starting_index = 121\n    \n    # Calculate percentage changes for each stock\n    percentage_change_X = (price_end_X - price_start_X) / price_start_X\n    percentage_change_Y = (price_end_Y - price_start_Y) / price_start_Y\n    percentage_change_Z = (price_end_Z - price_start_Z) / price_start_Z\n    \n    # Compute the average of the percentage changes (equal-weighted)\n    average_percentage_change = (percentage_change_X + percentage_change_Y + percentage_change_Z) / 3\n    \n    # Calculate the new index value\n    ending_index = starting_index * (1 + average_percentage_change)\n    \n    # Return the result rounded to 3 decimal places\n    return round(ending_index, 3)\n```"
        ],
        "retrieval_query": "Compute the equal-weighted index value for these three shares, assuming the starting index value is 121. Answer to three decimal places.",
        "useful_functions": [],
        "usage": {
            "completion_tokens": 484,
            "prompt_tokens": 504,
            "total_tokens": 988,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-891",
        "article_title": "Matching Orders",
        "function": "def match_orders_fifo(buy_orders: list, sell_orders: list) -> list:\n    \"\"\"\n    Match buy and sell orders using a FIFO (First-In-First-Out) approach.\n\n    This function matches orders based on the price-time priority algorithm, where the earliest\n    buy order at the highest price is prioritized over subsequent orders at the same price.\n\n    Args:\n        buy_orders (list): A list of buy orders, each represented as a dictionary with keys\n                           'quantity' and 'price'.\n        sell_orders (list): A list of sell orders, each represented as a dictionary with keys\n                            'quantity' and 'price'.\n\n    Returns:\n        matches (list): A list of matches, where each match is a dictionary indicating which\n                        buy and sell orders were matched and the executed quantity.\n\n    Notes:\n        - This function assumes buy and sell orders are sorted by time of entry.\n        - Only perfectly matched quantities or fully exhausted orders will be returned.\n        - This algorithm prioritizes transactions by 'first come, first served' philosophy.\n        - Ensure that buy orders are sorted by descending price and entry time.\n    \"\"\"\n    matches = []\n    buy_index, sell_index = 0, 0\n    \n    while buy_index < len(buy_orders) and sell_index < len(sell_orders):\n        buy_order = buy_orders[buy_index]\n        sell_order = sell_orders[sell_index]\n        \n        if buy_order['price'] >= sell_order['price']:\n            match_quantity = min(buy_order['quantity'], sell_order['quantity'])\n            matches.append({\n                'buy_order_index': buy_index,\n                'sell_order_index': sell_index,\n                'executed_quantity': match_quantity\n            })\n            buy_order['quantity'] -= match_quantity\n            sell_order['quantity'] -= match_quantity\n            \n            if buy_order['quantity'] == 0:\n                buy_index += 1\n            if sell_order['quantity'] == 0:\n                sell_index += 1\n        else:\n            break\n    \n    return matches",
        "statistics": {
            "number_statistics": {
                "args_numbers": 2,
                "question_numbers": 0,
                "context_numbers": 12,
                "total_numbers": 12
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 2,
                    "*": 0,
                    "/": 0,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 4
            },
            "code_statistics": {
                "lines": 21,
                "parentheses": 8
            }
        },
        "difficulty": 4.605170185988091,
        "context": "A stock exchange platform facilitates trading by matching buy and sell orders from investors. On a particular day, the buy orders are as follows: \n\n1. 100 shares at $50 per share\n2. 150 shares at $48 per share\n\nSimultaneously, there are sell orders:\n\n1. 50 shares at $48 per share\n2. 200 shares at $50 per share\n\nThe platform uses a FIFO (First-In-First-Out) approach to match orders, prioritizing buy orders at higher prices and earlier times. All orders are sorted by entry time and meet each other price conditionally for matching.",
        "question": "What is the total executed quantity from matched orders on the platform for that day? Answer to the nearest integer and provide the total number of shares matched.",
        "python_solution": "def solution():\n    # Define buy and sell orders\n    buy_orders = [{'quantity': 100, 'price': 50},\n                  {'quantity': 150, 'price': 48}]\n    \n    sell_orders = [{'quantity': 50, 'price': 48},\n                   {'quantity': 200, 'price': 50}]\n    \n    # Implementing FIFO logic to match orders\n    matches = []\n    buy_index, sell_index = 0, 0\n\n    while buy_index < len(buy_orders) and sell_index < len(sell_orders):\n        buy_order = buy_orders[buy_index]\n        sell_order = sell_orders[sell_index]\n        \n        if buy_order['price'] >= sell_order['price']:\n            match_quantity = min(buy_order['quantity'], sell_order['quantity'])\n            matches.append(match_quantity)\n            buy_order['quantity'] -= match_quantity\n            sell_order['quantity'] -= match_quantity\n            \n            if buy_order['quantity'] == 0:\n                buy_index += 1\n            if sell_order['quantity'] == 0:\n                sell_index += 1\n        else:\n            break\n    \n    # Calculate total executed quantity\n    total_executed_quantity = sum(matches)\n\n    # Return the result\n    return total_executed_quantity",
        "ground_truth": 100,
        "source": "FinanceReasoning-test-188",
        "question_id": "test-2102",
        "level": "hard",
        "output": [
            "### Analyzing the Problem Using the Advanced Reasoning Technique:\n\n#### **Step 1: Understanding Constraints**\n1. **Price Matching Constraint**: Buy orders can only execute against sell orders where the buy price is **greater than or equal to** the sell price.\n2. **FIFO Matching Constraint**: Orders are matched in the sequence they were entered, adhering to the First-In-First-Out (FIFO) rule.\n3. **Quantity Constraint**: Orders are matched based on the minimum of the available quantities for the given buy and sell orders.\n4. **Decimal Precision or Integer Constraint**: The total executed quantity must be returned as an integer.\n\n#### **Step 2: Plan Execution**\n1. Parse input buy and sell orders into data structures that detail their quantities and prices.\n2. Match orders by sorting **buy orders** in descending order of price and prioritize sell orders as they are (FIFO order).\n3. Calculate the executed quantity by iterating over orders and adhering to constraints.\n4. Sum up all the executed quantities from matched orders to compute the final result.\n\n#### **Step 3: Handling the Input Data**\n- Buy orders will be represented as a list of dictionaries, `buy_orders`, where each dictionary contains `quantity` and `price`.\n- Sell orders will be represented as a similar list, `sell_orders`, where each dictionary contains `quantity` and `price`.\n\n---\n\nHere is the Python program to compute the total executed quantity of matched orders based on the above analysis:\n\n```python\ndef solution():\n    # Define buy and sell orders\n    buy_orders = [\n        {'quantity': 100, 'price': 50},\n        {'quantity': 150, 'price': 48}\n    ]\n    sell_orders = [\n        {'quantity': 50, 'price': 48},\n        {'quantity': 200, 'price': 50}\n    ]\n    \n    executed_quantity = 0\n    \n    # Initialize buy and sell indices\n    buy_index, sell_index = 0, 0\n\n    # Perform FIFO-based matching\n    while buy_index < len(buy_orders) and sell_index < len(sell_orders):\n        buy_order = buy_orders[buy_index]\n        sell_order = sell_orders[sell_index]\n\n        # Only match if buy price >= sell price\n        if buy_order['price'] >= sell_order['price']:\n            match_quantity = min(buy_order['quantity'], sell_order['quantity'])\n            executed_quantity += match_quantity\n            \n            # Adjust quantities in the respective orders\n            buy_order['quantity'] -= match_quantity\n            sell_order['quantity'] -= match_quantity\n            \n            # If the buy order is completely executed, move to the next buy order\n            if buy_order['quantity'] == 0:\n                buy_index += 1\n                \n            # If the sell order is completely executed, move to the next sell order\n            if sell_order['quantity'] == 0:\n                sell_index += 1\n        else:\n            # If prices don't satisfy the matching condition, stop further execution\n            break\n    \n    return executed_quantity\n```"
        ],
        "retrieval_query": "What is the total executed quantity from matched orders on the platform for that day? Answer to the nearest integer and provide the total number of shares matched.",
        "useful_functions": [
            "def match_orders_fifo(buy_orders: list, sell_orders: list) -> list:\n    \"\"\"\n    Match buy and sell orders using a FIFO (First-In-First-Out) approach.\n\n    This function matches orders based on the price-time priority algorithm, where the earliest\n    buy order at the highest price is prioritized over subsequent orders at the same price.\n\n    Args:\n        buy_orders (list): A list of buy orders, each represented as a dictionary with keys\n                           'quantity' and 'price'.\n        sell_orders (list): A list of sell orders, each represented as a dictionary with keys\n                            'quantity' and 'price'.\n\n    Returns:\n        matches (list): A list of matches, where each match is a dictionary indicating which\n                        buy and sell orders were matched and the executed quantity.\n\n    Notes:\n        - This function assumes buy and sell orders are sorted by time of entry.\n        - Only perfectly matched quantities or fully exhausted orders will be returned.\n        - This algorithm prioritizes transactions by 'first come, first served' philosophy.\n        - Ensure that buy orders are sorted by descending price and entry time.\n    \"\"\"\n    matches = []\n    buy_index, sell_index = 0, 0\n    \n    while buy_index < len(buy_orders) and sell_index < len(sell_orders):\n        buy_order = buy_orders[buy_index]\n        sell_order = sell_orders[sell_index]\n        \n        if buy_order['price'] >= sell_order['price']:\n            match_quantity = min(buy_order['quantity'], sell_order['quantity'])\n            matches.append({\n                'buy_order_index': buy_index,\n                'sell_order_index': sell_index,\n                'executed_quantity': match_quantity\n            })\n            buy_order['quantity'] -= match_quantity\n            sell_order['quantity'] -= match_quantity\n            \n            if buy_order['quantity'] == 0:\n                buy_index += 1\n            if sell_order['quantity'] == 0:\n                sell_index += 1\n        else:\n            break\n    \n    return matches"
        ],
        "usage": {
            "completion_tokens": 631,
            "prompt_tokens": 908,
            "total_tokens": 1539,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-2785",
        "article_title": "Equated Monthly Installment (EMI)",
        "function": "def calculate_emi_reducing_balance(principal: float, annual_interest_rate: float, total_payments: int) -> float:\n    \"\"\"\n    Calculate the Equated Monthly Installment (EMI) using the reducing balance method.\n\n    This function computes the EMI for a loan using the reducing balance method, which accounts for the decreasing principal \n    over time. The method provides potentially lower overall interest payments compared to the flat-rate method.\n\n    Args:\n        principal (float): The principal amount borrowed.\n        annual_interest_rate (float): The annual interest rate as a decimal (e.g., 3.5% as 0.035).\n        total_payments (int): The total number of monthly payments.\n\n    Returns:\n        emi (float): The amount of the equated monthly installment.\n\n    Notes:\n        - Applicability: This function is applicable for loans where payments reduce the principal balance.\n        - Constraints: The principal and interest rate should be non-negative, and total_payments should be a positive integer.\n        - Considerations: Ensure the interest rate is provided on an annual basis and will be converted to a monthly rate internally.\n    \"\"\"\n    monthly_interest_rate = annual_interest_rate / 12\n    if monthly_interest_rate == 0:\n        return principal / total_payments\n    emi = principal * (monthly_interest_rate * (1 + monthly_interest_rate) ** total_payments) / \\\n          ((1 + monthly_interest_rate) ** total_payments - 1)\n    \n    return emi",
        "statistics": {
            "number_statistics": {
                "args_numbers": 3,
                "question_numbers": 0,
                "context_numbers": 3,
                "total_numbers": 3
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 1,
                    "*": 2,
                    "/": 3,
                    "%": 0,
                    "**": 2
                },
                "total_operators": 10
            },
            "code_statistics": {
                "lines": 6,
                "parentheses": 8
            }
        },
        "difficulty": 4.605170185988092,
        "context": "John is considering taking out a personal loan to fund his startup business. He plans to borrow $150,000 with an annual interest rate of 6%. He agrees to pay off the loan over 10 years with monthly payments. Before signing the agreement, John wants to calculate the monthly payment he will need to make if the loan uses a reducing balance method, which could help lower overall interest costs.",
        "question": "What will be the amount of the Equated Monthly Installment (EMI) John needs to pay for the loan? Answer to the nearest cent.",
        "python_solution": "def solution():\n    # Define the loan parameters\n    principal = 150000  # The principal amount borrowed\n    annual_interest_rate = 0.06  # Annual interest rate as a decimal\n    total_payments = 10 * 12  # Total payments over 10 years (monthly)\n\n    # Calculate the monthly interest rate\n    monthly_interest_rate = annual_interest_rate / 12\n\n    # Calculate the EMI using the reducing balance method\n    if monthly_interest_rate == 0:\n        emi = principal / total_payments\n    else:\n        emi = principal * (monthly_interest_rate * (1 + monthly_interest_rate) ** total_payments) / \\\n              ((1 + monthly_interest_rate) ** total_payments - 1)\n    \n    # Return the EMI rounded to the nearest cent\n    return round(emi, 2)\n\n# Call the solution function and simulate returning the answer\nsolution()",
        "ground_truth": 1665.31,
        "source": "FinanceReasoning-test-181",
        "question_id": "test-2103",
        "level": "hard",
        "output": [
            "### **Reasoning Process**\n\n1. **Emphasizing Constraints (EC):**\n   - The principal amount to be borrowed (`principal`) is $150,000. It is a non-negative value.\n   - The annual interest rate is provided as 6% or 0.06 as a decimal. We'll ensure it's converted to a monthly rate for the calculation.\n   - The loan term is 10 years with monthly payments. The total number of payments (`total_payments`) is \\(10 \\times 12 = 120\\) payments.\n   - The EMI calculation should adhere to the reducing balance method, which relies on the formula:  \n     \\[\n     EMI = \\frac{P \\cdot r \\cdot (1 + r)^n}{(1 + r)^n - 1}\n     \\]\n     Where:\n     - \\( P \\) = Principal amount\n     - \\( r \\) = Monthly interest rate (annual rate divided by 12)\n     - \\( n \\) = Total number of payments (loan term in months)\n\n2. **Output Constraints:**\n   - The output EMI should be rounded to the nearest cent (\\( 2 \\) decimal places). This ensures clarity and avoids overpayment/underpayment due to rounding errors.\n\n3. **Validation of the Financial Function Provided:**\n   - The `calculate_emi_reducing_balance` function correctly implements the EMI formula using the provided arguments.\n   - The function calculates the monthly interest rate (\\( r \\)) by dividing the annual rate by 12.\n   - It accounts for the scenario where there is no interest (\\( r = 0 \\)) by returning the simple division of \\( P \\) by \\( n \\).\n\n4. **Steps to Calculate EMI for This Problem:**\n   - Use the financial function `calculate_emi_reducing_balance` with the given parameters:\n     - `principal` = 150,000\n     - `annual_interest_rate` = 6% = 0.06\n     - `total_payments` = \\( 10 \\times 12 = 120 \\)\n   - Round the result to the nearest cent.\n\n---\n\n### Python Program\n```python\ndef solution():\n    def calculate_emi_reducing_balance(principal: float, annual_interest_rate: float, total_payments: int) -> float:\n        \"\"\"\n        Calculate the Equated Monthly Installment (EMI) using the reducing balance method.\n\n        Args:\n            principal (float): The principal amount borrowed.\n            annual_interest_rate (float): The annual interest rate as a decimal.\n            total_payments (int): The total number of monthly payments.\n\n        Returns:\n            float: The equated monthly installment (EMI).\n        \"\"\"\n        monthly_interest_rate = annual_interest_rate / 12\n        if monthly_interest_rate == 0:\n            return principal / total_payments\n        emi = principal * (monthly_interest_rate * (1 + monthly_interest_rate) ** total_payments) / \\\n              ((1 + monthly_interest_rate) ** total_payments - 1)\n        return emi\n\n    # Define variables\n    principal = 150000  # Loan amount\n    annual_interest_rate = 0.06  # Annual interest rate (6% as 0.06)\n    total_payments = 10 * 12  # Loan duration in months: 10 years * 12 months/year\n\n    # Calculate EMI\n    emi = calculate_emi_reducing_balance(principal, annual_interest_rate, total_payments)\n    \n    # Round EMI to the nearest cent\n    answer = round(emi, 2)\n\n    # Return the answer\n    return answer\n```"
        ],
        "retrieval_query": "What will be the amount of the Equated Monthly Installment (EMI) John needs to pay for the loan? Answer to the nearest cent.",
        "useful_functions": [
            "def calculate_emi_reducing_balance(principal: float, annual_interest_rate: float, total_payments: int) -> float:\n    \"\"\"\n    Calculate the Equated Monthly Installment (EMI) using the reducing balance method.\n\n    This function computes the EMI for a loan using the reducing balance method, which accounts for the decreasing principal \n    over time. The method provides potentially lower overall interest payments compared to the flat-rate method.\n\n    Args:\n        principal (float): The principal amount borrowed.\n        annual_interest_rate (float): The annual interest rate as a decimal (e.g., 3.5% as 0.035).\n        total_payments (int): The total number of monthly payments.\n\n    Returns:\n        emi (float): The amount of the equated monthly installment.\n\n    Notes:\n        - Applicability: This function is applicable for loans where payments reduce the principal balance.\n        - Constraints: The principal and interest rate should be non-negative, and total_payments should be a positive integer.\n        - Considerations: Ensure the interest rate is provided on an annual basis and will be converted to a monthly rate internally.\n    \"\"\"\n    monthly_interest_rate = annual_interest_rate / 12\n    if monthly_interest_rate == 0:\n        return principal / total_payments\n    emi = principal * (monthly_interest_rate * (1 + monthly_interest_rate) ** total_payments) / \\\n          ((1 + monthly_interest_rate) ** total_payments - 1)\n    \n    return emi"
        ],
        "usage": {
            "completion_tokens": 756,
            "prompt_tokens": 754,
            "total_tokens": 1510,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-582",
        "article_title": "Fixed-Rate Payment",
        "function": "def calculate_amortization_schedule(principal: float, annual_interest_rate: float, years: int) -> list:\n    \"\"\"\n    Generate an amortization schedule for a fixed-rate loan.\n\n    This function calculates and returns a list of tuples, each representing a\n    payment period in the amortization schedule of a fixed-rate loan. Each tuple\n    contains the total payment, the principal payment, the interest payment, the\n    total interest paid to date, and the remaining loan balance.\n\n    Args:\n        principal (float): The initial amount of the loan.\n        annual_interest_rate (float): The annual interest rate as a decimal (e.g., 0.045 for 4.5%).\n        years (int): The term of the loan in years.\n\n    Returns:\n        schedule (list): A list of tuples for each payment period, where each tuple contains:\n                         - total payment (float)\n                         - principal payment (float)\n                         - interest payment (float)\n                         - total interest to date (float)\n                         - remaining loan balance (float)\n\n    Notes:\n        - The monthly interest rate is calculated from the annual interest rate.\n        - The amortization schedule displays how much of each payment goes toward interest and principal.\n        - Applicability: This function is suitable for creating schedules for fixed-rate loans.\n        - Constraints: Ensure valid non-negative interest rate and positive principal and years.\n        - Considerations: The schedule is based on the assumption of monthly payments.\n    \"\"\"\n    monthly_payment = calculate_fixed_rate_payment(principal, annual_interest_rate, years)\n    monthly_interest_rate = annual_interest_rate / 12\n    number_of_payments = years * 12\n\n    schedule = []\n    total_interest = 0\n    remaining_balance = principal\n\n    for _ in range(number_of_payments):\n        interest_payment = remaining_balance * monthly_interest_rate\n        principal_payment = monthly_payment - interest_payment\n        total_interest += interest_payment\n        remaining_balance -= principal_payment\n\n        schedule.append((monthly_payment, principal_payment, interest_payment, total_interest, remaining_balance if remaining_balance > 0 else 0))\n\n    return schedule",
        "statistics": {
            "number_statistics": {
                "args_numbers": 3,
                "question_numbers": 1,
                "context_numbers": 3,
                "total_numbers": 4
            },
            "operator_statistics": {
                "operators": {
                    "+": 1,
                    "-": 2,
                    "*": 2,
                    "/": 1,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 6
            },
            "code_statistics": {
                "lines": 13,
                "parentheses": 8
            }
        },
        "difficulty": 4.624972813284272,
        "context": "A homeowner takes out a mortgage loan of $300,000 to buy a new house. The loan has a fixed annual interest rate of 4% and is to be repaid over a 30-year period with monthly payments. The homeowner wants to know the total amount of interest they will have paid by the end of the loan term.",
        "question": "What is the total amount of interest the homeowner will pay over the 30-year term of the mortgage? Answer to the nearest dollar.",
        "python_solution": "def solution():\n    # Define variables and their values\n    principal = 300000\n    annual_interest_rate = 0.04\n    years = 30\n    \n    # Calculate the monthly interest rate\n    monthly_interest_rate = annual_interest_rate / 12\n    \n    # Calculate the number of payments\n    number_of_payments = years * 12\n    \n    # Calculate the monthly payment using the fixed-rate mortgage formula\n    # M = P[r(1+r)^n] / [(1+r)^n \u2013 1]\n    monthly_payment = principal * (monthly_interest_rate * (1 + monthly_interest_rate) ** number_of_payments) / ((1 + monthly_interest_rate) ** number_of_payments - 1)\n    \n    # Initialize total interest\n    total_interest = 0\n    \n    # Initialize remaining loan balance\n    remaining_balance = principal\n    \n    # Loop through each payment to build the amortization schedule\n    for _ in range(number_of_payments):\n        # Calculate the interest payment for the month\n        interest_payment = remaining_balance * monthly_interest_rate\n        \n        # Calculate the principal payment for the month\n        principal_payment = monthly_payment - interest_payment\n        \n        # Add the interest payment to the total interest\n        total_interest += interest_payment\n        \n        # Reduce the remaining balance by the principal payment\n        remaining_balance -= principal_payment\n    \n    # Return the total interest to date, rounded to the nearest dollar\n    return round(total_interest)\n\n# Test and print the solution result\nprint(solution())  # This will output the result when the function is called.",
        "ground_truth": 215609,
        "source": "FinanceReasoning-test-145",
        "question_id": "test-2104",
        "level": "hard",
        "output": [
            "### Step-by-step reasoning:\n1. **Understand the Question and Constraints**:\n   - The loan principal is $300,000.\n   - The fixed annual interest rate is 4% (0.04 in decimal).\n   - The loan term is 30 years.\n   - We need to calculate the total interest paid by the end of the term, rounded to the nearest dollar.\n   - **Constraints**:\n     - The interest rate must be greater than 0.\n     - The duration must be positive.\n     - Use a standard amortization formula for fixed-rate loans with equal monthly payments.\n\n2. **Decomposing the Problem**:\n   - First, calculate the total payment for the mortgage over the 30-year term using a monthly payment formula (provided in the context).\n   - Then calculate the total interest paid by subtracting the loan principal from the total payment.\n\n3. **Consider Edge Cases**:\n   - Verify that inputs align with the constraints: the interest rate is positive and the loan term is valid.\n\n4. **Plan Implementation**:\n   - Use the formula provided to calculate the total payment over the life of the loan.\n   - Subtract the principal from the total payment to get the total interest.\n\nNow, let's write the Python program.\n\n```python\ndef solution():\n    # Define variables name and value\n    principal = 300000  # Loan amount\n    annual_interest_rate = 0.04  # Fixed annual interest rate\n    years = 30  # Loan term in years\n    \n    # Calculate the monthly interest rate and number of payments\n    monthly_interest_rate = annual_interest_rate / 12\n    number_of_payments = years * 12\n    \n    # Calculate the monthly payment using the amortization formula\n    monthly_payment = (principal * monthly_interest_rate * \n                      (1 + monthly_interest_rate)**number_of_payments) / \\\n                      ((1 + monthly_interest_rate)**number_of_payments - 1)\n    \n    # Calculate the total payment over the loan term\n    total_payment = monthly_payment * number_of_payments\n    \n    # The total interest paid is the total payment minus the principal\n    total_interest = total_payment - principal\n    \n    # Return the total interest with rounding to the nearest dollar\n    return round(total_interest)\n```"
        ],
        "retrieval_query": "What is the total amount of interest the homeowner will pay over the 30-year term of the mortgage? Answer to the nearest dollar.",
        "useful_functions": [
            "def calculate_mortgage_cost(principal: float, annual_interest_rate: float, years: int) -> float:\n    \"\"\"\n    Calculate the total cost of a mortgage over its full term.\n\n    This function calculates the total cost of a mortgage by summing the \n    principal and the total interest paid over the loan term.\n\n    Args:\n        principal (float): The amount borrowed for the mortgage.\n        annual_interest_rate (float): The annual interest rate of the mortgage expressed as a decimal.\n        years (int): The term of the mortgage in years.\n\n    Returns:\n        total_mortgage_cost (float): The total cost of the mortgage, including principal and interest.\n\n    Notes:\n        - This function assumes a fixed interest rate and equal monthly payments throughout the loan term.\n        - Constraints: The interest rate should be greater than 0, and the number of years should be positive.\n        - Considerations: Does not include additional costs such as insurance, property taxes, or opportunity cost.\n    \"\"\"\n    monthly_interest_rate = annual_interest_rate / 12\n    number_of_payments = years * 12\n    monthly_payment = principal * (monthly_interest_rate * (1 + monthly_interest_rate) ** number_of_payments) / ((1 + monthly_interest_rate) ** number_of_payments - 1)\n\n    total_payment = monthly_payment * number_of_payments\n    total_mortgage_cost = total_payment\n\n    return total_mortgage_cost"
        ],
        "usage": {
            "completion_tokens": 468,
            "prompt_tokens": 728,
            "total_tokens": 1196,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-777",
        "article_title": "Bull Put Spread",
        "function": "def calculate_bull_put_spread_profit_loss(sell_premium: float, buy_premium: float, sell_strike: float, buy_strike: float, stock_price_at_expiry: float) -> dict:\n    \"\"\"\n    Calculate the potential profit or loss of a bull put spread options strategy.\n\n    This function computes the maximum profit, maximum loss, and actual profit or loss\n    at expiration for a bull put spread strategy, based on option premiums and strike prices.\n\n    Args:\n        sell_premium (float): The premium received from selling the higher strike put option.\n        buy_premium (float): The premium paid for buying the lower strike put option.\n        sell_strike (float): The strike price of the put option that is sold.\n        buy_strike (float): The strike price of the put option that is bought.\n        stock_price_at_expiry (float): The stock price at the expiration of the options.\n\n    Returns:\n        result (dict): A dictionary containing:\n            - 'max_profit' (float): Maximum profit achievable from the strategy.\n            - 'max_loss' (float): Maximum loss potential from the strategy.\n            - 'profit_loss' (float): Actual profit or loss based on the stock price at expiration.\n\n    Notes:\n        - Applicability: This function is applicable for evaluating the bull put spread strategy under different market conditions.\n        - Constraints: Ensure that the sell_strike is higher than the buy_strike for a valid bull put spread.\n        - Considerations: The function does not account for transaction costs or taxes.\n    \"\"\"\n    net_credit = sell_premium - buy_premium\n    max_profit = net_credit\n    max_loss = (sell_strike - buy_strike) - net_credit\n\n    # Calculate actual profit or loss at expiration\n    if stock_price_at_expiry > sell_strike:\n        profit_loss = max_profit\n    elif stock_price_at_expiry < buy_strike:\n        profit_loss = -max_loss\n    else:\n        profit_loss = net_credit - (sell_strike - stock_price_at_expiry)\n\n    return {\n        'max_profit': max_profit,\n        'max_loss': max_loss,\n        'profit_loss': profit_loss\n    }",
        "statistics": {
            "number_statistics": {
                "args_numbers": 5,
                "question_numbers": 0,
                "context_numbers": 5,
                "total_numbers": 5
            },
            "operator_statistics": {
                "operators": {
                    "+": 0,
                    "-": 6,
                    "*": 0,
                    "/": 0,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 6
            },
            "code_statistics": {
                "lines": 15,
                "parentheses": 4
            }
        },
        "difficulty": 4.624972813284272,
        "context": "An investor is considering implementing a bull put spread options strategy on XYZ Corporation's stock. The investor sells a put option with a strike price of \\$110 for a premium of \\$6 and buys a put option with a strike price of \\$100 for a premium of \\$2. At the options' expiration, the stock price is \\$105.",
        "question": "What is the investor's actual profit or loss at the expiration of the bull put spread? Provide your answer in dollars, rounded to the nearest whole number.",
        "python_solution": "def solution():\n    # Given values\n    sell_premium = 6  # Premium received for the sold put\n    buy_premium = 2   # Premium paid for the bought put\n    sell_strike = 110  # Strike price of the sold put\n    buy_strike = 100   # Strike price of the bought put\n    stock_price_at_expiry = 105  # Stock price at expiration\n\n    # Calculate the net credit received from the strategy\n    net_credit = sell_premium - buy_premium\n\n    # Maximum potential profit from the strategy\n    max_profit = net_credit\n\n    # Maximum potential loss from the strategy\n    max_loss = (sell_strike - buy_strike) - net_credit\n\n    # Calculate actual profit or loss at expiration\n    if stock_price_at_expiry > sell_strike:\n        profit_loss = max_profit\n    elif stock_price_at_expiry < buy_strike:\n        profit_loss = -max_loss\n    else:\n        profit_loss = net_credit - (sell_strike - stock_price_at_expiry)\n\n    # Return the result rounded to the nearest whole number\n    return round(profit_loss)\n\n# Example output:\n# print(solution()) should return the calculated profit or loss.",
        "ground_truth": -1,
        "source": "FinanceReasoning-test-147",
        "question_id": "test-2105",
        "level": "hard",
        "output": [
            "### Step-by-step solution using advanced reasoning, primarily focusing on **Emphasizing Constraints (EC)**:\n\n---\n\n#### 1. Constraints in the problem:\n   - **Strike Price Relation**: For a valid bull put spread, the strike price of the sold put (\\$110) must be higher than the strike price of the purchased put (\\$100). This is true here, so this strategy is valid.\n   - **Stock Price at Expiration**: The stock price at expiration is \\$105, which lies between the strike prices (\\$110 and \\$100). This affects the calculation of actual profit or loss as partial losses will apply here.\n   - **Calculation Units**: All values (premiums, strike prices, profit/loss) are in dollars, so no unit conversion is needed.\n   - **Precision**: The result must be returned rounded to the nearest whole number for clarity.\n\n#### 2. Key Details and Formulas:\n   - **Sell Premium**: \\$6 per option is received from selling the \\$110 strike put.\n   - **Buy Premium**: \\$2 per option is paid for buying the \\$100 strike put.\n   - **Net Credit**: \\( \\text{Sell Premium - Buy Premium} = 6 - 2 = 4 \\). This represents the upfront premium received for entering the position.\n   - **Profit/Loss Calculation Logic**:\n     - If the stock price at expiration is **above the sold put's strike price (\\$110)**, the options expire worthless, and maximum profit is realized (\\$4).\n     - If the stock price at expiration is **below the purchased put's strike price (\\$100)**, maximum loss applies.\n     - If the stock price at expiration lies **between the two strike prices**, partial loss occurs: \\( \\text{Net Credit} - (\\text{Sell Strike} - \\text{Stock Price at Expiry}) \\).\n\n#### 3. Determining the Actual Outcome:\n   - Since the stock price at expiration is \\$105 (between \\$110 and \\$100):\n     \\[\n     \\text{Profit/Loss} = \\text{Net Credit} - (\\text{Sell Strike} - \\text{Stock Price at Expiry}) = 4 - (110 - 105) = 4 - 5 = -1.\n     \\]\n   - Therefore, the investor incurs a loss of \\$1 per spread.\n\n#### 4. Implementation:\nNow, the problem can be represented programmatically:\n\n---\n\n```python\ndef solution():\n    # Define variables name and value\n    sell_premium = 6      # Premium from selling the $110 put\n    buy_premium = 2       # Premium paid for buying the $100 put\n    sell_strike = 110     # Strike price of the sold put\n    buy_strike = 100      # Strike price of the purchased put\n    stock_price_at_expiry = 105  # Stock price at expiration\n    \n    # Calculate net credit\n    net_credit = sell_premium - buy_premium\n    \n    # Calculate profit or loss at expiration\n    if stock_price_at_expiry > sell_strike:\n        profit_loss = net_credit  # Maximum profit\n    elif stock_price_at_expiry < buy_strike:\n        profit_loss = -(sell_strike - buy_strike - net_credit)  # Maximum loss\n    else:\n        profit_loss = net_credit - (sell_strike - stock_price_at_expiry)  # Partial loss\n    \n    # Return the actual profit or loss, rounded to the nearest whole number\n    return round(profit_loss)\n```"
        ],
        "retrieval_query": "What is the investor's actual profit or loss at the expiration of the bull put spread? Provide your answer in dollars, rounded to the nearest whole number.",
        "useful_functions": [
            "def calculate_bull_put_spread_profit_loss(sell_premium: float, buy_premium: float, sell_strike: float, buy_strike: float, stock_price_at_expiry: float) -> dict:\n    \"\"\"\n    Calculate the potential profit or loss of a bull put spread options strategy.\n\n    This function computes the maximum profit, maximum loss, and actual profit or loss\n    at expiration for a bull put spread strategy, based on option premiums and strike prices.\n\n    Args:\n        sell_premium (float): The premium received from selling the higher strike put option.\n        buy_premium (float): The premium paid for buying the lower strike put option.\n        sell_strike (float): The strike price of the put option that is sold.\n        buy_strike (float): The strike price of the put option that is bought.\n        stock_price_at_expiry (float): The stock price at the expiration of the options.\n\n    Returns:\n        result (dict): A dictionary containing:\n            - 'max_profit' (float): Maximum profit achievable from the strategy.\n            - 'max_loss' (float): Maximum loss potential from the strategy.\n            - 'profit_loss' (float): Actual profit or loss based on the stock price at expiration.\n\n    Notes:\n        - Applicability: This function is applicable for evaluating the bull put spread strategy under different market conditions.\n        - Constraints: Ensure that the sell_strike is higher than the buy_strike for a valid bull put spread.\n        - Considerations: The function does not account for transaction costs or taxes.\n    \"\"\"\n    net_credit = sell_premium - buy_premium\n    max_profit = net_credit\n    max_loss = (sell_strike - buy_strike) - net_credit\n\n    # Calculate actual profit or loss at expiration\n    if stock_price_at_expiry > sell_strike:\n        profit_loss = max_profit\n    elif stock_price_at_expiry < buy_strike:\n        profit_loss = -max_loss\n    else:\n        profit_loss = net_credit - (sell_strike - stock_price_at_expiry)\n\n    return {\n        'max_profit': max_profit,\n        'max_loss': max_loss,\n        'profit_loss': profit_loss\n    }"
        ],
        "usage": {
            "completion_tokens": 741,
            "prompt_tokens": 891,
            "total_tokens": 1632,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-1791",
        "article_title": "Durbin Watson Statistic",
        "function": "def calculate_durbin_watson_statistic(actual_values: list, expected_values: list) -> float:\n    \"\"\"\n    Calculate the Durbin Watson statistic for detecting autocorrelation in the residuals \n    from a regression analysis.\n\n    Args:\n        actual_values (list): A list of actual observed y values from the data.\n        expected_values (list): A list of expected y values calculated from the \n                                regression line.\n\n    Returns:\n        dw_statistic (float): The Durbin Watson statistic value.\n\n    Notes:\n        - Applicability: Used in regression analysis to detect the presence of \n          autocorrelation in the residuals.\n        - Constraints: 'actual_values' and 'expected_values' must be of the same length.\n        - Considerations: This statistic is not valid if lagged dependent variables are \n          used as explanatory variables. Values typically range from 0 to 4.\n    \"\"\"\n    if len(actual_values) != len(expected_values):\n        raise ValueError(\"The length of 'actual_values' and 'expected_values' must be the same.\")\n\n    # Calculate residuals (errors)\n    errors = [actual - expected for actual, expected in zip(actual_values, expected_values)]\n    \n    # Calculate Sum of Errors Squared\n    sum_errors_squared = sum(error ** 2 for error in errors)\n    \n    # Calculate Sum of Differences Squared\n    differences_squared = [(errors[i] - errors[i-1]) ** 2 for i in range(1, len(errors))]\n    sum_differences_squared = sum(differences_squared)\n    \n    # Calculate Durbin Watson statistic\n    dw_statistic = sum_differences_squared / sum_errors_squared\n    \n    return dw_statistic",
        "statistics": {
            "number_statistics": {
                "args_numbers": 2,
                "question_numbers": 0,
                "context_numbers": 23,
                "total_numbers": 23
            },
            "operator_statistics": {
                "operators": {
                    "+": 0,
                    "-": 3,
                    "*": 0,
                    "/": 1,
                    "%": 0,
                    "**": 2
                },
                "total_operators": 6
            },
            "code_statistics": {
                "lines": 10,
                "parentheses": 14
            }
        },
        "difficulty": 4.624972813284272,
        "context": "A finance analyst is evaluating the fit of a regression model used to predict the daily closing prices of a tech company's stock over a two-week period. The analyst has 10 actual values representing the observed closing prices and 10 expected values that are the predicted closing prices from the regression model. The actual observed closing prices (in dollars) for these 10 days are: \n[150.2, 149.8, 150.5, 151.0, 150.7, 151.5, 152.0, 151.8, 152.3, 152.1].\nThe predicted closing prices (in dollars) are: \n[150.0, 150.1, 150.3, 150.9, 150.6, 151.3, 152.1, 151.9, 152.5, 152.0].\nThe analyst needs to determine whether there is any significant autocorrelation in the residuals of the regression model, which could indicate unreliable predictions.",
        "question": "Calculate the Durbin Watson statistic for the residuals. Provide your answer as a float rounded to two decimal places.",
        "python_solution": "def solution():\n    # Define actual and predicted values\n    actual_values = [150.2, 149.8, 150.5, 151.0, 150.7, 151.5, 152.0, 151.8, 152.3, 152.1]\n    expected_values = [150.0, 150.1, 150.3, 150.9, 150.6, 151.3, 152.1, 151.9, 152.5, 152.0]\n\n    # Calculate residuals (errors)\n    errors = [actual - expected for actual, expected in zip(actual_values, expected_values)]\n    \n    # Calculate Sum of Errors Squared\n    sum_errors_squared = sum(error ** 2 for error in errors)\n    \n    # Calculate Sum of Differences Squared\n    differences_squared = [(errors[i] - errors[i-1]) ** 2 for i in range(1, len(errors))]\n    sum_differences_squared = sum(differences_squared)\n    \n    # Calculate Durbin Watson statistic\n    dw_statistic = sum_differences_squared / sum_errors_squared\n\n    # Return the statistic rounded to two decimal places\n    return round(dw_statistic, 2)",
        "ground_truth": 2.37,
        "source": "FinanceReasoning-test-161",
        "question_id": "test-2106",
        "level": "hard",
        "output": [
            "Let's analyze and solve the problem step by step using reasoning techniques.\n\n### Step 1: Understand the Problem\nWe need to calculate the **Durbin-Watson (DW) statistic**, which is a metric used to detect the presence of autocorrelation in the residuals of a regression model. The formula for DW is given by:\n\n\\[\nDW = \\dfrac{\\sum_{i=2}^n (e_i - e_{i-1})^2}{\\sum_{i=1}^n e_i^2}\n\\]\n\nWhere:\n- \\( e_i \\): Residual at index \\( i \\), which is calculated as \\( e_i = \\text{actual}[i] - \\text{predicted}[i] \\).\n- \\( \\sum_{i=1}^n e_i^2 \\): The sum of squared residuals.\n- \\( \\sum_{i=2}^n (e_i - e_{i-1})^2 \\): The sum of squared differences between consecutive residuals.\n\n---\n\n### Step 2: Apply Constraints (EC)\n1. **Input Size Constraint**: Ensure that the length of the `actual_values` and `predicted_values` lists is equal, as the calculation of residuals requires element-wise subtraction. Here, both lists have 10 elements.\n2. **Rounded Result Constraint**: Return the DW statistic rounded to **two decimal places**.\n3. **Proper Calculation Constraints**:\n   - Correct computation of residuals as \\( \\text{actual} - \\text{predicted} \\).\n   - Proper handling of the summation terms for both numerator and denominator.\n\n---\n\n### Step 3: Implement the Calculation\nUsing the given data:\n- `actual_values`: [150.2, 149.8, 150.5, 151.0, 150.7, 151.5, 152.0, 151.8, 152.3, 152.1]\n- `predicted_values`: [150.0, 150.1, 150.3, 150.9, 150.6, 151.3, 152.1, 151.9, 152.5, 152.0]\n\nWe will:\n1. Calculate residuals: Element-wise subtraction of `predicted_values` from `actual_values`.\n2. Compute the numerator: The sum of squared differences between consecutive residuals.\n3. Compute the denominator: The sum of squared residuals.\n4. Calculate \\( DW = \\dfrac{\\text{numerator}}{\\text{denominator}} \\).\n5. Return the result rounded to two decimal places.\n\nHere is the Python program to solve the problem:\n\n```python\ndef solution():\n    # Define variables name and value\n    actual_values = [150.2, 149.8, 150.5, 151.0, 150.7, 151.5, 152.0, 151.8, 152.3, 152.1]\n    predicted_values = [150.0, 150.1, 150.3, 150.9, 150.6, 151.3, 152.1, 151.9, 152.5, 152.0]\n    \n    # Calculate residuals (errors)\n    residuals = [actual - predicted for actual, predicted in zip(actual_values, predicted_values)]\n    \n    # Calculate Sum of Errors Squared (denominator)\n    sum_errors_squared = sum(error ** 2 for error in residuals)\n    \n    # Calculate Sum of Differences Squared (numerator)\n    differences_squared = [(residuals[i] - residuals[i - 1]) ** 2 for i in range(1, len(residuals))]\n    sum_differences_squared = sum(differences_squared)\n    \n    # Calculate Durbin Watson statistic\n    dw_statistic = sum_differences_squared / sum_errors_squared\n    \n    # Return the statistic rounded to two decimal places\n    return round(dw_statistic, 2)\n\n```"
        ],
        "retrieval_query": "Calculate the Durbin Watson statistic for the residuals. Provide your answer as a float rounded to two decimal places.",
        "useful_functions": [
            "def calculate_durbin_watson_statistic(actual_values: list, expected_values: list) -> float:\n    \"\"\"\n    Calculate the Durbin Watson statistic for detecting autocorrelation in the residuals \n    from a regression analysis.\n\n    Args:\n        actual_values (list): A list of actual observed y values from the data.\n        expected_values (list): A list of expected y values calculated from the \n                                regression line.\n\n    Returns:\n        dw_statistic (float): The Durbin Watson statistic value.\n\n    Notes:\n        - Applicability: Used in regression analysis to detect the presence of \n          autocorrelation in the residuals.\n        - Constraints: 'actual_values' and 'expected_values' must be of the same length.\n        - Considerations: This statistic is not valid if lagged dependent variables are \n          used as explanatory variables. Values typically range from 0 to 4.\n    \"\"\"\n    if len(actual_values) != len(expected_values):\n        raise ValueError(\"The length of 'actual_values' and 'expected_values' must be the same.\")\n\n    # Calculate residuals (errors)\n    errors = [actual - expected for actual, expected in zip(actual_values, expected_values)]\n    \n    # Calculate Sum of Errors Squared\n    sum_errors_squared = sum(error ** 2 for error in errors)\n    \n    # Calculate Sum of Differences Squared\n    differences_squared = [(errors[i] - errors[i-1]) ** 2 for i in range(1, len(errors))]\n    sum_differences_squared = sum(differences_squared)\n    \n    # Calculate Durbin Watson statistic\n    dw_statistic = sum_differences_squared / sum_errors_squared\n    \n    return dw_statistic"
        ],
        "usage": {
            "completion_tokens": 846,
            "prompt_tokens": 920,
            "total_tokens": 1766,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-2481",
        "article_title": "Winsorized Mean",
        "function": "def calculate_winsorized_mean(data: list, winsor_percent: float) -> float:\n    \"\"\"\n    Calculate the winsorized mean of a dataset.\n\n    This function computes the winsorized mean by replacing a specified percentage of \n    the smallest and largest values in the dataset with the nearest values, thus reducing \n    the influence of outliers.\n\n    Args:\n        data (list): A list of numerical data points.\n        winsor_percent (float): The percentage of extreme values to replace at each end\n                                of the data. It should be between 0 and 0.5, where 0.1\n                                equals 10% of the data being replaced at each end.\n\n    Returns:\n        winsorized_mean (float): The winsorized mean of the dataset.\n\n    Notes:\n        - Applicability: Useful for datasets with outliers or when a robust central tendency \n                         measure is required.\n        - Constraints: The `data` list must not be empty, and `winsor_percent` must be \n                       between 0 and 0.5.\n        - Considerations: The function modifies the input data temporarily to compute \n                          the winsorized mean but does not alter the original dataset permanently.\n    \"\"\"\n    if not 0 <= winsor_percent <= 0.5:\n        raise ValueError(\"winsor_percent must be between 0 and 0.5.\")\n    if not data:\n        raise ValueError(\"The data list must not be empty.\")\n\n    n = int(len(data) * winsor_percent)\n    sorted_data = sorted(data)\n    winsorized_data = sorted_data[:]\n    if n > 0:\n        min_value = sorted_data[n]\n        max_value = sorted_data[-n-1]\n        for i in range(n):\n            winsorized_data[i] = min_value\n            winsorized_data[-i-1] = max_value\n\n    winsorized_mean = sum(winsorized_data) / len(winsorized_data)\n    return winsorized_mean",
        "statistics": {
            "number_statistics": {
                "args_numbers": 2,
                "question_numbers": 1,
                "context_numbers": 22,
                "total_numbers": 23
            },
            "operator_statistics": {
                "operators": {
                    "+": 0,
                    "-": 4,
                    "*": 1,
                    "/": 1,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 6
            },
            "code_statistics": {
                "lines": 11,
                "parentheses": 12
            }
        },
        "difficulty": 4.624972813284272,
        "context": "A financial analyst is analyzing a portfolio of 20 stocks that recently underwent significant market volatility. The analyst wants to report a robust central tendency for the stock returns, which are highly influenced by extreme outliers. The returns for the stocks over the last month (in percentage) are as follows: [15.4, -6.2, 7.8, -14.3, 12.0, -9.1, 18.5, 25.7, -5.0, 3.3, 21.2, -7.6, 11.7, 29.8, -19.4, 8.9, 4.5, -11.2, 6.6, -13.7]. To mitigate the effect of these extremes, the analyst decides to use a 10% winsorization technique on both ends of the data to compute a winsorized mean of stock returns.",
        "question": "What is the winsorized mean of the stock returns, considering a 10% winsorization? Answer as a percentage rounded to two decimal places.",
        "python_solution": "def solution():\n    # List of stock returns data\n    stock_returns = [15.4, -6.2, 7.8, -14.3, 12.0, -9.1, 18.5, 25.7, -5.0, 3.3,\n                     21.2, -7.6, 11.7, 29.8, -19.4, 8.9, 4.5, -11.2, 6.6, -13.7]\n    \n    # Winsorization percentage\n    winsor_percent = 0.10\n    \n    # Calculate the number of elements to winsorize on each side\n    n = int(len(stock_returns) * winsor_percent)\n    \n    # Sort the data\n    sorted_returns = sorted(stock_returns)\n    \n    # Create a copy for winsorized data\n    winsorized_returns = sorted_returns[:]\n    \n    if n > 0:\n        # Minimum and maximum values for winsorization\n        min_value = sorted_returns[n]\n        max_value = sorted_returns[-n-1]\n        \n        # Apply winsorization\n        for i in range(n):\n            winsorized_returns[i] = min_value\n            winsorized_returns[-i-1] = max_value\n    \n    # Calculate the winsorized mean\n    winsorized_mean = sum(winsorized_returns) / len(winsorized_returns)\n    \n    # Return the result, rounded to two decimal places\n    return round(winsorized_mean, 2)\n\n# Call the solution function to get the winsorized mean\nsolution()",
        "ground_truth": 3.6,
        "source": "FinanceReasoning-test-165",
        "question_id": "test-2107",
        "level": "hard",
        "output": [
            "### Let's reason step-by-step using the **Emphasizing Constraints (EC)** technique:\n\n1. **Understand the Constraints**:\n   - We are calculating a **winsorized mean** of stock returns with a **10% winsorization** on both ends of the data.\n   - The dataset consists of 20 stock returns in percentages: `[15.4, -6.2, 7.8, -14.3, 12.0, -9.1, 18.5, 25.7, -5.0, 3.3, 21.2, -7.6, 11.7, 29.8, -19.4, 8.9, 4.5, -11.2, 6.6, -13.7]`.\n   - For **10% winsorization on both ends**, we replace the smallest and largest 10% (2 values in this case, since 10% of 20 = 2) with the values at the 10th percentile (for the bottom 10%) and the 90th percentile (for the top 10%).\n\n2. **Winsorization Process**:\n   - Sort the data in ascending order.\n   - Identify the **10th percentile value** (3rd smallest value in sorted data) and **90th percentile value** (3rd largest value in sorted data).\n   - Replace all values below the **10th percentile value** with the **10th percentile value**.\n   - Replace all values above the **90th percentile value** with the **90th percentile value**.\n\n3. **Compute the Winsorized Mean**:\n   - Once the data is winsorized, simply calculate the arithmetic mean of the modified dataset.\n   - Round the resulting winsorized mean to **two decimal places** as per the constraint.\n\n4. **Output the Result**:\n   - Return the winsorized mean as a percentage.\n\nNow, let's implement the solution in Python:\n\n```python\ndef solution():\n    # Define original data of stock returns\n    stock_returns = [15.4, -6.2, 7.8, -14.3, 12.0, -9.1, 18.5, 25.7, -5.0, 3.3, \n                     21.2, -7.6, 11.7, 29.8, -19.4, 8.9, 4.5, -11.2, 6.6, -13.7]\n    \n    # Step 1: Sort the data\n    sorted_returns = sorted(stock_returns)\n    \n    # Step 2: Identify the 10th and 90th percentile values\n    n = len(sorted_returns)\n    lower_index = int(n * 0.1)  # Index for 10th percentile (2 in a dataset of 20 items)\n    upper_index = int(n * 0.9)  # Index for 90th percentile (18 in a dataset of 20 items)\n    lower_bound = sorted_returns[lower_index]\n    upper_bound = sorted_returns[upper_index - 1]  # Subtract 1 since upper_bound index is exclusive\n    \n    # Step 3: Winsorize the data (replace extremes with the bounds)\n    winsorized_data = [max(lower_bound, min(upper_bound, x)) for x in stock_returns]\n    \n    # Step 4: Compute the mean of the winsorized data\n    winsorized_mean = sum(winsorized_data) / len(winsorized_data)\n    \n    # Step 5: Round to two decimal places and return as percentage\n    return round(winsorized_mean, 2)\n```"
        ],
        "retrieval_query": "What is the winsorized mean of the stock returns, considering a 10% winsorization? Answer as a percentage rounded to two decimal places.",
        "useful_functions": [],
        "usage": {
            "completion_tokens": 790,
            "prompt_tokens": 552,
            "total_tokens": 1342,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-3078",
        "article_title": "Ordinary Loss",
        "function": "def calculate_net_gain_or_loss(ordinary_income: float, ordinary_expenses: float, short_term_gain: float, short_term_loss: float, long_term_gain: float, long_term_loss: float) -> dict:\n    \"\"\"\n    Calculate the net gain or loss from ordinary income and capital transactions.\n\n    This function computes the net ordinary gain or loss from business operations\n    as well as the net capital gain or loss from short-term and long-term investments.\n    The net values allow a taxpayer to understand their financial standing and tax liability.\n\n    Args:\n        ordinary_income (float): Total ordinary income earned from business operations.\n        ordinary_expenses (float): Total expenses incurred in business operations.\n        short_term_gain (float): Total short-term capital gains from asset sales.\n        short_term_loss (float): Total short-term capital losses from asset sales.\n        long_term_gain (float): Total long-term capital gains from asset sales.\n        long_term_loss (float): Total long-term capital losses from asset sales.\n\n    Returns:\n        result (dict): A dictionary containing:\n            'net_ordinary_gain' (float): The net ordinary gain or loss.\n            'net_short_term_capital' (float): The net short-term capital gain or loss.\n            'net_long_term_capital' (float): The net long-term capital gain or loss.\n            'net_overall_gain' (float): The overall net gain or loss considering allowable deductions.\n\n    Notes:\n        - Ordinary losses can be fully deducted to offset ordinary income.\n        - Capital losses exceeding capital gains can only offset $3,000 of ordinary income.\n        - Remaining capital losses can be carried over to subsequent years.\n        - This function does not handle carryover processes; it only returns current year\u2019s computations.\n    \"\"\"\n    net_ordinary_gain = ordinary_income - ordinary_expenses\n    net_short_term_capital = short_term_gain - short_term_loss\n    net_long_term_capital = long_term_gain - long_term_loss\n\n    net_capital = net_short_term_capital + net_long_term_capital\n\n    # Apply the $3,000 deduction limit for capital losses against ordinary income\n    if net_capital < 0:\n        capital_deduction = max(net_capital, -3000)\n    else:\n        capital_deduction = net_capital\n\n    net_overall_gain = net_ordinary_gain + capital_deduction\n\n    return {\n        'net_ordinary_gain': net_ordinary_gain,\n        'net_short_term_capital': net_short_term_capital,\n        'net_long_term_capital': net_long_term_capital,\n        'net_overall_gain': net_overall_gain\n    }",
        "statistics": {
            "number_statistics": {
                "args_numbers": 6,
                "question_numbers": 0,
                "context_numbers": 6,
                "total_numbers": 6
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 4,
                    "*": 0,
                    "/": 0,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 6
            },
            "code_statistics": {
                "lines": 16,
                "parentheses": 2
            }
        },
        "difficulty": 4.624972813284272,
        "context": "A small business owner is reviewing their financial statements at the end of the fiscal year to evaluate their net financial position. During the year, the business generated an ordinary income of $150,000 and incurred ordinary expenses totaling $120,000. The owner also engaged in various investment activities resulting in short-term capital gains of $12,000 and short-term capital losses of $18,000. Additionally, the owner recorded long-term capital gains of $5,000 and long-term capital losses of $9,000. \n\nThe business owner wants to determine the overall net gain or loss, considering the allowable capital loss deductions that can be applied against ordinary income for the current year.",
        "question": "What is the overall net gain or loss the business owner should report for the year, after considering the allowable deductions? Provide the answer to the nearest dollar.",
        "python_solution": "def solution():\n    # Define the financial numbers provided in the problem\n    ordinary_income = 150000\n    ordinary_expenses = 120000\n    short_term_gain = 12000\n    short_term_loss = 18000\n    long_term_gain = 5000\n    long_term_loss = 9000\n\n    # Calculate net ordinary gain or loss\n    net_ordinary_gain = ordinary_income - ordinary_expenses\n\n    # Calculate net short-term capital gain or loss\n    net_short_term_capital = short_term_gain - short_term_loss\n\n    # Calculate net long-term capital gain or loss\n    net_long_term_capital = long_term_gain - long_term_loss\n\n    # Calculate net capital gain or loss\n    net_capital = net_short_term_capital + net_long_term_capital\n\n    # Determine allowable capital deduction (max $3,000 against ordinary income)\n    if net_capital < 0:\n        capital_deduction = max(net_capital, -3000)\n    else:\n        capital_deduction = net_capital\n\n    # Calculate overall net gain or loss\n    net_overall_gain = net_ordinary_gain + capital_deduction\n\n    # Return the result rounded to the nearest dollar\n    return round(net_overall_gain)\n\n# Test the solution function\nprint(solution())",
        "ground_truth": 27000,
        "source": "FinanceReasoning-test-214",
        "question_id": "test-2108",
        "level": "hard",
        "output": [
            "### Step-by-Step Reasoning:\n\n#### 1. Understand the Problem\nThe business owner needs to calculate their overall net gain or loss based on the following:\n1. **Ordinary Income**: $150,000\n2. **Ordinary Expenses**: $120,000\n   - Resulting in **Net Ordinary Gain**.\n3. **Short-Term Capital Gains**: $12,000\n4. **Short-Term Capital Losses**: $18,000  \n   - Resulting in **Net Short-Term Capital**.\n5. **Long-Term Capital Gains**: $5,000\n6. **Long-Term Capital Losses**: $9,000\n   - Resulting in **Net Long-Term Capital**.\n\nThe **Net Capital Gain or Loss** is the sum of net short-term and long-term capital. Negative capital (net loss) can only offset ordinary income by up to **$3,000**.\n\n#### 2. Emphasizing Constraints (EC)\n1. **Ordinary Losses Constraint**: Ordinary losses can fully offset ordinary income.\n   - We compute **Net Ordinary Gain** = Ordinary Income - Ordinary Expenses.\n2. **Capital Deduction Limit**: When the **Net Capital** is a loss (negative), only **$3,000** or the total loss (whichever is smaller) can offset ordinary income. Net capital gains (positive) are fully added to ordinary income.\n3. **Unit Constraint**: The calculation result must be rounded to the nearest dollar.\n\n#### 3. Break Down the Calculation\n1. Calculate **Net Ordinary Gain**:  \n   \\[\n   \\text{Net Ordinary Gain} = \\text{Ordinary Income} - \\text{Ordinary Expenses}\n   \\]\n2. Calculate **Net Short-Term Capital**:  \n   \\[\n   \\text{Net Short-Term Capital} = \\text{Short-Term Capital Gains} - \\text{Short-Term Capital Losses}\n   \\]\n3. Calculate **Net Long-Term Capital**:  \n   \\[\n   \\text{Net Long-Term Capital} = \\text{Long-Term Capital Gains} - \\text{Long-Term Capital Losses}\n   \\]\n4. Combine Short-Term and Long-Term Capital:  \n   \\[\n   \\text{Net Capital} = \\text{Net Short-Term Capital} + \\text{Net Long-Term Capital}\n   \\]\n5. Apply the $3,000 deduction cap if net capital is negative:  \n   \\[\n   \\text{Capital Deduction} = \\begin{cases} \n   \\text{Net Capital} & \\text{if Net Capital} \\geq 0 \\\\ \n   \\max(\\text{Net Capital}, -3000) & \\text{if Net Capital} < 0 \n   \\end{cases}\n   \\]\n6. Calculate **Net Overall Gain**:  \n   \\[\n   \\text{Net Overall Gain} = \\text{Net Ordinary Gain} + \\text{Capital Deduction}\n   \\]\n\n---\n\n### Python Code Implementation:\n```python\ndef solution():\n    # Define variables name and value\n    ordinary_income = 150000\n    ordinary_expenses = 120000\n    short_term_gain = 12000\n    short_term_loss = 18000\n    long_term_gain = 5000\n    long_term_loss = 9000\n\n    # Step 1: Calculate net ordinary gain\n    net_ordinary_gain = ordinary_income - ordinary_expenses\n    \n    # Step 2: Calculate net short-term capital gain/loss\n    net_short_term_capital = short_term_gain - short_term_loss\n    \n    # Step 3: Calculate net long-term capital gain/loss\n    net_long_term_capital = long_term_gain - long_term_loss\n    \n    # Step 4: Calculate net total capital gain/loss\n    net_capital = net_short_term_capital + net_long_term_capital\n    \n    # Step 5: Capital deduction capped at $3,000 for losses\n    if net_capital < 0:\n        capital_deduction = max(net_capital, -3000)\n    else:\n        capital_deduction = net_capital\n    \n    # Step 6: Calculate the net overall gain\n    net_overall_gain = net_ordinary_gain + capital_deduction\n    \n    # Return the answer (rounded to the nearest dollar)\n    return round(net_overall_gain)\n```\n\n---\n\n### Execution\nLet's compute the result step-by-step based on the values:\n1. **Net Ordinary Gain**:  \n   \\[\n   150,000 - 120,000 = 30,000\n   \\]\n2. **Net Short-Term Capital**:  \n   \\[\n   12,000 - 18,000 = -6,000\n   \\]\n3. **Net Long-Term Capital**:  \n   \\[\n   5,000 - 9,000 = -4,000\n   \\]\n4. **Net Capital**:  \n   \\[\n   -6,000 + (-4,000) = -10,000\n   \\]\n5. **Capital Deduction**:  \n   \\[\n   \\max(-10,000, -3,000) = -3,000\n   \\]\n6. **Net Overall Gain**:  \n   \\[\n   30,000 + (-3,000) = 27,000\n   \\]\n\n### Final Answer\nThe overall net gain the business owner should report for the year is **$27,000**."
        ],
        "retrieval_query": "What is the overall net gain or loss the business owner should report for the year, after considering the allowable deductions? Provide the answer to the nearest dollar.",
        "useful_functions": [
            "def calculate_net_gain_or_loss(ordinary_income: float, ordinary_expenses: float, short_term_gain: float, short_term_loss: float, long_term_gain: float, long_term_loss: float) -> dict:\n    \"\"\"\n    Calculate the net gain or loss from ordinary income and capital transactions.\n\n    This function computes the net ordinary gain or loss from business operations\n    as well as the net capital gain or loss from short-term and long-term investments.\n    The net values allow a taxpayer to understand their financial standing and tax liability.\n\n    Args:\n        ordinary_income (float): Total ordinary income earned from business operations.\n        ordinary_expenses (float): Total expenses incurred in business operations.\n        short_term_gain (float): Total short-term capital gains from asset sales.\n        short_term_loss (float): Total short-term capital losses from asset sales.\n        long_term_gain (float): Total long-term capital gains from asset sales.\n        long_term_loss (float): Total long-term capital losses from asset sales.\n\n    Returns:\n        result (dict): A dictionary containing:\n            'net_ordinary_gain' (float): The net ordinary gain or loss.\n            'net_short_term_capital' (float): The net short-term capital gain or loss.\n            'net_long_term_capital' (float): The net long-term capital gain or loss.\n            'net_overall_gain' (float): The overall net gain or loss considering allowable deductions.\n\n    Notes:\n        - Ordinary losses can be fully deducted to offset ordinary income.\n        - Capital losses exceeding capital gains can only offset $3,000 of ordinary income.\n        - Remaining capital losses can be carried over to subsequent years.\n        - This function does not handle carryover processes; it only returns current year\u2019s computations.\n    \"\"\"\n    net_ordinary_gain = ordinary_income - ordinary_expenses\n    net_short_term_capital = short_term_gain - short_term_loss\n    net_long_term_capital = long_term_gain - long_term_loss\n\n    net_capital = net_short_term_capital + net_long_term_capital\n\n    # Apply the $3,000 deduction limit for capital losses against ordinary income\n    if net_capital < 0:\n        capital_deduction = max(net_capital, -3000)\n    else:\n        capital_deduction = net_capital\n\n    net_overall_gain = net_ordinary_gain + capital_deduction\n\n    return {\n        'net_ordinary_gain': net_ordinary_gain,\n        'net_short_term_capital': net_short_term_capital,\n        'net_long_term_capital': net_long_term_capital,\n        'net_overall_gain': net_overall_gain\n    }"
        ],
        "usage": {
            "completion_tokens": 1148,
            "prompt_tokens": 1049,
            "total_tokens": 2197,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "A retirement fund worth $100 million currently consists of 80% shares and 20% bonds. The beta of the shares section is 1.2, with the term of the bonds part being 5.0. How many stock index futures need to be purchased in order to shift the distribution to 60% shares and 40% bonds? Refer to the additional data: The value of the stock index stands at 1,200, the multiplier is $250, and the beta equals 0.95. The cost of a bond futures agreement is $105,300, which carries an underlying adjusted duration of 6.5. Answer to three decimal places.",
        "python_solution": "def solution():\n    current_value = 100000000\n    current_shares_value = 0.8 * current_value\n    target_shares_value = 0.6 * current_value\n    shares_value_to_be_shifted = current_shares_value - target_shares_value\n    beta_shares = 1.2\n    beta_stock_index = 0.95\n    stock_index_value = 1200\n    contract_price = 250\n    number_of_contracts = (0-beta_shares/beta_stock_index)*(shares_value_to_be_shifted/(stock_index_value * contract_price))\n    return number_of_contracts",
        "ground_truth": -84.211,
        "topic": "Asset Classes & Derivatives",
        "statistics": {
            "number_statistics": {
                "args_numbers": 5,
                "question_numbers": 12,
                "context_numbers": 0,
                "total_numbers": 12
            },
            "operator_statistics": {
                "operators": {
                    "+": 0,
                    "-": 2,
                    "*": 4,
                    "/": 2,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 8
            },
            "code_statistics": {
                "lines": 10,
                "parentheses": 6
            }
        },
        "difficulty": 4.6443908991413725,
        "source": "FinanceMath-validation-164",
        "context": "[]",
        "question_id": "test-2109",
        "level": "hard",
        "output": [
            "To solve the problem, we want to determine how many stock index futures contracts need to be purchased to shift the portfolio\u2019s asset allocation from 80% shares and 20% bonds to 60% shares and 40% bonds. Let's carefully break down the solution step by step:\n\n### Step-by-Step Reasoning\n\n1. **Understand Initial Portfolio Composition**:\n   - The current portfolio value is $100 million, with:\n     - 80% allocated to shares \u2192 $80 million.\n     - 20% allocated to bonds \u2192 $20 million.\n\n2. **Determine the Target Allocation**:\n   - We aim to adjust the portfolio so that:\n     - 60% is allocated to shares \u2192 $60 million.\n     - 40% is allocated to bonds \u2192 $40 million.\n\n3. **Determine the Shift in Allocation**:\n   - To achieve this new allocation:\n     - The shares allocation needs to decrease by $20 million ($80 million - $60 million).\n     - The bonds allocation needs to increase by $20 million ($20 million to $40 million).\n\n   This shift in allocation is important to consider when deciding how to hedge or adjust risk exposures.\n\n4. **Account for Changes in Market Sensitivity (Beta)**:\n   - The beta of the shares is 1.2, while the beta of the stock index futures is given as 0.95. We will use these betas to manage the risk exposure using the number of stock index futures contracts.\n\n5. **Calculate the Notional Value of Each Index Futures Contract**:\n   - The stock index value is 1,200, and the multiplier is $250.\n   - Notional value of one stock index future = \\( 1200 \\times 250 = 300,000 \\).\n\n6. **Calculate the Required Adjustment in the Portfolio\u2019s Beta**:\n   - The current portfolio beta is calculated as:\n     \\[\n     \\text{Current Beta Exposure} = (\\text{Shares Beta} \\times \\text{Shares Value}) / \\text{Total Portfolio Value}\n     = (1.2 \\times 80) / 100 = 0.96\n     \\]\n   - The target portfolio beta is:\n     \\[\n     \\text{Target Beta Exposure} = (\\text{Shares Beta} \\times \\text{Target Shares Value}) / \\text{Total Portfolio Value}\n     = (1.2 \\times 60) / 100 = 0.72\n     \\]\n   - The beta adjustment required is:\n     \\[\n     \\Delta \\beta = \\text{Target Beta} - \\text{Current Beta} = 0.72 - 0.96 = -0.24\n     \\]\n\n7. **Determine the Number of Futures Contracts**:\n   - The number of futures contracts to achieve this beta adjustment is calculated using the formula:\n     \\[\n     N = \\frac{\\Delta \\beta \\times \\text{Portfolio Value}}{\\text{Futures Beta} \\times \\text{Notional Value of One Future}}\n     \\]\n   - Substituting the values:\n     \\[\n     N = \\frac{-0.24 \\times 100,000,000}{0.95 \\times 300,000}\n     \\]\n\n8. **Adhere to Precision Constraints**:\n   - As per the problem, the answer should be rounded to three decimal places. This will be done in the final output.\n\n### Python Solution\nNow, let's calculate the answer using Python, adhering to all constraints.\n\n```python\ndef solution():\n    # Define variables\n    total_portfolio_value = 100_000_000  # $100 million\n    shares_beta = 1.2\n    futures_beta = 0.95\n    shares_initial_allocation = 0.8\n    shares_target_allocation = 0.6\n    futures_notional_value = 1200 * 250  # Stock index value * multiplier\n\n    # Calculate current and target beta exposures\n    current_beta = (shares_beta * shares_initial_allocation)\n    target_beta = (shares_beta * shares_target_allocation)\n\n    # Change in beta to achieve target allocation\n    delta_beta = target_beta - current_beta\n\n    # Calculate the number of futures contracts to hedge\n    num_futures = (delta_beta * total_portfolio_value) / (futures_beta * futures_notional_value)\n\n    # Return the answer rounded to three decimal places\n    return round(num_futures, 3)\n```"
        ],
        "retrieval_query": "A retirement fund worth $100 million currently consists of 80% shares and 20% bonds. The beta of the shares section is 1.2, with the term of the bonds part being 5.0. How many stock index futures need to be purchased in order to shift the distribution to 60% shares and 40% bonds? Refer to the additional data: The value of the stock index stands at 1,200, the multiplier is $250, and the beta equals 0.95. The cost of a bond futures agreement is $105,300, which carries an underlying adjusted duration of 6.5. Answer to three decimal places.",
        "useful_functions": [
            "def calculate_beta(stock_returns: list, market_returns: list) -> float:\n    \"\"\"\n    Calculate the beta of a stock, indicating its volatility relative to the market.\n\n    Beta is a measure of a stock's volatility in relation to the overall market.\n    A beta of 1 indicates that the stock's price tends to move with the market.\n    A beta greater than 1 indicates greater volatility than the market, while a beta less\n    than 1 indicates less volatility.\n\n    Args:\n        stock_returns (list): A list of periodic return rates for the stock.\n        market_returns (list): A list of periodic return rates for the market benchmark,\n                               such as the S&P 500. Must be of the same length as stock_returns.\n\n    Returns:\n        beta (float): The beta of the stock relative to the market.\n\n    Notes:\n        - Applicability: Used in assessing the risk and expected return of a stock or portfolio.\n        - Constraints: The input lists must represent returns for the same periods and must have\n          the same length.\n        - Considerations: Beta reflects past volatility and may not predict future volatility.\n          Values could be affected by outliers in the historical data.\n    \"\"\"\n    if len(stock_returns) != len(market_returns):\n        raise ValueError(\"Both input lists must have the same number of elements.\")\n\n    market_variance = sum((r - (sum(market_returns) / len(market_returns))) ** 2 for r in market_returns)\n    covariance = sum((s - (sum(stock_returns) / len(stock_returns))) * \n                     (m - (sum(market_returns) / len(market_returns))) for s, m in zip(stock_returns, market_returns))\n\n    if market_variance == 0:\n        raise ValueError(\"Market variance is zero, cannot calculate beta.\")\n    \n    beta = covariance / market_variance\n    \n    return beta"
        ],
        "usage": {
            "completion_tokens": 926,
            "prompt_tokens": 861,
            "total_tokens": 1787,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-2677",
        "article_title": "Swap",
        "function": "def calculate_swap_gains_or_losses(sofr_changes: list, notional_principal: float, fixed_rate: float, basis_points: float, years: int) -> dict:\n    \"\"\"\n    Calculate the gains or losses from an interest rate swap over a specified period.\n\n    This function calculates the annual and total gains or losses for two parties\n    involved in an interest rate swap. It assumes one party pays a fixed interest rate,\n    while the other pays a variable rate based on the SOFR plus a spread in basis points.\n\n    Args:\n        sofr_changes (list): A list of annual changes in the SOFR, each entry representing\n                             the SOFR's change for one year.\n        notional_principal (float): The notional principal amount over which the swap is executed.\n        fixed_rate (float): The fixed annual interest rate paid by one party (% as a decimal).\n        basis_points (float): The basis points added to the SOFR to calculate the variable rate (% as a decimal).\n        years (int): The number of years the swap agreement lasts.\n\n    Returns:\n        gains_losses (dict): A dictionary containing annual and total gains or losses for both parties.\n                             Format: {'party_A': {'annual': [...], 'total': float},\n                                      'party_B': {'annual': [...], 'total': float}}\n\n    Notes:\n        - Applicability: This function is applicable to interest rate swaps with fixed and variable legs.\n        - Constraints: The length of sofr_changes must match the number of years.\n        - Considerations: Ensure the interest rates are expressed as decimals for calculation.\n    \"\"\"\n    if len(sofr_changes) != years:\n        raise ValueError(\"The length of sofr_changes must match the number of years.\")\n\n    party_A_gains_losses = []\n    party_B_gains_losses = []\n\n    for year in range(years):\n        variable_rate = sofr_changes[year] + basis_points\n        variable_payment = notional_principal * variable_rate\n        fixed_payment = notional_principal * fixed_rate\n\n        party_A_gain_loss = variable_payment - fixed_payment\n        party_B_gain_loss = fixed_payment - variable_payment\n\n        party_A_gains_losses.append(party_A_gain_loss)\n        party_B_gains_losses.append(party_B_gain_loss)\n\n    total_party_A = sum(party_A_gains_losses)\n    total_party_B = sum(party_B_gains_losses)\n\n    return {\n        'party_A': {'annual': party_A_gains_losses, 'total': total_party_A},\n        'party_B': {'annual': party_B_gains_losses, 'total': total_party_B}\n    }",
        "statistics": {
            "number_statistics": {
                "args_numbers": 5,
                "question_numbers": 0,
                "context_numbers": 16,
                "total_numbers": 16
            },
            "operator_statistics": {
                "operators": {
                    "+": 1,
                    "-": 2,
                    "*": 2,
                    "/": 0,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 5
            },
            "code_statistics": {
                "lines": 16,
                "parentheses": 10
            }
        },
        "difficulty": 4.653960350157523,
        "context": "A financial institution enters into an interest rate swap agreement with a corporate client. The agreement specifies that the corporate client will pay a fixed interest rate of 2.5% per annum, while the financial institution will pay a variable rate, which is the SOFR plus a spread of 0.35% per annum, commonly expressed as 35 basis points. The swap is based on a notional principal amount of 1,000,000 USD and has a duration of 5 years. Over these 5 years, the annual changes in the SOFR are recorded as follows: Year 1: 1.4%, Year 2: 1.6%, Year 3: 1.8%, Year 4: 2.0%, Year 5: 2.2%.\n\nBoth parties want to calculate their total gains or losses over the entire period of the swap agreement.",
        "question": "What is the total gain or loss for the corporate client over the duration of the swap agreement? Answer in USD, rounded to the nearest integer.",
        "python_solution": "def solution():\n    # Define the known values from the problem context\n    notional_principal = 1000000  # USD\n    fixed_rate = 0.025  # 2.5% expressed as a decimal\n    basis_points = 0.0035  # 35 basis points expressed as a decimal\n    sofr_changes = [0.014, 0.016, 0.018, 0.020, 0.022]  # SOFR changes for each year\n    years = 5  # Total number of years in the swap agreement\n\n    # Initialize lists to store annual gains or losses\n    party_A_gains_losses = []\n    party_B_gains_losses = []\n\n    # Calculate the annual gains or losses\n    for year in range(years):\n        # Calculate variable rate as SOFR change plus basis points\n        variable_rate = sofr_changes[year] + basis_points\n        # Calculate payments for variable and fixed rates\n        variable_payment = notional_principal * variable_rate\n        fixed_payment = notional_principal * fixed_rate\n\n        # Calculate annual gain or loss for corporate client (party A)\n        party_A_gain_loss = variable_payment - fixed_payment\n        party_A_gains_losses.append(party_A_gain_loss)\n\n    # Calculate total gain or loss for corporate client\n    total_party_A = sum(party_A_gains_losses)\n\n    # Return the total gain or loss rounded to the nearest integer\n    return int(round(total_party_A))",
        "ground_truth": -17500,
        "source": "FinanceReasoning-test-94",
        "question_id": "test-2110",
        "level": "hard",
        "output": [
            "### Step-by-Step Reasoning\n\n#### Using **Emphasizing Constraints (EC)**:\n1. **Adherence to Constraints**:\n   - **Input constraints**:\n     - The `sofr_changes` list must have exactly 5 elements, corresponding to the 5 years of the agreement.\n     - The rates (fixed interest rate, SOFR, and spread) must be expressed as percentages in decimal format.\n     - The result must be provided in USD and rounded to the nearest integer.\n   - **Output constraint**:\n     - The total gain or loss for the corporate client (Party B) must be calculated as the difference between payments due from the client and payments the institution owes to the client for all 5 years.\n\n2. **Mathematical Logic**:\n   - Calculate the fixed payment the client owes:  \n     \\[\n     \\text{Fixed Payment}_i = \\text{Notional Principal} \\times \\text{Fixed Rate} \\, (2.5\\%)\n     \\]\n   - Calculate the variable payment the financial institution owes:  \n     \\[\n     \\text{Variable Payment}_i = \\text{Notional Principal} \\times (\\text{SOFR}_i + \\text{Spread}) \\, (35\\,\\text{basis points})\n     \\]\n   - Determine the corporate client\u2019s annual gain or loss by:  \n     \\[\n     \\text{Gain or Loss}_i = \\text{Fixed Payment}_i - \\text{Variable Payment}_i\n     \\]\n   - Sum these annual gains or losses over 5 years to get the total.\n\n3. **Expected Boundaries**:\n   - The SOFR levels provided (in percentages) are realistic and ensure no invalid inputs.\n   - The total should be calculated to the nearest integer as stated in the problem.\n\n4. **Planning the Python Program**:\n   - Use the provided `calculate_swap_gains_or_losses` function to simplify implementation and ensure full adherence to constraints.\n   - Extract the relevant result for the corporate client (Party B).\n\nNow, we will compute the total gain or loss for the corporate client over the 5-year period.\n\n#### Python Program\n```python\ndef solution():\n    # Define variables name and value\n    sofr_changes = [0.014, 0.016, 0.018, 0.020, 0.022]  # SOFRs for 5 years expressed in decimal\n    notional_principal = 1_000_000  # in USD\n    fixed_rate = 0.025  # Fixed rate (2.5%) in decimal\n    basis_points = 0.0035  # Spread (35 basis points) in decimal\n    years = 5  # Duration of the swap agreement\n    \n    # Reuse the provided financial function to calculate swap gains/losses\n    def calculate_swap_gains_or_losses(sofr_changes: list, notional_principal: float, fixed_rate: float, basis_points: float, years: int) -> dict:\n        if len(sofr_changes) != years:\n            raise ValueError(\"The length of sofr_changes must match the number of years.\")\n\n        party_A_gains_losses = []\n        party_B_gains_losses = []\n\n        for year in range(years):\n            variable_rate = sofr_changes[year] + basis_points\n            variable_payment = notional_principal * variable_rate\n            fixed_payment = notional_principal * fixed_rate\n\n            party_A_gain_loss = variable_payment - fixed_payment\n            party_B_gain_loss = fixed_payment - variable_payment\n\n            party_A_gains_losses.append(party_A_gain_loss)\n            party_B_gains_losses.append(party_B_gain_loss)\n\n        total_party_A = sum(party_A_gains_losses)\n        total_party_B = sum(party_B_gains_losses)\n\n        return {\n            'party_A': {'annual': party_A_gains_losses, 'total': total_party_A},\n            'party_B': {'annual': party_B_gains_losses, 'total': total_party_B}\n        }\n\n    # Calculate gains and losses using the predefined function\n    results = calculate_swap_gains_or_losses(sofr_changes, notional_principal, fixed_rate, basis_points, years)\n    \n    # Extract the total gain or loss for the corporate client (party_B)\n    total_gain_or_loss_for_corporate_client = results['party_B']['total']\n    \n    # Round to the nearest integer and return the result\n    return round(total_gain_or_loss_for_corporate_client)\n```"
        ],
        "retrieval_query": "What is the total gain or loss for the corporate client over the duration of the swap agreement? Answer in USD, rounded to the nearest integer.",
        "useful_functions": [
            "def calculate_swap_gains_or_losses(sofr_changes: list, notional_principal: float, fixed_rate: float, basis_points: float, years: int) -> dict:\n    \"\"\"\n    Calculate the gains or losses from an interest rate swap over a specified period.\n\n    This function calculates the annual and total gains or losses for two parties\n    involved in an interest rate swap. It assumes one party pays a fixed interest rate,\n    while the other pays a variable rate based on the SOFR plus a spread in basis points.\n\n    Args:\n        sofr_changes (list): A list of annual changes in the SOFR, each entry representing\n                             the SOFR's change for one year.\n        notional_principal (float): The notional principal amount over which the swap is executed.\n        fixed_rate (float): The fixed annual interest rate paid by one party (% as a decimal).\n        basis_points (float): The basis points added to the SOFR to calculate the variable rate (% as a decimal).\n        years (int): The number of years the swap agreement lasts.\n\n    Returns:\n        gains_losses (dict): A dictionary containing annual and total gains or losses for both parties.\n                             Format: {'party_A': {'annual': [...], 'total': float},\n                                      'party_B': {'annual': [...], 'total': float}}\n\n    Notes:\n        - Applicability: This function is applicable to interest rate swaps with fixed and variable legs.\n        - Constraints: The length of sofr_changes must match the number of years.\n        - Considerations: Ensure the interest rates are expressed as decimals for calculation.\n    \"\"\"\n    if len(sofr_changes) != years:\n        raise ValueError(\"The length of sofr_changes must match the number of years.\")\n\n    party_A_gains_losses = []\n    party_B_gains_losses = []\n\n    for year in range(years):\n        variable_rate = sofr_changes[year] + basis_points\n        variable_payment = notional_principal * variable_rate\n        fixed_payment = notional_principal * fixed_rate\n\n        party_A_gain_loss = variable_payment - fixed_payment\n        party_B_gain_loss = fixed_payment - variable_payment\n\n        party_A_gains_losses.append(party_A_gain_loss)\n        party_B_gains_losses.append(party_B_gain_loss)\n\n    total_party_A = sum(party_A_gains_losses)\n    total_party_B = sum(party_B_gains_losses)\n\n    return {\n        'party_A': {'annual': party_A_gains_losses, 'total': total_party_A},\n        'party_B': {'annual': party_B_gains_losses, 'total': total_party_B}\n    }"
        ],
        "usage": {
            "completion_tokens": 939,
            "prompt_tokens": 1087,
            "total_tokens": 2026,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-1842",
        "article_title": "Tax Rate",
        "function": "def calculate_marginal_tax(income: float, brackets: list) -> float:\n    \"\"\"\n    Calculate the tax owed for an individual based on their income and a set of income tax brackets.\n\n    This function computes the total income tax owed using a progressive tax system with specified\n    income brackets and corresponding tax rates.\n\n    Args:\n        income (float): The individual's taxable income.\n        brackets (list): A list of tuples, where each tuple contains two elements:\n                         (income_threshold, tax_rate), with income_threshold being the upper limit\n                         for that bracket and tax_rate being the tax percentage for that bracket.\n\n    Returns:\n        total_tax (float): The total tax owed based on the provided income and tax brackets.\n\n    Notes:\n        - The brackets must be sorted in increasing order of income thresholds.\n        - It is assumed that the lowest bracket starts at an income of 0.\n        - The function does not handle deductions or tax credits; it only applies the tax rates\n          directly to income.\n    \"\"\"\n    total_tax = 0.0\n    previous_threshold = 0.0\n\n    for threshold, rate in brackets:\n        if income > threshold:\n            total_tax += (threshold - previous_threshold) * rate\n            previous_threshold = threshold\n        else:\n            total_tax += (income - previous_threshold) * rate\n            break\n\n    return total_tax\n\ndef calculate_effective_tax_rate(income: float, total_tax: float) -> float:\n    \"\"\"\n    Calculate the effective tax rate based on total income and tax owed.\n\n    The effective tax rate is the average rate at which income is taxed, taking into account\n    all progressive tax brackets.\n\n    Args:\n        income (float): The individual's total taxable income.\n        total_tax (float): The total tax owed by the individual.\n\n    Returns:\n        effective_tax_rate (float): The effective tax rate as a decimal.\n\n    Notes:\n        - The income must be greater than zero to avoid division by zero.\n        - This function does not consider any other sources of income or deductions.\n    \"\"\"\n    if income <= 0:\n        raise ValueError(\"Income must be greater than zero.\")\n\n    effective_tax_rate = total_tax / income\n    return effective_tax_rate",
        "statistics": {
            "number_statistics": {
                "args_numbers": 3,
                "question_numbers": 0,
                "context_numbers": 15,
                "total_numbers": 15
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 3,
                    "*": 2,
                    "/": 0,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 7
            },
            "code_statistics": {
                "lines": 12,
                "parentheses": 6
            }
        },
        "difficulty": 4.653960350157523,
        "context": "Alex earns a salary of $120,000 per year. The government implements a progressive tax system with the following tax brackets:\n\n1. 0% tax rate for income up to $10,000\n2. 10% tax rate for income from $10,001 to $40,000\n3. 20% tax rate for income from $40,001 to $90,000\n4. 30% tax rate for income above $90,001\n\nAlex wants to know the effective tax rate that they pay on their income.",
        "question": "What is Alex's effective tax rate as a percentage? Answer to two decimal places.",
        "python_solution": "def solution():\n    # Define Alex's income and tax brackets\n    income = 120000\n    # Brackets are defined as tuples of (upper_limit, tax_rate)\n    brackets = [\n        (10000, 0.0),       # 0% for income up to $10,000\n        (40000, 0.10),      # 10% for income from $10,001 to $40,000\n        (90000, 0.20),      # 20% for income from $40,001 to $90,000\n        (float('inf'), 0.30) # 30% for income over $90,001\n    ]\n\n    # Calculate total tax using the progressive tax system\n    total_tax = 0.0\n    previous_threshold = 0.0\n\n    for threshold, rate in brackets:\n        if income > threshold:\n            total_tax += (threshold - previous_threshold) * rate\n            previous_threshold = threshold\n        else:\n            total_tax += (income - previous_threshold) * rate\n            break\n\n    # Calculate effective tax rate\n    effective_tax_rate = total_tax / income\n\n    # Convert effective tax rate to a percentage and round to two decimal places\n    effective_tax_rate_percentage = effective_tax_rate * 100\n    return round(effective_tax_rate_percentage, 2)\n\n# Solve the problem\nsolution_result = solution()\nsolution_result",
        "ground_truth": 18.33,
        "source": "FinanceReasoning-test-170",
        "question_id": "test-2111",
        "level": "hard",
        "output": [
            "### Step-by-step solution using Emphasizing Constraints (EC):\n\n1. **Understand the problem and the tax system**:\n   - Alex's yearly income is $120,000.\n   - The progressive tax structure is broken into four brackets:\n     1. 0% tax rate for income up to $10,000.\n     2. 10% tax rate for income between $10,001 and $40,000.\n     3. 20% tax rate for income between $40,001 and $90,000.\n     4. 30% tax rate for income above $90,001.\n   - We must calculate the total tax Alex pays and divide it by their total income to find their effective tax rate.\n\n2. **Consider constraints**:\n   - Effective tax rate must be expressed as a percentage.\n   - The answer must be rounded to two decimal places.\n\n3. **Breakdown the income into brackets**:\n   - Calculate how much of Alex\u2019s income falls into each bracket:\n     - First bracket: $10,000 at 0% tax rate \u2192 $0 tax.\n     - Second bracket: ($40,000 - $10,000) = $30,000 at 10% tax rate \u2192 $3,000 tax.\n     - Third bracket: ($90,000 - $40,000) = $50,000 at 20% tax rate \u2192 $10,000 tax.\n     - Fourth bracket: ($120,000 - $90,000) = $30,000 at 30% tax rate \u2192 $9,000 tax.\n   - Sum the total taxes: $0 + $3,000 + $10,000 + $9,000 = $22,000.\n\n4. **Calculate the effective tax rate**:\n   - The effective tax rate is given by:\n     \\[\n     \\text{Effective Tax Rate (\\%)} = \\left(\\frac{\\text{Total Tax Paid}}{\\text{Total Income}}\\right) \\times 100\n     \\]\n   - Substituting the values:\n     - Total income = $120,000\n     - Total tax paid = $22,000\n     - Effective tax rate = \\(\\left(\\frac{22,000}{120,000}\\right) \\times 100 = 18.33\\%\\).\n\nNow, let us convert this reasoning into a Python program:\n\n```python\ndef solution():\n    # Define variables name and values\n    income = 120000\n    tax_brackets = [\n        (0, 10000, 0.00),     # Bracket 1: 0% tax\n        (10001, 40000, 0.10), # Bracket 2: 10% tax\n        (40001, 90000, 0.20), # Bracket 3: 20% tax\n        (90001, float('inf'), 0.30) # Bracket 4: 30% tax\n    ]\n    \n    # Initialize total tax\n    total_tax = 0\n    \n    # Compute tax based on tax brackets\n    for lower, upper, rate in tax_brackets:\n        if income > lower:\n            taxable_income = min(income, upper) - lower\n            total_tax += taxable_income * rate\n    \n    # Effective tax rate calculation\n    effective_tax_rate = (total_tax / income) * 100\n    return round(effective_tax_rate, 2)\n```"
        ],
        "retrieval_query": "What is Alex's effective tax rate as a percentage? Answer to two decimal places.",
        "useful_functions": [],
        "usage": {
            "completion_tokens": 720,
            "prompt_tokens": 454,
            "total_tokens": 1174,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-706",
        "article_title": "Bear Put Spread",
        "function": "def calculate_bear_put_spread_profit(higher_strike_price: float, lower_strike_price: float, \n                                     cost_of_higher_strike: float, revenue_from_lower_strike: float, \n                                     underlying_at_expiration: float, shares_per_contract: int = 100) -> float:\n    \"\"\"\n    Calculate the profit or loss of a bear put spread strategy at expiration.\n\n    This function computes the potential profit or loss of a bearish investor's options strategy, \n    known as a bear put spread, based on the underlying asset's price at expiration.\n\n    Args:\n        higher_strike_price (float): The higher strike price of the purchased put option.\n        lower_strike_price (float): The lower strike price of the sold put option.\n        cost_of_higher_strike (float): The cost of purchasing the put option with the higher strike price.\n        revenue_from_lower_strike (float): The revenue from selling the put option with the lower strike price.\n        underlying_at_expiration (float): The price of the underlying asset at expiration.\n        shares_per_contract (int, optional): The number of shares per options contract. Default is 100.\n\n    Returns:\n        profit_or_loss (float): The profit or loss of the bear put spread trade.\n\n    Notes:\n        - Applicability: Suitable for evaluating the bear put spread strategy at expiration.\n        - Constraints: Assumes the options have the same expiration date and pertain to the same underlying asset.\n        - Considerations: Does not account for broker fees or taxes, and assumes no early assignment of options.\n    \"\"\"\n    net_cost_of_spread = (cost_of_higher_strike - revenue_from_lower_strike) * shares_per_contract\n    max_profit = (higher_strike_price - lower_strike_price) * shares_per_contract - net_cost_of_spread\n\n    if underlying_at_expiration <= lower_strike_price:\n        return max_profit\n    elif lower_strike_price < underlying_at_expiration < higher_strike_price:\n        intrinsic_value = (higher_strike_price - underlying_at_expiration) * shares_per_contract\n        return intrinsic_value - net_cost_of_spread\n    else:\n        return -net_cost_of_spread",
        "statistics": {
            "number_statistics": {
                "args_numbers": 6,
                "question_numbers": 0,
                "context_numbers": 7,
                "total_numbers": 7
            },
            "operator_statistics": {
                "operators": {
                    "+": 0,
                    "-": 6,
                    "*": 3,
                    "/": 0,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 9
            },
            "code_statistics": {
                "lines": 9,
                "parentheses": 6
            }
        },
        "difficulty": 4.68213122712422,
        "context": "An investor is interested in executing a bear put spread strategy on a stock currently priced at $150 per share. The investor purchases a put option with a strike price of $155 at a cost of $5 per share and simultaneously sells a put option with a strike price of $145, receiving a premium of $2 per share. Both options have the same expiration date, and each contract involves 100 shares. At expiration, the stock price has fallen to $140 per share.",
        "question": "What is the profit or loss of the bear put spread strategy at expiration? Answer to the nearest dollar.",
        "python_solution": "def solution():\n    # Define given values\n    higher_strike_price = 155  # Higher strike price of purchased put\n    lower_strike_price = 145   # Lower strike price of sold put\n    cost_of_higher_strike = 5  # Cost of buying the higher strike put\n    revenue_from_lower_strike = 2  # Revenue from selling the lower strike put\n    underlying_at_expiration = 140  # Stock price at expiration\n    shares_per_contract = 100  # Number of shares per contract\n\n    # Calculate net cost of spread\n    net_cost_of_spread = (cost_of_higher_strike - revenue_from_lower_strike) * shares_per_contract\n\n    # Calculate maximum profit\n    max_profit = (higher_strike_price - lower_strike_price) * shares_per_contract - net_cost_of_spread\n\n    # Determine the profit or loss based on the expiration price\n    if underlying_at_expiration <= lower_strike_price:\n        profit_or_loss = max_profit\n    elif lower_strike_price < underlying_at_expiration < higher_strike_price:\n        intrinsic_value = (higher_strike_price - underlying_at_expiration) * shares_per_contract\n        profit_or_loss = intrinsic_value - net_cost_of_spread\n    else:\n        profit_or_loss = -net_cost_of_spread\n\n    # Return the calculated profit or loss rounded to the nearest dollar\n    return round(profit_or_loss)",
        "ground_truth": 700,
        "source": "FinanceReasoning-test-108",
        "question_id": "test-2112",
        "level": "hard",
        "output": [
            "To solve the problem step by step using the \"Emphasizing Constraints (EC)\" reasoning technique:\n\n### Step 1: Understand the constraints\n1. **Bear Put Spread Strategy**:\n   - The investor purchases a put option at a higher strike price.\n   - The investor sells a put option at a lower strike price.\n   - The maximum profit is achieved when the stock price falls below the lower strike price at expiration.\n   - The maximum loss is limited to the net cost of the spread (the difference in premiums paid and received).\n   \n2. **Given values**:\n   - Strike price of purchased put (higher strike price): $155\n   - Premium (cost) for higher strike price: $5/share\n   - Strike price of sold put (lower strike price): $145\n   - Premium (revenue) for lower strike price: $2/share\n   - Stock price at expiration: $140\n   - Each option contract involves 100 shares.\n\n3. **Outcome Scenarios**:\n   - If the stock price falls below the lower strike price at $145, both options will be exercised for their intrinsic values.\n   - If the stock price is between the higher and lower strike prices, only the higher strike put will have intrinsic value.\n   - If the stock price is above the higher strike price, both options expire worthless.\n\n4. **Constraints to adhere to**:\n   - Consider only expiration outcomes (no early assignments or adjustments).\n   - Units must be in dollars, and the solution must be rounded to the nearest dollar.\n   - Calculate the profit/loss of the strategy accurately using the formula for a bear put spread.\n\n### Step 2: Required Output\n- Calculate the profit or loss at expiration for the given scenario where the stock price is $140.\n\n### Step 3: Plan\n- Use the `calculate_bear_put_spread_profit` function to compute the profit/loss at expiration with the given values.\n\nHere is the Python program to solve the problem:\n\n```python\ndef solution():\n    # Define variables name and value\n    higher_strike_price = 155  # Higher strike price of purchased put\n    lower_strike_price = 145   # Lower strike price of sold put\n    cost_of_higher_strike = 5  # Premium paid for higher strike price\n    revenue_from_lower_strike = 2  # Premium received for lower strike price\n    underlying_at_expiration = 140  # Stock price at expiration\n    shares_per_contract = 100  # Number of shares per contract\n    \n    # Calculate net cost of the spread\n    net_cost_of_spread = (cost_of_higher_strike - revenue_from_lower_strike) * shares_per_contract  # Net cost in dollars\n    \n    # Calculate maximum profit of the spread\n    max_profit = (higher_strike_price - lower_strike_price) * shares_per_contract - net_cost_of_spread  # Maximum profit in dollars\n    \n    # Determine the profit/loss based on the stock price at expiration\n    if underlying_at_expiration <= lower_strike_price:\n        # Maximum profit if stock price is below or equal to lower strike price\n        return round(max_profit)\n    elif lower_strike_price < underlying_at_expiration < higher_strike_price:\n        # Partial profit if stock price is between the lower and higher strike prices\n        intrinsic_value = (higher_strike_price - underlying_at_expiration) * shares_per_contract\n        profit_or_loss = intrinsic_value - net_cost_of_spread\n        return round(profit_or_loss)\n    else:\n        # Maximum loss if stock price is above the higher strike price (both options expire worthless)\n        return round(-net_cost_of_spread)\n\n# Solution function will return the profit or loss\nsolution()\n```"
        ],
        "retrieval_query": "What is the profit or loss of the bear put spread strategy at expiration? Answer to the nearest dollar.",
        "useful_functions": [
            "def calculate_bear_put_spread_profit(higher_strike_price: float, lower_strike_price: float, \n                                     cost_of_higher_strike: float, revenue_from_lower_strike: float, \n                                     underlying_at_expiration: float, shares_per_contract: int = 100) -> float:\n    \"\"\"\n    Calculate the profit or loss of a bear put spread strategy at expiration.\n\n    This function computes the potential profit or loss of a bearish investor's options strategy, \n    known as a bear put spread, based on the underlying asset's price at expiration.\n\n    Args:\n        higher_strike_price (float): The higher strike price of the purchased put option.\n        lower_strike_price (float): The lower strike price of the sold put option.\n        cost_of_higher_strike (float): The cost of purchasing the put option with the higher strike price.\n        revenue_from_lower_strike (float): The revenue from selling the put option with the lower strike price.\n        underlying_at_expiration (float): The price of the underlying asset at expiration.\n        shares_per_contract (int, optional): The number of shares per options contract. Default is 100.\n\n    Returns:\n        profit_or_loss (float): The profit or loss of the bear put spread trade.\n\n    Notes:\n        - Applicability: Suitable for evaluating the bear put spread strategy at expiration.\n        - Constraints: Assumes the options have the same expiration date and pertain to the same underlying asset.\n        - Considerations: Does not account for broker fees or taxes, and assumes no early assignment of options.\n    \"\"\"\n    net_cost_of_spread = (cost_of_higher_strike - revenue_from_lower_strike) * shares_per_contract\n    max_profit = (higher_strike_price - lower_strike_price) * shares_per_contract - net_cost_of_spread\n\n    if underlying_at_expiration <= lower_strike_price:\n        return max_profit\n    elif lower_strike_price < underlying_at_expiration < higher_strike_price:\n        intrinsic_value = (higher_strike_price - underlying_at_expiration) * shares_per_contract\n        return intrinsic_value - net_cost_of_spread\n    else:\n        return -net_cost_of_spread"
        ],
        "usage": {
            "completion_tokens": 774,
            "prompt_tokens": 906,
            "total_tokens": 1680,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-810",
        "article_title": "Make Whole Call Provision",
        "function": "def calculate_make_whole_call_price(remaining_payments: list, principal: float, treasury_yield: float, spread: float) -> float:\n    \"\"\"\n    Calculate the make-whole call price for a bond.\n\n    This function computes the make-whole call price, which is the present value of\n    the remaining scheduled payments (both interest and principal) of a bond, discounted\n    at a rate derived from the Treasury yield and a specified spread. It is used to determine\n    the payout an issuer must make to call a bond early with a make-whole provision.\n\n    Args:\n        remaining_payments (list): A list of remaining coupon payments.\n        principal (float): The principal amount of the bond to be paid at maturity.\n        treasury_yield (float): The yield of a comparable Treasury security used as a basis\n                                for discounting future cash flows (expressed as a decimal).\n        spread (float): The additional spread over the Treasury yield used for discounting\n                        (expressed as a decimal).\n\n    Returns:\n        make_whole_price (float): The present value of the bond's remaining cash flows including\n                                  the principal, representing the make-whole call price.\n\n    Notes:\n        - Applicability: This function is applicable in the context of make-whole call provisions\n          for bonds when calculating the early redemption price.\n        - Constraints: Ensure all interest rates are provided as decimals (e.g., 2% should be 0.02).\n        - Considerations: Consider the possibility of changes in interest rates affecting the discount rate.\n                          This function assumes cash flows occur at the end of each period.\n    \"\"\"\n    discount_rate = treasury_yield + spread\n    make_whole_price = sum(cf / ((1 + discount_rate) ** (i + 1)) for i, cf in enumerate(remaining_payments))\n    make_whole_price += principal / ((1 + discount_rate) ** len(remaining_payments))\n\n    return make_whole_price",
        "statistics": {
            "number_statistics": {
                "args_numbers": 4,
                "question_numbers": 0,
                "context_numbers": 4,
                "total_numbers": 4
            },
            "operator_statistics": {
                "operators": {
                    "+": 5,
                    "-": 0,
                    "*": 0,
                    "/": 2,
                    "%": 0,
                    "**": 2
                },
                "total_operators": 9
            },
            "code_statistics": {
                "lines": 4,
                "parentheses": 16
            }
        },
        "difficulty": 4.68213122712422,
        "context": "A corporation is considering calling one of its outstanding bonds before maturity using a make-whole call provision. The bond has three remaining annual coupon payments of 5,000 each, and a principal amount of 100,000 to be paid at maturity. The applicable Treasury yield for a comparable bond is 2.5%, and the corporation's required spread over this Treasury yield is 1.2%.",
        "question": "Calculate the make-whole call price for the bond. Answer to the nearest whole number.",
        "python_solution": "def solution():\n    # Define the parameters of the bond\n    remaining_payments = [5000, 5000, 5000]  # Remaining annual coupon payments\n    principal = 100000  # Principal amount to be paid at maturity\n    treasury_yield = 0.025  # Treasury yield as a decimal (2.5%)\n    spread = 0.012  # Required spread as a decimal (1.2%)\n\n    # Calculate the discount rate\n    discount_rate = treasury_yield + spread\n\n    # Calculate the present value of the remaining coupon payments\n    make_whole_price = sum(cf / ((1 + discount_rate) ** (i + 1)) for i, cf in enumerate(remaining_payments))\n\n    # Add the present value of the principal amount\n    make_whole_price += principal / ((1 + discount_rate) ** len(remaining_payments))\n\n    # Return the calculated make-whole call price, rounded to the nearest whole number\n    return round(make_whole_price)",
        "ground_truth": 103628,
        "source": "FinanceReasoning-test-121",
        "question_id": "test-2113",
        "level": "hard",
        "output": [
            "To solve this problem, let's break it down systematically:\n\n### Step-by-Step Solution Using the Emphasizing Constraints (EC) Technique:\n\n1. **Understand the objective**:\n   - We aim to calculate the make-whole call price for a bond. This is computed using the present value of all remaining payments (coupon payments and principal) discounted at the required rate (sum of the Treasury yield and the spread).\n\n2. **Constraints**:\n   - The Treasury yield is 2.5% (expressed as 0.025 in decimal form).\n   - The spread is 1.2% (expressed as 0.012 in decimal form).\n   - The discount rate is the sum of the Treasury yield and the spread.\n   - The calculation must include:\n     - Three remaining coupon payments of $5,000.\n     - The principal amount of $100,000 to be paid in the third period.\n   - The answer must be rounded to the nearest whole number.\n\n3. **Derive the discount rate**:\n   - Discount rate = Treasury yield + Spread = 0.025 + 0.012 = 0.037 (3.7%).\n\n4. **Timeline and cash flows**:\n   - Cash flows over the next three years:\n     - Year 1: $5,000 (coupon payment).\n     - Year 2: $5,000 (coupon payment).\n     - Year 3: $5,000 (coupon payment) + $100,000 (principal), which totals $105,000.\n   - These cash flows need to be discounted to their present value.\n\n5. **Present Value Formula**:\n   - Present Value = Cash Flow / (1 + Discount Rate)^(Time Period).\n   - Present value contributions from each of the three periods are summed.\n\n6. **Implementation details**:\n   - Use the `calculate_make_whole_call_price` function provided to compute the price based on input arguments:\n     - Cash flows = [$5,000, $5,000, $105,000].\n     - Treasury yield = 0.025.\n     - Spread = 0.012.\n\nNow, we can write the Python solution:\n\n```python\ndef solution():\n    # Define variables and values\n    remaining_payments = [5000, 5000, 5000 + 100000]  # List of cash flows for 3 years\n    principal = 100000  # Principal amount (already included in Year 3 payment)\n    treasury_yield = 0.025  # Comparable Treasury yield (as a decimal)\n    spread = 0.012  # Required spread over Treasury yield (as a decimal)\n    \n    # Function to calculate the make-whole call price\n    def calculate_make_whole_call_price(remaining_payments, principal, treasury_yield, spread):\n        discount_rate = treasury_yield + spread\n        make_whole_price = sum(cf / ((1 + discount_rate) ** (i + 1)) for i, cf in enumerate(remaining_payments))\n        return make_whole_price\n\n    # Calculate the make-whole price\n    make_whole_price = calculate_make_whole_call_price(remaining_payments, principal, treasury_yield, spread)\n    \n    # Round the result to the nearest whole number\n    return round(make_whole_price)\n```"
        ],
        "retrieval_query": "Calculate the make-whole call price for the bond. Answer to the nearest whole number.",
        "useful_functions": [
            "def calculate_make_whole_call_price(remaining_payments: list, principal: float, treasury_yield: float, spread: float) -> float:\n    \"\"\"\n    Calculate the make-whole call price for a bond.\n\n    This function computes the make-whole call price, which is the present value of\n    the remaining scheduled payments (both interest and principal) of a bond, discounted\n    at a rate derived from the Treasury yield and a specified spread. It is used to determine\n    the payout an issuer must make to call a bond early with a make-whole provision.\n\n    Args:\n        remaining_payments (list): A list of remaining coupon payments.\n        principal (float): The principal amount of the bond to be paid at maturity.\n        treasury_yield (float): The yield of a comparable Treasury security used as a basis\n                                for discounting future cash flows (expressed as a decimal).\n        spread (float): The additional spread over the Treasury yield used for discounting\n                        (expressed as a decimal).\n\n    Returns:\n        make_whole_price (float): The present value of the bond's remaining cash flows including\n                                  the principal, representing the make-whole call price.\n\n    Notes:\n        - Applicability: This function is applicable in the context of make-whole call provisions\n          for bonds when calculating the early redemption price.\n        - Constraints: Ensure all interest rates are provided as decimals (e.g., 2% should be 0.02).\n        - Considerations: Consider the possibility of changes in interest rates affecting the discount rate.\n                          This function assumes cash flows occur at the end of each period.\n    \"\"\"\n    discount_rate = treasury_yield + spread\n    make_whole_price = sum(cf / ((1 + discount_rate) ** (i + 1)) for i, cf in enumerate(remaining_payments))\n    make_whole_price += principal / ((1 + discount_rate) ** len(remaining_payments))\n\n    return make_whole_price"
        ],
        "usage": {
            "completion_tokens": 689,
            "prompt_tokens": 842,
            "total_tokens": 1531,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-2333",
        "article_title": "Annuity",
        "function": "def calculate_annuity_payment(principal: float, interest_rate: float, periods: int, annuity_due: bool = False) -> float:\n    \"\"\"\n    Calculate the annuity payment for a fixed annuity.\n\n    This function computes the fixed periodic payment for an annuity based on the principal,\n    interest rate, and number of periods. The calculation can also account for payments made\n    at the beginning of each period (annuity due) or at the end of each period (ordinary annuity).\n\n    Args:\n        principal (float): The initial lump sum amount invested in the annuity.\n        interest_rate (float): The interest rate per period as a decimal (e.g., 0.05 for 5%).\n        periods (int): The number of payment periods (e.g., months or years).\n        annuity_due (bool, optional): If True, calculates payment for an annuity due (default is False).\n\n    Returns:\n        payment (float): The periodic payment amount.\n\n    Notes:\n        - Applicable for fixed annuities where payments are constant across periods.\n        - The interest rate should be provided per period (e.g., annual rate if periods are in years).\n        - The function assumes the annuity is a fixed annuity with equal payments.\n        - This function does not account for taxes or inflation.\n    \"\"\"\n    if interest_rate == 0:\n        payment = principal / periods\n    else:\n        factor = (1 + interest_rate) ** periods\n        payment = principal * (interest_rate * factor) / (factor - 1)\n        if annuity_due:\n            payment /= (1 + interest_rate)\n\n    return payment",
        "statistics": {
            "number_statistics": {
                "args_numbers": 4,
                "question_numbers": 0,
                "context_numbers": 3,
                "total_numbers": 3
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 1,
                    "*": 2,
                    "/": 3,
                    "%": 0,
                    "**": 1
                },
                "total_operators": 9
            },
            "code_statistics": {
                "lines": 8,
                "parentheses": 8
            }
        },
        "difficulty": 4.68213122712422,
        "context": "Jane has won a lottery, and she decides to invest her winnings in a fixed annuity to secure her future financial stability. She intends to purchase an ordinary annuity that will pay her annually at the end of each year for 20 years. Jane has a total of $500,000 to invest, and the annuity offers an annual interest rate of 4%. She wants to know the amount she will receive each year from this investment.",
        "question": "What is the annual payment Jane will receive from her annuity investment? Answer to the nearest dollar.",
        "python_solution": "def solution():\n    # Define variables based on the problem statement\n    principal = 500000  # The amount Jane invests\n    interest_rate = 0.04  # Annual interest rate as a decimal\n    periods = 20  # The annuity lasts for 20 years\n    annuity_due = False  # Payments are made at the end of each period (ordinary annuity)\n\n    # Perform the annuity payment calculation\n    if interest_rate == 0:\n        payment = principal / periods\n    else:\n        factor = (1 + interest_rate) ** periods\n        payment = principal * (interest_rate * factor) / (factor - 1)\n        if annuity_due:\n            payment /= (1 + interest_rate)\n\n    # Return the payment rounded to the nearest dollar\n    return round(payment)\n\n# Output the result\nsolution()",
        "ground_truth": 36791,
        "source": "FinanceReasoning-test-122",
        "question_id": "test-2114",
        "level": "hard",
        "output": [
            "To address the problem systematically, I will apply the Emphasizing Constraints (EC) reasoning technique to ensure the solution aligns with the question's requirements. \n\n### Step-by-step Breakdown:\n1. **Inputs and Understanding the Problem**:\n   - Jane has $500,000 to invest (principal).\n   - The annuity has an annual interest rate of 4% (interest rate per period = 0.04).\n   - Payments occur annually for 20 years (number of periods = 20).\n   - Payments are made at the end of each year, meaning it's an ordinary annuity.\n\n2. **Constraints**:\n   - The interest rate must be expressed as a decimal (e.g., 4% = 0.04).\n   - The number of periods is a positive integer.\n   - Payments are calculated to the nearest dollar, ensuring no decimals in the output.\n\n3. **Mathematical Formula**:\n   - To compute the annual payment, I will use the standard annuity formula:\n     \\[\n     P = \\frac{r \\cdot PV \\cdot (1 + r)^n}{(1 + r)^n - 1}\n     \\]\n     Where:\n     - \\(P\\) is the annual payment.\n     - \\(PV\\) is the initial investment amount (present value, $500,000).\n     - \\(r\\) is the periodic interest rate (0.04).\n     - \\(n\\) is the total number of periods (20 years).\n\n4. **Implementation**:\n   - I'll define the inputs (`principal`, `interest_rate`, `periods`).\n   - Use the formula above to calculate the periodic payment and ensure it adheres to constraints.\n   - Round the final result to the nearest dollar, as requested.\n\nHere is the Python program:\n\n```python\ndef solution():\n    # Define variables name and value\n    principal = 500000  # Initial investment (Present Value)\n    interest_rate = 0.04  # Annual interest rate as a decimal\n    periods = 20  # Number of years of payment\n    \n    # Annuity formula for ordinary annuity payments\n    payout = principal * (interest_rate * (1 + interest_rate) ** periods) / ((1 + interest_rate) ** periods - 1)\n    \n    # Round result to the nearest dollar\n    answer = round(payout)\n    \n    # Return the annual payment\n    return answer\n```\n\nThis ensures that all constraints are respected and the calculations are accurate."
        ],
        "retrieval_query": "What is the annual payment Jane will receive from her annuity investment? Answer to the nearest dollar.",
        "useful_functions": [
            "def calculate_annuity_payout(principal: float, interest_rate: float, periods: int) -> float:\n    \"\"\"\n    Calculate the periodic annuity payout for a years certain annuity.\n\n    This function computes the regular payment amount for a fixed period annuity\n    given the initial principal, the periodic interest rate, and the number of periods.\n\n    Args:\n        principal (float): The initial amount of money invested in the annuity.\n        interest_rate (float): The interest rate per period as a decimal (e.g., 0.05 for 5%).\n        periods (int): The number of periods (e.g., months or years) over which payments are made.\n\n    Returns:\n        payout (float): The amount of each periodic payment.\n\n    Notes:\n        - Applicability: This function is applicable for fixed period or years certain annuities.\n        - Constraints: Interest rate must be greater than -1, and periods must be a positive integer.\n        - Considerations: Payments are assumed to be made at the end of each period.\n    \"\"\"\n    if interest_rate <= -1:\n        raise ValueError(\"Interest rate must be greater than -1.\")\n    if periods <= 0:\n        raise ValueError(\"Periods must be a positive integer.\")\n    \n    if interest_rate == 0:\n        payout = principal / periods\n    else:\n        payout = principal * (interest_rate * (1 + interest_rate) ** periods) / ((1 + interest_rate) ** periods - 1)\n    \n    return payout"
        ],
        "usage": {
            "completion_tokens": 517,
            "prompt_tokens": 759,
            "total_tokens": 1276,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-2829",
        "article_title": "Expectations Theory",
        "function": "def calculate_future_one_year_rate(two_year_rate: float, current_one_year_rate: float) -> float:\n    \"\"\"\n    Calculate the forecasted interest rate of a future one-year bond according to Expectations Theory.\n\n    This function applies the Expectations Theory to forecast the interest rate of a one-year bond\n    for the next year, based on the current long-term (two-year) bond interest rate and the\n    current one-year bond interest rate.\n\n    Args:\n        two_year_rate (float): The interest rate of a two-year bond (expressed as a decimal, e.g., 0.20 for 20%).\n        current_one_year_rate (float): The current interest rate of a one-year bond (expressed as a decimal, e.g., 0.18 for 18%).\n\n    Returns:\n        future_one_year_rate (float): The forecasted interest rate for the one-year bond in the next year.\n\n    Notes:\n        - Applicability: This function is applicable in financial contexts where Expectations Theory is used to predict bond rates.\n        - Constraints: The interest rates should be given in decimal form (e.g., 0.20 for 20%).\n        - Considerations: While forming predictions using expectations theory, be aware of its limitations and consider additional economic factors.\n    \"\"\"\n    # Step 1: Calculate (1 + two_year_rate)^2\n    compounded_two_year_rate = (1 + two_year_rate)**2\n\n    # Step 2: Divide by (1 + current_one_year_rate) and add 1\n    intermediate_result = (compounded_two_year_rate / (1 + current_one_year_rate)) + 1\n\n    # Step 3: Subtract 1 to get the forecasted future one-year rate\n    future_one_year_rate = intermediate_result - 1\n\n    return future_one_year_rate",
        "statistics": {
            "number_statistics": {
                "args_numbers": 2,
                "question_numbers": 0,
                "context_numbers": 2,
                "total_numbers": 2
            },
            "operator_statistics": {
                "operators": {
                    "+": 5,
                    "-": 2,
                    "*": 0,
                    "/": 1,
                    "%": 0,
                    "**": 1
                },
                "total_operators": 9
            },
            "code_statistics": {
                "lines": 7,
                "parentheses": 10
            }
        },
        "difficulty": 4.68213122712422,
        "context": "An economist is analyzing bond interest rate trends to forecast the interest rates for the upcoming year. She notes that the current interest rate for a two-year bond is 4.5%, while the current interest rate for a one-year bond is 3.0%. Using the Expectations Theory, she intends to predict the interest rate for a one-year bond that investors would anticipate for next year.",
        "question": "What is the forecasted interest rate for the one-year bond next year? Answer as a percentage to two decimal places.",
        "python_solution": "def solution():\n    # Define the interest rates as decimals\n    two_year_rate = 0.045  # 4.5%\n    current_one_year_rate = 0.030  # 3.0%\n\n    # Step 1: Calculate (1 + two_year_rate)^2\n    compounded_two_year_rate = (1 + two_year_rate)**2\n\n    # Step 2: Divide by (1 + current_one_year_rate)\n    intermediate_result = compounded_two_year_rate / (1 + current_one_year_rate)\n\n    # Step 3: Subtract 1 to get the forecasted future one-year rate\n    future_one_year_rate = intermediate_result - 1\n\n    # Convert the rate to a percentage and round to two decimal places\n    future_one_year_rate_percentage = future_one_year_rate * 100\n\n    # Return the result\n    return round(future_one_year_rate_percentage, 2)",
        "ground_truth": 6.02,
        "source": "FinanceReasoning-test-201",
        "question_id": "test-2115",
        "level": "hard",
        "output": [
            "To solve the problem of predicting the interest rate for a one-year bond next year using the Expectations Theory, we start by defining the key steps and constraints.\n\n---\n\n**Step-by-Step Analysis:**\n\n1. **Understanding the Expectations Theory:**\n   - According to the Expectations Theory, the interest rate for a long-term bond reflects the average of short-term interest rates expected over the bond's life.\n   - Here, a 2-year bond's interest rate (`4.5%`) is given, and the 1-year bond's current interest rate is (`3.0%`). \n   - Using this, we can forecast the one-year interest rate expected for next year.\n\n2. **Mathematical Formula:**\n   - Expectations Theory specifies that:\n     \\[\n     (1 + r_2)^2 = (1 + r_1) \\times (1 + r_{1,2})\n     \\]\n     where:\n     - \\( r_2 \\): 2-year bond interest rate = 4.5% = 0.045 (decimal form)\n     - \\( r_1 \\): 1-year bond interest rate = 3.0% = 0.03 (decimal form)\n     - \\( r_{1,2} \\): Forecasted 1-year bond interest rate for next year.\n\n   - Rearrange the equation to find the forecasted rate (\\( r_{1,2} \\)):\n     \\[\n     r_{1,2} = \\frac{(1 + r_2)^2}{(1 + r_1)} - 1\n     \\]\n\n3. **Constraints (EC):**\n   - Use percentage values with two decimal places (e.g., 4.50%).\n   - Ensure converting percentages into decimals for calculations and back into percentages for the final answer.\n\n4. **Implementation Steps:**\n   - Convert the input interest rates into decimals (e.g., `4.5%` becomes `0.045`).\n   - Apply the formula to calculate \\( r_{1,2} \\).\n   - Convert the resulting decimal value back into a percentage with two decimal places.\n\n---\n\nLet\u2019s now proceed to write the Python program to calculate the answer:\n\n```python\ndef solution():\n    # Define variables name and value (convert percentages to decimals)\n    r1 = 0.03  # 1-year current bond interest rate\n    r2 = 0.045  # 2-year current bond interest rate\n    \n    # Do math calculation to get the answer (applying Expectations Theory formula)\n    r1_2 = ((1 + r2)**2 / (1 + r1)) - 1\n    \n    # Convert the resulting rate back to percentage\n    answer = round(r1_2 * 100, 2)  # Return the value as a percentage to 2 decimal places\n    \n    # return answer\n    return answer\n```"
        ],
        "retrieval_query": "What is the forecasted interest rate for the one-year bond next year? Answer as a percentage to two decimal places.",
        "useful_functions": [
            "def calculate_n_year_spot_rate(spot_rates: list, par_rate: float, maturity: int) -> float:\n    \"\"\"\n    Calculate the n-year spot rate from a series of given shorter-term spot rates and a par rate.\n\n    This function determines the n-year spot rate for a bond by using shorter-term spot rates\n    and the par rate of an n-year bond. It is used to fill the gap in yield curves when\n    complete spot rate data is not available for longer maturities.\n\n    Args:\n        spot_rates (list): A list of known spot rates for maturities less than n. Each rate must\n                           correspond to an annual period (e.g., length 4 for a 5-year calculation).\n        par_rate (float): The par rate expressed as a decimal for the entire n-year period.\n        maturity (int): The number of years for the full period (must be greater than the length of spot_rates).\n\n    Returns:\n        n_year_spot_rate (float): The calculated n-year spot rate as a percentage.\n\n    Notes:\n        - Applicable for calculating spot rates for bonds based on available data \n          for shorter maturities and the par rate for the full maturity.\n        - Constraints: `maturity` must be greater than the length of `spot_rates`.\n        - It assumes annual coupon payment and compounding.\n        - Inflation and taxes are not considered.\n    \"\"\"\n    sum_discounted_payments = sum([par_rate / ((1 + rate) ** i) for i, rate in enumerate(spot_rates, start=1)])\n    n_year_spot_rate = ((1 + par_rate) / (1 - sum_discounted_payments)) ** (1 / maturity) - 1\n    return n_year_spot_rate * 100"
        ],
        "usage": {
            "completion_tokens": 599,
            "prompt_tokens": 801,
            "total_tokens": 1400,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "The existing yearly spot rates are presented as follows: 1 year at 2%, 2 years at 2.5%, 3 years at 3.5%, and 4 years at 5.5%. Can you tell me the forward rate for two years starting from two years from now (expressed as a percentage)? Answer to three decimal places.",
        "python_solution": "def solution():\n    # Given Spot rates\n    s1, s2, s3, s4 = 0.02, 0.025, 0.035, 0.055\n\n    # Formula for two years forward rate\n    forward_rate = (((1 + s4)**4 / (1 + s2)**2) ** (1/2)) - 1\n    \n    # Convert to percentage\n    forward_rate *= 100\n\n    return forward_rate",
        "ground_truth": 8.588,
        "topic": "Asset Classes & Derivatives",
        "statistics": {
            "number_statistics": {
                "args_numbers": 5,
                "question_numbers": 8,
                "context_numbers": 0,
                "total_numbers": 8
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 1,
                    "*": 1,
                    "/": 2,
                    "%": 0,
                    "**": 3
                },
                "total_operators": 9
            },
            "code_statistics": {
                "lines": 7,
                "parentheses": 10
            }
        },
        "difficulty": 4.68213122712422,
        "source": "FinanceMath-validation-81",
        "context": "[]",
        "question_id": "test-2116",
        "level": "hard",
        "output": [
            "### Step-by-Step Reasoning Using Advanced Technique: Emphasizing Constraints (EC)\n\n#### Step 1: Understand the question.\nWe need to calculate the **forward rate for two years starting two years from now**. This is often referred to as the \"2y2y forward rate\", where:\n- Forward period = From year 2 to year 4.\n- Spot rates are given for 1-year, 2-year, 3-year, and 4-year maturities.\n- The answer should be expressed in percentage and rounded to 3 decimal places.\n\n#### Step 2: Define necessary inputs for calculation.\nThe formula to calculate a forward rate is:\n\\[\nf_{t,t+n} = \\left(\\frac{(1 + S_{t+n})^{t+n}}{(1 + S_{t})^{t}}\\right)^{\\frac{1}{n}} - 1\n\\]\nWhere:\n- \\( S_t \\) and \\( S_{t+n} \\) are the spot rates at \\( t \\) and \\( t+n \\) years, respectively.\n- \\( f_{t,t+n} \\) is the forward rate.\n- \\( t \\) is the start year of the forward period.\n- \\( n \\) is the duration of the forward period.\n\nHere:\n- Start year \\( t = 2 \\).\n- Duration \\( n = 2 \\).\n- End year \\( t+n = 4 \\).\n- Spot rate for \\( t = 2 \\): \\( 2.5\\% = 0.025 \\) (in decimal form).\n- Spot rate for \\( t+n = 4 \\): \\( 5.5\\% = 0.055 \\) (in decimal form).\n\n#### Step 3: Constraints to consider.\n- Spot rates are provided as percentages, but the formula requires them in decimal form for calculation.\n- The final forward rate must be converted back to percentage and rounded to 3 decimal places.\n- Ensure no errors in exponentiation by adhering to order of operations.\n\n#### Step 4: Plan the program.\n1. Convert spot rates to decimals.\n2. Use the given formula to calculate the forward rate.\n3. Convert the result back to percentage and round to 3 decimal places.\n4. Return the result.\n\nNow, let's write the Python program.\n\n```python\ndef solution():\n    # Define variables (spot rates in decimal form and years)\n    spot_2_years = 0.025  # 2.5% as decimal\n    spot_4_years = 0.055  # 5.5% as decimal\n    start_years = 2       # Starting from 2nd year\n    end_years = 4         # Ending at 4th year\n    \n    # Calculate forward rate using the formula\n    compounded_end = (1 + spot_4_years) ** end_years\n    compounded_start = (1 + spot_2_years) ** start_years\n    forward_rate = ((compounded_end / compounded_start) ** (1 / (end_years - start_years))) - 1\n    \n    # Convert to percentage and round to 3 decimal places\n    forward_rate_percentage = round(forward_rate * 100, 3)\n    \n    # Return the forward rate\n    return forward_rate_percentage\n```"
        ],
        "retrieval_query": "The existing yearly spot rates are presented as follows: 1 year at 2%, 2 years at 2.5%, 3 years at 3.5%, and 4 years at 5.5%. Can you tell me the forward rate for two years starting from two years from now (expressed as a percentage)? Answer to three decimal places.",
        "useful_functions": [
            "def calculate_forward_rate(spot_start: float, spot_end: float, start_years: int, end_years: int) -> float:\n    \"\"\"\n    Calculate the forward rate given two spot rates and the respective periods.\n\n    This function computes the forward interest rate for a given period starting\n    from a specified number of years in the future, based on known spot rates for\n    different maturities.\n\n    Args:\n        spot_start (float): The spot rate percentage (in decimal form, e.g., 0.025 for 2.5%)\n                            at the beginning of the period.\n        spot_end (float): The spot rate percentage (in decimal form, e.g., 0.055 for 5.5%)\n                          at the end of the period.\n        start_years (int): The number of years from the present for the start of the forward period.\n        end_years (int): The number of years from the present for the end of the forward period.\n\n    Returns:\n        forward_rate (float): The forward rate for the specified period, expressed as a percentage\n                              (e.g., 8.588 for 8.588%).\n\n    Notes:\n        - Spot rates should be provided as decimals, not percentages.\n        - This function provides the forward rate as a percentage.\n        - The start_years and end_years must be consistent with the periods for which spot rates are given.\n        - Assumes no arbitrage between the different periods.\n    \"\"\"\n    # Calculate the forward rate based on spot rates and durations\n    compounded_end = (1 + spot_end) ** end_years\n    compounded_start = (1 + spot_start) ** start_years\n    forward_rate = ((compounded_end / compounded_start) ** (1 / (end_years - start_years))) - 1\n    \n    # Convert to percentage\n    forward_rate *= 100\n\n    return forward_rate",
            "def calculate_implied_forward_rate_after_years(spot_rate_short: float, spot_rate_long: float, years_short: int, years_long: int) -> float:\n    \"\"\"\n    Calculate the implied forward rate for an investment after a specified number of years.\n\n    This function computes the implied forward rate that will apply after a certain\n    number of years, based on given short-term and long-term spot rates. This is useful\n    for financial analysis when estimating future interest rates in the context of bonds \n    or loan agreements.\n\n    Args:\n        spot_rate_short (float): The spot rate for the shorter period in decimal form (e.g., 1.65% as 0.0165).\n        spot_rate_long (float): The spot rate for the longer period in decimal form (e.g., 2.15% as 0.0215).\n        years_short (int): The number of years for the short-term spot rate.\n        years_long (int): The number of years for the long-term spot rate.\n\n    Returns:\n        implied_forward_rate (float): The calculated implied forward rate as a percentage.\n\n    Notes:\n        - Applicability: This function applies to scenarios where forward interest rates\n          need to be derived from spot rates.\n        - Constraints: `years_long` must be greater than `years_short`.\n        - Considerations: Ensure spot rates are in decimal form and represent annual rates.\n    \"\"\"\n    if years_long <= years_short:\n        raise ValueError(\"years_long must be greater than years_short.\")\n\n    rate_long_term = (1 + spot_rate_long) ** years_long\n    rate_short_term = (1 + spot_rate_short) ** years_short\n\n    implied_forward_rate = (rate_long_term / rate_short_term) ** (1 / (years_long - years_short)) - 1\n\n    return implied_forward_rate * 100"
        ],
        "usage": {
            "completion_tokens": 691,
            "prompt_tokens": 1189,
            "total_tokens": 1880,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "Based on the BSM model, what is the value of the put option for company XYZ's stock, currently trading at $48.6? Presume that the volatility is 30%, the continuously compounded risk-free rate stands at 0.3%, we assume X is equal to 45, T equals 0.25, N(d1) is 0.6352 and N(d2) is 0.5486. Answer to three decimal places.",
        "python_solution": "def solution():\n    import math\n    X = 45 # Strike Price\n    S = 48.6 # Stock Price\n    T = 0.25 # Time to maturity in years\n    r = 0.003 # Risk-free interest rate\n    Nd1 = 0.6352 # Value of cumulative standard normal distribution at d1\n    Nd2 = 0.5486 # Value of cumulative standard normal distribution at d2\n    Nd1_neg = 1 - Nd1 \n    Nd2_neg = 1 - Nd2 \n    \n    put_option_price = math.exp(-r * T) * X * Nd2_neg - S * Nd1_neg\n    \n    return put_option_price",
        "ground_truth": 2.568,
        "topic": "Asset Classes & Derivatives",
        "statistics": {
            "number_statistics": {
                "args_numbers": 6,
                "question_numbers": 7,
                "context_numbers": 0,
                "total_numbers": 7
            },
            "operator_statistics": {
                "operators": {
                    "+": 0,
                    "-": 5,
                    "*": 4,
                    "/": 0,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 9
            },
            "code_statistics": {
                "lines": 11,
                "parentheses": 2
            }
        },
        "difficulty": 4.68213122712422,
        "source": "FinanceMath-validation-114",
        "context": "[]",
        "question_id": "test-2117",
        "level": "hard",
        "output": [
            "### Step by Step Analysis using EC Technique:\n\n1. **Identify Inputs and Constraints**:\n    - Stock price (S): $48.6\n    - Strike price (X): $45\n    - Time to maturity (T): 0.25 years\n    - Volatility (\u03c3): 30% or 0.3 in decimal.\n    - Risk-free interest rate (r): 0.3% or 0.003 in decimal.\n    - Given cumulative normal distribution values:\n        - \\( N(d1) = 0.6352 \\)\n        - \\( N(d2) = 0.5486 \\)\n    - Result should be computed using the BSM model for put options.\n    - Output must be rounded to three decimal places.\n\n2. **Relevant Formula**:\n    Using the BSM model, the formula for pricing a put option is:\n\n    \\[\n    P = X \\cdot e^{-r \\cdot T} \\cdot N(-d2) - S \\cdot N(-d1)\n    \\]\n\n    Where:\n    - \\( N(-d1) = 1 - N(d1) \\)\n    - \\( N(-d2) = 1 - N(d2) \\)\n    - \\( e^{-r \\cdot T} \\) is the discount factor for the strike price.\n\n3. **Adhering to Constraints**:\n    - The calculation follows the proper formula without deviation.\n    - We ensure no skipped steps and values are computed properly in decimal form.\n    - Final output will respect the precision constraint (rounded to 3 decimal places).\n\n4. **Plan to Implement**:\n    - Convert risk-free rate and volatility to decimals.\n    - Compute \\( N(-d1) \\) as \\( 1 - N(d1) \\).\n    - Compute \\( N(-d2) \\) as \\( 1 - N(d2) \\).\n    - Apply the given formula to calculate the put option price.\n    - Round the result to three decimal places.\n\nWith the plan outlined, let us now implement the solution.\n\n```python\ndef solution():\n    # Define variables name and value\n    stock_price = 48.6  # S\n    strike_price = 45  # X\n    time_to_maturity = 0.25  # T\n    risk_free_rate = 0.003  # r in decimal\n    nd1 = 0.6352  # N(d1)\n    nd2 = 0.5486  # N(d2)\n\n    # Calculate N(-d1) and N(-d2)\n    nd1_neg = 1 - nd1\n    nd2_neg = 1 - nd2\n\n    # Calculate the discount factor for the strike price\n    from math import exp\n    discount_factor = exp(-risk_free_rate * time_to_maturity)\n\n    # Calculate the put option price using the BSM model\n    put_option_price = (strike_price * discount_factor * nd2_neg) - (stock_price * nd1_neg)\n\n    # Return the answer rounded to 3 decimal places\n    return round(put_option_price, 3)\n```"
        ],
        "retrieval_query": "Based on the BSM model, what is the value of the put option for company XYZ's stock, currently trading at $48.6? Presume that the volatility is 30%, the continuously compounded risk-free rate stands at 0.3%, we assume X is equal to 45, T equals 0.25, N(d1) is 0.6352 and N(d2) is 0.5486. Answer to three decimal places.",
        "useful_functions": [
            "def calculate_bsm_put_option_price(stock_price: float, strike_price: float, time_to_maturity: float, \n                                   risk_free_rate: float, nd1: float, nd2: float) -> float:\n    \"\"\"\n    Calculate the value of a European put option using the Black-Scholes-Merton (BSM) model.\n\n    This function computes the price of a European put option based on the current stock \n    price, strike price, time to expiration, risk-free interest rate, and cumulative standard \n    normal distribution values for d1 and d2.\n\n    Args:\n        stock_price (float): The current price of the underlying stock (S).\n        strike_price (float): The strike price of the option (X).\n        time_to_maturity (float): The time to expiration of the option in years (T).\n        risk_free_rate (float): The continuously compounded risk-free interest rate (r).\n        nd1 (float): The cumulative standard normal distribution value for d1 (N(d1)).\n        nd2 (float): The cumulative standard normal distribution value for d2 (N(d2)).\n\n    Returns:\n        put_option_price (float): The calculated price of the European put option.\n\n    Notes:\n        - Applicability: This function applies to the valuation of European put options under \n          the assumption of constant volatility and risk-free rate, as per the BSM model.\n        - Constraints: This function does not account for dividend payouts. It assumes European \n          style options (exercisable only at expiration).\n        - Considerations: Ensure nd1 and nd2 are derived appropriately using an additional model\n          or calculation for d1 and d2 based on stock volatility and other factors.\n    \"\"\"\n    from math import exp\n\n    nd1_neg = 1 - nd1\n    nd2_neg = 1 - nd2\n\n    present_value_factor = exp(-risk_free_rate * time_to_maturity)\n    put_option_price = present_value_factor * strike_price * nd2_neg - stock_price * nd1_neg\n\n    return round(put_option_price, 3)",
            "def calculate_black_scholes_put_price(S: float, K: float, r: float, T: float, volatility: float) -> float:\n    \"\"\"\n    Calculate the European put option price using the Black-Scholes model.\n\n    This function computes the price of a European put option based on the Black-Scholes\n    option pricing model. It considers the option's underlying stock price, strike price,\n    risk-free interest rate, time to maturity, and volatility.\n\n    Args:\n        S (float): Current stock price.\n        K (float): Strike price of the option.\n        r (float): Risk-free interest rate (as a decimal).\n        T (float): Time to maturity in years.\n        volatility (float): Annualized volatility of the stock's returns (as a decimal).\n\n    Returns:\n        put_price (float): The calculated put option price.\n\n    Notes:\n        - This function assumes that the underlying stock does not pay dividends.\n        - European options can only be exercised at the expiration date.\n        - The volatility parameter should be the annualized standard deviation of returns.\n    \"\"\"\n    from math import log, sqrt, exp\n    from scipy.stats import norm\n\n    d1 = (log(S / K) + (r + 0.5 * volatility ** 2) * T) / (volatility * sqrt(T))\n    d2 = d1 - volatility * sqrt(T)\n\n    put_price = K * exp(-r * T) * norm.cdf(-d2) - S * norm.cdf(-d1)\n    \n    return put_price"
        ],
        "usage": {
            "completion_tokens": 659,
            "prompt_tokens": 1184,
            "total_tokens": 1843,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-896",
        "article_title": "McClellan Oscillator",
        "function": "def calculate_mcclellan_oscillator(advances: float, declines: float, prior_19_day_ema: float, prior_39_day_ema: float) -> float:\n    \"\"\"\n    Calculate the McClellan Oscillator using the number of advancing and declining stocks.\n\n    The McClellan Oscillator is a market breadth indicator based on the difference \n    between short-term (19-day) and long-term (39-day) exponential moving averages (EMA) \n    of net advances (advances minus declines) in a stock exchange.\n\n    Args:\n        advances (float): The number of stocks with gains over their previous day's close.\n        declines (float): The number of stocks with losses over their previous day's close.\n        prior_19_day_ema (float): The previous day's 19-day EMA of net advances.\n        prior_39_day_ema (float): The previous day's 39-day EMA of net advances.\n\n    Returns:\n        mcclellan_oscillator (float): The value of the McClellan Oscillator.\n\n    Notes:\n        - This function requires daily stock advances and declines as input.\n        - Prior day EMA values serve as the initial EMA values.\n        - Assumes continuous data to ensure EMA calculations are accurate.\n        - Useful for assessing stock market trends and potential reversals.\n    \"\"\"\n    net_advances = advances - declines\n    ema_19_day = (net_advances * 0.10) + (prior_19_day_ema * (1 - 0.10))\n    ema_39_day = (net_advances * 0.05) + (prior_39_day_ema * (1 - 0.05))\n    mcclellan_oscillator = ema_19_day - ema_39_day\n    \n    return mcclellan_oscillator",
        "statistics": {
            "number_statistics": {
                "args_numbers": 4,
                "question_numbers": 0,
                "context_numbers": 6,
                "total_numbers": 6
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 4,
                    "*": 4,
                    "/": 0,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 10
            },
            "code_statistics": {
                "lines": 5,
                "parentheses": 12
            }
        },
        "difficulty": 4.700480365792417,
        "context": "An investment analyst is evaluating the market using the McClellan Oscillator, a market breadth indicator. On a particular trading day, they recorded that 1,200 stocks advanced, while 800 stocks declined. The previous day's 19-day EMA of net advances was 150, and the previous day's 39-day EMA of net advances was 100. The analyst wants to calculate today's McClellan Oscillator value to assess potential trend reversals in the stock market.",
        "question": "What is today's McClellan Oscillator value? Answer to two decimal places.",
        "python_solution": "def solution():\n    # Define variables based on the given context\n    advances = 1200\n    declines = 800\n    prior_19_day_ema = 150\n    prior_39_day_ema = 100\n    \n    # Calculate net advances\n    net_advances = advances - declines\n    \n    # Calculate today's 19-day EMA\n    ema_19_day = (net_advances * 0.10) + (prior_19_day_ema * (1 - 0.10))\n    \n    # Calculate today's 39-day EMA\n    ema_39_day = (net_advances * 0.05) + (prior_39_day_ema * (1 - 0.05))\n    \n    # Calculate the McClellan Oscillator\n    mcclellan_oscillator = ema_19_day - ema_39_day\n    \n    # Return the McClellan Oscillator value rounded to two decimal places\n    return round(mcclellan_oscillator, 2)",
        "ground_truth": 60.0,
        "source": "FinanceReasoning-test-115",
        "question_id": "test-2118",
        "level": "hard",
        "output": [
            "To solve the given problem, let's work through it step by step using advanced reasoning techniques, specifically Emphasizing Constraints (EC).\n\n---\n\n### Step-by-Step Plan:\n\n1. **Evaluate and Define Input Variables**: \n   - `advances`: The number of advancing stocks = 1,200.\n   - `declines`: The number of declining stocks = 800.\n   - `prior_19_day_ema`: Previous day's 19-day EMA of net advances = 150.\n   - `prior_39_day_ema`: Previous day's 39-day EMA of net advances = 100.\n\n2. **Calculate Net Advances**:\n   - `net_advances = advances - declines`, which will give the net difference between advancing and declining stocks.\n\n3. **Calculate New 19-day EMA**:\n   - Formula: `ema_19_day = (net_advances * 0.10) + (prior_19_day_ema * (1 - 0.10))`\n   - This formula uses the smoothing factor of 0.10 (for 19-day EMA) while considering the prior EMA value.\n\n4. **Calculate New 39-day EMA**:\n   - Formula: `ema_39_day = (net_advances * 0.05) + (prior_39_day_ema * (1 - 0.05))`\n   - This formula uses the smoothing factor of 0.05 (for 39-day EMA) while considering the prior EMA value.\n\n5. **Compute the McClellan Oscillator**:\n   - Formula: `mcclellan_oscillator = ema_19_day - ema_39_day`\n   - Subtract the newly calculated 39-day EMA from the newly calculated 19-day EMA.\n\n6. **Emphasize Constraints (EC)**:\n   - Ensure rounding to two decimal places to meet the problem's requirement. \n   - Adhere strictly to the calculation formulas provided in the question.\n\n7. **Output the Result**: \n   - The final value of the McClellan Oscillator should be returned as the answer.\n\n---\n\nHere's the Python program implementing this logic:\n\n```python\ndef solution():\n    # Define variables name and value\n    advances = 1200\n    declines = 800\n    prior_19_day_ema = 150\n    prior_39_day_ema = 100\n    \n    # Step 1: Calculate net advances\n    net_advances = advances - declines\n    \n    # Step 2: Calculate the 19-day EMA\n    ema_19_day = (net_advances * 0.10) + (prior_19_day_ema * (1 - 0.10))\n    \n    # Step 3: Calculate the 39-day EMA\n    ema_39_day = (net_advances * 0.05) + (prior_39_day_ema * (1 - 0.05))\n    \n    # Step 4: Calculate the McClellan Oscillator\n    mcclellan_oscillator = ema_19_day - ema_39_day\n    \n    # Return the value rounded to 2 decimal places\n    return round(mcclellan_oscillator, 2)\n```"
        ],
        "retrieval_query": "What is today's McClellan Oscillator value? Answer to two decimal places.",
        "useful_functions": [
            "def calculate_mcclellan_oscillator(advances: float, declines: float, prior_19_day_ema: float, prior_39_day_ema: float) -> float:\n    \"\"\"\n    Calculate the McClellan Oscillator using the number of advancing and declining stocks.\n\n    The McClellan Oscillator is a market breadth indicator based on the difference \n    between short-term (19-day) and long-term (39-day) exponential moving averages (EMA) \n    of net advances (advances minus declines) in a stock exchange.\n\n    Args:\n        advances (float): The number of stocks with gains over their previous day's close.\n        declines (float): The number of stocks with losses over their previous day's close.\n        prior_19_day_ema (float): The previous day's 19-day EMA of net advances.\n        prior_39_day_ema (float): The previous day's 39-day EMA of net advances.\n\n    Returns:\n        mcclellan_oscillator (float): The value of the McClellan Oscillator.\n\n    Notes:\n        - This function requires daily stock advances and declines as input.\n        - Prior day EMA values serve as the initial EMA values.\n        - Assumes continuous data to ensure EMA calculations are accurate.\n        - Useful for assessing stock market trends and potential reversals.\n    \"\"\"\n    net_advances = advances - declines\n    ema_19_day = (net_advances * 0.10) + (prior_19_day_ema * (1 - 0.10))\n    ema_39_day = (net_advances * 0.05) + (prior_39_day_ema * (1 - 0.05))\n    mcclellan_oscillator = ema_19_day - ema_39_day\n    \n    return mcclellan_oscillator"
        ],
        "usage": {
            "completion_tokens": 667,
            "prompt_tokens": 832,
            "total_tokens": 1499,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-2990",
        "article_title": "Normal Distribution",
        "function": "def normal_distribution_probability(x: float, mean: float, std_dev: float) -> float:\n    \"\"\"\n    Calculate the probability density of a normal distribution.\n\n    This function computes the probability density function (PDF) value for a given x\n    in a normal distribution with specified mean and standard deviation. It is useful\n    for determining the probability density of specific outcomes in data believed to be\n    normally distributed.\n\n    Args:\n        x (float): The value at which the probability density is calculated.\n        mean (float): The mean (\u03bc) of the normal distribution.\n        std_dev (float): The standard deviation (\u03c3) of the normal distribution.\n\n    Returns:\n        probability_density (float): The probability density of the normal distribution\n                                     at the specified x.\n\n    Notes:\n        - This function assumes a continuous normal distribution.\n        - The standard deviation must be positive.\n        - The result is the probability density, not the cumulative probability.\n    \"\"\"\n    import math\n    \n    if std_dev <= 0:\n        raise ValueError(\"Standard deviation must be positive.\")\n\n    variance = std_dev ** 2\n    probability_density = (1 / (math.sqrt(2 * math.pi * variance))) * \\\n                          math.exp(- (x - mean) ** 2 / (2 * variance))\n    \n    return probability_density",
        "statistics": {
            "number_statistics": {
                "args_numbers": 3,
                "question_numbers": 1,
                "context_numbers": 3,
                "total_numbers": 4
            },
            "operator_statistics": {
                "operators": {
                    "+": 0,
                    "-": 2,
                    "*": 4,
                    "/": 2,
                    "%": 0,
                    "**": 2
                },
                "total_operators": 10
            },
            "code_statistics": {
                "lines": 5,
                "parentheses": 12
            }
        },
        "difficulty": 4.700480365792417,
        "context": "A financial analyst is assessing a stock's daily returns, which approximately follow a normal distribution. The stock has shown a mean daily return of 1% with a standard deviation of 0.5%. The analyst is interested in computing the probability density of the stock returning exactly 0.5% on a particular day to assist in the investment decision-making process.",
        "question": "What is the probability density of the stock returning exactly 0.5% on a given day? Provide the answer as a decimal rounded to six decimal places.",
        "python_solution": "def solution():\n    import math\n\n    # Define the parameters\n    x = 0.005       # The return value for which we calculate the probability density\n    mean = 0.01     # Mean daily return\n    std_dev = 0.005 # Standard deviation of daily returns\n\n    # Calculate variance\n    variance = std_dev ** 2\n    \n    # Calculate the probability density using the formula for a normal distribution\n    probability_density = (1 / (math.sqrt(2 * math.pi * variance))) * \\\n                          math.exp(- (x - mean) ** 2 / (2 * variance))\n    \n    # Return the result rounded to six decimal places\n    return round(probability_density, 6)",
        "ground_truth": 48.394145,
        "source": "FinanceReasoning-test-149",
        "question_id": "test-2119",
        "level": "hard",
        "output": [
            "To solve this problem, let us step through carefully:\n\n1. **Understand the Problem and its Context**:\n   - The stock's daily returns follow a normal distribution.\n   - Mean (\\( \\mu \\)) = 1% = 0.01 (in decimal form).\n   - Standard deviation (\\( \\sigma \\)) = 0.5% = 0.005 (in decimal form).\n   - A normal distribution is described by the probability density function (PDF):\n     \\[\n     f(x) = \\frac{1}{\\sigma \\sqrt{2\\pi}} e^{-\\frac{(x - \\mu)^2}{2\\sigma^2}}\n     \\]\n   - Our task is to compute the probability density \\( f(x) \\) at \\( x = 0.005 \\), which represents a 0.5% return.\n\n2. **Constraint Emphasis (EC)**:\n   - The probability density itself does not give the exact \"probability\" but the height of the density curve at \\( x \\). This is correct since the probability of any specific point in a continuous distribution is zero.\n   - We must compute and return the probability density as a decimal rounded to six decimal places.\n\n3. **Steps for Implementation**:\n   - Use the provided formula for the normal distribution's PDF.\n   - Compute the probability density for \\( x = 0.005 \\) using:\n     - \\( \\mu = 0.01 \\)\n     - \\( \\sigma = 0.005 \\)\n   - Round the final result to six decimal places as instructed.\n\nWe now proceed to implement the solution in Python:\n\n```python\nimport math\n\ndef solution():\n    # Define variables (mean, standard deviation, point to evaluate)\n    mu = 0.01  # Mean in decimal form\n    sigma = 0.005  # Standard deviation in decimal\n    x = 0.005  # Value (0.5%) for evaluation\n    \n    # Calculate the probability density using the normal distribution formula\n    pdf = (1 / (sigma * math.sqrt(2 * math.pi))) * math.exp(-((x - mu) ** 2) / (2 * sigma ** 2))\n    \n    # Round the result to six decimal places\n    answer = round(pdf, 6)\n    \n    # Return the answer\n    return answer\n```"
        ],
        "retrieval_query": "What is the probability density of the stock returning exactly 0.5% on a given day? Provide the answer as a decimal rounded to six decimal places.",
        "useful_functions": [],
        "usage": {
            "completion_tokens": 490,
            "prompt_tokens": 429,
            "total_tokens": 919,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-1353",
        "article_title": "Probability Distribution",
        "function": "def calculate_normal_distribution_probability(mean: float, std_dev: float, x: float) -> float:\n    \"\"\"\n    Calculate the probability of a value from a normal distribution.\n\n    This function computes the probability of obtaining a specific value 'x'\n    from a normal distribution defined by its mean and standard deviation.\n    It is useful for statistical analysis and forecasts in finance and investing.\n\n    Args:\n        mean (float): The mean (average) of the normal distribution.\n        std_dev (float): The standard deviation of the normal distribution.\n        x (float): The value for which to calculate the probability.\n\n    Returns:\n        probability (float): The calculated probability of the given value 'x'.\n\n    Notes:\n        - Applicability: Used for normally distributed data, often in finance\n          for modelling returns, asset pricing, etc.\n        - Constraints: Assumes input data follows a normal distribution.\n        - Considerations: Probability is calculated for individual points and not \n          intervals or cumulative probability.\n    \"\"\"\n    import math\n\n    exponent = -((x - mean) ** 2) / (2 * std_dev ** 2)\n    probability = (1 / (math.sqrt(2 * math.pi) * std_dev)) * math.exp(exponent)\n    \n    return probability",
        "statistics": {
            "number_statistics": {
                "args_numbers": 3,
                "question_numbers": 1,
                "context_numbers": 3,
                "total_numbers": 4
            },
            "operator_statistics": {
                "operators": {
                    "+": 0,
                    "-": 2,
                    "*": 4,
                    "/": 2,
                    "%": 0,
                    "**": 2
                },
                "total_operators": 10
            },
            "code_statistics": {
                "lines": 4,
                "parentheses": 14
            }
        },
        "difficulty": 4.700480365792417,
        "context": "A stock market analyst is evaluating the performance of a company's stock returns, which are normally distributed with an average return (mean) of 5% per month and a standard deviation of 2% per month. The analyst is interested in determining the probability that the stock will return exactly 7% in the next month, to evaluate the likelihood of this specific return outperforming the average.",
        "question": "What is the probability that the company's stock will return exactly 7% in the next month? Answer as a probability to four decimal places.",
        "python_solution": "def solution():\n    import math\n    \n    # Define parameters\n    mean = 0.05  # 5% monthly return, expressed as a decimal\n    std_dev = 0.02  # 2% standard deviation, expressed as a decimal\n    x = 0.07  # 7% return, expressed as a decimal\n\n    # Calculate the probability using the normal distribution formula\n    exponent = -((x - mean) ** 2) / (2 * std_dev ** 2)\n    probability = (1 / (math.sqrt(2 * math.pi) * std_dev)) * math.exp(exponent)\n    \n    # Return the probability rounded to four decimal places\n    return round(probability, 4)\n\nsolution()",
        "ground_truth": 12.0985,
        "source": "FinanceReasoning-test-159",
        "question_id": "test-2120",
        "level": "hard",
        "output": [
            "To solve this problem, let\u2019s assess and decompose it step by step using the \"Emphasizing Constraints (EC)\" reasoning technique.\n\n### Problem Analysis\n1. **Given Details**:\n   - The stock returns are normally distributed with:\n     - Mean (\u00b5) = 5% per month (0.05 in decimal form)\n     - Standard deviation (\u03c3) = 2% per month (0.02 in decimal form)\n   - We are asked to compute the probability that the stock will return exactly 7% (0.07 in decimal form) in the next month.\n\n2. **Constraints**:\n   - Normal distributions are continuous probability distributions. The probability of a specific, exact value in a continuous distribution is effectively **zero** because it represents an infinitesimally small interval.\n   - Therefore, for any continuous distribution (e.g., normal distribution), the probability of the random variable being exactly equal to a specific value is \\( P(X = x) = 0 \\).\n   - We are constrained to output \\( P(X = 0.07) = 0.0000 \\) in line with the requirement to report to four decimal places.\n\n3. **Solution Approach**:\n   - Since this problem involves computing the probability of an exact value for a continuous distribution, the answer is zero. However, we will structure the solution to illustrate this reasoning for educational completeness.\n\n### Python Program Solution\nHere is the Python program implementing this reasoning:\n\n```python\ndef solution():\n    # Define variables for the normal distribution's parameters\n    mean = 0.05  # Mean of stock returns (5%)\n    std_dev = 0.02  # Standard deviation of stock returns (2%)\n    \n    # Define the specific return value we are calculating probability for\n    specific_return = 0.07  # 7% in decimal form\n    \n    # For a continuous normal distribution, the probability of a specific value is always 0\n    # because the area under the curve at a single point is negligible.\n    answer = 0.0000  # Probability of exactly 7%\n    \n    # Return the answer\n    return answer\n```"
        ],
        "retrieval_query": "What is the probability that the company's stock will return exactly 7% in the next month? Answer as a probability to four decimal places.",
        "useful_functions": [],
        "usage": {
            "completion_tokens": 444,
            "prompt_tokens": 430,
            "total_tokens": 874,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-2132",
        "article_title": "Lifetime Cost",
        "function": "def calculate_mortgage_cost(principal: float, annual_interest_rate: float, years: int) -> float:\n    \"\"\"\n    Calculate the total cost of a mortgage over its full term.\n\n    This function calculates the total cost of a mortgage by summing the \n    principal and the total interest paid over the loan term.\n\n    Args:\n        principal (float): The amount borrowed for the mortgage.\n        annual_interest_rate (float): The annual interest rate of the mortgage expressed as a decimal.\n        years (int): The term of the mortgage in years.\n\n    Returns:\n        total_mortgage_cost (float): The total cost of the mortgage, including principal and interest.\n\n    Notes:\n        - This function assumes a fixed interest rate and equal monthly payments throughout the loan term.\n        - Constraints: The interest rate should be greater than 0, and the number of years should be positive.\n        - Considerations: Does not include additional costs such as insurance, property taxes, or opportunity cost.\n    \"\"\"\n    monthly_interest_rate = annual_interest_rate / 12\n    number_of_payments = years * 12\n    monthly_payment = principal * (monthly_interest_rate * (1 + monthly_interest_rate) ** number_of_payments) / ((1 + monthly_interest_rate) ** number_of_payments - 1)\n\n    total_payment = monthly_payment * number_of_payments\n    total_mortgage_cost = total_payment\n\n    return total_mortgage_cost",
        "statistics": {
            "number_statistics": {
                "args_numbers": 3,
                "question_numbers": 1,
                "context_numbers": 3,
                "total_numbers": 4
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 1,
                    "*": 4,
                    "/": 2,
                    "%": 0,
                    "**": 2
                },
                "total_operators": 11
            },
            "code_statistics": {
                "lines": 6,
                "parentheses": 8
            }
        },
        "difficulty": 4.700480365792417,
        "context": "John is planning to buy a house and has been approved for a mortgage loan of $300,000. The loan comes with a fixed annual interest rate of 4.5%, and is structured over a period of 30 years. John wants to know the total cost he will incur over the term of the loan, including both the principal and interest payments, assuming no additional costs such as insurance or taxes.",
        "question": "What will be the total cost of John's mortgage over the entire 30-year term? Answer to the nearest dollar.",
        "python_solution": "def solution():\n    # Define parameters\n    principal = 300000  # Principal amount in dollars\n    annual_interest_rate = 0.045  # Annual interest rate as a decimal\n    years = 30  # Term of the mortgage in years\n    \n    # Perform calculations\n    monthly_interest_rate = annual_interest_rate / 12\n    number_of_payments = years * 12\n    monthly_payment = principal * (monthly_interest_rate * (1 + monthly_interest_rate) ** number_of_payments) / ((1 + monthly_interest_rate) ** number_of_payments - 1)\n    \n    total_payment = monthly_payment * number_of_payments\n    \n    # Return the final total mortgage cost, rounded to the nearest dollar\n    return round(total_payment)",
        "ground_truth": 547220,
        "source": "FinanceReasoning-test-164",
        "question_id": "test-2121",
        "level": "hard",
        "output": [
            "First, let's reason through the problem using the \"Emphasizing Constraints (EC)\" technique and clarify the key constraints and steps to solve this:\n\n### Constraints:\n1. **Loan Principal**: The amount borrowed is $300,000.\n2. **Annual Interest Rate**: 4.5% expressed as a decimal is 0.045.\n3. **Loan Term**: 30 years (360 months in total).\n4. **Monthly Payments**: We need to calculate the fixed monthly payments over the loan term.\n5. **Precision**: Total cost should be rounded to the nearest dollar.\n6. **Additional Costs**: No property taxes or insurance are considered.\n\n### Steps to Solve:\n1. **Calculate the fixed monthly payment**:\n   - Use the formula for calculating the fixed monthly payment for a fixed-rate loan:\n     \\[\n     M = P \\cdot \\frac{r \\cdot (1 + r)^n}{(1 + r)^n - 1}\n     \\]\n     where:\n     - \\( M \\): Monthly payment\n     - \\( P \\): Loan principal ($300,000)\n     - \\( r \\): Monthly interest rate (Annual Rate / 12)\n     - \\( n \\): Total number of payments (Loan Term in months)\n\n2. **Calculate total cost**:\n   - Multiply the monthly payment by the total number of payments:\n     \\[\n     \\text{Total Cost} = M \\cdot n\n     \\]\n\n3. **Return the total cost of the loan over the 30 years, rounded to the nearest dollar**.\n\nLet\u2019s implement the solution in Python:\n\n```python\ndef solution():\n    # Define variables name and value\n    principal = 300000  # Loan amount\n    annual_interest_rate = 0.045  # Annual interest rate in decimal\n    loan_term_years = 30  # Loan term in years\n    \n    # Calculate monthly interest rate\n    monthly_interest_rate = annual_interest_rate / 12\n    \n    # Calculate the total number of payments (months)\n    number_of_payments = loan_term_years * 12\n    \n    # Calculate the monthly payment using the loan formula\n    monthly_payment = (principal * monthly_interest_rate * (1 + monthly_interest_rate) ** number_of_payments) / \\\n                      ((1 + monthly_interest_rate) ** number_of_payments - 1)\n    \n    # Calculate the total cost of the loan\n    total_cost = monthly_payment * number_of_payments\n    \n    # Return the total cost rounded to the nearest dollar\n    return round(total_cost)\n```"
        ],
        "retrieval_query": "What will be the total cost of John's mortgage over the entire 30-year term? Answer to the nearest dollar.",
        "useful_functions": [
            "def calculate_mortgage_cost(principal: float, annual_interest_rate: float, years: int) -> float:\n    \"\"\"\n    Calculate the total cost of a mortgage over its full term.\n\n    This function calculates the total cost of a mortgage by summing the \n    principal and the total interest paid over the loan term.\n\n    Args:\n        principal (float): The amount borrowed for the mortgage.\n        annual_interest_rate (float): The annual interest rate of the mortgage expressed as a decimal.\n        years (int): The term of the mortgage in years.\n\n    Returns:\n        total_mortgage_cost (float): The total cost of the mortgage, including principal and interest.\n\n    Notes:\n        - This function assumes a fixed interest rate and equal monthly payments throughout the loan term.\n        - Constraints: The interest rate should be greater than 0, and the number of years should be positive.\n        - Considerations: Does not include additional costs such as insurance, property taxes, or opportunity cost.\n    \"\"\"\n    monthly_interest_rate = annual_interest_rate / 12\n    number_of_payments = years * 12\n    monthly_payment = principal * (monthly_interest_rate * (1 + monthly_interest_rate) ** number_of_payments) / ((1 + monthly_interest_rate) ** number_of_payments - 1)\n\n    total_payment = monthly_payment * number_of_payments\n    total_mortgage_cost = total_payment\n\n    return total_mortgage_cost",
            "def calculate_savings_from_float_down(original_rate: float, new_rate: float, loan_amount: float, loan_term_years: int, float_down_fee_percent: float) -> float:\n    \"\"\"\n    Calculate the potential savings from exercising a mortgage rate lock float down option.\n\n    This function computes the savings a borrower could realize by opting for the \n    float down in the mortgage rate during the underwriting process, considering \n    the fee paid for the option.\n\n    Args:\n        original_rate (float): The initially locked interest rate (e.g., 4.25% as 0.0425).\n        new_rate (float): The new, lower interest rate available during float down (e.g., 3.80% as 0.0380).\n        loan_amount (float): The total loan amount in currency units.\n        loan_term_years (int): The term of the loan in years (e.g., 30 for a 30-year mortgage).\n        float_down_fee_percent (float): The cost of the float down option as a percentage (e.g., 0.5 for 0.5%).\n\n    Returns:\n        savings (float): The total savings from the reduced mortgage rate over the loan term, \n                         minus the cost of the float down option.\n\n    Notes:\n        - Applicability: This function is applicable for fixed-rate mortgages with a float down \n          option during the lock-in period.\n        - Constraints: Assumes constant principal and interest payment throughout the loan term.\n        - Considerations: Ensure that savings exceed the float down fee to make the float down \n          financially worthwhile.\n    \"\"\"\n    import math\n\n    # Calculate monthly payments for original and new rates\n    def monthly_payment(rate, n_periods, principal):\n        return principal * rate / (1 - (1 + rate) ** -n_periods)\n\n    # Convert annual rates to monthly rates\n    original_monthly_rate = original_rate / 12\n    new_monthly_rate = new_rate / 12\n\n    # Total number of payments\n    total_payments = loan_term_years * 12\n\n    # Calculate monthly payments\n    original_payment = monthly_payment(original_monthly_rate, total_payments, loan_amount)\n    new_payment = monthly_payment(new_monthly_rate, total_payments, loan_amount)\n\n    # Calculate savings in monthly payments over the loan term\n    total_payment_savings = (original_payment - new_payment) * total_payments\n\n    # Calculate the cost of the float down option as a flat fee\n    float_down_cost = loan_amount * (float_down_fee_percent / 100)\n\n    # Calculate net savings\n    savings = total_payment_savings - float_down_cost\n\n    return savings"
        ],
        "usage": {
            "completion_tokens": 534,
            "prompt_tokens": 1296,
            "total_tokens": 1830,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "Martinez took over a Spanish packaging firm. The Spanish venture involved Martinez purchasing 200,000 shares of a packaging firm at EUR90 per share. He resolved to fully secure the position with a six-month USD/EUR forward agreement. Given Exhibit 1, if the Spanish shares were sold after three months, what would have been the cash expenditure (in US dollars) necessary to terminate the forward agreement? Answer to a single decimal place.",
        "python_solution": "def solution():\n    initial_position_eur = 200000 * 90\n    six_month_forward_rate = 1.3935 - 19 / 10000\n    three_month_forward_rate = 1.4210 - 21 / 10000\n    cash_outflow_at_settlement = initial_position_eur * (three_month_forward_rate - six_month_forward_rate)\n    dollar_libor_rate = 0.01266\n    cash_expenditure = cash_outflow_at_settlement / (1 + dollar_libor_rate * 90 / 360)\n    return int(cash_expenditure)",
        "ground_truth": 489849.0,
        "topic": "Asset Classes & Derivatives",
        "statistics": {
            "number_statistics": {
                "args_numbers": 4,
                "question_numbers": 2,
                "context_numbers": 22,
                "total_numbers": 24
            },
            "operator_statistics": {
                "operators": {
                    "+": 1,
                    "-": 3,
                    "*": 3,
                    "/": 4,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 11
            },
            "code_statistics": {
                "lines": 7,
                "parentheses": 6
            }
        },
        "difficulty": 4.700480365792417,
        "source": "FinanceMath-validation-3",
        "context": "['| Maturity          | At Initiation    | Three Months  Later | At Maturity   |\\n|-----------------  |----------------- |---------------------|---------------|\\n| Spot (USD/EUR)    | 1.3935/1.3983    | 1.4106/1.4210       | 1.4189/1.4289 |\\n| 3-month forward   | -8.1/-7.6        | -21.6/-21.0         |               |\\n| 6-month forward   | -19.0/-18.3      |                     | -27.0/-26.2   |\\n| USD Libor         | 1.266%           | 1.266%              | 1.266%        |\\n| EUR Libor         | 1.814%           | 1.814%              | 1.814%        |']",
        "question_id": "test-2122",
        "level": "hard",
        "output": [
            "To determine the cash expenditure (in USD) necessary to terminate the forward agreement, here's a step-by-step breakdown applying the Emphasizing Constraints (EC) reasoning technique:\n\n---\n\n### Step 1: Understand the Question and Constraints\n- The forward agreement is a **six-month USD/EUR forward agreement**.\n- Martinez is selling 200,000 shares, each at EUR90 = EUR18,000,000 in total.\n- We need to calculate the cost of terminating the forward agreement **after three months**.\n- **Tracking evolution**: At three months, the three-month forward rate needs to be used since:\n  - After three months of a six-month forward start, three months remain.\n  - The rate to use will therefore align precisely with the \"Three Months Later\" row from the table.\n- Forward rates are in \"discount terms.\" To convert this to the forward exchange rate:\n  ```plaintext\n  Forward exchange rate (bid/ask) = Spot rate - Forward discount\n  ```\n- The cash expenditure must be in USD, using the forward rate at \"Three Months Later.\"\n- Answer to **1 decimal place**, adhering to precision constraints.\n\n### Step 2: Determine the Relevant Forward Rate\nAt three months, the \"Three Months Later\" three-month forward discount is:\n  - Bid = -21.6\n  - Ask = -21.0\n\nThe corresponding spot USD/EUR rates from the table are:\n  - Bid = 1.4106\n  - Ask = 1.4210\n\nThe relevant forward USD/EUR rate after three months will be:\n  ```plaintext\n  Forward bid rate = Spot bid - Forward bid discount\n  Forward ask rate = Spot ask - Forward ask discount\n  ```\n\n### Step 3: Calculate the Forward Bid/Ask Rate at Termination\nIn this situation:\n  - Forward bid rate (three months later) = Spot bid (1.4106) - (Forward bid/10,000)\n  - Forward ask rate (three months later) = Spot ask (1.4210) - (Forward ask/10,000)\n\nThe division by 10,000 is because forward discounts are stated in basis points (bps).\n\n### Step 4: Convert EUR18,000,000 to USD\nTo ensure alignment with proper risk management practices, Martinez will compute the cash expenditure:\n- Cash expenditure in USD = EUR18,000,000 \u00d7 **Forward ask rate** (since terminating the contract involves selling EUR).\n\n---\n\n### Python Program Implementation\nThe below Python program captures the above logic step-by-step, adhering to the constraints and ensuring proper handling of precision:\n\n```python\ndef solution():\n    # Define constants and values from the table\n    eur_shares = 200000       # Number of shares\n    eur_per_share = 90        # Price per share in EUR\n    total_eur_value = eur_shares * eur_per_share  # Total EUR expenditure is 200,000 * 90\n    \n    # Spot and forward rates (Three Months Later row)\n    spot_bid = 1.4106\n    spot_ask = 1.4210\n    forward_bid_discount = -21.6  # forward bid discount in bps\n    forward_ask_discount = -21.0  # forward ask discount in bps\n    \n    # Convert forward discounts from bps to spot currency adjustment\n    forward_bid = spot_bid - (forward_bid_discount / 10000)\n    forward_ask = spot_ask - (forward_ask_discount / 10000)\n    \n    # Calculate cash expenditure in USD using the forward ask rate\n    cash_expenditure_usd = total_eur_value * forward_ask  # Termination cost uses forward ask rate\n    \n    # Return the value rounded to one decimal place\n    return round(cash_expenditure_usd, 1)\n\n```\n\n### Explanation of the Code\n1. **EUR Value**: Compute the total EUR position Martinez holds (shares \u00d7 price/share).\n2. **Forward Rate**: Adjust the forward discount for both bid and ask rates.\n3. **Cash Expenditure in USD**: Convert the EUR value to USD using the ask rate at termination (as Martinez is selling EUR).\n4. **Precision**: Ensure the returned value is expressed to **1 decimal place**.\n\nWhen executed, this program will calculate the cash required in USD to terminate the forward contract after three months."
        ],
        "retrieval_query": "Martinez took over a Spanish packaging firm. The Spanish venture involved Martinez purchasing 200,000 shares of a packaging firm at EUR90 per share. He resolved to fully secure the position with a six-month USD/EUR forward agreement. Given Exhibit 1, if the Spanish shares were sold after three months, what would have been the cash expenditure (in US dollars) necessary to terminate the forward agreement? Answer to a single decimal place.",
        "useful_functions": [
            "def calculate_discount_margin(present_value: float, index_rate: float, quoted_margin: float, face_value: float, semiannual_periods: int, annual_yield: float) -> float:\n    \"\"\"\n    Calculate the discount margin for a bond in basis points (bps).\n\n    This function computes the discount margin for a two-year floating-rate bond \n    based on its present value, current index rate (e.g., LPR), added quoted margin, \n    face value, number of semiannual periods, and annual yield. The result is expressed \n    in basis points (bps).\n\n    Args:\n        present_value (float): The current price of the bond for every unit of face value.\n        index_rate (float): The current 6-month lending prime rate (e.g., LPR) expressed as a decimal.\n        quoted_margin (float): The quoted margin above the index rate, expressed as a decimal.\n        face_value (float): The face value of the bond.\n        semiannual_periods (int): Number of semiannual periods (e.g., 2 for a two-year bond).\n        annual_yield (float): The current annual yield expressed as a decimal.\n\n    Returns:\n        discount_margin (float): The discount margin in basis points (bps).\n\n    Notes:\n        - Applicability: This function is applicable for bonds with floating rates based on an index rate.\n        - Constraints: The annual yield, index rate, and quoted margin should be provided as decimals.\n        - Considerations: Ensure that the calculated yield is correct and in the desired format (bps).\n    \"\"\"\n    discount_margin_decimal = (annual_yield - index_rate) / semiannual_periods\n    discount_margin_bps = discount_margin_decimal * 10000\n    \n    return discount_margin_bps"
        ],
        "usage": {
            "completion_tokens": 907,
            "prompt_tokens": 984,
            "total_tokens": 1891,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "Assuming the same series of spot rates, what is the cost of a 3-year bond that provides an annual interest payment at a 10% coupon rate, and has a face value of 100? Answer to three decimal places.",
        "python_solution": "def solution():\n    Z1, Z2, Z3, PMT, FV = 0.08, 0.09, 0.095, 10, 100\n    PV1 = PMT / (1 + Z1)\n    PV2 = PMT / (1 + Z2)**2\n    PV3 = (PMT + FV) / (1 + Z3)**3\n    PV = PV1 + PV2 + PV3\n    return PV",
        "ground_truth": 101.458,
        "topic": "Asset Classes & Derivatives",
        "statistics": {
            "number_statistics": {
                "args_numbers": 4,
                "question_numbers": 3,
                "context_numbers": 6,
                "total_numbers": 9
            },
            "operator_statistics": {
                "operators": {
                    "+": 6,
                    "-": 0,
                    "*": 0,
                    "/": 3,
                    "%": 0,
                    "**": 2
                },
                "total_operators": 11
            },
            "code_statistics": {
                "lines": 6,
                "parentheses": 8
            }
        },
        "difficulty": 4.700480365792417,
        "source": "FinanceMath-validation-82",
        "context": "['| Time-to- Maturity | Spot Rates |\\n| --- | --- |\\n| 1 year | 8.0% |\\n| 2 years | 9.0% |\\n| 3 years | 9.5% |']",
        "question_id": "test-2123",
        "level": "hard",
        "output": [
            "Let's solve the given problem step by step.\n\n---\n\n### Reasoning Approach: Emphasizing Constraints (EC)\n#### The following constraints must be adhered to:\n1. The bond's annual cash flows, including coupon payments and final maturity value, need to be calculated.\n2. The present value of each cash flow must be determined by discounting it with the respective spot rate for that year.\n3. Ensure **three decimal places** precision in the final answer.\n4. Spot rates are provided as percentages; these must be converted to decimals for calculations.\n\n---\n\n### Problem Analysis\n1. The bond has a **3-year maturity**, a **10% coupon rate**, and a **face value of 100**.\n    - Coupon payments = \\( \\text{face value} \\times \\text{coupon rate} = 100 \\times 0.10 = 10 \\) annually.\n    - Final year cash flow includes the face value and the last coupon payment \\( 110 \\).\n\n2. **Spot Rates** for each year:\n    - 1-year spot rate = 8.0% = 0.08.\n    - 2-year spot rate = 9.0% = 0.09.\n    - 3-year spot rate = 9.5% = 0.095.\n\n3. For each year, calculate the present value (\\( PV \\)) of the cash flow:\n    \\[\n    PV = \\frac{\\text{Cash Flow}}{(1 + \\text{Spot Rate})^{\\text{Year}}}\n    \\]\n\n4. Sum up the present values for all 3 years to get the bond price.\n\n5. Round the final bond price to **three decimal places**.\n\n---\n\n### Step-by-Step Solution\n- **Year 1**: \\( PV_1 = \\frac{10}{(1 + 0.08)^1} \\)\n- **Year 2**: \\( PV_2 = \\frac{10}{(1 + 0.09)^2} \\)\n- **Year 3**: \\( PV_3 = \\frac{110}{(1 + 0.095)^3} \\)\n- Total bond price = \\( PV_1 + PV_2 + PV_3 \\).\n\nNow, let's write the Python program to calculate the bond price.\n\n---\n\n```python\ndef solution():\n    # Define variables\n    face_value = 100.0  # Face value of the bond\n    coupon_rate = 0.10  # Annual coupon rate (10% as a decimal)\n    spot_rates = [0.08, 0.09, 0.095]  # Spot rates for 1, 2, and 3 years\n    maturity = 3  # Bond maturity period in years\n\n    # Calculate bond price\n    bond_price = 0.0\n    for i in range(maturity):\n        # Cash flow for each year\n        if i == maturity - 1:  # Last year includes face value in addition to coupon payment\n            cash_flow = (coupon_rate * face_value) + face_value\n        else:\n            cash_flow = coupon_rate * face_value\n        \n        # Discount the cash flow to present value\n        bond_price += cash_flow / ((1 + spot_rates[i]) ** (i + 1))\n    \n    # Return bond price rounded to three decimal places\n    return round(bond_price, 3)\n```"
        ],
        "retrieval_query": "Assuming the same series of spot rates, what is the cost of a 3-year bond that provides an annual interest payment at a 10% coupon rate, and has a face value of 100? Answer to three decimal places.",
        "useful_functions": [
            "def calculate_bond_price(face_value: float, coupon_rate: float, years: int, spot_rates: list) -> float:\n    \"\"\"\n    Calculate the price of a bond using its face value, annual coupon rate, and spot rates for each year.\n\n    This function computes the present value of the bond's future cash flows, \n    which include regular coupon payments and the face value at maturity. Each \n    cash flow is discounted using the specified spot rate for its corresponding year.\n\n    Args:\n        face_value (float): The face value of the bond.\n        coupon_rate (float): The annual coupon rate of the bond as a decimal (e.g., 0.05 for 5%).\n        years (int): The number of years until the bond matures.\n        spot_rates (list): A list of annual spot rates as decimals (one for each year up to maturity).\n\n    Returns:\n        bond_price (float): The calculated price of the bond.\n\n    Notes:\n        - Applicability: This function is used for bonds with annual coupon payments.\n        - Constraints: The length of spot_rates must equal the number of years.\n        - Considerations: Ensure that spot_rates contain realistic values \n          (greater than -1) to prevent calculation errors in the discounting process.\n    \"\"\"\n    if len(spot_rates) != years:\n        raise ValueError(\"The number of spot rates must match the number of years.\")\n\n    bond_price = 0.0\n    coupon_payment = face_value * coupon_rate\n\n    for year in range(1, years + 1):\n        cash_flow = coupon_payment\n        if year == years:\n            cash_flow += face_value  # Add face value at maturity\n        bond_price += cash_flow / ((1 + spot_rates[year - 1]) ** year)\n\n    return round(bond_price, 2)",
            "def calculate_bond_price(spot_rates: list, coupon_rate: float, face_value: float, maturity: int) -> float:\n    \"\"\"\n    Calculate the price of a bond given its spot rates, coupon rate, and face value.\n\n    This function computes the present value of a bond's cash flows using a list\n    of spot rates for each year until maturity, a fixed coupon rate, and the face\n    value of the bond. The price of the bond is the sum of all discounted future\n    cash flows.\n\n    Args:\n        spot_rates (list): A list of annual spot rates as floats, each representing\n                           the rate for a specific year until the bond matures.\n        coupon_rate (float): The annual coupon rate of the bond as a decimal (e.g., 0.1\n                             for 10%).\n        face_value (float): The face value of the bond.\n        maturity (int): The maturity of the bond in years.\n\n    Returns:\n        bond_price (float): The present value of the bond's cash flows.\n\n    Notes:\n        - Applicability: Use for bonds with annual coupons and face value payable at maturity.\n        - Constraints: The length of spot_rates should be equal to the maturity of the bond.\n        - Considerations: Ensure that spot rates are provided as decimals and represent annual rates.\n    \"\"\"\n    if len(spot_rates) != maturity:\n        raise ValueError(\"The length of spot_rates must match the bond's maturity.\")\n\n    bond_price = 0.0\n    for i in range(maturity):\n        cash_flow = coupon_rate * face_value if i < maturity - 1 else (coupon_rate * face_value + face_value)\n        bond_price += cash_flow / ((1 + spot_rates[i]) ** (i + 1))\n        \n    return bond_price"
        ],
        "usage": {
            "completion_tokens": 710,
            "prompt_tokens": 1194,
            "total_tokens": 1904,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "What percentage of the total leased locations are in Texas? Answer to three decimal places.",
        "context": "we are not under any obligation ( and expressly disclaim any such obligation ) to update or alter our forward- looking statements , whether as a result of new information , future events or otherwise . you should carefully consider the possibility that actual results may differ materially from our forward-looking statements . item 1b . unresolved staff comments . item 2 . properties . our corporate headquarters are located in jacksonville , florida , in an owned facility . fnf occupies and pays us rent for approximately 121000 square feet in this facility . we lease office space as follows : number of locations ( 1 ) .\n\n| State | Number of   Locations(1) |\n| :--- | :--- |\n| California | 57 |\n| Florida | 26 |\n| Georgia | 22 |\n| Texas | 19 |\n| Minnesota, New York | 9 |\n| Illinois, Ohio, Maryland | 8 |\n| Pennsylvania | 7 |\n| Other | 63 |\n\n( 1 ) represents the number of locations in each state listed . we also lease approximately 81 locations outside the united states . we believe our properties are adequate for our business as presently conducted . item 3 . legal proceedings . in the ordinary course of business , we are involved in various pending and threatened litigation matters related to our operations , some of which include claims for punitive or exemplary damages . we believe that no actions , other than the matters listed below , depart from customary litigation incidental to our business . as background to the disclosure below , please note the following : 2022 these matters raise difficult and complicated factual and legal issues and are subject to many uncertainties and complexities . 2022 we review these matters on an on-going basis and follows the provisions of statement of financial accounting standards ( 201csfas 201d ) no . 5 , 201caccounting for contingencies , 201d when making accrual and disclosure decisions . when assessing reasonably possible and probable outcomes , we base our decision on our assessment of the ultimate outcome following all appeals . the company and certain of its employees were named on march 6 , 2006 as defendants in a civil lawsuit brought by grace & digital information technology co. , ltd . ( 201cgrace 201d ) , a chinese company that formerly acted as a sales agent for alltel information services ( 201cais 201d ) . grace originally filed suit in december 2004 in state court in monterey county , california , alleging that the company breached a sales agency agreement by failing to pay commissions associated with sales contracts signed in 2001 and 2003 . the 2001 contracts were never completed . the 2003 contracts , as to which grace provided no assistance , were for a different project and were executed one and one-half years after grace 2019s sales agency agreement was terminated . in addition to its breach of contract claim , grace also alleged that the company violated the foreign corrupt practices act ( fcpa ) in its dealings with a bank customer in china . the company denied grace 2019s allegations in this california lawsuit. .\n",
        "statistics": {
            "number_statistics": {
                "question_numbers": 0,
                "context_numbers": 16,
                "total_numbers": 16
            },
            "operator_statistics": {
                "operators": {
                    "+": 8,
                    "-": 0,
                    "*": 1,
                    "/": 1,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 10
            },
            "code_statistics": {
                "lines": 8,
                "parentheses": 6
            }
        },
        "difficulty": 4.700480365792417,
        "ground_truth": 6.507,
        "source": "CodeFinQA-test-37",
        "python_solution": "# Number of leased locations in Texas\nleased_locations_texas = 19  \n\n# Total leased locations (sum of all states and international locations)\ntotal_leased_locations = 57 + 26 + 22 + 19 + 9 + 8 + 7 + 63 + 81  \n\n# Calculate percentage\npercent_texas = (leased_locations_texas / total_leased_locations) * 100  \n\n# Round to three decimal places\nanswer = round(percent_texas, 3)",
        "question_id": "test-2124",
        "level": "hard",
        "output": [
            "To determine the percentage of total leased locations that are in Texas, we need to execute the following steps:\n\n**Step-by-step breakdown:**\n\n1. **Understand the data and the constraint:**\n   - From the table, Texas has 19 locations.\n   - Other locations are provided for different states and groups. We need to calculate the total number of leased locations.\n   - There is a constraint to answer the percentage to **three decimal places**.\n\n2. **Additional Consideration:**\n   - Apart from U.S. locations, there are also **81 leased locations outside the United States**. These should be included in the count of \"total leased locations.\"\n\n3. **Calculation Plan:**\n   - Add all U.S. state-based locations and 81 international locations to get the **total leased locations**.\n   - Compute the percentage of locations in Texas as:  \n     \\[\n     \\text{Percentage} = \\left( \\frac{\\text{Texas locations}}{\\text{Total locations}} \\right) \\times 100\n     \\]\n   - Round the result to three decimal places.\n\nNow let's implement these steps in Python:\n\n```python\ndef solution():\n    # Define variables: number of leased locations in each category\n    texas_locations = 19\n    california_locations = 57\n    florida_locations = 26\n    georgia_locations = 22\n    min_ny_locations = 9\n    ill_oh_md_locations = 8\n    pennsylvania_locations = 7\n    other_locations = 63\n    international_locations = 81  # Outside the United States\n    \n    # Calculate total leased locations\n    total_locations = (california_locations + florida_locations + georgia_locations + \n                       texas_locations + min_ny_locations + ill_oh_md_locations + \n                       pennsylvania_locations + other_locations + international_locations)\n    \n    # Calculate the percentage of locations in Texas\n    texas_percentage = (texas_locations / total_locations) * 100\n    \n    # Return the result rounded to three decimal places\n    return round(texas_percentage, 3)\n\n```"
        ],
        "retrieval_query": "What percentage of the total leased locations are in Texas? Answer to three decimal places.",
        "useful_functions": [],
        "usage": {
            "completion_tokens": 429,
            "prompt_tokens": 964,
            "total_tokens": 1393,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-365",
        "article_title": "Incentive Stock Options (ISOs)",
        "function": "def is_qualifying_disposition(grant_date: str, exercise_date: str, sale_date: str) -> bool:\n    \"\"\"\n    Determine if the sale of stocks under ISOs qualifies for favorable tax treatment.\n\n    A sale qualifies for favorable long-term capital gains tax treatment \n    if the stock is held for more than one year from the exercise date (sale_condition)\n    and more than two years from the grant date (grant_condition).\n\n    Args:\n        grant_date (str): The date when the stock options were granted.\n                           Expected format: 'YYYY-MM-DD'.\n        exercise_date (str): The date when the stock options were exercised.\n                             Expected format: 'YYYY-MM-DD'.\n        sale_date (str): The date when the stock options were sold.\n                         Expected format: 'YYYY-MM-DD'.\n\n    Returns:\n        is_qualifying (bool): Returns True if qualifying disposition conditions are met,\n                              otherwise returns False.\n\n    Notes:\n        - Applicability: Useful for determining tax implications of ISO sales.\n        - Constraints: Dates must be in 'YYYY-MM-DD' format.\n        - Considerations: Does not consider potential changes in tax law or other personal factors.\n    \"\"\"\n    from datetime import datetime\n\n    def parse_date(date_str):\n        return datetime.strptime(date_str, '%Y-%m-%d')\n\n    grant_date_parsed = parse_date(grant_date)\n    exercise_date_parsed = parse_date(exercise_date)\n    sale_date_parsed = parse_date(sale_date)\n\n    sale_condition = (sale_date_parsed - exercise_date_parsed).days > 365\n    grant_condition = (sale_date_parsed - grant_date_parsed).days > 730\n\n    return sale_condition and grant_condition",
        "statistics": {
            "number_statistics": {
                "args_numbers": 6,
                "question_numbers": 0,
                "context_numbers": 3,
                "total_numbers": 3
            },
            "operator_statistics": {
                "operators": {
                    "+": 0,
                    "-": 4,
                    "*": 0,
                    "/": 0,
                    "%": 3,
                    "**": 0
                },
                "total_operators": 7
            },
            "code_statistics": {
                "lines": 9,
                "parentheses": 14
            }
        },
        "difficulty": 4.718498871295094,
        "context": "Jessica was granted incentive stock options (ISOs) by her company. The grant date of these options was January 15, 2021. She exercised her options on February 20, 2022. On May 5, 2023, she decided to sell the stocks she acquired through these options. Jessica is interested in understanding if this sale will qualify for favorable long-term capital gains tax treatment. For qualification, the stocks must be held for more than one year from the exercise date and more than two years from the grant date.",
        "question": "Does Jessica's sale of her incentive stock options qualify for favorable long-term capital gains tax treatment? Answer with \"True\" if it qualifies, otherwise \"False\".",
        "python_solution": "def solution():\n    from datetime import datetime\n\n    # Dates provided\n    grant_date = '2021-01-15'\n    exercise_date = '2022-02-20'\n    sale_date = '2023-05-05'\n\n    # Parse the dates\n    grant_date_parsed = datetime.strptime(grant_date, '%Y-%m-%d')\n    exercise_date_parsed = datetime.strptime(exercise_date, '%Y-%m-%d')\n    sale_date_parsed = datetime.strptime(sale_date, '%Y-%m-%d')\n\n    # Conditions for qualifying disposition\n    sale_condition = (sale_date_parsed - exercise_date_parsed).days > 365\n    grant_condition = (sale_date_parsed - grant_date_parsed).days > 730\n\n    # Determine if the sale qualifies\n    is_qualifying = sale_condition and grant_condition\n\n    # Return the result\n    return is_qualifying",
        "ground_truth": true,
        "source": "FinanceReasoning-test-78",
        "question_id": "test-2125",
        "level": "hard",
        "output": [
            "To determine whether Jessica's sale of her incentive stock options qualifies for favorable long-term capital gains tax treatment, we need to verify two conditions provided in the problem constraints:\n\n1. **More than one year from the exercise date:** \n   - Jessica exercised the stock options on February 20, 2022.\n   - She sold the stocks on May 5, 2023.\n   - The difference between the sale date and the exercise date must exceed one year.\n\n2. **More than two years from the grant date:** \n   - Jessica was granted the stock options on January 15, 2021.\n   - She sold the stocks on May 5, 2023.\n   - The difference between the sale date and the grant date must exceed two years.\n\nBy calculating and confirming both time constraints step-by-step, we can determine whether this sale qualifies for favorable long-term capital gains tax treatment.\n\n### Python Program:\n```python\nfrom datetime import datetime\n\ndef solution():\n    # Define the critical dates\n    grant_date = datetime(2021, 1, 15)\n    exercise_date = datetime(2022, 2, 20)\n    sale_date = datetime(2023, 5, 5)\n    \n    # Calculate the time differences\n    time_since_exercise = (sale_date - exercise_date).days\n    time_since_grant = (sale_date - grant_date).days\n    \n    # Check the constraints\n    condition_1 = time_since_exercise > 365  # More than one year since exercise\n    condition_2 = time_since_grant > 2 * 365  # More than two years since grant\n    \n    # Return True if both conditions are satisfied, otherwise False\n    return condition_1 and condition_2\n```"
        ],
        "retrieval_query": "Does Jessica's sale of her incentive stock options qualify for favorable long-term capital gains tax treatment? Answer with \"True\" if it qualifies, otherwise \"False\".",
        "useful_functions": [],
        "usage": {
            "completion_tokens": 364,
            "prompt_tokens": 469,
            "total_tokens": 833,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-2378",
        "article_title": "Autocorrelation",
        "function": "def calculate_autocorrelation(time_series: list, lag: int) -> float:\n    \"\"\"\n    Calculate the autocorrelation of a time series at a specified lag.\n\n    This function computes the autocorrelation of a time series for a given lag.\n    Autocorrelation measures the linear relationship between current values and lagged values of the same series.\n\n    Args:\n        time_series (list): A list of numeric values representing the time series.\n        lag (int): The number of lag periods to consider. Must be a non-negative integer.\n\n    Returns:\n        autocorrelation (float): The autocorrelation coefficient, ranging from -1 to +1.\n\n    Notes:\n        - Applicability: Useful in financial analysis to identify momentum or trends within a time series.\n        - Constraints: The time series must contain enough data points to apply the lag.\n                       The function assumes evenly spaced time intervals.\n        - Considerations: Autocorrelation can indicate non-independence in a series, which might affect model assumptions.\n    \"\"\"\n    if lag < 0:\n        raise ValueError(\"Lag must be a non-negative integer.\")\n    if len(time_series) <= lag:\n        raise ValueError(\"Time series must contain more data points than the lag value.\")\n\n    mean = sum(time_series) / len(time_series)\n    numerator = sum((time_series[i] - mean) * (time_series[i - lag] - mean) for i in range(lag, len(time_series)))\n    denominator = sum((x - mean) ** 2 for x in time_series)\n\n    autocorrelation = numerator / denominator if denominator != 0 else 0\n\n    return autocorrelation",
        "statistics": {
            "number_statistics": {
                "args_numbers": 2,
                "question_numbers": 0,
                "context_numbers": 14,
                "total_numbers": 14
            },
            "operator_statistics": {
                "operators": {
                    "+": 0,
                    "-": 4,
                    "*": 1,
                    "/": 2,
                    "%": 0,
                    "**": 1
                },
                "total_operators": 8
            },
            "code_statistics": {
                "lines": 5,
                "parentheses": 18
            }
        },
        "difficulty": 4.718498871295094,
        "context": "A financial analyst is examining the quarterly returns of a specific stock over the past 12 quarters to identify potential patterns or trends. The analyst is particularly interested in determining the first-order autocorrelation of the returns, which could indicate potential momentum in the stock's performance. The returns for these 12 quarters are as follows: [5%, 3%, 8%, 2%, 7%, 3%, 6%, 4%, 5%, 7%, 6%, 4%]. The analyst wants to understand how the current return is related to the return in the previous quarter.",
        "question": "What is the first-order autocorrelation of the quarterly returns of this stock? Provide your answer rounded to four decimal places.",
        "python_solution": "def solution():\n    # Define the time series data (returns as percentages) and lag\n    time_series = [0.05, 0.03, 0.08, 0.02, 0.07, 0.03, 0.06, 0.04, 0.05, 0.07, 0.06, 0.04]\n    lag = 1\n\n    # Calculate the mean of the time series\n    mean = sum(time_series) / len(time_series)\n\n    # Calculate the numerator of the autocorrelation formula\n    numerator = sum((time_series[i] - mean) * (time_series[i - lag] - mean) for i in range(lag, len(time_series)))\n\n    # Calculate the denominator of the autocorrelation formula\n    denominator = sum((x - mean) ** 2 for x in time_series)\n\n    # Calculate the autocorrelation\n    autocorrelation = numerator / denominator if denominator != 0 else 0\n\n    # Return the autocorrelation rounded to four decimal places\n    return round(autocorrelation, 4)\n\n# Execute the solution function to obtain the result\nprint(solution())",
        "ground_truth": -0.7105,
        "source": "FinanceReasoning-test-177",
        "question_id": "test-2126",
        "level": "hard",
        "output": [
            "### Step-by-step Thinking:\n\n1. **Emphasize Constraints:**\n   - **Constraint 1:** The input data consists of quarterly stock returns specified as percentages. \n   - **Constraint 2:** To properly compute correlations, the returns should first be converted to decimal format.\n   - **Constraint 3:** Follow the definition of first-order autocorrelation, which measures the correlation between each return and its next-lagged value.\n   - **Constraint 4:** The result must be rounded to four decimal places.\n\n2. **Steps for Calculation:**\n   - Convert the percentage returns to decimals (i.e., divide by 100).\n   - Compute the mean of the returns (\u00b5).\n   - Use the formula for lag-1 autocorrelation:\n     \\[\n     r = \\frac{\\sum_{i=1}^{n-1} (x_i - \\mu) (x_{i+1} - \\mu)}{\\sum_{i=1}^n (x_i - \\mu)^2}\n     \\]\n     - Numerator: Compute the covariance between the current returns and the lagged returns.\n     - Denominator: Variance of the returns.\n\n3. **Consider the Number of Observations:**\n   - Since you're calculating lag-1 autocorrelation, you'll lose one element (first return does not have a previous return).\n\n4. **Output Constraint:**\n   - The result should be rounded to 4 decimal places.\n\n---\n\n### Python Program:\n```python\ndef solution():\n    # Define variables: quarterly returns in percentage values\n    returns_percentage = [5, 3, 8, 2, 7, 3, 6, 4, 5, 7, 6, 4]\n    \n    # Convert percentages to decimals\n    returns = [r / 100 for r in returns_percentage]\n    \n    # Calculate the mean of the returns\n    mean_return = sum(returns) / len(returns)\n    \n    # Compute the numerator (covariance)\n    numerator = sum((returns[i] - mean_return) * (returns[i+1] - mean_return) for i in range(len(returns) - 1))\n    \n    # Compute the denominator (variance)\n    denominator = sum((ret - mean_return) ** 2 for ret in returns)\n    \n    # Calculate first-order autocorrelation\n    autocorrelation = numerator / denominator\n    \n    # Return the autocorrelation rounded to four decimal places\n    return round(autocorrelation, 4)\n\n```"
        ],
        "retrieval_query": "What is the first-order autocorrelation of the quarterly returns of this stock? Provide your answer rounded to four decimal places.",
        "useful_functions": [],
        "usage": {
            "completion_tokens": 517,
            "prompt_tokens": 468,
            "total_tokens": 985,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-2419",
        "article_title": "Johannesburg Interbank Average Rate (JIBAR)",
        "function": "def calculate_jibar_rate(bid_rates: list, offer_rates: list) -> float:\n    \"\"\"\n    Calculate the Johannesburg Interbank Average Rate (JIBAR) based on bid and offer rates.\n\n    This function computes the JIBAR by averaging the mid-rates derived from bid\n    and offer rates submitted by participating banks, after excluding the two highest\n    and two lowest mid-rates.\n\n    Args:\n        bid_rates (list): A list of bid rates from banks.\n        offer_rates (list): A list of offer rates from banks.\n\n    Returns:\n        jibar_rate (float): The calculated JIBAR rate.\n\n    Notes:\n        - Applicability: This function is applicable to calculate the JIBAR based on\n          rates submitted by multiple banks.\n        - Constraints: The input lists must have the same length and contain at least\n          8 rates each, as 8 banks are involved in the submission.\n        - Considerations: Ensure that bid and offer rates are correctly paired, and\n          input lists are pre-sorted if necessary, although sorting is not obligatory.\n    \"\"\"\n    if len(bid_rates) != len(offer_rates) or len(bid_rates) < 8:\n        raise ValueError(\"Each list must contain at least 8 rates and be of equal length.\")\n\n    # Calculate mid-rates as the halfway point between bid and offer rates\n    mid_rates = [(bid + offer) / 2 for bid, offer in zip(bid_rates, offer_rates)]\n\n    # Sort the mid-rates\n    mid_rates.sort()\n\n    # Remove the two highest and two lowest mid-rates\n    trimmed_mid_rates = mid_rates[2:-2]\n\n    # Calculate the average from the remaining mid-rates\n    jibar_rate = sum(trimmed_mid_rates) / len(trimmed_mid_rates)\n    \n    return jibar_rate",
        "statistics": {
            "number_statistics": {
                "args_numbers": 2,
                "question_numbers": 0,
                "context_numbers": 17,
                "total_numbers": 17
            },
            "operator_statistics": {
                "operators": {
                    "+": 1,
                    "-": 5,
                    "*": 0,
                    "/": 2,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 8
            },
            "code_statistics": {
                "lines": 9,
                "parentheses": 10
            }
        },
        "difficulty": 4.718498871295094,
        "context": "A financial analyst is tasked with calculating the Johannesburg Interbank Average Rate (JIBAR) as part of a regular review of interbank lending rates. The analyst receives the bid rates and offer rates from 8 different banks participating in this process. These rates are used to determine the mid-rates, which are then averaged to calculate the JIBAR after removing the two highest and two lowest mid-rates. The following bid rates and offer rates were reported: \n\n- Bid Rates: 6.2%, 6.4%, 6.1%, 6.5%, 6.3%, 6.4%, 6.0%, 6.1%\n- Offer Rates: 6.6%, 6.7%, 6.5%, 6.8%, 6.7%, 6.8%, 6.4%, 6.5%",
        "question": "What is the calculated Johannesburg Interbank Average Rate (JIBAR) based on the reported bid and offer rates? Provide the answer as a percentage to two decimal places.",
        "python_solution": "def solution():\n    # Given bid rates and offer rates\n    bid_rates = [6.2, 6.4, 6.1, 6.5, 6.3, 6.4, 6.0, 6.1]\n    offer_rates = [6.6, 6.7, 6.5, 6.8, 6.7, 6.8, 6.4, 6.5]\n\n    # Calculate mid-rates for each pair of bid and offer rates\n    mid_rates = [(bid + offer) / 2 for bid, offer in zip(bid_rates, offer_rates)]\n\n    # Sort the mid-rates\n    mid_rates.sort()\n\n    # Remove the two highest and two lowest mid-rates\n    trimmed_mid_rates = mid_rates[2:-2]\n\n    # Calculate the average of the remaining mid-rates\n    jibar_rate = sum(trimmed_mid_rates) / len(trimmed_mid_rates)\n\n    # Return the calculated JIBAR rate rounded to two decimal places\n    return round(jibar_rate, 2)",
        "ground_truth": 6.44,
        "source": "FinanceReasoning-test-178",
        "question_id": "test-2127",
        "level": "hard",
        "output": [
            "### Step-by-step Analysis using Emphasizing Constraints (EC):\n\n1. **Understanding the Input Constraints**:\n   - The `bid_rates` and `offer_rates` must each have at least 8 numbers.\n   - The two lists must have the same length.\n   - All rates are given as percentages.\n\n2. **Mid-rate Calculation**:\n   - Compute the mid-rate for each bank by averaging their bid and offer rates:\n     \\[\n     \\text{Mid\\_rate} = \\frac{\\text{Bid Rate} + \\text{Offer Rate}}{2}\n     \\]\n   - This computation should be performed for all 8 banks.\n\n3. **Sorting Mid-rates**:\n   - After calculating the mid-rates, we are required to sort them in ascending order.\n\n4. **Exclusion of Extremes**:\n   - From the sorted mid-rates, remove the two highest and two lowest values to eliminate outliers.\n\n5. **Final JIBAR Calculation**:\n   - Compute the average from the remaining mid-rates after trimming the extremes.\n   - The result should be formatted as a percentage with 2 decimal places.\n\n6. **Accuracy and Precision**:\n   - Ensure all calculations are performed precisely and return the final value formatted to two decimal places.\n\n7. **Output Format**:\n   - The result must be the JIBAR rate as a percentage to two decimal places.\n\n---\n\n### Python Program\n\n```python\ndef solution():\n    # Define bid and offer rates\n    bid_rates = [6.2, 6.4, 6.1, 6.5, 6.3, 6.4, 6.0, 6.1]\n    offer_rates = [6.6, 6.7, 6.5, 6.8, 6.7, 6.8, 6.4, 6.5]\n    \n    # Step 1: Calculate mid-rates\n    mid_rates = [(bid + offer) / 2 for bid, offer in zip(bid_rates, offer_rates)]\n    \n    # Step 2: Sort mid-rates\n    mid_rates.sort()\n    \n    # Step 3: Remove the two highest and two lowest mid-rates\n    trimmed_mid_rates = mid_rates[2:-2]\n    \n    # Step 4: Calculate the average of the remaining mid-rates\n    jibar_rate = sum(trimmed_mid_rates) / len(trimmed_mid_rates)\n    \n    # Step 5: Format the result to two decimal places\n    return round(jibar_rate, 2)\n```"
        ],
        "retrieval_query": "What is the calculated Johannesburg Interbank Average Rate (JIBAR) based on the reported bid and offer rates? Provide the answer as a percentage to two decimal places.",
        "useful_functions": [
            "def calculate_jibar_rate(bid_rates: list, offer_rates: list) -> float:\n    \"\"\"\n    Calculate the Johannesburg Interbank Average Rate (JIBAR) based on bid and offer rates.\n\n    This function computes the JIBAR by averaging the mid-rates derived from bid\n    and offer rates submitted by participating banks, after excluding the two highest\n    and two lowest mid-rates.\n\n    Args:\n        bid_rates (list): A list of bid rates from banks.\n        offer_rates (list): A list of offer rates from banks.\n\n    Returns:\n        jibar_rate (float): The calculated JIBAR rate.\n\n    Notes:\n        - Applicability: This function is applicable to calculate the JIBAR based on\n          rates submitted by multiple banks.\n        - Constraints: The input lists must have the same length and contain at least\n          8 rates each, as 8 banks are involved in the submission.\n        - Considerations: Ensure that bid and offer rates are correctly paired, and\n          input lists are pre-sorted if necessary, although sorting is not obligatory.\n    \"\"\"\n    if len(bid_rates) != len(offer_rates) or len(bid_rates) < 8:\n        raise ValueError(\"Each list must contain at least 8 rates and be of equal length.\")\n\n    # Calculate mid-rates as the halfway point between bid and offer rates\n    mid_rates = [(bid + offer) / 2 for bid, offer in zip(bid_rates, offer_rates)]\n\n    # Sort the mid-rates\n    mid_rates.sort()\n\n    # Remove the two highest and two lowest mid-rates\n    trimmed_mid_rates = mid_rates[2:-2]\n\n    # Calculate the average from the remaining mid-rates\n    jibar_rate = sum(trimmed_mid_rates) / len(trimmed_mid_rates)\n    \n    return jibar_rate"
        ],
        "usage": {
            "completion_tokens": 543,
            "prompt_tokens": 935,
            "total_tokens": 1478,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "Assuming the application of U.S. GAAP unless specified differently, an analyst collected data from a corporation as follows: The bonds were released at par value and are convertible into 300,000 ordinary shares. All securities have been in circulation for the complete year. What is the diluted earnings per share for this corporation? Answer to three decimal places.",
        "python_solution": "def solution():\n    # given data\n    net_income = 1500000\n    preferred_stock_dividends = 140000\n    outstanding_shares = 1000000\n    bond_interest = 400000\n    bond_conversion_shares = 300000\n\n    # calculate amount available for common shareholders\n    amount_for_common_shareholders = net_income - preferred_stock_dividends\n\n    # calculate the interest add back to net income\n    add_back_to_income = bond_interest * 0.7  # tax rate is 30%, hence considering 70%\n\n    # calculate diluted earnings\n    diluted_earnings = amount_for_common_shareholders + add_back_to_income\n\n    # calculate diluted EPS\n    diluted_eps = diluted_earnings / (outstanding_shares + bond_conversion_shares)\n\n    return diluted_eps",
        "ground_truth": 1.262,
        "topic": "Accounting",
        "statistics": {
            "number_statistics": {
                "args_numbers": 2,
                "question_numbers": 1,
                "context_numbers": 7,
                "total_numbers": 8
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 1,
                    "*": 1,
                    "/": 1,
                    "%": 2,
                    "**": 0
                },
                "total_operators": 7
            },
            "code_statistics": {
                "lines": 15,
                "parentheses": 2
            }
        },
        "difficulty": 4.718498871295094,
        "source": "FinanceMath-validation-58",
        "context": "['| Shares of common stock | 1,000,000 |\\n|:----------------------:|:---------:|\\n| Net income for the year | $1,500,000 |\\n| Par value of convertible bonds with a 4% coupon rate | $10,000,000 |\\n| Par value of cumulative preferred stock with a 7% dividend rate | $2,000,000 |\\n| Tax rate | 30% |']",
        "question_id": "test-2128",
        "level": "hard",
        "output": [
            "To calculate the diluted earnings per share (EPS), we need to consider the basic EPS and adjust for potential dilution from convertible securities (such as bonds). Let's work through the problem step by step.\n\n### Step-by-step Analysis\n\n1. **Basic Earnings Per Share Computation:**\n   - Basic EPS = (Net Income - Preferred Dividends) / Weighted Average Shares Outstanding.\n   - Here, we calculate the preferred dividend using:\n     \\[\n     \\text{Preferred Dividend} = \\text{Par Value of Preferred Stock} \\times \\text{Dividend Rate}.\n     \\]\n\n2. **Adjust for Convertible Bonds:**\n   - If the convertible bonds are converted into ordinary shares, we need to:\n     - Add the interest expense (after considering tax savings) that the company pays on these bonds back to the numerator (net income).\n     - Include the additional shares issued from these bonds in the denominator.\n\n   - The interest expense on the bonds can be calculated as:\n     \\[\n     \\text{Interest Expense} = \\text{Par Value of Bonds} \\times \\text{Coupon Rate}.\n     \\]\n     The tax savings from the interest expense are incorporated using the tax rate:\n     \\[\n     \\text{After-Tax Interest Expense} = \\text{Interest Expense} \\times (1 - \\text{Tax Rate}).\n     \\]\n\n3. **Diluted EPS Formula:**\n   The diluted EPS formula is as follows:\n   \\[\n   \\text{Diluted EPS} = \\frac{\\text{Net Income} - \\text{Preferred Dividends} + \\text{After-Tax Interest Expense from Convertible Bonds}}{\\text{Weighted Average Shares Outstanding} + \\text{Shares Issued from Convertible Bonds}}.\n   \\]\n\n4. **Constraints:**\n   - Final answer should have a precision of three decimal places.\n\n### Python Program Implementation\nHere's how the calculation can be implemented in Python:\n\n```python\ndef solution():\n    # Define variables\n    net_income = 1_500_000\n    common_shares_outstanding = 1_000_000\n    par_value_bonds = 10_000_000\n    coupon_rate = 0.04\n    par_value_preferred_stock = 2_000_000\n    preferred_dividend_rate = 0.07\n    tax_rate = 0.30\n    convertible_shares_from_bonds = 300_000\n    \n    # Calculate preferred dividends\n    preferred_dividends = par_value_preferred_stock * preferred_dividend_rate\n    \n    # Calculate after-tax interest expense for convertible bonds\n    interest_expense = par_value_bonds * coupon_rate\n    after_tax_interest_expense = interest_expense * (1 - tax_rate)\n    \n    # Calculate diluted EPS\n    diluted_eps = (net_income - preferred_dividends + after_tax_interest_expense) / (common_shares_outstanding + convertible_shares_from_bonds)\n    \n    # Return the answer, rounded to 3 decimal places\n    return round(diluted_eps, 3)\n```"
        ],
        "retrieval_query": "Assuming the application of U.S. GAAP unless specified differently, an analyst collected data from a corporation as follows: The bonds were released at par value and are convertible into 300,000 ordinary shares. All securities have been in circulation for the complete year. What is the diluted earnings per share for this corporation? Answer to three decimal places.",
        "useful_functions": [
            "def calculate_protective_put_breakeven_price(market_price: float, option_price: float) -> float:\n    \"\"\"\n    Calculate the breakeven price for a protective put strategy at expiration.\n\n    This function determines the breakeven price of a share for an investor\n    using a protective put strategy. The breakeven price is where the cost of \n    the shares and the options premium matches the market value of the shares.\n\n    Args:\n        market_price (float): The initial market price of the share.\n        option_price (float): The price per share of the put option purchased.\n\n    Returns:\n        breakeven_price (float): The breakeven price per share at expiration,\n                                  rounded to two decimal places.\n\n    Notes:\n        - This function does not account for dividends or transaction costs.\n        - Assumes options are used solely for protection, not speculation.\n        - The investor should take into account taxes which are not considered \n          in this calculation.\n    \"\"\"\n    breakeven_price = market_price + option_price\n    return round(breakeven_price, 2)"
        ],
        "usage": {
            "completion_tokens": 631,
            "prompt_tokens": 727,
            "total_tokens": 1358,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "Cobb Inc.'s inventory at May 1 consisted of 200 units at a total cost of $1250. Cobb uses the periodic inventory method. Purchases for the month were as follows: \nDate No. of Units Unit cost Total Cost \nMay 4 20 $5.80 $116.00 \nMay 17 80 $5.50 $440.00 \nCobb sold 10 units on May 14 for $120. What is Cobb's weighted average cost of goods sold for May? Answer to the nearest cent.",
        "context": "",
        "statistics": {
            "number_statistics": {
                "question_numbers": 13,
                "context_numbers": 0,
                "total_numbers": 13
            },
            "operator_statistics": {
                "operators": {
                    "+": 4,
                    "-": 0,
                    "*": 3,
                    "/": 1,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 8
            },
            "code_statistics": {
                "lines": 13,
                "parentheses": 2
            }
        },
        "difficulty": 4.718498871295094,
        "ground_truth": 60.2,
        "source": "FinCode-test-44",
        "python_solution": "inventory_units = 200\ninventory_cost = 1250.0\npurchase_units_1 = 20\npurchase_cost_1 = 5.80\npurchase_units_2 = 80\npurchase_cost_2 = 5.50\nsales_units = 10\nsales_price = 120.0\ntotal_cost = inventory_cost + purchase_units_1 * purchase_cost_1 + purchase_units_2 * purchase_cost_2\ntotal_units = inventory_units + purchase_units_1 + purchase_units_2\nweighted_average_cost = total_cost / total_units\ncost_of_goods_sold = weighted_average_cost * sales_units\nround(cost_of_goods_sold, 2)",
        "question_id": "test-2129",
        "level": "hard",
        "output": [
            "To calculate the weighted average cost of goods sold (COGS):\n\nLet\u2019s proceed step-by-step:\n\n**Step 1: Emphasizing Constraints (EC)**\n- First, address the constraint that the units and costs should be handled correctly with no loss of precision, and COGS should be computed to the nearest cent.\n- The method is a **periodic inventory method**, so we calculate the total cost and total units at the end of May before determining the weighted average cost.\n- The sales of 10 units made on May 14 will be assigned an average cost per unit calculated for the entire month.\n\n---\n\n**Step 2: Organizing Information**\n- Beginning inventory:\n  - Units: 200\n  - Cost: $1250\n- Purchases:\n  - May 4: 20 units \u00d7 $5.80 = $116.00\n  - May 17: 80 units \u00d7 $5.50 = $440.00\n- Total units at the end of May: Beginning inventory + Purchases = 200 + 20 + 80 = 300 units\n- Total cost at the end of May: Beginning inventory cost + Purchases = $1250 + $116 + $440 = $1806\n- Weighted average cost per unit: Total cost \u00f7 Total units = $1806 \u00f7 300 units = $6.02\n- Number of units sold: 10 units\n\n**Step 3: Formula**\n- Weighted average cost of goods sold (COGS) = Weighted average cost per unit \u00d7 Units sold\n- Substitute values: COGS = $6.02 \u00d7 10 units = $60.20\n- Outcome: The weighted average COGS for May is **$60.20**.\n\n---\n\nNow let\u2019s build the Python program:\n\n```python\ndef solution():\n    # Define variables\n    beginning_inventory_units = 200\n    beginning_inventory_cost = 1250.00\n    purchases = [(20, 5.80), (80, 5.50)]  # (units_purchased, unit_cost)\n    units_sold = 10\n    \n    # Calculate total units and total cost\n    total_units = beginning_inventory_units\n    total_cost = beginning_inventory_cost\n    \n    for units, unit_cost in purchases:\n        total_units += units\n        total_cost += units * unit_cost\n    \n    # Calculate weighted average cost per unit\n    weighted_average_cost = total_cost / total_units\n    \n    # Calculate cost of goods sold\n    cogs = weighted_average_cost * units_sold\n    \n    # Return COGS rounded to the nearest cent\n    return round(cogs, 2)\n```\n\nThis function will compute the weighted average cost at the end of the month and determine the COGS for the 10 units sold. The result will be returned rounded to the nearest cent."
        ],
        "retrieval_query": "Cobb Inc.'s inventory at May 1 consisted of 200 units at a total cost of $1250. Cobb uses the periodic inventory method. Purchases for the month were as follows: \nDate No. of Units Unit cost Total Cost \nMay 4 20 $5.80 $116.00 \nMay 17 80 $5.50 $440.00 \nCobb sold 10 units on May 14 for $120. What is Cobb's weighted average cost of goods sold for May? Answer to the nearest cent.",
        "useful_functions": [
            "def calculate_weighted_average_cogs(beginning_inventory_units: int, \n                                    beginning_inventory_cost: float, \n                                    purchases: list, \n                                    units_sold: int) -> float:\n    \"\"\"\n    Calculate the weighted average cost of goods sold (COGS) using the periodic inventory method.\n\n    This function calculates the weighted average COGS based on the beginning inventory \n    and a series of purchases during a period. It computes the average cost per unit \n    and uses it to determine the COGS for a certain number of units sold.\n\n    Args:\n        beginning_inventory_units (int): Number of units in the beginning inventory.\n        beginning_inventory_cost (float): Total cost of the beginning inventory.\n        purchases (list): A list of tuples where each tuple represents a purchase with \n                          (units_purchased, unit_cost).\n        units_sold (int): Number of units sold during the period.\n\n    Returns:\n        cogs (float): The calculated cost of goods sold for the units sold, rounded to the nearest cent.\n\n    Notes:\n        - This function assumes that inventory is evaluated at the end of the period.\n        - Purchases should be supplied as a list of tuples in chronological order.\n        - The function does not account for inventory losses, damage, or other adjustments.\n    \"\"\"\n    total_units = beginning_inventory_units\n    total_cost = beginning_inventory_cost\n\n    for units, unit_cost in purchases:\n        total_units += units\n        total_cost += units * unit_cost\n\n    if total_units == 0:\n        raise ValueError(\"Total units cannot be zero.\")\n\n    weighted_average_cost = total_cost / total_units\n    cogs = weighted_average_cost * units_sold\n\n    return round(cogs, 2)"
        ],
        "usage": {
            "completion_tokens": 589,
            "prompt_tokens": 793,
            "total_tokens": 1382,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-3100",
        "article_title": "Out-of-Pocket Limit",
        "function": "def calculate_out_of_pocket_cost(total_billed_amount: float, deductible: float, coinsurance_rate: float, out_of_pocket_max: float) -> float:\n    \"\"\"\n    Calculate the total out-of-pocket cost for a healthcare service until the out-of-pocket maximum is reached.\n\n    This function calculates the total amount a policyholder has to pay out-of-pocket for a healthcare service, \n    factoring in the deductible, coinsurance, and the out-of-pocket maximum limit. The insurance company covers \n    the remaining costs once the out-of-pocket maximum is reached.\n\n    Args:\n        total_billed_amount (float): The total billed amount by the healthcare provider for the service.\n        deductible (float): The deductible amount that must be paid by the policyholder before insurance cover starts.\n        coinsurance_rate (float): The portion (as a decimal) of costs, after the deductible, that the policyholder is responsible for.\n        out_of_pocket_max (float): The maximum out-of-pocket expense a policyholder will pay in a year.\n\n    Returns:\n        total_out_of_pocket (float): The total out-of-pocket cost paid by the policyholder for the healthcare service.\n\n    Notes:\n        - Applicability: Use for calculating out-of-pocket costs when covering healthcare services under insurance plans.\n        - Constraints: Ensure valid numerical inputs; coinsurance_rate should be between 0 and 1.\n        - Considerations: This function assumes all expenses are within covered services and does not include out-of-network costs or non-covered services.\n    \"\"\"\n    # Calculate the initial part to be paid by the deductible\n    pay_after_deductible = max(total_billed_amount - deductible, 0)\n    current_out_of_pocket = min(deductible, total_billed_amount)\n    \n    # Calculate coinsurance cost\n    coinsurance_cost = pay_after_deductible * coinsurance_rate\n    \n    # Determine total potential out-of-pocket before checking max limit\n    total_potential_out_of_pocket = current_out_of_pocket + coinsurance_cost\n    \n    # Final out-of-pocket cost is limited by the out-of-pocket maximum\n    total_out_of_pocket = min(total_potential_out_of_pocket, out_of_pocket_max)\n    \n    return total_out_of_pocket",
        "statistics": {
            "number_statistics": {
                "args_numbers": 4,
                "question_numbers": 0,
                "context_numbers": 4,
                "total_numbers": 4
            },
            "operator_statistics": {
                "operators": {
                    "+": 1,
                    "-": 7,
                    "*": 1,
                    "/": 0,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 9
            },
            "code_statistics": {
                "lines": 10,
                "parentheses": 6
            }
        },
        "difficulty": 4.762173934797756,
        "context": "Anna has a health insurance plan that requires her to pay a deductible of $1,200 before her insurance starts to cover medical expenses. Once the deductible is met, Anna is responsible for 20% of the remaining costs (coinsurance). Her plan features an out-of-pocket maximum of $3,000. Recently, Anna received a medical bill from her provider totaling $10,000.",
        "question": "What is Anna's total out-of-pocket cost for this medical bill? Provide the answer as a dollar amount rounded to the nearest integer.",
        "python_solution": "def solution():\n    # Define the variables based on the problem statement\n    total_billed_amount = 10000  # Total medical bill\n    deductible = 1200            # Deductible Anna must pay before insurance coverage\n    coinsurance_rate = 0.20      # Coinsurance rate after deductible is met\n    out_of_pocket_max = 3000     # Maximum out-of-pocket expense Anna can pay\n\n    # Calculate the amount Anna pays after the deductible is removed\n    pay_after_deductible = max(total_billed_amount - deductible, 0)\n    \n    # Calculate initial out-of-pocket payment as deductible or total billed amount, whichever is less\n    current_out_of_pocket = min(deductible, total_billed_amount)\n    \n    # Calculate the coinsurance cost on the remaining balance after the deductible\n    coinsurance_cost = pay_after_deductible * coinsurance_rate\n    \n    # Calculate total potential out-of-pocket cost, considering both deductible and coinsurance\n    total_potential_out_of_pocket = current_out_of_pocket + coinsurance_cost\n    \n    # Ensure the total out-of-pocket cost does not exceed the out-of-pocket maximum\n    total_out_of_pocket = min(total_potential_out_of_pocket, out_of_pocket_max)\n    \n    # Return the result rounded to the nearest integer\n    return round(total_out_of_pocket)\n\n# Call the solution function and output the result\noutput = solution()\nprint(output)",
        "ground_truth": 2960,
        "source": "FinanceReasoning-test-131",
        "question_id": "test-2130",
        "level": "hard",
        "output": [
            "### Step-by-Step Reasoning using Advanced Techniques:\n\n1. **Understand the Problem Constraints:**\n   - **Deductible:** $1,200 must be paid before insurance coverage kicks in.\n   - **Coinsurance Rate:** Once the deductible is paid, Anna pays 20% of remaining charges (0.2).\n   - **Out-of-Pocket Maximum:** Anna's total out-of-pocket costs for the year cannot exceed $3,000.\n   - The total billed amount is $10,000.\n   - Ensure all calculations respect these constraints, particularly the out-of-pocket maximum limit.\n\n2. **Break Down the Calculation Steps:**\n   - Determine how much of the $10,000 is consumed by the deductible.\n   - Calculate the portion of the bill that remains after the deductible.\n   - Apply the coinsurance rate to the remaining amount to determine Anna's share.\n   - Sum the deductible and coinsurance amounts to compute the total potential out-of-pocket cost.\n   - Ensure this total is capped by the out-of-pocket maximum.\n\n3. **Special Cases and Validations:**\n   - If the total billed amount is less than or equal to the deductible, Anna pays only the billed amount.\n   - Ensure the total out-of-pocket cost never exceeds $3,000, as constrained by the insurance policy.\n\n### Python Program:\n```python\ndef solution():\n    # Define variables for the calculation\n    total_billed_amount = 10000  # Anna's medical bill\n    deductible = 1200           # Deductible amount Anna must pay\n    coinsurance_rate = 0.2      # Coinsurance rate (20%)\n    out_of_pocket_max = 3000    # Out-of-pocket maximum restriction\n    \n    # Calculate the amount remaining after paying the deductible\n    pay_after_deductible = max(total_billed_amount - deductible, 0)\n    \n    # Initial out-of-pocket payment is the full deductible (or the total bill if less than deductible)\n    current_out_of_pocket = min(deductible, total_billed_amount)\n    \n    # Calculate the coinsurance cost (20% of the remaining bill after deductible)\n    coinsurance_cost = pay_after_deductible * coinsurance_rate\n    \n    # Total potential out-of-pocket cost before checking the max limit\n    total_potential_out_of_pocket = current_out_of_pocket + coinsurance_cost\n    \n    # Final out-of-pocket cost capped by the out-of-pocket maximum\n    total_out_of_pocket = min(total_potential_out_of_pocket, out_of_pocket_max)\n    \n    # Return rounded result as per the problem requirements\n    return round(total_out_of_pocket)\n```"
        ],
        "retrieval_query": "What is Anna's total out-of-pocket cost for this medical bill? Provide the answer as a dollar amount rounded to the nearest integer.",
        "useful_functions": [
            "def calculate_out_of_pocket_cost(total_billed_amount: float, deductible: float, coinsurance_rate: float, out_of_pocket_max: float) -> float:\n    \"\"\"\n    Calculate the total out-of-pocket cost for a healthcare service until the out-of-pocket maximum is reached.\n\n    This function calculates the total amount a policyholder has to pay out-of-pocket for a healthcare service, \n    factoring in the deductible, coinsurance, and the out-of-pocket maximum limit. The insurance company covers \n    the remaining costs once the out-of-pocket maximum is reached.\n\n    Args:\n        total_billed_amount (float): The total billed amount by the healthcare provider for the service.\n        deductible (float): The deductible amount that must be paid by the policyholder before insurance cover starts.\n        coinsurance_rate (float): The portion (as a decimal) of costs, after the deductible, that the policyholder is responsible for.\n        out_of_pocket_max (float): The maximum out-of-pocket expense a policyholder will pay in a year.\n\n    Returns:\n        total_out_of_pocket (float): The total out-of-pocket cost paid by the policyholder for the healthcare service.\n\n    Notes:\n        - Applicability: Use for calculating out-of-pocket costs when covering healthcare services under insurance plans.\n        - Constraints: Ensure valid numerical inputs; coinsurance_rate should be between 0 and 1.\n        - Considerations: This function assumes all expenses are within covered services and does not include out-of-network costs or non-covered services.\n    \"\"\"\n    # Calculate the initial part to be paid by the deductible\n    pay_after_deductible = max(total_billed_amount - deductible, 0)\n    current_out_of_pocket = min(deductible, total_billed_amount)\n    \n    # Calculate coinsurance cost\n    coinsurance_cost = pay_after_deductible * coinsurance_rate\n    \n    # Determine total potential out-of-pocket before checking max limit\n    total_potential_out_of_pocket = current_out_of_pocket + coinsurance_cost\n    \n    # Final out-of-pocket cost is limited by the out-of-pocket maximum\n    total_out_of_pocket = min(total_potential_out_of_pocket, out_of_pocket_max)\n    \n    return total_out_of_pocket"
        ],
        "usage": {
            "completion_tokens": 546,
            "prompt_tokens": 904,
            "total_tokens": 1450,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-1294",
        "article_title": "Portfolio Variance",
        "function": "def calculate_portfolio_variance(weights: list, variances: list, covariances: list) -> float:\n    \"\"\"\n    Calculate the variance of a two-asset portfolio.\n\n    This function computes the portfolio variance using the weights, variances,\n    and covariances of two assets in the portfolio. The calculation uses the\n    given formula for a two-asset portfolio, which involves both the variances\n    of the individual assets and their covariance.\n\n    Args:\n        weights (list): A list containing the portfolio weights of the two assets [w1, w2].\n        variances (list): A list containing the variances of the two assets [\u03c31\u00b2, \u03c32\u00b2].\n        covariances (list): A list containing the covariance(s) [Cov1,2] of the asset pairs.\n\n    Returns:\n        portfolio_variance (float): The calculated variance of the portfolio.\n\n    Notes:\n        - Applicability: This function is suitable for portfolios with exactly two assets.\n        - Constraints: The sum of weights should equal 1. The list lengths must match the\n          assumption of two assets (weights and variances must each have length 2).\n        - Considerations: Ensure that input values are accurate and based on consistent\n          units (e.g., percentages or decimals) to maintain accuracy.\n    \"\"\"\n    if len(weights) != 2 or len(variances) != 2 or len(covariances) != 1:\n        raise ValueError(\"This function requires exactly two assets with appropriate input lengths.\")\n    \n    w1, w2 = weights\n    variance1, variance2 = variances\n    covariance = covariances[0]\n\n    portfolio_variance = (\n        (w1**2 * variance1) +\n        (w2**2 * variance2) +\n        (2 * w1 * w2 * covariance)\n    )\n\n    return portfolio_variance",
        "statistics": {
            "number_statistics": {
                "args_numbers": 3,
                "question_numbers": 0,
                "context_numbers": 5,
                "total_numbers": 5
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 0,
                    "*": 5,
                    "/": 0,
                    "%": 0,
                    "**": 2
                },
                "total_operators": 9
            },
            "code_statistics": {
                "lines": 9,
                "parentheses": 8
            }
        },
        "difficulty": 4.762173934797756,
        "context": "An investor is considering forming a portfolio consisting of two stocks, Stock A and Stock B. The investor aims to find the variance of this new portfolio to understand its risk level. Stock A has an expected variance of 0.04, while Stock B has an expected variance of 0.09. The covariance between Stock A and Stock B is 0.02. The investor decides to allocate 40% of their investment in Stock A and the remaining 60% in Stock B.",
        "question": "What is the variance of the portfolio consisting of Stock A and Stock B? Provide the answer as a decimal rounded to four decimal places.",
        "python_solution": "def solution():\n    # Define variables and their values\n    w1 = 0.40  # weight of Stock A\n    w2 = 0.60  # weight of Stock B\n    variance1 = 0.04  # variance of Stock A\n    variance2 = 0.09  # variance of Stock B\n    covariance = 0.02  # covariance between Stock A and Stock B\n\n    # Calculate the portfolio variance\n    portfolio_variance = (\n        (w1**2 * variance1) +\n        (w2**2 * variance2) +\n        (2 * w1 * w2 * covariance)\n    )\n\n    # Return the final answer, rounded to four decimal places\n    return round(portfolio_variance, 4)",
        "ground_truth": 0.0484,
        "source": "FinanceReasoning-test-138",
        "question_id": "test-2131",
        "level": "hard",
        "output": [
            "#### Step-by-Step Analysis Using \"Emphasizing Constraints (EC)\":\n\n1. **Understand the Problem**:\n   - We need to calculate the variance of a portfolio consisting of two stocks (Stock A and Stock B).\n   - The formula for the variance of a two-stock portfolio is:\n     \\[\n     \\sigma^2_p = w_A^2 \\cdot \\sigma_A^2 + w_B^2 \\cdot \\sigma_B^2 + 2 \\cdot w_A \\cdot w_B \\cdot \\text{Cov}(A, B)\n     \\]\n     Where:\n     - \\( w_A \\) and \\( w_B \\) = weights of Stock A and Stock B in the portfolio.\n     - \\( \\sigma_A^2 \\) and \\( \\sigma_B^2 \\) = variances of Stock A and Stock B.\n     - \\( \\text{Cov}(A, B) \\) = covariance between Stock A and Stock B.\n\n2. **Extract Given Values**:\n   - Variance of Stock A (\\( \\sigma_A^2 \\)): \\( 0.04 \\)\n   - Variance of Stock B (\\( \\sigma_B^2 \\)): \\( 0.09 \\)\n   - Covariance (\\( \\text{Cov}(A, B) \\)): \\( 0.02 \\)\n   - Weight of Stock A (\\( w_A \\)): \\( 0.40 \\)\n   - Weight of Stock B (\\( w_B \\)): \\( 0.60 \\)\n\n3. **Constraints**:\n   - Result should be rounded to four decimal places.\n   - All input values are specified as decimals, and the solution should adhere to the same format.\n\n4. **Calculation Procedure**:\n   - Using the provided formula, substitute the given values.\n   - Perform the calculation step-by-step to avoid errors in computation.\n   - Ensure proper precision and rounding at the final step.\n\n5. **Implement via Python Code**:\nLet's now calculate the portfolio variance.\n\n```python\ndef solution():\n    # Define variables name and value\n    variance_A = 0.04\n    variance_B = 0.09\n    covariance_AB = 0.02\n    weight_A = 0.40\n    weight_B = 0.60\n\n    # Do math calculation to get the answer\n    portfolio_variance = (\n        (weight_A ** 2) * variance_A +\n        (weight_B ** 2) * variance_B +\n        2 * weight_A * weight_B * covariance_AB\n    )\n\n    # Round the result to four decimal places\n    return round(portfolio_variance, 4)\n```"
        ],
        "retrieval_query": "What is the variance of the portfolio consisting of Stock A and Stock B? Provide the answer as a decimal rounded to four decimal places.",
        "useful_functions": [
            "def calculate_beta_icpam(covariance: float, expected_return_market: float, risk_free_rate: float, sharpe_ratio_market: float) -> float:\n    \"\"\"\n    Calculate the beta of an asset using the International Capital Asset Pricing Model (ICAPM).\n\n    This function determines the beta coefficient for a given asset with respect to\n    the broader market, under the assumption of perfect markets. The beta reflects\n    the sensitivity of the asset's returns to the market returns, providing insights\n    into the asset's risk contribution to a diversified portfolio.\n\n    Args:\n        covariance (float): The covariance between the asset's returns and the market returns.\n        expected_return_market (float): The expected return of the market (as a decimal, e.g., 0.072 for 7.2%).\n        risk_free_rate (float): The risk-free rate (as a decimal, e.g., 0.031 for 3.1%).\n        sharpe_ratio_market (float): The Sharpe ratio of the market.\n\n    Returns:\n        beta (float): The calculated beta of the asset, representing its risk relative to the market.\n\n    Notes:\n        - Applicability: This calculation is applicable under the assumption of perfect markets.\n        - Constraints: Ensure that the market return and risk-free rate are represented as decimals.\n        - Considerations: The integration value is not considered here as the assumption is full market integration.\n    \"\"\"\n    # Calculate market risk premium\n    market_risk_premium = expected_return_market - risk_free_rate\n    \n    # Calculate the standard deviation of the market using Sharpe ratio\n    std_dev_market = market_risk_premium / sharpe_ratio_market\n    \n    # Calculate the variance of the market\n    variance_market = std_dev_market ** 2\n    \n    # Calculate beta using covariance and variance\n    beta = covariance / variance_market\n    \n    return round(beta, 3)"
        ],
        "usage": {
            "completion_tokens": 553,
            "prompt_tokens": 850,
            "total_tokens": 1403,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "Assuming the going rate for the base asset at present is $50, with the risk-free rate being 4%, and the contract ends in three months. If the current value of the advantages is $5, and the current value of the disadvantages is $6. What would be the forward price (calculated using annual compounding rather than continuous compounding)? Answer to three decimal places.",
        "python_solution": "def solution():\n    T = 3 / 12\n    s0 = 50\n    r = 0.04\n    q1 = 5\n    q2 = 6\n    \n    forward_price = s0 * ((1+r)**T) - ((q1 - q2) * ((1+r)**T))\n    \n    return forward_price",
        "ground_truth": 51.503,
        "topic": "Asset Classes & Derivatives",
        "statistics": {
            "number_statistics": {
                "args_numbers": 2,
                "question_numbers": 4,
                "context_numbers": 0,
                "total_numbers": 4
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 2,
                    "*": 2,
                    "/": 1,
                    "%": 0,
                    "**": 2
                },
                "total_operators": 9
            },
            "code_statistics": {
                "lines": 7,
                "parentheses": 12
            }
        },
        "difficulty": 4.762173934797756,
        "source": "FinanceMath-validation-120",
        "context": "[]",
        "question_id": "test-2132",
        "level": "hard",
        "output": [
            "### Step-by-step approach to solve the problem:\n\n1. **Understand Given Data and Constraints (EC)**:\n   - Spot price of the asset: \\( \\$50 \\)\n   - Risk-free rate: \\( 4\\% \\) = \\( 0.04 \\) (as it should be expressed as a decimal).\n   - Time to maturity: \\( 3 \\) months, which is \\( 3/12 = 0.25 \\) years.\n   - Advantages (present value): \\( 5 \\)\n   - Disadvantages (present value): \\( 6 \\)\n   - Use **annual compounding** to calculate the forward price.\n   - The final forward price is required with **three decimal places of precision**.\n\n2. **Formula for Forward Price**:\n   - The formula for forward price with annual compounding is:\n     \\[\n     \\text{Forward Price} = \\text{Adjusted Spot Price} \\times \\text{Compounding Factor}\n     \\]\n   - Adjusted Spot Price = Spot Price \u2212 Advantages + Disadvantages\n   - Compounding Factor = \\( (1 + \\text{Risk-Free Rate})^{\\text{Time to Maturity in Years}} \\)\n\n3. **Calculate Adjusted Spot Price**:\n   - \\( \\text{Adjusted Spot Price} = 50 - 5 + 6 = 51 \\)\n\n4. **Calculate Compounding Factor**:\n   - \\( \\text{Compounding Factor} = (1 + 0.04)^{0.25} \\)\n\n5. **Combine Results to Get the Forward Price**:\n   - Multiply the Adjusted Spot Price by the Compounding Factor.\n\n6. **Output the Result**:\n   - The program should return the forward price rounded to three decimal places.\n\nNow, let\u2019s implement this in Python:\n\n```python\ndef solution():\n    # Define variables name and value\n    spot_price = 50  # Current spot price of the asset\n    risk_free_rate = 0.04  # Annual risk-free interest rate (as decimal)\n    time_to_maturity_in_years = 3 / 12  # Time to maturity in years (3 months = 0.25 years)\n    advantages = 5  # Present value of advantages\n    disadvantages = 6  # Present value of disadvantages\n    \n    # Calculate the adjusted spot price\n    adjusted_spot_price = spot_price - advantages + disadvantages\n    \n    # Calculate the compounding factor using annual compounding\n    compounding_factor = (1 + risk_free_rate) ** time_to_maturity_in_years\n    \n    # Compute the forward price\n    forward_price = adjusted_spot_price * compounding_factor\n    \n    # Round result to three decimal places as per requirement\n    return round(forward_price, 3)\n```"
        ],
        "retrieval_query": "Assuming the going rate for the base asset at present is $50, with the risk-free rate being 4%, and the contract ends in three months. If the current value of the advantages is $5, and the current value of the disadvantages is $6. What would be the forward price (calculated using annual compounding rather than continuous compounding)? Answer to three decimal places.",
        "useful_functions": [
            "def calculate_forward_price(spot_price: float, risk_free_rate: float, time_to_maturity_in_years: float, advantages: float, disadvantages: float) -> float:\n    \"\"\"\n    Calculate the forward price of an asset using adjusted spot price and annual compounding.\n\n    This function computes the forward price based on the current spot price of an asset,\n    adjusting for the present value of advantages and disadvantages. The calculation uses\n    annual compounding for the given time to maturity.\n\n    Args:\n        spot_price (float): The current spot price of the asset.\n        risk_free_rate (float): The annual risk-free interest rate, expressed as a decimal.\n        time_to_maturity_in_years (float): The time to maturity of the contract, in years.\n        advantages (float): The present value of any advantages associated with holding the asset.\n        disadvantages (float): The present value of any disadvantages associated with holding the asset.\n\n    Returns:\n        forward_price (float): The calculated forward price of the asset.\n\n    Notes:\n        - Applicability: This function is applicable for calculating forward prices of financial contracts\n          using annual compounding instead of continuous compounding.\n        - Constraints: The risk-free rate should be a positive decimal representing an annual interest rate.\n          The time to maturity should be expressed in years.\n        - Considerations: Ensure the spot price, advantages, and disadvantages are provided as amounts in\n          the same currency and at the same point in time.\n    \"\"\"\n    adjusted_spot_price = spot_price - advantages + disadvantages\n    compounding_factor = (1 + risk_free_rate) ** time_to_maturity_in_years\n    forward_price = adjusted_spot_price * compounding_factor\n    \n    return forward_price"
        ],
        "usage": {
            "completion_tokens": 577,
            "prompt_tokens": 770,
            "total_tokens": 1347,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "A 150-day money market instrument has an add-on rate of 6.50%. Assuming there are 360 days in a year, what is the bond equivalent yield? Answer as a percentage to two decimal places.",
        "context": "",
        "statistics": {
            "number_statistics": {
                "question_numbers": 3,
                "context_numbers": 0,
                "total_numbers": 3
            },
            "operator_statistics": {
                "operators": {
                    "+": 1,
                    "-": 1,
                    "*": 4,
                    "/": 3,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 9
            },
            "code_statistics": {
                "lines": 8,
                "parentheses": 10
            }
        },
        "difficulty": 4.762173934797756,
        "ground_truth": 6.59,
        "source": "FinCode-test-33",
        "python_solution": "present_value = 100.0\nadd_on_rate = 0.065\ndays = 150.0\ndays_in_year = 360.0\nface_value = present_value + (present_value * (days / days_in_year) * add_on_rate)\nbond_equivalent_yield = (365 / days) * (face_value - present_value) / present_value\nbond_equivalent_yield_percent = 100.0 * bond_equivalent_yield\nround(bond_equivalent_yield_percent, 2)",
        "question_id": "test-2133",
        "level": "hard",
        "output": [
            "### **Step-by-Step Reasoning:**\nTo solve the problem and ensure accuracy, let's reason through it step-by-step using the **Emphasizing Constraints (EC)** technique.\n\n#### 1. **Understanding the Inputs and Goal:**\n- We are given:\n  - Add-on rate = 6.50% (as a percentage).\n  - Time to maturity = 150 days.\n  - 1 financial year definition = 360 days.\n- The task:\n  - Compute the bond equivalent yield (BEY) based on the given add-on rate.\n  - Express the result as a percentage to **two-decimal places**.\n\n---\n\n#### 2. **Formula and Constraints:**\n- Add-on rate is a simple annualized percentage rate characteristic of money market instruments, assuming a linear relationship.\n- BEY Formula:\n  \\[\n  BEY = \\text{Add-on Rate} \\times \\frac{365}{\\text{Days to Maturity}}\n  \\]\n  - This formula annualizes the return, adjusted to a 365-day year for BEY calculation.\n\n- **Constraints to Emphasize**:\n  - Percentage precision must be **to two decimal places**.\n  - Use **365 days per year** in the BEY calculation.\n  - Convert inputs when required (e.g., percentages to decimals for calculations).\n\n---\n\n#### 3. **Implementation Steps and Calculation**:\n1. Convert the add-on rate from a percentage to a decimal (divide by 100).\n2. Use the provided formula for BEY calculation.\n3. Return the result converted back into a percentage and rounded to two decimal places.\n\n---\n\nLet's implement the solution in Python.\n\n```python\ndef solution():\n    # Define variables name and value\n    add_on_rate = 6.50  # Add-on rate in percentage\n    days_to_maturity = 150  # Time to maturity\n    days_in_year = 365  # Using 365 days for BEY calculation\n\n    # Convert add-on rate to decimal form for calculation\n    add_on_rate_decimal = add_on_rate / 100\n    \n    # Calculate bond equivalent yield (BEY) using the formula\n    bey = add_on_rate_decimal * (days_in_year / days_to_maturity)\n    \n    # Convert back to percentage and round to two decimal places\n    bey_percentage = round(bey * 100, 2)\n    \n    # return the computed bond equivalent yield\n    return bey_percentage\n```"
        ],
        "retrieval_query": "A 150-day money market instrument has an add-on rate of 6.50%. Assuming there are 360 days in a year, what is the bond equivalent yield? Answer as a percentage to two decimal places.",
        "useful_functions": [
            "def calculate_bond_equivalent_yield(effective_annual_rate: float) -> float:\n    \"\"\"\n    Calculate the bond-equivalent yield (BEY) from an effective annual rate (EAR).\n\n    This function converts an effective annual rate (EAR) into a bond-equivalent yield\n    (BEY), which assumes semi-annual compounding. The BEY is used for comparing\n    yields that utilize different compounding periods.\n\n    Args:\n        effective_annual_rate (float): The effective annual rate as a decimal (e.g., 0.09 for 9%).\n\n    Returns:\n        bond_equivalent_yield (float): The bond-equivalent yield as a percentage to two decimal places.\n\n    Notes:\n        - Applicability: This function is useful for financial analysis and comparing investments \n          that compound at different intervals.\n        - Constraints: The effective annual rate must be greater than or equal to 0.\n        - Considerations: Ensure the input for the effective annual rate is in decimal form, \n          not as a percentage.\n    \"\"\"\n    if effective_annual_rate < 0:\n        raise ValueError(\"Effective annual rate must be non-negative.\")\n    \n    semi_annual_rate = pow((1 + effective_annual_rate), 0.5) - 1\n    bond_equivalent_yield = semi_annual_rate * 2\n    \n    return round(bond_equivalent_yield * 100, 2)"
        ],
        "usage": {
            "completion_tokens": 506,
            "prompt_tokens": 663,
            "total_tokens": 1169,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-1432",
        "article_title": "Zero-Volatility Spread (Z-spread)",
        "function": "def calculate_z_spread(bond_price: float, cash_flows: list, spot_rates: list, periods: list) -> float:\n    \"\"\"\n    Calculate the zero-volatility spread (z-spread) for a bond.\n\n    This function computes the z-spread, which is the constant spread added to the \n    Treasury spot rates that makes the present value of a bond's cash flows equal \n    to its current market price. It helps in assessing the additional yield required \n    for the risk associated with the bond compared to risk-free government securities.\n\n    Args:\n        bond_price (float): The current market price of the bond plus any accrued interest.\n        cash_flows (list): A list of the bond's future cash flows (in the order they occur).\n        spot_rates (list): A list of Treasury spot rates corresponding to each cash flow's maturity.\n        periods (list): A list of the relevant time periods for each cash flow (in years).\n\n    Returns:\n        z_spread (float): The calculated zero-volatility spread as a decimal.\n\n    Notes:\n        - Applicability: This function is applicable for evaluating corporate or non-government \n          bonds relative to government bonds using the entire yield curve.\n        - Constraints: The lists for cash_flows, spot_rates, and periods must be of the same length.\n        - Considerations: This function assumes cash flows are regular and periodic. Ensure spot_rates \n          are accurate for the corresponding periods.\n    \"\"\"\n    from scipy.optimize import fsolve\n\n    def pv_difference(z):\n        total_pv = sum(\n            cf / ((1 + (spot_rate + z) / 2) ** (2 * period)) \n            for cf, spot_rate, period in zip(cash_flows, spot_rates, periods)\n        )\n        return total_pv - bond_price\n\n    z_spread, = fsolve(pv_difference, 0.0)  # Start solving with an initial guess of 0.0\n\n    return z_spread",
        "statistics": {
            "number_statistics": {
                "args_numbers": 4,
                "question_numbers": 0,
                "context_numbers": 7,
                "total_numbers": 7
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 1,
                    "*": 1,
                    "/": 2,
                    "%": 0,
                    "**": 1
                },
                "total_operators": 7
            },
            "code_statistics": {
                "lines": 9,
                "parentheses": 16
            }
        },
        "difficulty": 4.77912349311153,
        "context": "A corporate bond issued by XYZ Corporation has a market price of $950. The bond pays annual coupons and is expected to have cash flows of $50 annually for the next 3 years until it matures with an additional $1,000 received at maturity. The corresponding Treasury spot rates for these cash flows are 1.5% for the first year, 1.8% for the second year, and 2.0% for the third year, reflecting the risk-free rates at each time period. Investors want to determine the additional yield spread, known as the z-spread, that investors require over the risk-free rates to justify the bond's risk.",
        "question": "What is the z-spread for the XYZ Corporation bond over the Treasury spot rates? Provide the answer as a percentage to two decimal places.",
        "python_solution": "def solution():\n    # Given values\n    bond_price = 950\n    cash_flows = [50, 50, 1050]\n    spot_rates = [0.015, 0.018, 0.020]\n    periods = [1, 2, 3]\n\n    # Function to compute the present value difference given a z-spread\n    def pv_difference(z):\n        total_pv = sum(\n            cf / ((1 + (spot_rate + z) / 1) ** period) \n            for cf, spot_rate, period in zip(cash_flows, spot_rates, periods)\n        )\n        return total_pv - bond_price\n\n    # Use numerical solver to find z-spread\n    from scipy.optimize import fsolve\n    initial_guess = 0.0\n    z_spread_solution = fsolve(pv_difference, initial_guess)\n\n    # Extract the z-spread calculated\n    z_spread = z_spread_solution[0]\n\n    # Convert z-spread to percentage\n    z_spread_percentage = z_spread * 100\n\n    # Return the z-spread as a percentage rounded to two decimal places\n    return round(z_spread_percentage, 2)\n\n# Call the solution function and output the result\nsolution()",
        "ground_truth": 4.92,
        "source": "FinanceReasoning-test-93",
        "question_id": "test-2134",
        "level": "hard",
        "output": [
            "### Step-by-Step Reasoning\n\n#### 1. Understand the Problem & Define Constraints\nThis is a financial problem where the goal is to calculate the **z-spread** for XYZ Corporation's bond. The calculation involves adding a constant yield spread to the Treasury spot rates to ensure the present value of the bond's cash flows equals its market price.\n\n**Constraints**:\n- We must calculate the z-spread accurate to **two decimal places** in percentage form (e.g., 1.23%).\n- Cash flows, spot rates, and the periods lists must be of the **same length**.\n- Spot rates are annualized values and are provided as percentages. Arithmetic operations like addition should account for conversion to decimals.\n\n#### 2. Formula for Present Value\nWe use the formula for the **present value** of cash flows:\n\\[\nPV = \\sum \\frac{CF_i}{(1 + (R_i + Z))^T}\n\\]\nWhere:\n- \\(CF_i\\): Cash flow in period \\(i\\),\n- \\(R_i\\): Corresponding Treasury spot rate for period \\(i\\),\n- \\(T\\): Time period for the cash flow,\n- \\(Z\\): z-spread (to be determined).\n\nThe task is to solve for \\(Z\\), which essentially involves finding the spread \\(Z\\) that ensures:\n\\[\n\\text{Total PV of cash flows} = \\text{Market Price of Bond}\n\\]\n\n#### 3. Use Numerical Methods\nGiven this equation is non-linear, we use **numerical methods**, such as the `fsolve` function from `scipy.optimize`, to find the root.\n\n#### 4. Data Breakdown\n- **Bond Market Price**: \\$950.\n- **Cash Flows**: \\$50 (annual for 3 years), plus \\$1,000 at maturity in Year 3.\n  - Cash flows: `[50, 50, 1050]` (last year includes the bond's face value).\n- **Spot Rates**: 1.5%, 1.8%, 2.0%.\n  - Spot rates (as decimals): `[0.015, 0.018, 0.020]`.\n- **Time Periods**: `[1, 2, 3]`.\n\n#### 5. Compute and Return Z-Spread\nThe z-spread will be solved for such that the total present value equals \\$950. The answer will be presented as a percentage rounded to **two decimal places**.\n\nNow, let's implement the solution.\n\n```python\ndef solution():\n    # Import necessary library\n    from scipy.optimize import fsolve\n\n    # Define variables\n    bond_price = 950  # market price of the bond\n    cash_flows = [50, 50, 1050]  # cash flows inclusive of face value\n    spot_rates = [0.015, 0.018, 0.020]  # Treasury spot rates as decimals\n    periods = [1, 2, 3]  # time periods in years\n\n    # Define the function to compute PV difference\n    def pv_difference(z):\n        total_pv = sum(\n            cf / ((1 + (spot_rate + z)) ** period)\n            for cf, spot_rate, period in zip(cash_flows, spot_rates, periods)\n        )\n        return total_pv - bond_price\n\n    # Use fsolve to find z-spread (initial guess = 0.0)\n    z_spread, = fsolve(pv_difference, 0.0)\n\n    # Return the z-spread as percentage rounded to 2 decimal places\n    return round(z_spread * 100, 2)\n\n```"
        ],
        "retrieval_query": "What is the z-spread for the XYZ Corporation bond over the Treasury spot rates? Provide the answer as a percentage to two decimal places.",
        "useful_functions": [
            "def calculate_z_spread(bond_price: float, cash_flows: list, spot_rates: list, periods: list) -> float:\n    \"\"\"\n    Calculate the zero-volatility spread (z-spread) for a bond.\n\n    This function computes the z-spread, which is the constant spread added to the \n    Treasury spot rates that makes the present value of a bond's cash flows equal \n    to its current market price. It helps in assessing the additional yield required \n    for the risk associated with the bond compared to risk-free government securities.\n\n    Args:\n        bond_price (float): The current market price of the bond plus any accrued interest.\n        cash_flows (list): A list of the bond's future cash flows (in the order they occur).\n        spot_rates (list): A list of Treasury spot rates corresponding to each cash flow's maturity.\n        periods (list): A list of the relevant time periods for each cash flow (in years).\n\n    Returns:\n        z_spread (float): The calculated zero-volatility spread as a decimal.\n\n    Notes:\n        - Applicability: This function is applicable for evaluating corporate or non-government \n          bonds relative to government bonds using the entire yield curve.\n        - Constraints: The lists for cash_flows, spot_rates, and periods must be of the same length.\n        - Considerations: This function assumes cash flows are regular and periodic. Ensure spot_rates \n          are accurate for the corresponding periods.\n    \"\"\"\n    from scipy.optimize import fsolve\n\n    def pv_difference(z):\n        total_pv = sum(\n            cf / ((1 + (spot_rate + z) / 2) ** (2 * period)) \n            for cf, spot_rate, period in zip(cash_flows, spot_rates, periods)\n        )\n        return total_pv - bond_price\n\n    z_spread, = fsolve(pv_difference, 0.0)  # Start solving with an initial guess of 0.0\n\n    return z_spread"
        ],
        "usage": {
            "completion_tokens": 769,
            "prompt_tokens": 909,
            "total_tokens": 1678,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "Compute the standard deviation of the investment portfolio using the following figures: the percentage weight of asset X is 30%, the weight of asset Y is 70%, the standard deviation for asset X is 25%, that for asset Y is 10%, and their correlation coefficient is 0.8. (expressed as a percentage) Answer to two decimal places.",
        "python_solution": "def solution():\n    weight_X = 0.30\n    standard_deviation_X = 0.25\n    weight_Y = 0.70\n    standard_deviation_Y = 0.10\n    correlation_coefficient = 0.8\n\n    variance = weight_X**2 * standard_deviation_X**2 + weight_Y**2 * standard_deviation_Y**2 + 2 * weight_X * weight_Y * standard_deviation_X * standard_deviation_Y * correlation_coefficient\n\n    return round(variance**0.5 * 100, 2)",
        "ground_truth": 13.76,
        "topic": "Portfolio Management & Strategy",
        "statistics": {
            "number_statistics": {
                "args_numbers": 7,
                "question_numbers": 5,
                "context_numbers": 0,
                "total_numbers": 5
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 0,
                    "*": 8,
                    "/": 0,
                    "%": 0,
                    "**": 5
                },
                "total_operators": 15
            },
            "code_statistics": {
                "lines": 7,
                "parentheses": 2
            }
        },
        "difficulty": 4.787491742782046,
        "source": "FinanceMath-validation-199",
        "context": "[]",
        "question_id": "test-2135",
        "level": "hard",
        "output": [
            "### **Step-by-Step Advanced Reasoning**\n\n#### **Step 1: Interpretation of Problem and Constraints (EC)**\n- **Input Details**:\n  - Weight of Asset X: 30% = 0.3 (converted to decimal format).\n  - Weight of Asset Y: 70% = 0.7 (converted to decimal format).\n  - Standard Deviation of Asset X: 25% = 0.25 (converted to decimal format).\n  - Standard Deviation of Asset Y: 10% = 0.10 (converted to decimal format).\n  - Correlation coefficient between X and Y: 0.8.\n\n- **Output Expected**:\n  - Portfolio standard deviation expressed as a percentage and rounded to **two decimal places**.\n\n- **Constraints**:\n  - Weights of assets should sum up to 1:\n    \\[\n    w_X + w_Y = 1\n    \\]\n    Here \\(0.3 + 0.7 = 1 \\: \\text{(valid)}\\).\n  - Standard deviations and weights must be represented as decimals, and the correlation must be in the range [-1, 1].\n  - The final result needs to be returned in **percentage** format with **two decimal precision**.\n\n#### **Step 2: Formula for Portfolio Standard Deviation**\nUsing the given weights, standard deviations, and correlation coefficient, the formula for portfolio standard deviation is:\n\\[\n\\sigma_p = \\sqrt{w_X^2 \\cdot \\sigma_X^2 + w_Y^2 \\cdot \\sigma_Y^2 + 2 \\cdot w_X \\cdot w_Y \\cdot \\rho \\cdot \\sigma_X \\cdot \\sigma_Y}\n\\]\nwhere:\n- \\(\\sigma_p\\) is the portfolio standard deviation.\n- \\(w_X\\), \\(w_Y\\) are the portfolio weights for assets \\(X\\) and \\(Y\\).\n- \\(\\sigma_X\\), \\(\\sigma_Y\\) are the standard deviations of \\(X\\) and \\(Y\\).\n- \\(\\rho\\) is the correlation coefficient between \\(X\\) and \\(Y\\).\n\n#### **Step 3: Calculation Steps**\n1. Calculate the variance of the portfolio:\n   \\[\n   \\text{Variance} = w_X^2 \\cdot \\sigma_X^2 + w_Y^2 \\cdot \\sigma_Y^2 + 2 \\cdot w_X \\cdot w_Y \\cdot \\rho \\cdot \\sigma_X \\cdot \\sigma_Y\n   \\]\n2. Compute the portfolio standard deviation (\\(\\sigma_p\\)):\n   \\[\n   \\sigma_p = \\sqrt{\\text{Variance}}\n   \\]\n3. Express the result in percentage form and round it to **two decimal places**.\n\n#### **Step 4: Python Code Implementation**\nThe implementation of these steps using Python follows.\n\n```python\ndef solution():\n    # Define variables (weights, standard deviations, correlation)\n    w_X = 0.3  # Weight of Asset X\n    w_Y = 0.7  # Weight of Asset Y\n    sigma_X = 0.25  # Standard Deviation of Asset X\n    sigma_Y = 0.10  # Standard Deviation of Asset Y\n    rho = 0.8  # Correlation coefficient between Asset X and Asset Y\n    \n    # Step 1: Calculate the variance of the portfolio\n    variance = (w_X ** 2 * sigma_X ** 2) + (w_Y ** 2 * sigma_Y ** 2) + (2 * w_X * w_Y * rho * sigma_X * sigma_Y)\n    \n    # Step 2: Calculate the portfolio standard deviation\n    portfolio_std_dev = variance ** 0.5  # Standard deviation in decimal\n    \n    # Step 3: Convert to percentage and round to 2 decimal places\n    portfolio_std_dev_percentage = portfolio_std_dev * 100\n    answer = round(portfolio_std_dev_percentage, 2)\n    \n    # Return the final answer\n    return answer\n```"
        ],
        "retrieval_query": "Compute the standard deviation of the investment portfolio using the following figures: the percentage weight of asset X is 30%, the weight of asset Y is 70%, the standard deviation for asset X is 25%, that for asset Y is 10%, and their correlation coefficient is 0.8. (expressed as a percentage) Answer to two decimal places.",
        "useful_functions": [
            "def calculate_portfolio_standard_deviation(weights: list, standard_deviations: list, correlation_matrix: list) -> float:\n    \"\"\"\n    Calculate the standard deviation of a two-asset investment portfolio.\n\n    This function computes the standard deviation of a portfolio consisting of\n    two assets given their respective weights, standard deviations, and the\n    correlation coefficient between them.\n\n    Args:\n        weights (list): A list containing the weights of two assets in the portfolio\n                        as decimal fractions [w_X, w_Y].\n        standard_deviations (list): A list of the standard deviations of these two\n                                    assets as decimal fractions [\u03c3_X, \u03c3_Y].\n        correlation_matrix (list): A list containing the correlation coefficient\n                                   between the two assets [\u03c1_XY].\n\n    Returns:\n        portfolio_standard_deviation (float): The portfolio's standard deviation as\n                                              a decimal fraction.\n\n    Notes:\n        - This function is applicable for a portfolio with exactly two assets.\n        - The weights should sum to 1, and both the weights and standard deviations\n          should be provided in decimal form, not percentages.\n        - The correlation coefficient should be in the range [-1, 1].\n        - The order of inputs in the lists should be consistent across weights,\n          standard deviations, and correlation_matrix.\n    \"\"\"\n    w_X, w_Y = weights\n    \u03c3_X, \u03c3_Y = standard_deviations\n    \u03c1_XY = correlation_matrix[0]\n\n    variance = (w_X ** 2) * (\u03c3_X ** 2) + (w_Y ** 2) * (\u03c3_Y ** 2) + \\\n               2 * w_X * w_Y * \u03c3_X * \u03c3_Y * \u03c1_XY\n\n    portfolio_standard_deviation = variance ** 0.5\n\n    return portfolio_standard_deviation",
            "def calculate_portfolio_standard_deviation(weights: list, \n                                           standard_deviations: list, \n                                           correlation: float) -> float:\n    \"\"\"\n    Calculate the standard deviation of a two-asset portfolio.\n\n    This function computes the standard deviation of the returns of a portfolio\n    that consists of two assets, given their individual standard deviations,\n    portfolio weights, and the correlation between the two assets.\n\n    Args:\n        weights (list): A list of two floats representing the portfolio weights\n                        of the two assets. The weights should sum up to 1.\n        standard_deviations (list): A list of two floats representing the standard\n                                    deviations of the two assets. Expressed in\n                                    decimal form (e.g., 12% as 0.12).\n        correlation (float): The correlation coefficient between the two assets'\n                             returns, ranging from -1 to 1.\n\n    Returns:\n        float: The standard deviation of the portfolio returns as a percentage.\n\n    Notes:\n        - Applicability: Use this function for a portfolio with exactly two assets.\n        - Constraints: The sum of weights should equal 1.\n        - Considerations: Ensure that standard deviations are provided in decimal \n                          form and the correlation is correctly specified.\n    \"\"\"\n    if len(weights) != 2 or len(standard_deviations) != 2:\n        raise ValueError(\"Both weights and standard deviations lists must contain exactly two elements.\")\n    if not (0 <= weights[0] <= 1 and 0 <= weights[1] <= 1):\n        raise ValueError(\"Portfolio weights must be between 0 and 1.\")\n    if not (-1 <= correlation <= 1):\n        raise ValueError(\"Correlation coefficient must be between -1 and 1.\")\n    \n    w1, w2 = weights\n    sigma1, sigma2 = standard_deviations\n\n    # Calculate covariance\n    covariance = correlation * sigma1 * sigma2\n    \n    # Calculate portfolio variance\n    variance = (w1 ** 2 * sigma1 ** 2) + (w2 ** 2 * sigma2 ** 2) + (2 * w1 * w2 * covariance)\n    \n    # Calculate portfolio standard deviation\n    std_dev = variance ** 0.5\n\n    # Return standard deviation as a percentage\n    return std_dev * 100",
            "def calculate_empirical_rule_proportions(mean: float, std_dev: float, data_points: list) -> dict:\n    \"\"\"\n    Calculate the percentage of data points within 1, 2, and 3 standard deviations \n    from the mean using the empirical rule for a normal distribution.\n\n    This function utilizes the empirical rule (68-95-99.7 rule) to determine what portion \n    of the data points in a list fall within 1, 2, and 3 standard deviations from the mean \n    in a normally distributed dataset.\n\n    Args:\n        mean (float): The mean (average) of the data distribution.\n        std_dev (float): The standard deviation of the data distribution.\n        data_points (list): A list of numeric data points.\n\n    Returns:\n        proportions (dict): A dictionary containing the proportion of data points within\n                            1, 2, and 3 standard deviations from the mean. Keys are \n                            'within_1_std_dev', 'within_2_std_dev', and 'within_3_std_dev'.\n\n    Notes:\n        - Applicability: Applicable to datasets that are normally distributed.\n        - Constraints: Assumes the data is symmetrically distributed around the mean.\n        - Considerations: Data should be preprocessed to remove anomalies that \n                          do not reflect the characteristics of a normal distribution.\n    \"\"\"\n    within_1_std_dev = sum(mean - std_dev <= x <= mean + std_dev for x in data_points) / len(data_points)\n    within_2_std_dev = sum(mean - 2 * std_dev <= x <= mean + 2 * std_dev for x in data_points) / len(data_points)\n    within_3_std_dev = sum(mean - 3 * std_dev <= x <= mean + 3 * std_dev for x in data_points) / len(data_points)\n\n    proportions = {\n        'within_1_std_dev': within_1_std_dev * 100,\n        'within_2_std_dev': within_2_std_dev * 100,\n        'within_3_std_dev': within_3_std_dev * 100\n    }\n\n    return proportions"
        ],
        "usage": {
            "completion_tokens": 855,
            "prompt_tokens": 1714,
            "total_tokens": 2569,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-461",
        "article_title": "Interpolation",
        "function": "def linear_interpolation(x_point: float, x_values: list, y_values: list) -> float:\n    \"\"\"\n    Estimate the value at a given point using linear interpolation.\n\n    This function applies linear interpolation to estimate the value of a function\n    at a particular point within the range of known data points. It assumes that\n    the relationship between the data points is linear.\n\n    Args:\n        x_point (float): The specific point at which the interpolation is to be\n                         estimated. Must be within the range of x_values.\n        x_values (list): A list of known x-values (independent variables).\n                         Must be sorted in ascending order and contain at least two values.\n        y_values (list): A list of known y-values (dependent variables) corresponding\n                         to each x-value. Must be the same length as x_values.\n\n    Returns:\n        interpolated_value (float): The interpolated value at the given x_point.\n\n    Notes:\n        - Applicability: Used in estimating unknown values when dealing with financial\n          time series or other datasets with linear characteristics.\n        - Constraints: x_values must be sorted and contain at least two elements.\n        - Considerations: This method assumes linearity between the data points,\n          which may not suit all datasets, especially those with non-linear trends.\n    \"\"\"\n    if len(x_values) != len(y_values):\n        raise ValueError(\"x_values and y_values must have the same length.\")\n    if len(x_values) < 2:\n        raise ValueError(\"There must be at least two data points for interpolation.\")\n    if not (x_values[0] <= x_point <= x_values[-1]):\n        raise ValueError(\"x_point must be within the range of x_values.\")\n\n    for i in range(len(x_values) - 1):\n        if x_values[i] <= x_point <= x_values[i + 1]:\n            x0, x1 = x_values[i], x_values[i + 1]\n            y0, y1 = y_values[i], y_values[i + 1]\n            interpolated_value = y0 + (y1 - y0) * (x_point - x0) / (x1 - x0)\n            return interpolated_value\n    \n    raise ValueError(\"Interpolation cannot be performed for the given x_point.\")",
        "statistics": {
            "number_statistics": {
                "args_numbers": 3,
                "question_numbers": 0,
                "context_numbers": 4,
                "total_numbers": 4
            },
            "operator_statistics": {
                "operators": {
                    "+": 4,
                    "-": 4,
                    "*": 1,
                    "/": 1,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 10
            },
            "code_statistics": {
                "lines": 7,
                "parentheses": 10
            }
        },
        "difficulty": 4.787491742782047,
        "context": "A bond investment firm is tracking the yield of a government bond over the course of a year, measured quarterly. They have recorded the following yields at the end of each quarter: 2.0% at the end of Q1, 2.5% at the end of Q2, 3.0% at the end of Q3, and 3.5% at the end of Q4. The firm wants to estimate the yield at the midpoint of Q3 using linear interpolation, assuming a linear trend between the recorded quarterly yields.",
        "question": "What is the estimated yield of the government bond at the midpoint of Q3? Answer as a percentage to two decimal places.",
        "python_solution": "def solution():\n    # Define the known x and y values\n    x_values = [1, 2, 3, 4]  # Corresponding to Q1, Q2, Q3, and Q4\n    y_values = [2.0, 2.5, 3.0, 3.5]  # Yields at the end of each quarter in percentage\n\n    # Point to interpolate\n    x_point = 2.5  # Midpoint of Q3 is halfway between Q2 and Q3\n\n    # Perform linear interpolation\n    for i in range(len(x_values) - 1):\n        if x_values[i] <= x_point <= x_values[i + 1]:\n            x0, x1 = x_values[i], x_values[i + 1]\n            y0, y1 = y_values[i], y_values[i + 1]\n            interpolated_value = y0 + (y1 - y0) * (x_point - x0) / (x1 - x0)\n            return round(interpolated_value, 2)\n\n    # Raise error if interpolation cannot proceed (should not occur in this problem)\n    raise ValueError(\"Interpolation cannot be performed for the given x_point.\")",
        "ground_truth": 2.75,
        "source": "FinanceReasoning-test-133",
        "question_id": "test-2136",
        "level": "hard",
        "output": [
            "To solve the problem, I will proceed step by step:\n\n### Step-by-Step Reasoning:\n\n1. **Understanding the Problem**:\n   - We need to estimate the yield at the midpoint of Q3 using linear interpolation based on the quarterly yields provided.\n   - Data points include Q2 (2.5%) and Q3 (3.0%). Since we're interested in the midpoint of Q3, the interpolation segment lies between Q2 (end of Q2) and Q3 (end of Q3).\n\n2. **Linear Interpolation Formula**:\n   - Linear interpolation formula is given by:\n     \\[\n     y = y_1 + \\frac{x - x_1}{x_2 - x_1} \\times (y_2 - y_1)\n     \\]\n     where:\n     - \\( y \\): Estimated yield at position \\( x \\) (midpoint of Q3 here).\n     - \\( x_1, x_2 \\): Positions of the known yields (end of Q2 and end of Q3 in this case).\n     - \\( y_1, y_2 \\): Known yields corresponding to \\( x_1, x_2 \\) (2.5% and 3.0%).\n\n3. **Key Observations**:\n   - \\( x_1 = 2.0 \\) (end of Q2, as it's the second quarter of the year).\n   - \\( x_2 = 3.0 \\) (end of Q3, as it's the third quarter of the year).\n   - \\( x = 2.5 \\) (midpoint of Q3 since it's halfway between Q2 and Q3).\n   - \\( y_1 = 2.5 \\)% and \\( y_2 = 3.0 \\)% are the corresponding yields at \\( x_1 \\) and \\( x_2 \\).\n\n4. **Constraints to Emphasize (EC)**:\n   - Return the estimated yield as a percentage to **two decimal places**.\n   - Ensure to handle percentages properly, maintaining clarity and correctness.\n\n5. **Substitute into Formula**:\n   \\[\n   y = y_1 + \\frac{x - x_1}{x_2 - x_1} \\times (y_2 - y_1)\n   \\]\n   Substitute:\n   - \\( y_1 = 2.5 \\), \\( x = 2.5 \\), \\( x_1 = 2.0 \\), \\( x_2 = 3.0 \\), \\( y_2 = 3.0 \\).\n\n   Hence:\n   \\[\n   y = 2.5 + \\frac{2.5 - 2.0}{3.0 - 2.0} \\times (3.0 - 2.5)\n   \\]\n\n   Simplify:\n   \\[\n   y = 2.5 + 0.5 \\times 0.5\n   \\]\n   \\[\n   y = 2.5 + 0.25 = 2.75\n   \\]\n\nSo the estimated yield at the midpoint of Q3 is 2.75%. This will be the output of our Python program.\n\n### Python Program:\n```python\ndef solution():\n    # Define variables name and value\n    yield_Q2 = 2.5  # End of Q2\n    yield_Q3 = 3.0  # End of Q3\n    midpoint_Q3 = (2.0 + 3.0) / 2  # Midpoint of Q3\n    x1 = 2.0  # End of Q2\n    x2 = 3.0  # End of Q3\n\n    # Linear interpolation formula\n    estimated_yield = yield_Q2 + ((midpoint_Q3 - x1) / (x2 - x1)) * (yield_Q3 - yield_Q2)\n    \n    # Return estimated yield as a percentage rounded to two decimal places\n    return round(estimated_yield, 2)\n```"
        ],
        "retrieval_query": "What is the estimated yield of the government bond at the midpoint of Q3? Answer as a percentage to two decimal places.",
        "useful_functions": [],
        "usage": {
            "completion_tokens": 841,
            "prompt_tokens": 461,
            "total_tokens": 1302,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-1638",
        "article_title": "Debt Consolidation",
        "function": "def calculate_monthly_payment(principal: float, annual_interest_rate: float, term_months: int) -> float:\n    \"\"\"\n    Calculate the monthly payment required to repay a loan.\n\n    This function calculates the monthly payment needed to repay a loan\n    within a specified term at a given annual interest rate using the \n    formula for amortizing loans.\n\n    Args:\n        principal (float): The total amount of the loan.\n        annual_interest_rate (float): The annual interest rate (as a decimal).\n                                      For example, 11% should be input as 0.11.\n        term_months (int): The term of the loan in months.\n\n    Returns:\n        monthly_payment (float): The monthly payment amount needed to repay\n                                 the loan over its term.\n\n    Notes:\n        - The formula used assumes a fixed interest rate for the entire term.\n        - Interest is compounded monthly.\n        - The calculated monthly payment does not include taxes or insurance, if applicable.\n    \"\"\"\n    if annual_interest_rate < 0 or principal < 0 or term_months <= 0:\n        raise ValueError(\"Invalid input values: ensure all values are positive and term is greater than 0.\")\n    \n    monthly_interest_rate = annual_interest_rate / 12\n    if monthly_interest_rate == 0:  # Handle case where interest rate is 0%\n        monthly_payment = principal / term_months\n    else:\n        monthly_payment = (principal * monthly_interest_rate) / (1 - (1 + monthly_interest_rate) ** -term_months)\n    \n    return monthly_payment\n\n\ndef calculate_total_interest_paid(principal: float, monthly_payment: float, term_months: int) -> float:\n    \"\"\"\n    Calculate the total interest paid over the life of a loan.\n\n    This function computes the total interest paid when repaying a loan with\n    specified monthly payments over a given term.\n\n    Args:\n        principal (float): The initial amount of the loan.\n        monthly_payment (float): The monthly payment amount.\n        term_months (int): The total number of months to repay the loan.\n\n    Returns:\n        total_interest_paid (float): The total interest amount paid over the term.\n\n    Notes:\n        - The calculation assumes that the loan is fully repaid using equal monthly payments.\n        - Does not account for early repayments or additional fees that may alter total interest.\n    \"\"\"\n    if monthly_payment <= 0 or principal < 0 or term_months <= 0:\n        raise ValueError(\"Invalid input values: ensure payments and principal are positive and term is greater than 0.\")\n    \n    total_paid = monthly_payment * term_months\n    total_interest_paid = total_paid - principal\n    \n    return total_interest_paid",
        "statistics": {
            "number_statistics": {
                "args_numbers": 3,
                "question_numbers": 1,
                "context_numbers": 3,
                "total_numbers": 4
            },
            "operator_statistics": {
                "operators": {
                    "+": 1,
                    "-": 3,
                    "*": 1,
                    "/": 3,
                    "%": 1,
                    "**": 1
                },
                "total_operators": 10
            },
            "code_statistics": {
                "lines": 8,
                "parentheses": 8
            }
        },
        "difficulty": 4.787491742782047,
        "context": "John is planning to buy a new car and has taken a loan from a bank. The loan amount is $20,000, with an annual interest rate of 6.5%, to be repaid over 5 years. John wants to know how much he will pay in total interest over the life of the loan.",
        "question": "What is the total interest John will pay over the life of the 5-year loan? Answer in dollars to the nearest integer.",
        "python_solution": "def solution():\n    # Define the parameters for the loan\n    principal = 20000  # The total loan amount in dollars\n    annual_interest_rate = 0.065  # Annual interest rate as a decimal\n    term_months = 5 * 12  # Term of the loan in months\n\n    # Calculate the monthly payment using the formula for amortizing loans\n    monthly_interest_rate = annual_interest_rate / 12\n    monthly_payment = (principal * monthly_interest_rate) / (1 - (1 + monthly_interest_rate) ** -term_months)\n\n    # Calculate the total interest paid over the life of the loan\n    total_paid = monthly_payment * term_months\n    total_interest_paid = total_paid - principal\n\n    # Return the total interest paid, rounded to the nearest integer\n    return round(total_interest_paid)",
        "ground_truth": 3479,
        "source": "FinanceReasoning-test-141",
        "question_id": "test-2137",
        "level": "hard",
        "output": [
            "To solve the problem, we need to calculate the total interest John will pay over the life of the 5-year loan. This requires us to calculate the total payment over the 5 years and subtract the loan principal.\n\nStep-by-step reasoning:\n\n1. **Key Formula Overview**:\n   - The monthly payment for a loan can be calculated using the formula for an amortized loan:\n     \\[\n     M = P \\frac{r(1+r)^n}{(1+r)^n-1}\n     \\]\n     where:\n     - \\(M\\): Monthly payment\n     - \\(P\\): Loan principal (\\$20,000)\n     - \\(r\\): Monthly interest rate (annual interest rate divided by 12 = \\(6.5\\% / 12\\))\n     - \\(n\\): Total number of payments (number of years \\(\\times\\) 12 = \\(5 \\times 12\\))\n\n2. **Constraints**:\n   - We round the total interest to the nearest integer for final output since the problem specifies an integer result.\n   - All calculations will respect financial precision principles based on the formula above to ensure accurate computation.\n\n3. **Implementation Plan**:\n   - Calculate \\(r\\) (monthly interest rate) and \\(n\\) (total number of payments).\n   - Compute the monthly payment \\(M\\) using the formula above.\n   - Calculate the total amount paid over the loan life (\\(M \\times n\\)).\n   - Subtract the principal amount (\\$20,000) from the total payments to get the total interest.\n   - Ensure the final result is rounded to the nearest integer.\n\nNow let's implement this in Python:\n\n```python\ndef solution():\n    # Define variables name and value\n    loan_amount = 20000  # Principal amount in dollars\n    annual_interest_rate = 6.5 / 100  # Annual interest rate as a decimal\n    loan_term_years = 5  # Loan term in years\n    \n    # Calculate monthly interest rate and total number of payments\n    monthly_interest_rate = annual_interest_rate / 12\n    total_payments = loan_term_years * 12  # Total number of monthly payments\n    \n    # Calculate monthly payment using the amortization formula\n    monthly_payment = loan_amount * (monthly_interest_rate * (1 + monthly_interest_rate) ** total_payments) / \\\n                      ((1 + monthly_interest_rate) ** total_payments - 1)\n    \n    # Calculate total payment over the life of the loan\n    total_payment = monthly_payment * total_payments\n    \n    # Calculate total interest paid\n    total_interest = total_payment - loan_amount\n    \n    # Return the total interest, rounded to the nearest integer\n    return round(total_interest)\n```"
        ],
        "retrieval_query": "What is the total interest John will pay over the life of the 5-year loan? Answer in dollars to the nearest integer.",
        "useful_functions": [
            "def calculate_portion_due_within_year(term_loan_due_next_year: float, total_outstanding_term_loan: float) -> float:\n    \"\"\"\n    Calculate the portion of the total outstanding term loan that is due within the next 12 months.\n\n    This function computes the percentage of the total outstanding term loan amount that is scheduled\n    to be repaid or due within the next 12 months, expressed as a percentage.\n\n    Args:\n        term_loan_due_next_year (float): The amount of the term loan that is due within the next year.\n        total_outstanding_term_loan (float): The total outstanding amount of the term loan.\n\n    Returns:\n        portion_due (float): The portion of the total outstanding term loan due within the next 12 months,\n                             expressed as a percentage rounded to three decimal places.\n\n    Notes:\n        - Applicability: This function is applicable for calculating the due portion of any term loans\n          when repayment schedules are available.\n        - Constraints: The total outstanding term loan must be non-zero to avoid division by zero errors.\n        - Considerations: Ensure that the input values are consistent in terms of time and currency units.\n    \"\"\"\n    if total_outstanding_term_loan == 0:\n        raise ValueError(\"Total outstanding term loan must be greater than zero.\")\n\n    portion_due = (term_loan_due_next_year / total_outstanding_term_loan) * 100\n    \n    return round(portion_due, 3)"
        ],
        "usage": {
            "completion_tokens": 567,
            "prompt_tokens": 727,
            "total_tokens": 1294,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "What is the sample standard deviation from the following 10 measurements taken from a roughly normal group? Answer to three decimal places.",
        "python_solution": "def solution():\n    import math\n    measurements = [-3, -11, 3, -18, 18, 20, -6, 9, 2, -16]\n    mean = sum(measurements) / len(measurements)\n    variance = sum((xi - mean) ** 2 for xi in measurements) / (len(measurements) - 1)\n    return math.sqrt(variance)",
        "ground_truth": 13.181,
        "topic": "Quantitative Analysis & Valuation",
        "statistics": {
            "number_statistics": {
                "args_numbers": 1,
                "question_numbers": 1,
                "context_numbers": 20,
                "total_numbers": 21
            },
            "operator_statistics": {
                "operators": {
                    "+": 0,
                    "-": 7,
                    "*": 0,
                    "/": 2,
                    "%": 0,
                    "**": 1
                },
                "total_operators": 10
            },
            "code_statistics": {
                "lines": 5,
                "parentheses": 14
            }
        },
        "difficulty": 4.787491742782047,
        "source": "FinanceMath-validation-115",
        "context": "['| Observation | 1  | 2   | 3 | 4   | 5  | 6  | 7  | 8 | 9 | 10  |\\n|-------------|----|-----|---|-----|----|----|----|---|---|-----|\\n| Value       | -3 | -11 | 3 | -18 | 18 | 20 | -6 | 9 | 2 | -16 |']",
        "question_id": "test-2138",
        "level": "hard",
        "output": [
            "### Step-by-step Thinking Using Advanced Reasoning Technique\n\n#### Step 1: Understand the Problem and Identify Constraints\n- The sample standard deviation formula is used because we are working with a sample (not the population). \n  \\[\n  s = \\sqrt{\\frac{\\sum_{i=1}^n (x_i - \\bar{x})^2}{n-1}}\n  \\]\n  where:\n  - \\( s \\): sample standard deviation,\n  - \\( x_i \\): an individual observation,\n  - \\( \\bar{x} \\): sample mean,\n  - \\( n \\): number of observations.\n  \n- Constraints:\n  - Output should be calculated to **three decimal places**.\n  - Count of observations (\\( n \\)) is 10.\n  \n#### Step 2: Calculate Mean (\\( \\bar{x} \\))\n- Multiply observations and sum them up to find the mean: \n  \\[\n  \\bar{x} = \\frac{\\sum x_i}{n}\n  \\]\n\n#### Step 3: Calculate the Variance Term (\\( \\sum (x_i - \\bar{x})^2 \\))\n- For each observation, subtract the mean, square it, and sum the squared terms.\n\n#### Step 4: Divide Variance Term By (\\( n-1 \\)) and Compute Standard Deviation\n- Use \\( n-1 \\) in the denominator because it\u2019s a sample (Bessel's correction).\n\n#### Step 5: Solve and Round the Answer\n- Compute the square root of the variance term to get the standard deviation.\n- Round the result to 3 decimal places.\n\n#### Step 6: Implement the Steps in Python Code\nThe Python program for solving the question follows.\n\n```python\ndef solution():\n    # Define variables name and values\n    values = [-3, -11, 3, -18, 18, 20, -6, 9, 2, -16]\n    n = len(values)\n    \n    # Step 1: Calculate the mean\n    mean = sum(values) / n\n    \n    # Step 2: Calculate the variance term (sum of squared deviations from the mean)\n    squared_deviations = [(x - mean) ** 2 for x in values]\n    variance_term = sum(squared_deviations) / (n - 1)\n    \n    # Step 3: Calculate the sample standard deviation\n    std_dev = variance_term ** 0.5\n\n    # Step 4: Return rounded answer to three decimal places\n    return round(std_dev, 3)\n```"
        ],
        "retrieval_query": "What is the sample standard deviation from the following 10 measurements taken from a roughly normal group? Answer to three decimal places.",
        "useful_functions": [],
        "usage": {
            "completion_tokens": 533,
            "prompt_tokens": 452,
            "total_tokens": 985,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-1068",
        "article_title": "Home-Equity Loan",
        "function": "def calculate_monthly_payment(loan_amount: float, interest_rate: float, loan_term_years: int) -> float:\n    \"\"\"\n    Calculate the monthly payment for a fixed-rate loan.\n\n    This function calculates the monthly payment amount for a fixed-rate loan \n    over a specified term, based on the loan amount and annual interest rate.\n\n    Args:\n        loan_amount (float): The total amount of the loan.\n        interest_rate (float): The annual interest rate as a decimal (e.g., 0.05 for 5%).\n        loan_term_years (int): The term of the loan in years.\n\n    Returns:\n        monthly_payment (float): The monthly payment amount.\n\n    Notes:\n        - Applicability: Use this function for fixed-rate loan payment calculations.\n        - Constraints: Interest rate must be positive and greater than zero.\n        - Considerations: The calculation assumes payments are made monthly and are consistent over the term.\n    \"\"\"\n    monthly_interest_rate = interest_rate / 12\n    num_payments = loan_term_years * 12\n    if monthly_interest_rate == 0:\n        monthly_payment = loan_amount / num_payments\n    else:\n        monthly_payment = loan_amount * (monthly_interest_rate * (1 + monthly_interest_rate) ** num_payments) / ((1 + monthly_interest_rate) ** num_payments - 1)\n    \n    return monthly_payment",
        "statistics": {
            "number_statistics": {
                "args_numbers": 3,
                "question_numbers": 3,
                "context_numbers": 3,
                "total_numbers": 6
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 1,
                    "*": 3,
                    "/": 3,
                    "%": 0,
                    "**": 2
                },
                "total_operators": 11
            },
            "code_statistics": {
                "lines": 7,
                "parentheses": 8
            }
        },
        "difficulty": 4.795790545596741,
        "context": "A recent graduate is planning to buy a new car and is considering taking out a loan to finance this purchase. The total cost of the car, after down payment and other considerations, requires an additional loan of 30,000. The graduate has secured an annual fixed interest rate of 4.5% from their bank. They are looking at a loan term of 5 years to repay the loan. However, they are curious to understand what their monthly payments would look like under these terms to budget accordingly.",
        "question": "What is the monthly payment amount the graduate must make to repay the 30,000 loan at a 4.5% annual interest rate over 5 years? Answer to the nearest cent.",
        "python_solution": "def solution():\n    # Define variables and their values\n    loan_amount = 30000  # The total amount of the loan\n    interest_rate = 0.045  # Annual interest rate as a decimal\n    loan_term_years = 5  # Term of the loan in years\n\n    # Calculate the monthly interest rate\n    monthly_interest_rate = interest_rate / 12\n\n    # Calculate the number of payments (months)\n    num_payments = loan_term_years * 12\n\n    # Calculate monthly payment based on the financial formula for fixed-rate loans\n    if monthly_interest_rate == 0:\n        monthly_payment = loan_amount / num_payments\n    else:\n        monthly_payment = loan_amount * (monthly_interest_rate * (1 + monthly_interest_rate) ** num_payments) / ((1 + monthly_interest_rate) ** num_payments - 1)\n\n    # Return the monthly payment amount, rounded to the nearest cent\n    return round(monthly_payment, 2)",
        "ground_truth": 559.29,
        "source": "FinanceReasoning-test-146",
        "question_id": "test-2139",
        "level": "hard",
        "output": [
            "To solve this problem, we need to compute the monthly payment for a fixed-rate loan using the given details. Here are the steps we need to take following the advanced reasoning technique \"Emphasizing Constraints (EC)\":\n\n### Step 1: Understand the Input and Constraints\n1. **Principal (Loan Amount)**: $30,000.\n2. **Annual Interest Rate**: 4.5% (need to convert this into a monthly interest rate as a decimal).\n3. **Loan Term**: 5 years (need to convert this into months: 5 * 12 = 60 months).\n4. **Constraints**:\n   - The values must be positive.\n   - We must handle decimal precision carefully to ensure accuracy up to the nearest cent.\n\n### Step 2: Formulate the Monthly Payment Calculation\nThe formula for calculating the monthly payment is derived from the amortizing loan formula:\n\\[\nM = P \\cdot \\frac{r \\cdot (1 + r)^n}{(1 + r)^n - 1}\n\\]\nWhere:\n- \\(M\\) = Monthly Payment\n- \\(P\\) = Principal (Loan Amount) = 30,000\n- \\(r\\) = Monthly Interest Rate (Annual Interest Rate \u00f7 12 \u00f7 100 for decimal form)\n- \\(n\\) = Total Number of Payments in Months = 5 * 12 = 60\n\n### Step 3: Include Rounding to the Nearest Cent\nThe result needs to be rounded to 2 decimal places.\n\n### Step 4: Constraints Validation\n1. Ensure that the annual interest rate and loan term are positive.\n2. Handle potential edge cases (e.g., zero or even infinitesimal interest rate properly).\n\n### Python Program Implementation:\nHere's the complete solution:\n\n```python\ndef solution():\n    # Define variables\n    principal = 30000  # Loan Amount in dollars\n    annual_interest_rate = 4.5  # Annual interest rate in percentage\n    loan_term_years = 5  # Loan term in years\n    \n    # Convert annual interest rate to monthly interest rate in decimal\n    monthly_interest_rate = annual_interest_rate / 100 / 12\n    \n    # Convert loan term to months\n    total_months = loan_term_years * 12\n    \n    # Apply the amortization formula to calculate monthly payment\n    monthly_payment = (principal * monthly_interest_rate) / \\\n                      (1 - (1 + monthly_interest_rate) ** -total_months)\n    \n    # Round the result to the nearest cent\n    return round(monthly_payment, 2)\n```"
        ],
        "retrieval_query": "What is the monthly payment amount the graduate must make to repay the 30,000 loan at a 4.5% annual interest rate over 5 years? Answer to the nearest cent.",
        "useful_functions": [
            "def calculate_monthly_payment(principal: float, annual_interest_rate: float, years: int) -> float:\n    \"\"\"\n    Calculate the monthly payment required to fully repay a loan over a specified time period\n    using a fixed interest rate.\n\n    This calculation is applicable for fixed-rate loans including standard repayment plans for\n    student loans or mortgages.\n\n    Args:\n        principal (float): The initial amount of the loan.\n        annual_interest_rate (float): The annual interest rate as a percentage.\n        years (int): The total time in years over which the loan is to be repaid.\n\n    Returns:\n        monthly_payment (float): The amount to be paid monthly to repay the loan in full.\n\n    Notes:\n        - Applicability: Use for fixed-rate loans.\n        - Constraints: Interest rate should be greater than 0; years should be a positive integer.\n        - Considerations: This does not account for fees, taxes, or insurance that may also be part\n                          of monthly payments.\n    \"\"\"\n    if annual_interest_rate <= 0:\n        raise ValueError(\"Interest rate must be greater than zero.\")\n    if years <= 0:\n        raise ValueError(\"Years must be a positive integer.\")\n\n    monthly_interest_rate = annual_interest_rate / 100 / 12\n    number_of_payments = years * 12\n\n    monthly_payment = (principal * monthly_interest_rate) / \\\n                      (1 - (1 + monthly_interest_rate) ** -number_of_payments)\n\n    return monthly_payment",
            "def calculate_monthly_payment(loan_amount: float, annual_interest_rate: float, number_of_payments: int) -> float:\n    \"\"\"\n    Calculate the total monthly payment for an amortized loan.\n\n    This function computes the monthly payment required to fully amortize a loan\n    over a specified term, given the loan's amount, the annual interest rate,\n    and the number of payments. It uses the standard amortization formula for loans.\n\n    Args:\n        loan_amount (float): The total amount of the loan.\n        annual_interest_rate (float): The annual interest rate as a decimal (e.g., 0.03 for 3%).\n        number_of_payments (int): The total number of payments over the life of the loan.\n\n    Returns:\n        total_payment (float): The calculated total monthly payment.\n\n    Notes:\n        - Applicability: Use this function to calculate monthly payments for fixed-rate loans.\n        - Constraints: The annual_interest_rate should be divided by 12 for monthly rate calculation.\n        - Considerations: Ensure the interest rate and number of payments are greater than zero.\n    \"\"\"\n    monthly_rate = annual_interest_rate / 12\n    if monthly_rate == 0:\n        return loan_amount / number_of_payments\n    total_payment = loan_amount * (monthly_rate * (1 + monthly_rate) ** number_of_payments) / ((1 + monthly_rate) ** number_of_payments - 1)\n    \n    return total_payment",
            "def calculate_monthly_payment(principal: float, annual_interest_rate: float, term_months: int) -> float:\n    \"\"\"\n    Calculate the monthly payment required to repay a loan.\n\n    This function calculates the monthly payment needed to repay a loan\n    within a specified term at a given annual interest rate using the \n    formula for amortizing loans.\n\n    Args:\n        principal (float): The total amount of the loan.\n        annual_interest_rate (float): The annual interest rate (as a decimal).\n                                      For example, 11% should be input as 0.11.\n        term_months (int): The term of the loan in months.\n\n    Returns:\n        monthly_payment (float): The monthly payment amount needed to repay\n                                 the loan over its term.\n\n    Notes:\n        - The formula used assumes a fixed interest rate for the entire term.\n        - Interest is compounded monthly.\n        - The calculated monthly payment does not include taxes or insurance, if applicable.\n    \"\"\"\n    if annual_interest_rate < 0 or principal < 0 or term_months <= 0:\n        raise ValueError(\"Invalid input values: ensure all values are positive and term is greater than 0.\")\n    \n    monthly_interest_rate = annual_interest_rate / 12\n    if monthly_interest_rate == 0:  # Handle case where interest rate is 0%\n        monthly_payment = principal / term_months\n    else:\n        monthly_payment = (principal * monthly_interest_rate) / (1 - (1 + monthly_interest_rate) ** -term_months)\n    \n    return monthly_payment\n\n\ndef calculate_total_interest_paid(principal: float, monthly_payment: float, term_months: int) -> float:\n    \"\"\"\n    Calculate the total interest paid over the life of a loan.\n\n    This function computes the total interest paid when repaying a loan with\n    specified monthly payments over a given term.\n\n    Args:\n        principal (float): The initial amount of the loan.\n        monthly_payment (float): The monthly payment amount.\n        term_months (int): The total number of months to repay the loan.\n\n    Returns:\n        total_interest_paid (float): The total interest amount paid over the term.\n\n    Notes:\n        - The calculation assumes that the loan is fully repaid using equal monthly payments.\n        - Does not account for early repayments or additional fees that may alter total interest.\n    \"\"\"\n    if monthly_payment <= 0 or principal < 0 or term_months <= 0:\n        raise ValueError(\"Invalid input values: ensure payments and principal are positive and term is greater than 0.\")\n    \n    total_paid = monthly_payment * term_months\n    total_interest_paid = total_paid - principal\n    \n    return total_interest_paid"
        ],
        "usage": {
            "completion_tokens": 540,
            "prompt_tokens": 1644,
            "total_tokens": 2184,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "Using the 2007 and 2008 financial reports for Holt Corporation, which are presented in Exhibits 1 and 2 and in line with US GAAP, what is Holt's 2008 FCFE (in millions) as Jake Thompson is preparing a presentation to analyze the valuation of this company and Emerald Corp's common stock using a FCFE model? Thompson also plans to do a value estimate for Emerald through a dividend discount model for potential recommendations to his firm. Answer to a single decimal place.",
        "python_solution": "def solution():\n    NI = 485\n    NCC = 270\n    FCInv = 4275 - 3752\n    WCInv = (1988 - 1806) - (1090 - 1007)\n    Net_borrowing = (465 - 450) + (1575 - 1515)\n    FCFE = NI + NCC - FCInv - WCInv + Net_borrowing\n    return FCFE",
        "ground_truth": 208,
        "topic": "Asset Classes & Derivatives",
        "statistics": {
            "number_statistics": {
                "args_numbers": 1,
                "question_numbers": 2,
                "context_numbers": 44,
                "total_numbers": 46
            },
            "operator_statistics": {
                "operators": {
                    "+": 3,
                    "-": 8,
                    "*": 0,
                    "/": 0,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 11
            },
            "code_statistics": {
                "lines": 7,
                "parentheses": 8
            }
        },
        "difficulty": 4.795790545596741,
        "source": "FinanceMath-validation-31",
        "context": "[\"|                                           |                    |  2008   |                   |  2007   |\\n|-------------------------------------------|--------------------|---------|-------------------|---------|\\n| **As of 31 December**                     |                    |         |                   |         |\\n| **Assets**                                |                    |         |                   |         |\\n| Current assets                            |                    |         |                   |         |\\n| Cash and cash equivalents                 |                    |   $372  |                   |  $315   |\\n| Accounts receivable                       |                    |   $770  |                   |  $711   |\\n| Inventories                               |                    |   $846  |                   |  $780   |\\n| Total current assets                      |                    |  $1,988 |                   |  $1,806 |\\n| Gross fixed assets                        |   $4,275           |         |   $3,752          |         |\\n| Less: Accumulated depreciation            |   $1,176           |  $3,099 |   $906            |  $2,846 |\\n| **Total assets**                          |                    |  $5,087 |                   |  $4,652 |\\n| **Liabilities and shareholders' equity**  |                    |         |                   |         |\\n| Current liabilities                       |                    |         |                   |         |\\n| Accounts payable                          |                    |  $476   |                   |  $443   |\\n| Accrued taxes and expenses                |                    |  $149   |                   |  $114   |\\n| Notes payable                             |                    |  $465   |                   |  $450   |\\n| Total current liabilities                 |                    |  $1,090 |                   |  $1,007 |\\n| Long-term debt                            |                    |  $1,575 |                   |  $1,515 |\\n| Common stock                              |                    |  $525   |                   |  $525   |\\n| Retained earnings                         |                    |  $1,897 |                   |  $1,605 |\\n| **Total liabilities and shareholders' equity** |              |  $5,087 |                   |  $4,652 |\", '|   |   |\\n|---|---|\\n| Total revenues | $3,323 |\\n| Cost  of goods  sold | 1,287 |\\n| Selling, general, and administrative expenses | 858 |\\n| Earnings before interest, taxes, depreciation, and amortization (EBITDA) | 1,178 |\\n| Depreciation expense | 270 |\\n| Operating income | 908 |\\n| Interest expense | 195 |\\n| Pretax income | 713 |\\n| Income tax (at 32 percent) | 228 |\\n| Net income | $485 |']",
        "question_id": "test-2140",
        "level": "hard",
        "output": [
            "To solve the problem of calculating Holt Corporation\u2019s Free Cash Flow to Equity (FCFE) for 2008 based on the provided financial data, I will carefully examine and apply the given function `calculate_fcfe()`. I will compute the FCFE step-by-step by identifying and appropriately utilizing all necessary inputs.\n\n### Step-by-step Calculation:\n\n#### 1. Identify Inputs for the `calculate_fcfe()` Function:\n- **Net Income (`net_income`)**: Given as $485 million for 2008.\n- **Non-Cash Charges (`non_cash_charges`)**: Depreciation expense is given as $270 million.\n- **Gross Fixed Assets (`gross_fixed_assets_end` and `gross_fixed_assets_start`)**:\n  - Gross fixed assets at the end of 2008: $4,275 million.\n  - Gross fixed assets at the beginning of 2008: $3,752 million.\n- **Total Current Assets (`total_current_assets_end` and `total_current_assets_start`)**:\n  - Total current assets at the end of 2008: $1,988 million.\n  - Total current assets at the beginning of 2008: $1,806 million.\n- **Total Current Liabilities (`total_current_liabilities_end` and `total_current_liabilities_start`)**:\n  - Total current liabilities at the end of 2008: $1,090 million.\n  - Total current liabilities at the beginning of 2008: $1,007 million.\n- **Notes Payable (`notes_payable_end` and `notes_payable_start`)**:\n  - Notes payable at the end of 2008: $465 million.\n  - Notes payable at the beginning of 2008: $450 million.\n- **Long-Term Debt (`long_term_debt_end` and `long_term_debt_start`)**:\n  - Long-term debt at the end of 2008: $1,575 million.\n  - Long-term debt at the beginning of 2008: $1,515 million.\n\n#### 2. Emphasize Constraints (EC):\n- Maintain data precision and units (mil$ throughout calculations).\n- Conform to GAAP standards in computation.\n- Round the FCFE result to one decimal place for clarity and constraint compliance.\n\n#### 3. Compute Using the Formula:\nFCFE is calculated as:\n\\[\nFCFE = \\text{Net Income} + \\text{Non-Cash Charges} - (\\text{Gross Fixed Assets End} - \\text{Gross Fixed Assets Start}) - (\\text{Total Current Assets End} - \\text{Total Current Assets Start} - (\\text{Total Current Liabilities End} - \\text{Total Current Liabilities Start})) + ((\\text{Notes Payable End} - \\text{Notes Payable Start}) + (\\text{Long-Term Debt End} - \\text{Long-Term Debt Start}))\n\\]\n\nLet's implement this in Python.\n\n```python\ndef solution():\n    # Define variables based on provided data\n    net_income = 485  # in millions\n    non_cash_charges = 270  # depreciation\n    gross_fixed_assets_end = 4275  # end of 2008\n    gross_fixed_assets_start = 3752  # start of 2008\n    total_current_assets_end = 1988  # end of 2008\n    total_current_assets_start = 1806  # start of 2008\n    total_current_liabilities_end = 1090  # end of 2008\n    total_current_liabilities_start = 1007  # start of 2008\n    notes_payable_end = 465  # end of 2008\n    notes_payable_start = 450  # start of 2008\n    long_term_debt_end = 1575  # end of 2008\n    long_term_debt_start = 1515  # start of 2008\n    \n    # Compute components of FCFE\n    fc_inv = gross_fixed_assets_end - gross_fixed_assets_start\n    wc_inv = (total_current_assets_end - total_current_assets_start) - \\\n             (total_current_liabilities_end - total_current_liabilities_start)\n    net_borrowing = (notes_payable_end - notes_payable_start) + \\\n                    (long_term_debt_end - long_term_debt_start)\n    \n    # Calculate FCFE\n    fcfe = net_income + non_cash_charges - fc_inv - wc_inv + net_borrowing\n    \n    # Return final result rounded to one decimal\n    return round(fcfe, 1)\n```\n\nThis program calculates the FCFE by strictly following financial reporting standards and the constraints. Let's execute the solution to find the result."
        ],
        "retrieval_query": "Using the 2007 and 2008 financial reports for Holt Corporation, which are presented in Exhibits 1 and 2 and in line with US GAAP, what is Holt's 2008 FCFE (in millions) as Jake Thompson is preparing a presentation to analyze the valuation of this company and Emerald Corp's common stock using a FCFE model? Thompson also plans to do a value estimate for Emerald through a dividend discount model for potential recommendations to his firm. Answer to a single decimal place.",
        "useful_functions": [
            "def calculate_fcfe(net_income: float, non_cash_charges: float, \n                   gross_fixed_assets_end: float, gross_fixed_assets_start: float, \n                   total_current_assets_end: float, total_current_assets_start: float,\n                   total_current_liabilities_end: float, total_current_liabilities_start: float,\n                   notes_payable_end: float, notes_payable_start: float,\n                   long_term_debt_end: float, long_term_debt_start: float) -> float:\n    \"\"\"\n    Calculate the Free Cash Flow to Equity (FCFE).\n\n    This function computes the FCFE, which is a measure of the cash available to the company's equity holders after all expenses, reinvestment, and debt repayment. It is crucial for valuation models based on free cash flows to equity.\n\n    Args:\n        net_income (float): Net income available to equity holders for the period.\n        non_cash_charges (float): Non-cash charges such as depreciation and amortization.\n        gross_fixed_assets_end (float): Gross fixed assets at the end of the period.\n        gross_fixed_assets_start (float): Gross fixed assets at the beginning of the period.\n        total_current_assets_end (float): Total current assets at the end of the period.\n        total_current_assets_start (float): Total current assets at the beginning of the period.\n        total_current_liabilities_end (float): Total current liabilities at the end of the period.\n        total_current_liabilities_start (float): Total current liabilities at the beginning of the period.\n        notes_payable_end (float): Notes payable at the end of the period.\n        notes_payable_start (float): Notes payable at the beginning of the period.\n        long_term_debt_end (float): Long-term debt at the end of the period.\n        long_term_debt_start (float): Long-term debt at the beginning of the period.\n\n    Returns:\n        fcfe (float): The Free Cash Flow to Equity.\n\n    Notes:\n        - Applicability: Useful for equity valuation models and performance analysis.\n        - Constraints: Requires accurate financial data; assumptions about net borrowing.\n        - Considerations: Assumes all given data are in the same currency and on a comparable accounting basis.\n    \"\"\"\n    fc_inv = gross_fixed_assets_end - gross_fixed_assets_start\n    wc_inv = (total_current_assets_end - total_current_assets_start) - (total_current_liabilities_end - total_current_liabilities_start)\n    net_borrowing = (notes_payable_end - notes_payable_start) + (long_term_debt_end - long_term_debt_start)\n    \n    fcfe = net_income + non_cash_charges - fc_inv - wc_inv + net_borrowing\n    \n    return fcfe",
            "def calculate_diluted_eps_treasury_stock_method(net_income: float, shares_outstanding: int,\n                                                options_outstanding: int, option_strike_price: float,\n                                                average_market_price: float) -> float:\n    \"\"\"\n    Calculate the diluted earnings per share (EPS) using the treasury stock method.\n\n    This function computes the diluted EPS for a company by considering the potential dilution\n    from outstanding options using the treasury stock method. It accounts for the impact of\n    options being exercised, generating proceeds used to repurchase shares at the average\n    market price.\n\n    Args:\n        net_income (float): The net income of the company for the period.\n        shares_outstanding (int): The weighted average number of shares outstanding during the period.\n        options_outstanding (int): The number of options that could potentially dilute the EPS.\n        option_strike_price (float): The exercise price for the outstanding options.\n        average_market_price (float): The average market price of the stock during the period.\n\n    Returns:\n        diluted_eps (float): The diluted EPS, rounded to the nearest cent.\n\n    Notes:\n        - This function is applicable for calculating diluted EPS in scenarios with potential dilution from options.\n        - The treasury stock method assumes that options are exercised at the beginning of the period or at the date\n          of issuance if later.\n        - Important considerations include ensuring options are in-the-money (exercise price < market price) to have\n          a dilutive effect.\n    \"\"\"\n    proceeds_from_option_exercise = options_outstanding * option_strike_price\n    repurchased_shares = proceeds_from_option_exercise / average_market_price\n    incremental_shares = options_outstanding - repurchased_shares\n    diluted_shares_outstanding = shares_outstanding + incremental_shares\n    diluted_eps = net_income / diluted_shares_outstanding\n\n    return round(diluted_eps, 2)"
        ],
        "usage": {
            "completion_tokens": 975,
            "prompt_tokens": 1978,
            "total_tokens": 2953,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-508",
        "article_title": "Kiddie Tax",
        "function": "def calculate_kiddie_tax(unearned_income: float, child_tax_rate: float, parent_tax_rate: float, threshold1: float = 1250, threshold2: float = 2500) -> float:\n    \"\"\"\n    Calculate the kiddie tax for a child's unearned income based on specified tax rates and thresholds.\n\n    This function computes the kiddie tax applicable to a child's unearned income. The income is taxed at\n    different rates based on the specified thresholds, with the potential application of both the child's \n    and the parent's tax rates.\n\n    Args:\n        unearned_income (float): The total unearned income of the child.\n        child_tax_rate (float): The tax rate applicable to the child's income.\n        parent_tax_rate (float): The tax rate applicable to the parent's income.\n        threshold1 (float): The first income threshold where no tax is applied. Default is $1,250.\n        threshold2 (float): The second income threshold up to which the child's tax rate is applied. \n                            Earnings above this threshold are taxed at the parent's rate. Default is $2,500.\n\n    Returns:\n        kiddie_tax (float): The calculated kiddie tax based on the unearned income and applicable tax rates.\n\n    Notes:\n        - This function assumes the use of static thresholds as specified by the tax rules (e.g., 2023 values).\n        - The unearned income should be a non-negative value.\n        - This function does not account for other deductions or credits that may affect actual tax liabilities.\n    \"\"\"\n    if unearned_income < threshold1:\n        return 0.0\n    \n    kiddie_tax = 0.0\n\n    # Income between threshold1 and threshold2 is taxed at the child's rate\n    if unearned_income <= threshold2:\n        kiddie_tax += (unearned_income - threshold1) * child_tax_rate\n    else:\n        kiddie_tax += (threshold2 - threshold1) * child_tax_rate\n        # Income above threshold2 is taxed at the parent's rate\n        kiddie_tax += (unearned_income - threshold2) * parent_tax_rate\n\n    return kiddie_tax",
        "statistics": {
            "number_statistics": {
                "args_numbers": 5,
                "question_numbers": 0,
                "context_numbers": 7,
                "total_numbers": 7
            },
            "operator_statistics": {
                "operators": {
                    "+": 3,
                    "-": 3,
                    "*": 3,
                    "/": 0,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 9
            },
            "code_statistics": {
                "lines": 11,
                "parentheses": 6
            }
        },
        "difficulty": 4.836281906951478,
        "context": "A young investor, Alex, receives $3,400 in unearned income from a trust fund. According to the IRS regulations, part of this income is subject to federal tax under the \"kiddie tax\" rules. For the 2023 tax year, the first $1,250 of unearned income is not taxed. Any unearned income over $1,250, up to $2,500, is taxed at Alex's tax rate of 10%. Income beyond $2,500 is taxed at Alex's parent's tax rate, which is 24%. \n\nAlex is trying to calculate the total kiddie tax liability for the year.",
        "question": "Calculate Alex's total kiddie tax liability for the year. Answer to the nearest dollar.",
        "python_solution": "def solution():\n    # Define the income and tax rates\n    unearned_income = 3400\n    child_tax_rate = 0.10\n    parent_tax_rate = 0.24\n    threshold1 = 1250\n    threshold2 = 2500\n\n    # Initialize kiddie_tax\n    kiddie_tax = 0.0\n\n    # Calculate kiddie tax based on the thresholds\n    if unearned_income > threshold1:\n        if unearned_income <= threshold2:\n            kiddie_tax += (unearned_income - threshold1) * child_tax_rate\n        else:\n            kiddie_tax += (threshold2 - threshold1) * child_tax_rate\n            kiddie_tax += (unearned_income - threshold2) * parent_tax_rate\n\n    # Return the final answer rounded to the nearest integer\n    return round(kiddie_tax)\n\n# Example usage:\n# print(solution())  # Expected output would depend on the given values",
        "ground_truth": 341,
        "source": "FinanceReasoning-test-107",
        "question_id": "test-2141",
        "level": "hard",
        "output": [
            "### Step-by-step Problem Analysis Using *Emphasizing Constraints (EC)*\n\n1. **Identifying Components**:\n   - Alex's unearned income: $3,400.\n   - The tax thresholds and rates:\n     - First $1,250: Not taxed.\n     - Income between $1,250 and $2,500: Taxed at Alex's rate of 10%.\n     - Income above $2,500: Taxed at Alex's parent's tax rate of 24%.\n\n2. **Constraints**:\n   - The calculation must adhere strictly to the given thresholds ($1,250 and $2,500) for tax rate application.\n   - Tax liabilities are calculated in steps:\n     - First part of income: Not taxed.\n     - Second part: Taxed at 10%.\n     - Remaining income: Taxed at 24%.\n   - The final result must be rounded to the nearest dollar.\n\n3. **Solution Construction**:\n   - Calculate the taxable amounts for each segment:\n     - Income not taxed: $1,250.\n     - Income taxed at 10%: Between $1,250 and $2,500.\n     - Income taxed at 24%: Above $2,500.\n   - Add the tax from different segments to determine the total liability.\n\n4. **Output**:\n   - The program should output Alex's total kiddie tax liability for 2023, rounded to the nearest dollar.\n\n---\n\nNow, I will implement this step-by-step reasoning into a Python program:\n\n```python\ndef solution():\n    # Define variables for the inputs\n    unearned_income = 3400\n    child_tax_rate = 0.10\n    parent_tax_rate = 0.24\n    threshold1 = 1250\n    threshold2 = 2500\n    \n    # Initialize the variable for kiddie_tax liability\n    kiddie_tax = 0.0\n    \n    # Step 1: Apply tax rules based on thresholds\n    # Case 1: First $1,250 is not taxed\n    if unearned_income > threshold1:\n        # Case 2: Income between $1,250 and $2,500 is taxed at 10%\n        if unearned_income <= threshold2:\n            kiddie_tax += (unearned_income - threshold1) * child_tax_rate\n        else:\n            kiddie_tax += (threshold2 - threshold1) * child_tax_rate\n            # Case 3: Income above $2,500 is taxed at 24%\n            kiddie_tax += (unearned_income - threshold2) * parent_tax_rate\n            \n    # Round the result to the nearest dollar\n    return round(kiddie_tax)\n```"
        ],
        "retrieval_query": "Calculate Alex's total kiddie tax liability for the year. Answer to the nearest dollar.",
        "useful_functions": [
            "def calculate_kiddie_tax(unearned_income: float, child_tax_rate: float, parent_tax_rate: float, threshold1: float = 1250, threshold2: float = 2500) -> float:\n    \"\"\"\n    Calculate the kiddie tax for a child's unearned income based on specified tax rates and thresholds.\n\n    This function computes the kiddie tax applicable to a child's unearned income. The income is taxed at\n    different rates based on the specified thresholds, with the potential application of both the child's \n    and the parent's tax rates.\n\n    Args:\n        unearned_income (float): The total unearned income of the child.\n        child_tax_rate (float): The tax rate applicable to the child's income.\n        parent_tax_rate (float): The tax rate applicable to the parent's income.\n        threshold1 (float): The first income threshold where no tax is applied. Default is $1,250.\n        threshold2 (float): The second income threshold up to which the child's tax rate is applied. \n                            Earnings above this threshold are taxed at the parent's rate. Default is $2,500.\n\n    Returns:\n        kiddie_tax (float): The calculated kiddie tax based on the unearned income and applicable tax rates.\n\n    Notes:\n        - This function assumes the use of static thresholds as specified by the tax rules (e.g., 2023 values).\n        - The unearned income should be a non-negative value.\n        - This function does not account for other deductions or credits that may affect actual tax liabilities.\n    \"\"\"\n    if unearned_income < threshold1:\n        return 0.0\n    \n    kiddie_tax = 0.0\n\n    # Income between threshold1 and threshold2 is taxed at the child's rate\n    if unearned_income <= threshold2:\n        kiddie_tax += (unearned_income - threshold1) * child_tax_rate\n    else:\n        kiddie_tax += (threshold2 - threshold1) * child_tax_rate\n        # Income above threshold2 is taxed at the parent's rate\n        kiddie_tax += (unearned_income - threshold2) * parent_tax_rate\n\n    return kiddie_tax"
        ],
        "usage": {
            "completion_tokens": 553,
            "prompt_tokens": 926,
            "total_tokens": 1479,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-725",
        "article_title": "Binomial Distribution",
        "function": "def calculate_binomial_probability(n: int, x: int, p: float) -> float:\n    \"\"\"\n    Calculate the probability of achieving exactly x successes in n trials.\n\n    This function calculates the binomial probability using the binomial\n    distribution formula, which includes combinations and the probability\n    of success in a binary outcome setting.\n\n    Args:\n        n (int): The number of trials (occurrences).\n        x (int): The number of successful trials.\n        p (float): The probability of success in a single trial.\n\n    Returns:\n        probability (float): The probability of achieving exactly x successes in n trials.\n\n    Notes:\n        - Applicability: This is applicable in scenarios modeled by binary outcomes\n          where each trial is independent, such as coin flips, yes/no surveys, and certain\n          financial models.\n        - Constraints: Ensure that 0 <= x <= n and 0 <= p <= 1 for valid calculations.\n        - Considerations: The function does not handle negative inputs or probabilities\n          outside the [0, 1] range. Use Python's math library for factorial calculations.\n    \"\"\"\n    from math import factorial\n\n    # Calculate combination n C x\n    combinations = factorial(n) / (factorial(x) * factorial(n - x))\n\n    # Calculate the binomial probability\n    probability = combinations * (p ** x) * ((1 - p) ** (n - x))\n    \n    return probability",
        "statistics": {
            "number_statistics": {
                "args_numbers": 3,
                "question_numbers": 2,
                "context_numbers": 5,
                "total_numbers": 7
            },
            "operator_statistics": {
                "operators": {
                    "+": 0,
                    "-": 3,
                    "*": 3,
                    "/": 1,
                    "%": 0,
                    "**": 2
                },
                "total_operators": 9
            },
            "code_statistics": {
                "lines": 6,
                "parentheses": 16
            }
        },
        "difficulty": 4.836281906951478,
        "context": "A financial analyst is evaluating a promotional campaign for a new credit card. Out of 10,000 recipients of the campaign, 200 individuals have shown interest in applying for the card. Based on similar campaigns in the past, the probability that an interested recipient actually applies for the card is 5%. The analyst wants to determine the likelihood that exactly 10 out of the 200 interested recipients will apply for the card. This calculation will help assess the campaign's effectiveness.",
        "question": "What is the probability that exactly 10 out of the 200 interested recipients will apply for the card? Answer as a percentage to two decimal places.",
        "python_solution": "def solution():\n    from math import factorial\n\n    # Define variables based on the problem statement\n    n = 200  # number of interested recipients\n    x = 10   # number of successful applications\n    p = 0.05 # probability of a single application success\n\n    # Calculate combination n C x\n    def combinations(n, x):\n        return factorial(n) / (factorial(x) * factorial(n - x))\n\n    # Calculate the binomial probability\n    def binomial_probability(n, x, p):\n        comb = combinations(n, x)\n        probability = comb * (p ** x) * ((1 - p) ** (n - x))\n        return probability\n\n    # Compute the probability\n    probability = binomial_probability(n, x, p)\n\n    # Convert probability to percentage\n    probability_percentage = probability * 100\n\n    # Return the probability as a percentage rounded to two decimal places\n    return round(probability_percentage, 2)\n\n# Call the function to get the result\nresult = solution()\nresult",
        "ground_truth": 12.84,
        "source": "FinanceReasoning-test-114",
        "question_id": "test-2142",
        "level": "hard",
        "output": [
            "### Step-by-step solution:\n\n1. **Understand the Problem Context**:\n   - We need to determine the probability that exactly 10 out of 200 interested individuals will apply for the card.\n   - The likelihood of an individual applying for the card, given interest, is 5% or 0.05.\n\n2. **Probability Distribution**:\n   - This is a binomial probability problem because we have:\n     - A fixed number of trials: \\(n = 200\\),\n     - Each individual represents a \"success\" (applying for the card) or \"failure\".\n   - The probability of success in each trial: \\(p = 0.05\\).\n   - The formula for the binomial probability (\\(P(X = k)\\)) is:\n     \\[\n     P(X = k) = \\binom{n}{k} \\cdot p^k \\cdot (1-p)^{n-k}\n     \\]\n     Where:\n     - \\( n \\) is the total number of trials,\n     - \\( k \\) is the desired number of successes (10 in this case),\n     - \\( p \\) is the success probability (0.05).\n\n3. **Constraints**:\n   - We are asked to calculate the probability explicitly for \\( k = 10 \\) out of 200.\n   - The result should be expressed as a percentage rounded to two decimal places.\n\n4. **Plan**:\n   - Use Python's `math.factorial` or `scipy.special.comb` to compute the binomial coefficient \\(\\binom{n}{k}\\).\n   - Calculate \\( p^k \\) and \\( (1-p)^{n-k} \\).\n   - Multiply these components to find the probability.\n   - Convert the result to a percentage (multiplying by 100) and ensure it is rounded to two decimal places.\n\n### Python Program Implementation:\n```python\nfrom math import comb, pow\n\ndef solution():\n    # Define variables\n    n = 200  # Total trials (interested individuals)\n    k = 10   # Desired successes (applicants)\n    p = 0.05 # Probability of success in each trial\n    \n    # Calculate binomial probability P(X = k)\n    binomial_prob = comb(n, k) * (pow(p, k)) * (pow(1-p, n-k))\n    \n    # Convert result to percentage and round to two decimal places\n    answer = round(binomial_prob * 100, 2)\n    \n    return answer\n```"
        ],
        "retrieval_query": "What is the probability that exactly 10 out of the 200 interested recipients will apply for the card? Answer as a percentage to two decimal places.",
        "useful_functions": [],
        "usage": {
            "completion_tokens": 524,
            "prompt_tokens": 449,
            "total_tokens": 973,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-2738",
        "article_title": "Economic Value of Equity (EVE)",
        "function": "def calculate_economic_value_of_equity(asset_cash_flows: list, liability_cash_flows: list, discount_rate: float) -> float:\n    \"\"\"\n    Calculate the Economic Value of Equity (EVE) for a bank's balance sheet.\n\n    This function computes the economic value of equity (EVE) by taking the \n    present value of all asset cash flows and subtracting the present value \n    of all liability cash flows. EVE is used to assess the bank's sensitivity \n    to interest rate changes and manage asset-liability balance.\n\n    Args:\n        asset_cash_flows (list): A list of expected future cash flows from assets.\n        liability_cash_flows (list): A list of expected future cash flows from liabilities.\n        discount_rate (float): The discount rate used to present value the cash flows,\n                               representing the interest rate risk. Must be greater than -1.\n\n    Returns:\n        eve (float): The economic value of equity.\n\n    Notes:\n        - This function assumes that cash flows occur at the end of each period.\n        - The discount rate must be greater than -1 to ensure a valid result.\n        - Cash flows should be provided in chronological order.\n        - Assumptions made in cash flow estimations, especially for liabilities\n          with uncertain duration, may impact accuracy.\n        - EVE calculations may require adjustments for complex financial products\n          with embedded options.\n    \"\"\"\n    if discount_rate <= -1:\n        raise ValueError(\"Discount rate must be greater than -1.\")\n\n    present_value_assets = sum(cf / ((1 + discount_rate) ** (i + 1)) for i, cf in enumerate(asset_cash_flows))\n    present_value_liabilities = sum(cf / ((1 + discount_rate) ** (i + 1)) for i, cf in enumerate(liability_cash_flows))\n    \n    eve = present_value_assets - present_value_liabilities\n\n    return eve",
        "statistics": {
            "number_statistics": {
                "args_numbers": 3,
                "question_numbers": 0,
                "context_numbers": 13,
                "total_numbers": 13
            },
            "operator_statistics": {
                "operators": {
                    "+": 4,
                    "-": 1,
                    "*": 0,
                    "/": 2,
                    "%": 0,
                    "**": 2
                },
                "total_operators": 9
            },
            "code_statistics": {
                "lines": 4,
                "parentheses": 20
            }
        },
        "difficulty": 4.836281906951478,
        "context": "A bank is evaluating its balance sheet to determine the impact of interest rate changes on its economic value of equity (EVE). The bank expects future cash flows from its assets to be: 500,000 in 1 year, 300,000 in 2 years, and 200,000 in 3 years. The expected future cash flows from its liabilities are 400,000 in 1 year, 250,000 in 2 years, and 150,000 in 3 years. Given the current interest rate environment, the bank uses a discount rate of 5% per annum to calculate the present value of these cash flows.",
        "question": "What is the Economic Value of Equity (EVE) for the bank's balance sheet based on the provided asset and liability cash flows and the discount rate? Answer to the nearest integer.",
        "python_solution": "def solution():\n    # Define cash flows for assets and liabilities\n    asset_cash_flows = [500000, 300000, 200000]\n    liability_cash_flows = [400000, 250000, 150000]\n    \n    # Define the discount rate\n    discount_rate = 0.05\n    \n    # Calculate the present value of asset cash flows\n    present_value_assets = sum(\n        cf / ((1 + discount_rate) ** (i + 1)) for i, cf in enumerate(asset_cash_flows)\n    )\n    \n    # Calculate the present value of liability cash flows\n    present_value_liabilities = sum(\n        cf / ((1 + discount_rate) ** (i + 1)) for i, cf in enumerate(liability_cash_flows)\n    )\n    \n    # Calculate EVE as the difference between present value of assets and liabilities\n    eve = present_value_assets - present_value_liabilities\n    \n    # Return the Economic Value of Equity rounded to the nearest integer\n    return round(eve)",
        "ground_truth": 183781,
        "source": "FinanceReasoning-test-130",
        "question_id": "test-2143",
        "level": "hard",
        "output": [
            "Let's evaluate the problem step-by-step using the **Emphasizing Constraints (EC)** reasoning technique to ensure accuracy and efficiency:\n\n1. **Understand the Problem Requirements**:\n   - The goal is to compute the Economic Value of Equity (EVE) for the bank's balance sheet.\n   - EVE equals the present value of asset cash flows minus the present value of liability cash flows.\n\n2. **Identify the Inputs**:\n   - Asset cash flows: [500,000 in 1 year, 300,000 in 2 years, 200,000 in 3 years].\n   - Liability cash flows: [400,000 in 1 year, 250,000 in 2 years, 150,000 in 3 years].\n   - Discount rate: 5% per annum or 0.05 in decimal form.\n   - Cash flows occur at the end of each respective year.\n\n3. **Constraints**:\n   - Discount rate must be > -1. Here, the discount rate is 0.05, which satisfies the constraint.\n   - Compute present values using the formula: \n     \\(\\text{Present Value (PV)} = \\frac{\\text{Cash Flow}}{(1 + \\text{discount_rate})^n}\\), where \\(n\\) represents the year.\n   - Answer needs to be rounded to the nearest integer.\n\n4. **Plan**:\n   - Calculate the present value of asset cash flows.\n   - Calculate the present value of liability cash flows.\n   - Subtract the present value of liabilities from that of assets to get the EVE.\n   - Use the provided function to handle present-value calculations appropriately.\n\n5. **Output Requirements**:\n   - The EVE should be returned as an integer after rounding.\n\nNow, let's proceed to write the Python program.\n\n```python\ndef solution():\n    # Define variables\n    asset_cash_flows = [500000, 300000, 200000]  # Asset cash flows per year\n    liability_cash_flows = [400000, 250000, 150000]  # Liability cash flows per year\n    discount_rate = 0.05  # Annual discount rate expressed as a decimal\n    \n    # Calculate present value of assets\n    present_value_assets = sum(cf / ((1 + discount_rate) ** (i + 1)) for i, cf in enumerate(asset_cash_flows))\n    \n    # Calculate present value of liabilities\n    present_value_liabilities = sum(cf / ((1 + discount_rate) ** (i + 1)) for i, cf in enumerate(liability_cash_flows))\n    \n    # Calculate Economic Value of Equity (EVE)\n    eve = present_value_assets - present_value_liabilities\n    \n    # Return EVE rounded to the nearest integer\n    return round(eve)\n```"
        ],
        "retrieval_query": "What is the Economic Value of Equity (EVE) for the bank's balance sheet based on the provided asset and liability cash flows and the discount rate? Answer to the nearest integer.",
        "useful_functions": [
            "def calculate_economic_value_of_equity(asset_cash_flows: list, liability_cash_flows: list, discount_rate: float) -> float:\n    \"\"\"\n    Calculate the Economic Value of Equity (EVE) for a bank's balance sheet.\n\n    This function computes the economic value of equity (EVE) by taking the \n    present value of all asset cash flows and subtracting the present value \n    of all liability cash flows. EVE is used to assess the bank's sensitivity \n    to interest rate changes and manage asset-liability balance.\n\n    Args:\n        asset_cash_flows (list): A list of expected future cash flows from assets.\n        liability_cash_flows (list): A list of expected future cash flows from liabilities.\n        discount_rate (float): The discount rate used to present value the cash flows,\n                               representing the interest rate risk. Must be greater than -1.\n\n    Returns:\n        eve (float): The economic value of equity.\n\n    Notes:\n        - This function assumes that cash flows occur at the end of each period.\n        - The discount rate must be greater than -1 to ensure a valid result.\n        - Cash flows should be provided in chronological order.\n        - Assumptions made in cash flow estimations, especially for liabilities\n          with uncertain duration, may impact accuracy.\n        - EVE calculations may require adjustments for complex financial products\n          with embedded options.\n    \"\"\"\n    if discount_rate <= -1:\n        raise ValueError(\"Discount rate must be greater than -1.\")\n\n    present_value_assets = sum(cf / ((1 + discount_rate) ** (i + 1)) for i, cf in enumerate(asset_cash_flows))\n    present_value_liabilities = sum(cf / ((1 + discount_rate) ** (i + 1)) for i, cf in enumerate(liability_cash_flows))\n    \n    eve = present_value_assets - present_value_liabilities\n\n    return eve"
        ],
        "usage": {
            "completion_tokens": 578,
            "prompt_tokens": 896,
            "total_tokens": 1474,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-537",
        "article_title": "FICO Score",
        "function": "def calculate_fico_score(payment_history: float, accounts_owed: float, length_of_credit_history: float, \n                         credit_mix: float, new_credit: float) -> float:\n    \"\"\"\n    Calculate the FICO score based on the weighted factors of creditworthiness.\n\n    This function calculates a FICO score using the weighted averages of different credit \n    categories typically used in FICO score calculations. \n\n    Args:\n        payment_history (float): The percentage representing the payment history factor, usually weighted at 35%.\n        accounts_owed (float): The percentage representing the accounts owed factor, usually weighted at 30%.\n        length_of_credit_history (float): The percentage representing the length of credit history factor, usually weighted at 15%.\n        credit_mix (float): The percentage representing the credit mix factor, usually weighted at 10%.\n        new_credit (float): The percentage representing the new credit factor, usually weighted at 10%.\n\n    Returns:\n        fico_score (float): The calculated FICO score.\n\n    Notes:\n        - Applicability: This function is applicable in contexts where FICO score calculations need \n          to be approximated using typical weightings.\n        - Constraints: The inputs should be adjusted percentages applicable to an individual's \n          financial records; actual credit scoring might involve more data.\n        - Considerations: This is a simplified model and might not fully accurately reflect all \n          intricacies of the FICO calculations as conducted by FICO.\n    \"\"\"\n    # Weights for each category\n    payment_history_weight = 0.35\n    accounts_owed_weight = 0.30\n    length_of_credit_history_weight = 0.15\n    credit_mix_weight = 0.10\n    new_credit_weight = 0.10\n    \n    # Calculate the FICO score\n    fico_score = (payment_history * payment_history_weight +\n                  accounts_owed * accounts_owed_weight +\n                  length_of_credit_history * length_of_credit_history_weight +\n                  credit_mix * credit_mix_weight +\n                  new_credit * new_credit_weight)\n    \n    return fico_score",
        "statistics": {
            "number_statistics": {
                "args_numbers": 5,
                "question_numbers": 0,
                "context_numbers": 10,
                "total_numbers": 10
            },
            "operator_statistics": {
                "operators": {
                    "+": 4,
                    "-": 0,
                    "*": 5,
                    "/": 0,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 9
            },
            "code_statistics": {
                "lines": 13,
                "parentheses": 2
            }
        },
        "difficulty": 4.836281906951478,
        "context": "A young professional is evaluating his creditworthiness to apply for a mortgage. His financial advisor collects data on his credit behavior and assigns a percentage rating to several aspects of his credit profile: a payment history of 90%, accounts owed at 65%, a length of credit history of 70%, a credit mix at 80%, and new credit at 50%. These factors help approximate a FICO score, which weighs each aspect differently: 35% for payment history, 30% for accounts owed, 15% for the length of credit history, 10% for credit mix, and 10% for new credit.",
        "question": "What is the approximate FICO score of this individual based on the given factors? Answer to the nearest integer.",
        "python_solution": "def solution():\n    # Define the input percentages for each factor\n    payment_history = 90\n    accounts_owed = 65\n    length_of_credit_history = 70\n    credit_mix = 80\n    new_credit = 50\n\n    # Define the weights for each factor\n    payment_history_weight = 0.35\n    accounts_owed_weight = 0.30\n    length_of_credit_history_weight = 0.15\n    credit_mix_weight = 0.10\n    new_credit_weight = 0.10\n\n    # Perform the FICO score calculation\n    fico_score = (payment_history * payment_history_weight +\n                  accounts_owed * accounts_owed_weight +\n                  length_of_credit_history * length_of_credit_history_weight +\n                  credit_mix * credit_mix_weight +\n                  new_credit * new_credit_weight)\n\n    # Return the FICO score rounded to the nearest integer\n    return round(fico_score)\n\n# The calculated FICO score will be returned when the solution function is called.\nprint(solution())  # Expected output: An integer representing the calculated FICO score",
        "ground_truth": 74,
        "source": "FinanceReasoning-test-210",
        "question_id": "test-2144",
        "level": "hard",
        "output": [
            "### Step-by-step Reasoning (Applying Reasoning Techniques):\n\n#### Emphasizing Constraints (EC):\n1. **Understand the Problem**:\n   - We are tasked to calculate an approximate FICO score based on specific percentage ratings for various aspects and respective weightings of these aspects in the score calculation.\n   \n2. **Specified Weights**:\n   - The weights are:\n     - Payment History: 35%\n     - Accounts Owed: 30%\n     - Length of Credit History: 15%\n     - Credit Mix: 10%\n     - New Credit: 10%\n\n3. **Inputs to the Calculation**:\n   - Payment history: 90% (or 0.90 as a fractional value)\n   - Accounts owed: 65% (or 0.65 as a fractional value)\n   - Length of credit history: 70% (or 0.70 as a fractional value)\n   - Credit mix: 80% (or 0.80 as a fractional value)\n   - New credit: 50% (or 0.50 as a fractional value)\n\n4. **Calculation Formula**:\n   - The FICO score can be approximated as:\n     \\[\n     \\text{FICO Score} = (\\text{Payment History} \\times 0.35) + (\\text{Accounts Owed} \\times 0.30) + (\\text{Length of Credit History} \\times 0.15) + (\\text{Credit Mix} \\times 0.10) + (\\text{New Credit} \\times 0.10)\n     \\]\n\n5. **Constraints**:\n   - The final output (FICO score) should be rounded to the nearest integer.\n\n6. **Steps for Calculation**:\n   - Multiply each factor by its respective weight.\n   - Sum these weighted values to calculate the FICO score.\n   - Round the result to the nearest integer.\n\nBy following the outlined steps and adhering to constraints, this is how the problem will be solved in Python.\n\n### Python Program:\n```python\ndef solution():\n    # Define variables name and value\n    payment_history = 90 / 100  # Convert percentage to decimal\n    accounts_owed = 65 / 100    # Convert percentage to decimal\n    length_of_credit_history = 70 / 100  # Convert percentage to decimal\n    credit_mix = 80 / 100       # Convert percentage to decimal\n    new_credit = 50 / 100       # Convert percentage to decimal\n    \n    # Weights for each category\n    payment_history_weight = 0.35\n    accounts_owed_weight = 0.30\n    length_of_credit_history_weight = 0.15\n    credit_mix_weight = 0.10\n    new_credit_weight = 0.10\n    \n    # Calculate the approximate FICO score\n    fico_score = (\n        payment_history * payment_history_weight +\n        accounts_owed * accounts_owed_weight +\n        length_of_credit_history * length_of_credit_history_weight +\n        credit_mix * credit_mix_weight +\n        new_credit * new_credit_weight\n    )\n    \n    # Return the FICO score rounded to the nearest integer\n    return round(fico_score)\n\n# Example usage and expected output\nsolution()\n```"
        ],
        "retrieval_query": "What is the approximate FICO score of this individual based on the given factors? Answer to the nearest integer.",
        "useful_functions": [
            "def calculate_fico_score(payment_history: float, accounts_owed: float, length_of_credit_history: float, \n                         credit_mix: float, new_credit: float) -> float:\n    \"\"\"\n    Calculate the FICO score based on the weighted factors of creditworthiness.\n\n    This function calculates a FICO score using the weighted averages of different credit \n    categories typically used in FICO score calculations. \n\n    Args:\n        payment_history (float): The percentage representing the payment history factor, usually weighted at 35%.\n        accounts_owed (float): The percentage representing the accounts owed factor, usually weighted at 30%.\n        length_of_credit_history (float): The percentage representing the length of credit history factor, usually weighted at 15%.\n        credit_mix (float): The percentage representing the credit mix factor, usually weighted at 10%.\n        new_credit (float): The percentage representing the new credit factor, usually weighted at 10%.\n\n    Returns:\n        fico_score (float): The calculated FICO score.\n\n    Notes:\n        - Applicability: This function is applicable in contexts where FICO score calculations need \n          to be approximated using typical weightings.\n        - Constraints: The inputs should be adjusted percentages applicable to an individual's \n          financial records; actual credit scoring might involve more data.\n        - Considerations: This is a simplified model and might not fully accurately reflect all \n          intricacies of the FICO calculations as conducted by FICO.\n    \"\"\"\n    # Weights for each category\n    payment_history_weight = 0.35\n    accounts_owed_weight = 0.30\n    length_of_credit_history_weight = 0.15\n    credit_mix_weight = 0.10\n    new_credit_weight = 0.10\n    \n    # Calculate the FICO score\n    fico_score = (payment_history * payment_history_weight +\n                  accounts_owed * accounts_owed_weight +\n                  length_of_credit_history * length_of_credit_history_weight +\n                  credit_mix * credit_mix_weight +\n                  new_credit * new_credit_weight)\n    \n    return fico_score"
        ],
        "usage": {
            "completion_tokens": 672,
            "prompt_tokens": 905,
            "total_tokens": 1577,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "The chief financial officer of a manufacturing firm based in the UK, Susan Sullivan, gathers the exchange rates from Dealer B as given in Exhibit 1. The company will receive EUR 5,000,000 from a different client in three months. Half a year ago, the firm traded EUR 5,000,000 for GBP using a forward contract of nine months at an inclusive price of GBP/EUR 0.7400. Considering Exhibits 1 and 2, what would be the mark-to-market gain for Sullivan's forward position if the position is marked to the market by gathering the GBP/EUR forward rates displayed in Exhibit 2? Answer to three decimal places.",
        "python_solution": "def solution():\n    spot_rate = 0.7344\n    forward_points = 15/10000\n    three_month_forward_rate = spot_rate + forward_points\n    contract_rate = 0.7400\n    eur_amount = 5000000\n    libor_rate = 58/100\n\n    net_cash_flow = eur_amount * (contract_rate - three_month_forward_rate)\n    mark_to_market_gain = net_cash_flow / ((1 + libor_rate/100)**(3/12))\n\n    return mark_to_market_gain",
        "ground_truth": 20470.382,
        "topic": "Market Analysis & Economics",
        "statistics": {
            "number_statistics": {
                "args_numbers": 3,
                "question_numbers": 7,
                "context_numbers": 24,
                "total_numbers": 31
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 1,
                    "*": 1,
                    "/": 5,
                    "%": 0,
                    "**": 1
                },
                "total_operators": 10
            },
            "code_statistics": {
                "lines": 9,
                "parentheses": 8
            }
        },
        "difficulty": 4.867534450455583,
        "source": "FinanceMath-validation-95",
        "context": "['| Currency Pair (Price/Base) | Bid    | Offer  | Midpoint |\\n|----------------------------|--------|--------|----------|\\n| JPY/GBP                    | 187.39 | 187.43 | 187.41   |\\n| MXN/USD                    | 17.147 | 17.330 | 17.239   |\\n| GBP/EUR                    | 0.7342 | 0.7344 | 0.7343   |\\n| USD/EUR                    | 1.1572 | 1.1576 | 1.1574   |\\n| USD/GBP                    | 1.5762 | 1.5766 | 1.5764   |', '|          |                        |\\n|----------|------------------------|\\n|Exhibit 2. GBP/EUR Forward Rates||\\n| Maturity   | Forward Points  |\\n| One month  | 4.40/4.55       |\\n| Three months| 14.0/15.0      |\\n| Six months  | 29.0/30.0       |\\n|          | the GBP 90- day Libor = 0.5800%|']",
        "question_id": "test-2145",
        "level": "hard",
        "output": [
            "### Step-by-Step Thought Process:\n\n1. **Understand the Problem**:\n   - The UK company entered into a forward contract to convert EUR to GBP at GBP/EUR 0.7400 for nine months.\n   - After six months, the position is to be marked to market, and the question is to calculate the mark-to-market gain using the current GBP/EUR forward rates for three months from Exhibit 2.\n\n2. **Relevant Data**:\n   - Original forward rate (GBP/EUR): **0.7400**.\n   - Spot rate (GBP/EUR midpoint): **0.7343**.\n   - Three-month forward points (from Exhibit 2): **0.0014/0.0015** (divide by 10^4 to convert).\n   - Amount to be converted: **EUR 5,000,000**.\n   - Libor is irrelevant in this context because we're marking to market using forward rates, and no interest component needs to be adjusted.\n\n3. **Constraints** (EC technique):\n   - Ensure all forward points are in the **correct decimal form**. Forward points (given as 14.0/15.0 basis points) are **divided by 10,000**.\n   - Follow the three-decimal place **rounding rule**.\n   - Work strictly with GBP/EUR currency pair rates for this problem.\n\n4. **Steps to Solve**:\n   - Convert the three-month forward points to decimal form: \n     - Bid forward rate points: \\( 0.0014 \\)\n     - Ask forward rate points: \\( 0.0015 \\).\n   - Calculate the three-month forward **bid and ask rates**:\n     - Forward bid = Spot bid + Bid forward points \\( = 0.7342 + 0.0014 \\)\n     - Forward ask = Spot ask + Ask forward points \\( = 0.7344 + 0.0015 \\).\n   - Take the midpoint of the three-month forward rates:\n     - Midpoint \\( = \\frac{\\text{Forward bid} + \\text{Forward ask}}{2} \\).\n   - Calculate the difference between the initial forward rate (\\(0.7400\\)) and the three-month midpoint forward rate.\n   - Compute the mark-to-market value as the difference multiplied by EUR 5,000,000.\n   - Return the absolute value of this figure to show the mark-to-market gain.\n\n5. **Required Output**:\n   - The mark-to-market gain in GBP, rounded to **three decimal places**.\n\n### Python Program:\n\n```python\ndef solution():\n    # Define variables\n    initial_forward_rate = 0.7400\n    spot_rate_bid = 0.7342\n    spot_rate_ask = 0.7344\n    three_month_forward_points_bid_bps = 14.0\n    three_month_forward_points_ask_bps = 15.0\n    amount_eur = 5000000  # EUR to be converted\n    \n    # Convert forward points from basis points (bps) to decimal\n    three_month_forward_points_bid = three_month_forward_points_bid_bps / 10000\n    three_month_forward_points_ask = three_month_forward_points_ask_bps / 10000\n    \n    # Calculate the three-month forward bid and ask rates\n    forward_rate_bid = spot_rate_bid + three_month_forward_points_bid\n    forward_rate_ask = spot_rate_ask + three_month_forward_points_ask\n    \n    # Calculate midpoint of the forward bid and ask rates\n    three_month_forward_rate = (forward_rate_bid + forward_rate_ask) / 2\n    \n    # Calculate the difference between initial forward rate and current three-month forward\n    rate_difference = initial_forward_rate - three_month_forward_rate\n    \n    # Calculate mark-to-market value (gain/loss) in GBP\n    mark_to_market_value = rate_difference * amount_eur\n    \n    # Return the result rounded to three decimal places\n    return round(mark_to_market_value, 3)\n```"
        ],
        "retrieval_query": "The chief financial officer of a manufacturing firm based in the UK, Susan Sullivan, gathers the exchange rates from Dealer B as given in Exhibit 1. The company will receive EUR 5,000,000 from a different client in three months. Half a year ago, the firm traded EUR 5,000,000 for GBP using a forward contract of nine months at an inclusive price of GBP/EUR 0.7400. Considering Exhibits 1 and 2, what would be the mark-to-market gain for Sullivan's forward position if the position is marked to the market by gathering the GBP/EUR forward rates displayed in Exhibit 2? Answer to three decimal places.",
        "useful_functions": [
            "def calculate_mark_to_market_value(total_shares: int, \n                                   share_price_eur: float, \n                                   init_spot_bid: float, \n                                   init_forward_pips: float, \n                                   later_spot_ask: float, \n                                   later_forward_pips: float, \n                                   annual_usd_libor: float, \n                                   period_days: int) -> float:\n    \"\"\"\n    Calculate the mark-to-market value of a hedged foreign investment.\n\n    This function computes the mark-to-market value of a position initially hedged with a forward \n    contract, after a given period, using the initial and later forward rates.\n\n    Args:\n        total_shares (int): The total number of shares purchased.\n        share_price_eur (float): The price per share in Euros.\n        init_spot_bid (float): The initial spot bid rate in USD/EUR.\n        init_forward_pips (float): The initial forward rate premium/discount in pips.\n        later_spot_ask (float): The spot ask rate at a later time in USD/EUR.\n        later_forward_pips (float): The forward rate premium/discount at a later time in pips.\n        annual_usd_libor (float): The annual USD Libor rate as a percentage.\n        period_days (int): The number of days for the investment period.\n\n    Returns:\n        mark_to_market_value (float): The mark-to-market value in USD.\n\n    Notes:\n        - This function assumes a forward contract with a linear distribution of pips.\n        - The notional value is adjusted based on the difference between forward rates.\n        - The annual USD Libor rate is applied proportionally to the investment period.\n        - Ensure that all percentages and pips are converted to decimal form where necessary.\n    \"\"\"\n    # Calculate initial forward rate\n    init_forward_rate = init_spot_bid - init_forward_pips / 10000\n    \n    # Calculate settling forward rate\n    settling_forward_rate = later_spot_ask - later_forward_pips / 10000\n    \n    # Calculate the difference in rates\n    diff_rate = init_forward_rate - settling_forward_rate\n    \n    # Calculate the total value in Euros\n    total_value_eur = total_shares * share_price_eur\n    \n    # Calculate the notional value in USD\n    notional_value_usd = diff_rate * total_value_eur\n    \n    # Calculate the present value of the mark-to-market difference\n    mark_to_market_value = notional_value_usd / (1 + (annual_usd_libor / 100) * (period_days / 360))\n    \n    return mark_to_market_value"
        ],
        "usage": {
            "completion_tokens": 832,
            "prompt_tokens": 1274,
            "total_tokens": 2106,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-2310",
        "article_title": "What Is an Amortization Schedule? How to Calculate With Formula",
        "function": "def calculate_monthly_payment(loan_amount: float, annual_interest_rate: float, loan_term_years: int) -> float:\n    \"\"\"\n    Calculate the monthly payment for an amortizing loan.\n\n    This function computes the total monthly payment required to repay a loan amount\n    over a specified term with a given annual interest rate. It is commonly used in\n    creating amortization schedules for loans such as mortgages or car loans.\n\n    Args:\n        loan_amount (float): The principal amount of the loan.\n        annual_interest_rate (float): The annual interest rate as a decimal (e.g., 0.03 for 3%).\n        loan_term_years (int): The term of the loan in years.\n\n    Returns:\n        monthly_payment (float): The monthly payment amount.\n\n    Notes:\n        - The annual interest rate is divided by 12 to obtain the monthly rate.\n        - The loan term in years is multiplied by 12 to obtain the total number of payments.\n        - Not applicable for non-amortizing or interest-only loans.\n    \"\"\"\n    monthly_interest_rate = annual_interest_rate / 12\n    number_of_payments = loan_term_years * 12\n    monthly_payment = loan_amount * (monthly_interest_rate * (1 + monthly_interest_rate) ** number_of_payments) / (\n        (1 + monthly_interest_rate) ** number_of_payments - 1)\n    \n    return monthly_payment\n\ndef calculate_amortization_schedule(loan_amount: float, annual_interest_rate: float, loan_term_years: int) -> list:\n    \"\"\"\n    Generate an amortization schedule showing the breakdown of payments over the loan term.\n\n    This function returns a list of dictionaries where each dictionary represents a payment period,\n    detailing the beginning balance, total payment, interest payment, principal payment, and ending balance.\n\n    Args:\n        loan_amount (float): The principal amount of the loan.\n        annual_interest_rate (float): The annual interest rate as a decimal (e.g., 0.03 for 3%).\n        loan_term_years (int): The term of the loan in years.\n\n    Returns:\n        schedule (list): A list of dictionaries, each containing:\n                         - 'Period': The period number.\n                         - 'Beginning Balance': Loan balance at the start of the period.\n                         - 'Payment': The total payment for the period.\n                         - 'Interest': The interest component of the payment.\n                         - 'Principal': The principal component of the payment.\n                         - 'Ending Balance': Loan balance at the end of the period.\n\n    Notes:\n        - Assumes a fixed interest and principal repayment schedule.\n        - Intends to provide a complete loan amortization overview.\n        - Suitable for traditional fully-amortizing loans.\n    \"\"\"\n    monthly_payment = calculate_monthly_payment(loan_amount, annual_interest_rate, loan_term_years)\n    monthly_interest_rate = annual_interest_rate / 12\n    number_of_payments = loan_term_years * 12\n\n    schedule = []\n    beginning_balance = loan_amount\n\n    for period in range(1, number_of_payments + 1):\n        interest_payment = beginning_balance * monthly_interest_rate\n        principal_payment = monthly_payment - interest_payment\n        ending_balance = beginning_balance - principal_payment\n\n        schedule.append({\n            'Period': period,\n            'Beginning Balance': beginning_balance,\n            'Payment': monthly_payment,\n            'Interest': interest_payment,\n            'Principal': principal_payment,\n            'Ending Balance': ending_balance\n        })\n\n        beginning_balance = ending_balance\n\n    return schedule",
        "statistics": {
            "number_statistics": {
                "args_numbers": 3,
                "question_numbers": 2,
                "context_numbers": 3,
                "total_numbers": 5
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 2,
                    "*": 3,
                    "/": 2,
                    "%": 0,
                    "**": 2
                },
                "total_operators": 11
            },
            "code_statistics": {
                "lines": 7,
                "parentheses": 10
            }
        },
        "difficulty": 4.882801922586371,
        "context": "John is planning to buy a new house and has received a mortgage loan offer from his bank. The loan amount he needs is $350,000, with an annual interest rate of 3.5%. The bank offers a 30-year term for the loan. John wants to know what his monthly payment would be to manage his budget accordingly.",
        "question": "What will be John's monthly mortgage payment for the 30-year loan term at an annual interest rate of 3.5%? Answer to the nearest dollar.",
        "python_solution": "def solution():\n    # Define the loan details\n    loan_amount = 350000  # Principal loan amount in dollars\n    annual_interest_rate = 0.035  # Annual interest rate as a decimal\n    loan_term_years = 30  # Loan term in years\n\n    # Calculate monthly interest rate\n    monthly_interest_rate = annual_interest_rate / 12\n    # Calculate number of payments (months)\n    number_of_payments = loan_term_years * 12\n\n    # Calculate monthly payment using the formula for annuity payments\n    monthly_payment = loan_amount * (monthly_interest_rate * (1 + monthly_interest_rate) ** number_of_payments) / (\n        (1 + monthly_interest_rate) ** number_of_payments - 1)\n\n    # Return the monthly payment rounded to the nearest dollar\n    return round(monthly_payment)\n\n# Execute the solution function\nsolution()",
        "ground_truth": 1572,
        "source": "FinanceReasoning-test-119",
        "question_id": "test-2146",
        "level": "hard",
        "output": [
            "### Analyzing the problem step by step using **Emphasizing Constraints (EC)**:\n\n1. **Understanding the problem**:\n   - John needs to compute the monthly payment for his mortgage loan.\n   - The total loan amount is **$350,000**.\n   - The annual interest rate is **3.5%**.\n   - The loan term is **30 years** (360 monthly payments).\n   - The payment formula or function uses a fixed annual interest rate and fully amortized schedule.\n\n2. **Key financial formula**:\n   - Monthly interest rate = Annual interest rate / 12 / 100.\n   - Total payments (n) = Loan term in years x 12 (since payments are monthly).\n   - Using the amortization formula:\n   \n   \\[ M = P \\times \\frac{r(1 + r)^n}{(1 + r)^n - 1} \\]\n   Where:\n   \\[ M \\] = Monthly payment.\n   \\[ P \\] = Loan amount (principal).\n   \\[ r \\] = Monthly interest rate.\n   \\[ n \\] = Total number of payments.\n\n3. **Constraints**:\n   - The annual interest rate **must be > 0%** because a zero interest rate would require simple division of the loan amount by the number of payments.\n   - The loan term in years and loan amount must also be positive.\n   - The result for the payment should be **rounded to the nearest dollar**, as per the question.\n\n4. **Steps**:\n   - Calculate the monthly interest rate.\n   - Compute the total number of payments.\n   - Plug the values into the formula to compute the monthly mortgage payment.\n   - Return the result rounded to the nearest dollar.\n\n### Python Program:\n\nBelow is the Python program to solve the problem step-by-step:\n\n```python\ndef solution():\n    # Define variables name and value\n    loan_amount = 350000  # Loan principal in dollars\n    annual_interest_rate = 3.5  # Annual interest rate in percentage\n    loan_term_years = 30  # Loan term in years (30 years)\n    \n    # Calculate monthly interest rate and total number of payments\n    monthly_interest_rate = annual_interest_rate / 12 / 100\n    total_payments = loan_term_years * 12\n    \n    # Calculate the monthly payment using the amortization formula\n    monthly_payment = loan_amount * (monthly_interest_rate * (1 + monthly_interest_rate) ** total_payments) / \\\n                      ((1 + monthly_interest_rate) ** total_payments - 1)\n    \n    # Return the result rounded to the nearest dollar\n    return round(monthly_payment)\n```\n\nThis program adheres to all constraints and ensures that the final result meets the required specifications."
        ],
        "retrieval_query": "What will be John's monthly mortgage payment for the 30-year loan term at an annual interest rate of 3.5%? Answer to the nearest dollar.",
        "useful_functions": [
            "def calculate_monthly_payment(principal: float, annual_interest_rate: float, years: int) -> float:\n    \"\"\"\n    Calculate the monthly payment required to fully repay a loan over a specified time period\n    using a fixed interest rate.\n\n    This calculation is applicable for fixed-rate loans including standard repayment plans for\n    student loans or mortgages.\n\n    Args:\n        principal (float): The initial amount of the loan.\n        annual_interest_rate (float): The annual interest rate as a percentage.\n        years (int): The total time in years over which the loan is to be repaid.\n\n    Returns:\n        monthly_payment (float): The amount to be paid monthly to repay the loan in full.\n\n    Notes:\n        - Applicability: Use for fixed-rate loans.\n        - Constraints: Interest rate should be greater than 0; years should be a positive integer.\n        - Considerations: This does not account for fees, taxes, or insurance that may also be part\n                          of monthly payments.\n    \"\"\"\n    if annual_interest_rate <= 0:\n        raise ValueError(\"Interest rate must be greater than zero.\")\n    if years <= 0:\n        raise ValueError(\"Years must be a positive integer.\")\n\n    monthly_interest_rate = annual_interest_rate / 100 / 12\n    number_of_payments = years * 12\n\n    monthly_payment = (principal * monthly_interest_rate) / \\\n                      (1 - (1 + monthly_interest_rate) ** -number_of_payments)\n\n    return monthly_payment",
            "def calculate_monthly_payment(loan_amount: float, annual_interest_rate: float, number_of_payments: int) -> float:\n    \"\"\"\n    Calculate the total monthly payment for an amortized loan.\n\n    This function computes the monthly payment required to fully amortize a loan\n    over a specified term, given the loan's amount, the annual interest rate,\n    and the number of payments. It uses the standard amortization formula for loans.\n\n    Args:\n        loan_amount (float): The total amount of the loan.\n        annual_interest_rate (float): The annual interest rate as a decimal (e.g., 0.03 for 3%).\n        number_of_payments (int): The total number of payments over the life of the loan.\n\n    Returns:\n        total_payment (float): The calculated total monthly payment.\n\n    Notes:\n        - Applicability: Use this function to calculate monthly payments for fixed-rate loans.\n        - Constraints: The annual_interest_rate should be divided by 12 for monthly rate calculation.\n        - Considerations: Ensure the interest rate and number of payments are greater than zero.\n    \"\"\"\n    monthly_rate = annual_interest_rate / 12\n    if monthly_rate == 0:\n        return loan_amount / number_of_payments\n    total_payment = loan_amount * (monthly_rate * (1 + monthly_rate) ** number_of_payments) / ((1 + monthly_rate) ** number_of_payments - 1)\n    \n    return total_payment",
            "def calculate_monthly_mortgage_payment(loan_amount: float, annual_interest_rate: float, loan_term_years: int) -> float:\n    \"\"\"\n    Calculate the monthly mortgage payment for an amortizing loan.\n\n    This function computes the monthly payment amount for a fixed-rate mortgage,\n    given the loan amount, annual interest rate, and the term of the loan in years.\n    It uses the formula for calculating payments on an amortizing loan.\n\n    Args:\n        loan_amount (float): The total amount of the loan.\n        annual_interest_rate (float): The annual interest rate as a percentage (e.g., 5.8 for 5.8%).\n        loan_term_years (int): The loan term in years.\n\n    Returns:\n        monthly_payment (float): The calculated monthly payment amount.\n\n    Notes:\n        - Applicability: Suitable for fixed-rate mortgages where payments are made monthly.\n        - Constraints: The annual interest rate should be positive and expressed as a percentage.\n        - Considerations: This calculation assumes a fully amortizing loan with no additional fees or insurance.\n    \"\"\"\n    monthly_interest_rate = annual_interest_rate / 12 / 100\n    number_of_payments = loan_term_years * 12\n    \n    # Calculate the monthly payment using the formula for an amortizing loan\n    monthly_payment = loan_amount * (monthly_interest_rate * (1 + monthly_interest_rate) ** number_of_payments) / \\\n                      ((1 + monthly_interest_rate) ** number_of_payments - 1)\n\n    return monthly_payment"
        ],
        "usage": {
            "completion_tokens": 575,
            "prompt_tokens": 1362,
            "total_tokens": 1937,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-2563",
        "article_title": "Self Employed Contributions Act (SECA)",
        "function": "def calculate_seca_tax(net_earnings: float, additional_medicare_threshold: float, filing_status: str = 'single') -> float:\n    \"\"\"\n    Calculate the Self-Employed Contributions Act (SECA) tax for a given amount of net earnings.\n\n    This function computes the SECA tax for self-employed individuals based on their net earnings,\n    considering Social Security and Medicare taxes. It also accounts for the additional Medicare Tax\n    if the earnings exceed certain thresholds based on filing status.\n\n    Args:\n        net_earnings (float): The net earnings from self-employment.\n        additional_medicare_threshold (float): The threshold for the additional Medicare tax, based on filing status.\n        filing_status (str, optional): The filing status of the individual. Defaults to 'single'. Options are\n                                       'single', 'married_jointly', 'married_separately'.\n\n    Returns:\n        total_seca_tax (float): The total SECA tax owed based on the net earnings.\n\n    Notes:\n        - This function assumes the tax rates are 12.4% for Social Security and 2.9% for Medicare.\n        - The Social Security tax applies only to earnings up to $160,200 for 2023.\n        - The additional 0.9% Medicare Tax applies to earnings above $200,000 for 'single',\n          $250,000 for 'married_jointly', and $125,000 for 'married_separately'.\n        - Adjustments are necessary if thresholds or rates change in future tax years.\n        - This function does not consider reductions from deductions or tax credits.\n\n    Constraints:\n        - Net earnings must be a positive number. Below $400, no SECA tax is applicable.\n    \"\"\"\n    social_security_tax_rate = 0.124\n    medicare_tax_rate = 0.029\n    additional_medicare_tax_rate = 0.009\n    social_security_cap = 160200\n\n    if net_earnings < 400:\n        return 0.0\n\n    social_security_taxable = min(net_earnings, social_security_cap)\n    social_security_tax = social_security_taxable * social_security_tax_rate\n    medicare_tax = net_earnings * medicare_tax_rate\n\n    additional_medicare_thresholds = {\n        'single': 200000,\n        'married_jointly': 250000,\n        'married_separately': 125000\n    }\n    \n    additional_medicare_threshold = additional_medicare_thresholds.get(filing_status, 200000)\n    additional_medicare_tax = 0.0\n\n    if net_earnings > additional_medicare_threshold:\n        additional_medicare_tax = (net_earnings - additional_medicare_threshold) * additional_medicare_tax_rate\n\n    total_seca_tax = social_security_tax + medicare_tax + additional_medicare_tax\n    return total_seca_tax",
        "statistics": {
            "number_statistics": {
                "args_numbers": 3,
                "question_numbers": 0,
                "context_numbers": 6,
                "total_numbers": 6
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 1,
                    "*": 3,
                    "/": 0,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 6
            },
            "code_statistics": {
                "lines": 20,
                "parentheses": 6
            }
        },
        "difficulty": 4.927253685157204,
        "context": "John, a successful freelance photographer, recently calculated his total net earnings for the year to be $220,000 from his self-employment activities. John files his taxes as 'single'. He's preparing to pay his Self-Employed Contributions Act (SECA) tax, which includes both Social Security and Medicare taxes, along with an additional Medicare tax for earnings over a certain threshold. For 2023, the Social Security tax applies only to earnings up to $160,200, at a rate of 12.4%. The Medicare tax is applied at a rate of 2.9% for the entire net earnings amount. Additionally, since John is filing as 'single', an extra 0.9% Medicare Tax applies to earnings above $200,000. John wants to know the total SECA tax he needs to pay based on these earnings.",
        "question": "What is the total SECA tax John needs to pay for 2023 based on his net earnings? Provide the answer in dollars to the nearest cent.",
        "python_solution": "def solution():\n    # Define the given values\n    net_earnings = 220000\n    social_security_tax_rate = 0.124\n    medicare_tax_rate = 0.029\n    additional_medicare_tax_rate = 0.009\n    social_security_cap = 160200\n    additional_medicare_threshold = 200000  # for 'single'\n\n    # Calculate the Social Security tax\n    social_security_taxable = min(net_earnings, social_security_cap)\n    social_security_tax = social_security_taxable * social_security_tax_rate\n    \n    # Calculate the Medicare tax\n    medicare_tax = net_earnings * medicare_tax_rate\n    \n    # Calculate the additional Medicare tax\n    additional_medicare_tax = 0.0\n    if net_earnings > additional_medicare_threshold:\n        additional_medicare_tax = (net_earnings - additional_medicare_threshold) * additional_medicare_tax_rate\n    \n    # Calculate the total SECA tax\n    total_seca_tax = social_security_tax + medicare_tax + additional_medicare_tax\n\n    # Return the total SECA tax rounded to the nearest cent\n    return round(total_seca_tax, 2)\n\nsolution()",
        "ground_truth": 26424.8,
        "source": "FinanceReasoning-test-129",
        "question_id": "test-2147",
        "level": "hard",
        "output": [
            "Let's solve this step by step using advanced reasoning techniques.\n\n### Step 1: Constraints Analysis\n- **Net Earnings**: $220,000 - This is above the $400 minimum threshold for SECA taxes.\n- **Social Security Tax**:\n  - Taxable income limited to $160,200.\n  - Tax rate = 12.4%.\n- **Medicare Tax**:\n  - Applied to all gross earnings without caps.\n  - Tax rate = 2.9%.\n- **Additional Medicare Tax**:\n  - Applies to earnings above $200,000 for 'single' filing status.\n  - Tax rate = 0.9%.\n- **Dollar Precision**:\n  - The final result must be calculated in dollars to the nearest cent.\n\n### Step 2: Tax Calculation for SECA\n#### 1. **Social Security Tax:**\n   - Use the smaller value between the Social Security taxable cap ($160,200) and John\u2019s earnings ($220,000). That means $160,200 is taxable.\n   - Calculation: \\( 160,200 \\times 12.4\\% = 160,200 \\times 0.124 \\).\n\n#### 2. **Medicare Tax:**\n   - All earnings are taxable for Medicare Tax, i.e., $220,000.\n   - Calculation: \\( 220,000 \\times 2.9\\% = 220,000 \\times 0.029 \\).\n\n#### 3. **Additional Medicare Tax:**\n   - Applies only to the portion of income above $200,000.\n   - Excess earnings: \\( 220,000 - 200,000 = 20,000 \\).\n   - Calculation: \\( 20,000 \\times 0.9\\% = 20,000 \\times 0.009 \\).\n\n### Step 3: Total SECA Tax\n- Sum the calculated Social Security Tax, Medicare Tax, and Additional Medicare Tax.\n- Maintain accuracy to the nearest cent.\n\n### Step 4: Generate the Python Program\nHere's the Python program implementing the above:\n\n```python\ndef solution():\n    # Define variables name and value\n    net_earnings = 220000  # John's net earnings\n    filing_status = 'single'  # Filing status\n    social_security_cap = 160200  # Social Security taxable cap for 2023\n    social_security_tax_rate = 0.124  # Social Security Tax rate\n    medicare_tax_rate = 0.029  # Medicare Tax rate\n    additional_medicare_tax_rate = 0.009  # Additional Medicare Tax rate\n    additional_medicare_threshold = 200000  # Threshold for Additional Medicare Tax for 'single'\n\n    # Calculate Social Security Tax\n    social_security_taxable = min(net_earnings, social_security_cap)\n    social_security_tax = social_security_taxable * social_security_tax_rate\n\n    # Calculate Medicare Tax\n    medicare_tax = net_earnings * medicare_tax_rate\n\n    # Calculate Additional Medicare Tax\n    additional_medicare_tax = 0.0\n    if net_earnings > additional_medicare_threshold:\n        excess_earnings = net_earnings - additional_medicare_threshold\n        additional_medicare_tax = excess_earnings * additional_medicare_tax_rate\n\n    # Total SECA Tax\n    total_seca_tax = social_security_tax + medicare_tax + additional_medicare_tax\n    \n    # Return the answer rounded to the nearest cent\n    return round(total_seca_tax, 2)\n```"
        ],
        "retrieval_query": "What is the total SECA tax John needs to pay for 2023 based on his net earnings? Provide the answer in dollars to the nearest cent.",
        "useful_functions": [
            "def calculate_seca_tax(net_earnings: float, additional_medicare_threshold: float, filing_status: str = 'single') -> float:\n    \"\"\"\n    Calculate the Self-Employed Contributions Act (SECA) tax for a given amount of net earnings.\n\n    This function computes the SECA tax for self-employed individuals based on their net earnings,\n    considering Social Security and Medicare taxes. It also accounts for the additional Medicare Tax\n    if the earnings exceed certain thresholds based on filing status.\n\n    Args:\n        net_earnings (float): The net earnings from self-employment.\n        additional_medicare_threshold (float): The threshold for the additional Medicare tax, based on filing status.\n        filing_status (str, optional): The filing status of the individual. Defaults to 'single'. Options are\n                                       'single', 'married_jointly', 'married_separately'.\n\n    Returns:\n        total_seca_tax (float): The total SECA tax owed based on the net earnings.\n\n    Notes:\n        - This function assumes the tax rates are 12.4% for Social Security and 2.9% for Medicare.\n        - The Social Security tax applies only to earnings up to $160,200 for 2023.\n        - The additional 0.9% Medicare Tax applies to earnings above $200,000 for 'single',\n          $250,000 for 'married_jointly', and $125,000 for 'married_separately'.\n        - Adjustments are necessary if thresholds or rates change in future tax years.\n        - This function does not consider reductions from deductions or tax credits.\n\n    Constraints:\n        - Net earnings must be a positive number. Below $400, no SECA tax is applicable.\n    \"\"\"\n    social_security_tax_rate = 0.124\n    medicare_tax_rate = 0.029\n    additional_medicare_tax_rate = 0.009\n    social_security_cap = 160200\n\n    if net_earnings < 400:\n        return 0.0\n\n    social_security_taxable = min(net_earnings, social_security_cap)\n    social_security_tax = social_security_taxable * social_security_tax_rate\n    medicare_tax = net_earnings * medicare_tax_rate\n\n    additional_medicare_thresholds = {\n        'single': 200000,\n        'married_jointly': 250000,\n        'married_separately': 125000\n    }\n    \n    additional_medicare_threshold = additional_medicare_thresholds.get(filing_status, 200000)\n    additional_medicare_tax = 0.0\n\n    if net_earnings > additional_medicare_threshold:\n        additional_medicare_tax = (net_earnings - additional_medicare_threshold) * additional_medicare_tax_rate\n\n    total_seca_tax = social_security_tax + medicare_tax + additional_medicare_tax\n    return total_seca_tax"
        ],
        "usage": {
            "completion_tokens": 738,
            "prompt_tokens": 1150,
            "total_tokens": 1888,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-2845",
        "article_title": "Exponential Moving Average (EMA)",
        "function": "def calculate_exponential_moving_average(prices: list, smoothing: float = 2, days: int = 20) -> list:\n    \"\"\"\n    Calculate the Exponential Moving Average (EMA) of a list of prices.\n\n    This function computes the EMA, which emphasizes the latest price data more heavily \n    by using an exponentially decreasing weight for past observations. It is used in \n    financial markets to analyze data points like stock prices.\n\n    Args:\n        prices (list): A list of prices in chronological order, where each element\n                       represents the price for a given day.\n        smoothing (float): The smoothing factor typically used as 2. It determines how\n                           much weight is applied to the most recent prices. Default is 2.\n        days (int): The number of periods (days) to calculate the EMA for. Typically a \n                    10, 20, 50, or similar period is used. Default is 20.\n\n    Returns:\n        ema_values (list): A list of EMA values calculated for each price in the input list\n                           starting from the (days+1)th day. The first (days) entries will \n                           be None to indicate insufficient data to compute the EMA.\n\n    Notes:\n        - Applicability: Useful in financial analysis for smoothing out price data to \n          identify trends.\n        - Constraints: Requires at least `days` number of price entries to start calculating EMAs.\n        - Considerations: Different periods may result in different trend sensitivities;\n          shorter EMAs react quicker to price changes than longer ones.\n    \"\"\"\n    if len(prices) < days:\n        raise ValueError(\"Number of prices should be at least equal to the 'days' parameter.\")\n\n    multiplier = smoothing / (1 + days)\n    ema_values = [None] * (days - 1)\n    sma = sum(prices[:days]) / days\n    ema_values.append(sma)\n\n    for price in prices[days:]:\n        new_ema = (price - ema_values[-1]) * multiplier + ema_values[-1]\n        ema_values.append(new_ema)\n\n    return ema_values",
        "statistics": {
            "number_statistics": {
                "args_numbers": 3,
                "question_numbers": 1,
                "context_numbers": 25,
                "total_numbers": 26
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 4,
                    "*": 2,
                    "/": 2,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 10
            },
            "code_statistics": {
                "lines": 8,
                "parentheses": 12
            }
        },
        "difficulty": 4.941642422609304,
        "context": "A financial analyst at a brokerage firm is tasked with analyzing the stock price trend of a technology company. The analyst decides to use the Exponential Moving Average (EMA) to smooth out the daily stock prices. Given the stock prices over the last 22 days: [150, 152, 151, 153, 155, 154, 156, 158, 157, 160, 162, 161, 163, 162, 164, 165, 167, 168, 166, 169, 170, 172], the analyst wants to compute the 20-day EMA. The smoothing factor to be used is the default value of 2.",
        "question": "What is the EMA for the 22nd day using the 20-day period? Answer to two decimal places.",
        "python_solution": "def solution():\n    # Define the input list of prices and parameters\n    prices = [150, 152, 151, 153, 155, 154, 156, 158, 157, 160, \n              162, 161, 163, 162, 164, 165, 167, 168, 166, 169, 170, 172]\n    smoothing = 2\n    days = 20\n\n    # Check if we have enough prices to calculate the EMA\n    if len(prices) < days:\n        raise ValueError(\"Not enough prices to calculate the EMA.\")\n\n    # Calculate the multiplier\n    multiplier = smoothing / (1 + days)\n\n    # Calculate the simple moving average for the first 'days' prices\n    sma = sum(prices[:days]) / days\n\n    # Initialize the EMA values list with None for the first (days-1) elements\n    ema_values = [None] * (days - 1)\n    # Append the first EMA, which is the SMA\n    ema_values.append(sma)\n\n    # Calculate the EMA\n    for price in prices[days:]:\n        new_ema = (price - ema_values[-1]) * multiplier + ema_values[-1]\n        ema_values.append(new_ema)\n\n    # Return the EMA for the 22nd day\n    return round(ema_values[-1], 2)\n\nresult = solution()",
        "ground_truth": 161.72,
        "source": "FinanceReasoning-test-110",
        "question_id": "test-2148",
        "level": "hard",
        "output": [
            "To calculate the Exponential Moving Average (EMA) for the 22nd day given a 20-day period:\n\n1. **Understand the Constraint (EC):**  \n    - We need to use the EMA formula, which computes the EMA with an initial value using the Simple Moving Average (SMA).  \n    - The input list of stock prices has 22 values, which is sufficient since we need a minimum of 20 periods for the calculation.  \n    - The default smoothing factor of 2 is used, and we must calculate the EMA for the 22nd value.  \n    - The answer must be rounded off and displayed to two decimal places.\n\n2. **Plan the Steps:**  \n    - Use the given formula: \n      - Start by calculating the SMA for the first 20 days.\n      - Use the multiplier for the weighting factor: `Multiplier = 2 / (20 + 1) = 2 / 21`.\n      - Update the EMA iteratively using the formula:  \n        \\[\n        \\text{EMA}_{\\text{next}} = (\\text{Current Price} - \\text{EMA}_{\\text{previous}}) \\times \\text{Multiplier} + \\text{EMA}_{\\text{previous}}\n        \\]\n    - Iterate by adding one price at a time from the 21st day onward.\n\n3. **Implementation Considerations:**  \n    - Ensure there are at least 20 values in the price list.\n    - Initialize EMA using the SMA formula.\n    - Respect precision constraints (answer to two decimal places).\n    \nNow, let\u2019s generate the Python program.\n\n```python\ndef solution():\n    # Define variables: stock prices for last 22 days and the period\n    stock_prices = [150, 152, 151, 153, 155, 154, 156, 158, 157, 160, 162, 161, 163, 162, 164, 165, 167, 168, 166, 169, 170, 172]\n    period = 20  # 20-day EMA\n    smoothing_factor = 2\n    \n    # Ensure there are sufficient data points\n    if len(stock_prices) < period:\n        raise ValueError(\"The number of stock prices must be at least equal to the period.\")\n    \n    # Step 1: Calculate SMA for the first 'period' days\n    sma = sum(stock_prices[:period]) / period\n    \n    # Step 2: Initialize variables for EMA calculation\n    multiplier = smoothing_factor / (period + 1)\n    ema = sma  # start with SMA as the initial EMA value\n    \n    # Step 3: Apply the EMA formula starting from the (period + 1)-th day\n    for price in stock_prices[period:]:\n        ema = (price - ema) * multiplier + ema\n    \n    # Step 4: Round the result to 2 decimal places and return\n    return round(ema, 2)\n\n```"
        ],
        "retrieval_query": "What is the EMA for the 22nd day using the 20-day period? Answer to two decimal places.",
        "useful_functions": [
            "def calculate_ema(close_prices: list, n_periods: int) -> float:\n    \"\"\"\n    Calculate the Exponential Moving Average (EMA) for a given number of periods.\n\n    The EMA helps to smooth out price data and capture the current trend by giving\n    more weight to recent prices. It is used in technical analysis to anticipate\n    potential breakouts or identify current trends.\n\n    Args:\n        close_prices (list): A list of closing prices in chronological order.\n        n_periods (int): The number of periods over which to calculate the EMA.\n\n    Returns:\n        ema (float): The calculated exponential moving average.\n\n    Notes:\n        - Applicability: Useful for trend analysis in financial time series data.\n        - Constraints: The list of closing prices must contain at least `n_periods` values.\n        - Considerations: The first EMA value is calculated using a Simple Moving Average (SMA).\n    \"\"\"\n    # Calculate the initial SMA\n    if len(close_prices) < n_periods:\n        raise ValueError(\"The number of close prices must be at least equal to the number of periods.\")\n    \n    sma = sum(close_prices[:n_periods]) / n_periods\n\n    # Calculate the multiplier for weighting the EMA\n    multiplier = 2 / (n_periods + 1)\n    \n    # Calculate the initial EMA using the SMA\n    ema = sma\n\n    # Calculate the EMA for the rest of the periods\n    for price in close_prices[n_periods:]:\n        ema = (price - ema) * multiplier + ema\n    \n    return ema"
        ],
        "usage": {
            "completion_tokens": 619,
            "prompt_tokens": 826,
            "total_tokens": 1445,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-2883",
        "article_title": "Negative Volume Index (NVI)",
        "function": "def calculate_negative_volume_index(prices: list, volumes: list) -> list:\n    \"\"\"\n    Calculate the Negative Volume Index (NVI) to analyze price movements during low volume days.\n\n    This function computes the NVI, which is used to identify smart money movements and trend directions\n    by focusing on days when trading volume decreases compared to the previous day.\n\n    Args:\n        prices (list): A list of prices or index levels at each time period (e.g., daily closing prices).\n        volumes (list): A list of trading volumes corresponding to each time period.\n\n    Returns:\n        nvi (list): A list of NVI values for each time period, starting from the second period.\n\n    Notes:\n        - Prices and volumes lists must have equal lengths.\n        - The first NVI value assumes an initial value of the same size as the prices[0] (e.g., 1000).\n        - If the volume does not decrease compared to the previous day, the NVI value does not change for that day.\n        - The function does not handle time series index; NVI values align with input list indices.\n        - Ensure that both lists contain valid numerical data with at least two elements.\n\n    \"\"\"\n    if len(prices) != len(volumes):\n        raise ValueError(\"Prices and volumes lists must have the same length.\")\n    \n    nvi = [1000]  # Initialize NVI with a starting value (e.g., 1000)\n    \n    for t in range(1, len(prices)):\n        if volumes[t] < volumes[t - 1]:\n            nvi_value = nvi[-1] + ((prices[t] - prices[t - 1]) / prices[t - 1]) * nvi[-1]\n        else:\n            nvi_value = nvi[-1]\n        \n        nvi.append(nvi_value)\n        \n    return nvi",
        "statistics": {
            "number_statistics": {
                "args_numbers": 2,
                "question_numbers": 0,
                "context_numbers": 5,
                "total_numbers": 5
            },
            "operator_statistics": {
                "operators": {
                    "+": 1,
                    "-": 7,
                    "*": 1,
                    "/": 1,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 10
            },
            "code_statistics": {
                "lines": 8,
                "parentheses": 12
            }
        },
        "difficulty": 4.941642422609304,
        "context": "An investment analyst is tracking the price movements and trading volumes of ABC Corp over a recent period to identify smart money movements. The closing prices for ABC Corp for five consecutive days are: [102, 100, 105, 107, 103]. The corresponding trading volumes (in thousands of shares) for these days are: [1500, 1600, 1400, 1300, 1350]. The analyst uses the Negative Volume Index (NVI) starting with an initial value of 1000 to focus on days with decreased trading volumes and analyze the potential price trends during these days.",
        "question": "Calculate the Negative Volume Index (NVI) after five days. Provide your answer rounded to two decimal places.",
        "python_solution": "def solution():\n    # Define the given prices and volumes\n    prices = [102, 100, 105, 107, 103]\n    volumes = [1500, 1600, 1400, 1300, 1350]\n    \n    # Initialize initial NVI value\n    initial_nvi = 1000\n    nvi = [initial_nvi]  # Start NVI with the initial value\n\n    # Iterate over each day's prices and volumes starting from day 2\n    for t in range(1, len(prices)):\n        if volumes[t] < volumes[t - 1]:\n            # Calculate the change in NVI when volume decreases\n            price_change_percentage = (prices[t] - prices[t - 1]) / prices[t - 1]\n            new_nvi_value = nvi[-1] + price_change_percentage * nvi[-1]\n        else:\n            # Maintain the same NVI value when volume does not decrease\n            new_nvi_value = nvi[-1]\n        \n        # Append the calculated NVI value for the day\n        nvi.append(new_nvi_value)\n\n    # Return the NVI value for the last day\n    return round(nvi[-1], 2)",
        "ground_truth": 1070.0,
        "source": "FinanceReasoning-test-142",
        "question_id": "test-2149",
        "level": "hard",
        "output": [
            "To solve the problem of calculating the Negative Volume Index (NVI) over five days, we will systematically follow these steps:\n\n### Step-by-step Breakdown:\n1. **Define Constraints (Emphasizing Constraints)**:\n   - Ensure the list of prices and volumes are of the same length.\n   - If the volume of the current day is less than the previous day's volume, the NVI changes; otherwise, it remains constant.\n   - The NVI starts with an initial value of 1000 and updates based on the percentage change of the price when there is a decrease in volume.\n   - The final result must be calculated with two decimal places.\n\n2. **Algorithm**:\n   - Initialize the NVI with a value of 1000.\n   - Iterate through the specified days starting from the second day.\n   - Check if the trading volume has decreased compared to the previous day.\n     - If decreased, update the NVI using the percentage change in price:  \n       \\( \\text{NVI}_t = \\text{NVI}_{t-1} + \\left( \\frac{\\text{Price}_t - \\text{Price}_{t-1}}{\\text{Price}_{t-1}} \\right) \\times \\text{NVI}_{t-1}\\)\n     - If not decreased, retain the NVI value of the previous day.\n   - After finishing the iteration, return the NVI for the fifth day rounded to two decimal places.\n\n3. **Implementation**:\n   We'll calculate the NVI day by day based on the algorithm described and return the value after five days.\n\nHere is the Python program:\n\n```python\ndef solution():\n    # Define variables name and value\n    prices = [102, 100, 105, 107, 103]\n    volumes = [1500, 1600, 1400, 1300, 1350]\n    initial_nvi = 1000\n    \n    # Initialize the NVI list\n    nvi = [initial_nvi]\n    \n    # Perform calculations for NVI\n    for t in range(1, len(prices)):\n        if volumes[t] < volumes[t - 1]:  # Check if volume decreases\n            nvi_value = nvi[-1] + ((prices[t] - prices[t - 1]) / prices[t - 1]) * nvi[-1]\n        else:\n            nvi_value = nvi[-1]  # NVI remains constant if volume does not decrease\n        nvi.append(nvi_value)\n    \n    # Return the NVI after five days, rounded to two decimal places\n    return round(nvi[-1], 2)\n```"
        ],
        "retrieval_query": "Calculate the Negative Volume Index (NVI) after five days. Provide your answer rounded to two decimal places.",
        "useful_functions": [
            "def calculate_negative_volume_index(prices: list, volumes: list) -> list:\n    \"\"\"\n    Calculate the Negative Volume Index (NVI) to analyze price movements during low volume days.\n\n    This function computes the NVI, which is used to identify smart money movements and trend directions\n    by focusing on days when trading volume decreases compared to the previous day.\n\n    Args:\n        prices (list): A list of prices or index levels at each time period (e.g., daily closing prices).\n        volumes (list): A list of trading volumes corresponding to each time period.\n\n    Returns:\n        nvi (list): A list of NVI values for each time period, starting from the second period.\n\n    Notes:\n        - Prices and volumes lists must have equal lengths.\n        - The first NVI value assumes an initial value of the same size as the prices[0] (e.g., 1000).\n        - If the volume does not decrease compared to the previous day, the NVI value does not change for that day.\n        - The function does not handle time series index; NVI values align with input list indices.\n        - Ensure that both lists contain valid numerical data with at least two elements.\n\n    \"\"\"\n    if len(prices) != len(volumes):\n        raise ValueError(\"Prices and volumes lists must have the same length.\")\n    \n    nvi = [1000]  # Initialize NVI with a starting value (e.g., 1000)\n    \n    for t in range(1, len(prices)):\n        if volumes[t] < volumes[t - 1]:\n            nvi_value = nvi[-1] + ((prices[t] - prices[t - 1]) / prices[t - 1]) * nvi[-1]\n        else:\n            nvi_value = nvi[-1]\n        \n        nvi.append(nvi_value)\n        \n    return nvi"
        ],
        "usage": {
            "completion_tokens": 553,
            "prompt_tokens": 869,
            "total_tokens": 1422,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "If ABC Corporation releases three-year bonds dated 1 January 2015 that have a face value of $5,000,000, how are they most likely reported as bonds payable when issued, considering the market interest rate for bonds of similar risk and term is 3% and the bonds yield an annual rate of 2.5% on 31 December? Answer to three decimal places.",
        "python_solution": "def solution():\n    FV = 5000000 # Face Value of Bond\n    I_M = 0.03 # Market Interest Rate\n    I_B = 0.025 # Bond Yield Rate\n    N = 3 # Period of Bond in Years\n    PMT = FV * I_B # Annual Payments\n    PV = 0 # Present Value of Bond\n    \n    # Compute for Present value\n    for i in range(1, N+1):\n        PV += PMT/(1+I_M)**i # Compute Present Value based on Discount Factor Formula\n    PV += FV/(1+I_M)**N # Add the Face Value discounted back to today at Market Rate\n    \n    return PV",
        "ground_truth": 4929284.716,
        "topic": "Accounting",
        "statistics": {
            "number_statistics": {
                "args_numbers": 3,
                "question_numbers": 5,
                "context_numbers": 0,
                "total_numbers": 5
            },
            "operator_statistics": {
                "operators": {
                    "+": 5,
                    "-": 0,
                    "*": 1,
                    "/": 2,
                    "%": 0,
                    "**": 2
                },
                "total_operators": 10
            },
            "code_statistics": {
                "lines": 11,
                "parentheses": 6
            }
        },
        "difficulty": 4.941642422609304,
        "source": "FinanceMath-validation-185",
        "context": "[]",
        "question_id": "test-2150",
        "level": "hard",
        "output": [
            "To solve the given problem, we'll use the \"Emphasizing Constraints (EC)\" reasoning technique to ensure all calculations adhere to the constraints provided in the context and the question.\n\n### Step 1: Problem Analysis\nThe problem requires us to calculate the reporting value of bonds payable when issued based on their face value, the market interest rate (3%), and the yield or coupon rate (2.5%). \n\nThis setup indicates that the bonds were issued at a **premium** or **discount**. Bonds issued at a discount or premium are valued based on the present value of their future cash flows (coupon payments and repayment of face value), using the market interest rate as the discount rate.\n\n### Step 2: Constraints\n1. **Precision**: The answer should be calculated up to three decimal places.\n2. **Discounting Rates**: The market interest rate (3%) and coupon rate (2.5%) must be converted to decimals.\n3. **Cash Flow Schedule**: Bonds have three annual payments (coupon payments + face value repayment at the end).\n\n### Step 3: Key Formulas\nFor bonds valuation:\n1. **Coupon Payment** (`annual_coupon`): \n   \\[\n   \\text{Coupon Payment} = \\text{Face Value} \\times \\text{Coupon Rate}\n   \\]\n\n2. **Discounted Present Value of Cash Flows**:\n   - Present value of annual coupon payments for three years:\n     \\[\n     PV_{\\text{coupon}} = \\sum_{t=1}^{3} \\frac{\\text{Coupon Payment}}{(1 + r)^t}\n     \\]\n   - Present value of the principal repayment (face value) at maturity:\n     \\[\n     PV_{\\text{principal}} = \\frac{\\text{Face Value}}{(1 + r)^3}\n     \\]\n   - Total present value (issue price of the bond):\n     \\[\n     \\text{Bond Price} = PV_{\\text{coupon}} + PV_{\\text{principal}}\n     \\]\n\nWhere:\n- \\( r \\) = Market interest rate (3% or 0.03 in decimal form).\n\n### Step 4: Plan\n1. Calculate the annual coupon payment (\\( \\text{Coupon Payment} \\)).\n2. Calculate the present value of the three coupon payments using the market interest rate.\n3. Calculate the present value of the face value repayment.\n4. Sum the present values to determine the total bond issue price.\n5. Return the final answer rounded to three decimal places.\n\nNow, let's write the Python program for this calculation.\n\n```python\ndef solution():\n    # Define variables\n    face_value = 5000000  # Face value of the bond\n    coupon_rate = 2.5 / 100  # Annual coupon rate as a decimal\n    market_rate = 3 / 100  # Market interest rate as a decimal\n    num_periods = 3  # Bond term in years\n    \n    # Calculate coupon payment\n    annual_coupon = face_value * coupon_rate\n    \n    # Calculate present value of coupon payments\n    pv_coupon = sum(annual_coupon / ((1 + market_rate) ** t) for t in range(1, num_periods + 1))\n    \n    # Calculate present value of the face value repayment\n    pv_principal = face_value / ((1 + market_rate) ** num_periods)\n    \n    # Total bond price (issue price)\n    bond_price = pv_coupon + pv_principal\n    \n    # Return the result rounded to three decimal places\n    return round(bond_price, 3)\n```"
        ],
        "retrieval_query": "If ABC Corporation releases three-year bonds dated 1 January 2015 that have a face value of $5,000,000, how are they most likely reported as bonds payable when issued, considering the market interest rate for bonds of similar risk and term is 3% and the bonds yield an annual rate of 2.5% on 31 December? Answer to three decimal places.",
        "useful_functions": [
            "def calculate_make_whole_call_price(remaining_payments: list, principal: float, treasury_yield: float, spread: float) -> float:\n    \"\"\"\n    Calculate the make-whole call price for a bond.\n\n    This function computes the make-whole call price, which is the present value of\n    the remaining scheduled payments (both interest and principal) of a bond, discounted\n    at a rate derived from the Treasury yield and a specified spread. It is used to determine\n    the payout an issuer must make to call a bond early with a make-whole provision.\n\n    Args:\n        remaining_payments (list): A list of remaining coupon payments.\n        principal (float): The principal amount of the bond to be paid at maturity.\n        treasury_yield (float): The yield of a comparable Treasury security used as a basis\n                                for discounting future cash flows (expressed as a decimal).\n        spread (float): The additional spread over the Treasury yield used for discounting\n                        (expressed as a decimal).\n\n    Returns:\n        make_whole_price (float): The present value of the bond's remaining cash flows including\n                                  the principal, representing the make-whole call price.\n\n    Notes:\n        - Applicability: This function is applicable in the context of make-whole call provisions\n          for bonds when calculating the early redemption price.\n        - Constraints: Ensure all interest rates are provided as decimals (e.g., 2% should be 0.02).\n        - Considerations: Consider the possibility of changes in interest rates affecting the discount rate.\n                          This function assumes cash flows occur at the end of each period.\n    \"\"\"\n    discount_rate = treasury_yield + spread\n    make_whole_price = sum(cf / ((1 + discount_rate) ** (i + 1)) for i, cf in enumerate(remaining_payments))\n    make_whole_price += principal / ((1 + discount_rate) ** len(remaining_payments))\n\n    return make_whole_price",
            "def amortize_bond_discount(purchase_price: float, face_value: float, num_periods: int, coupon_rate: float, market_rate: float) -> list:\n    \"\"\"\n    Amortize the bond discount using the effective interest rate method.\n\n    This function computes the amortization schedule of a bond discount over\n    its life using the effective interest rate method. The bond discount is\n    gradually expensed to interest, with each period's interest expense based\n    on the bond's book value at the start of the period.\n\n    Args:\n        purchase_price (float): The price at which the bond was originally purchased.\n        face_value (float): The face value or par value of the bond.\n        num_periods (int): The total number of periods (e.g., years) until maturity.\n        coupon_rate (float): The annual coupon rate of the bond as a percentage.\n        market_rate (float): The annual market interest rate during issuance as a percentage.\n\n    Returns:\n        amortization_schedule (list): A list of tuples representing each period's\n        interest payment, interest expense, and amortization amount.\n\n    Notes:\n        - Applicability: Useful for calculating interest expenses for bonds issued at a discount.\n        - Constraints: Assumes the bond has periodic, fixed coupon payments.\n        - Considerations: Ensure that coupon and market rates are expressed as percentages.\n    \"\"\"\n    amortization_schedule = []\n    book_value = purchase_price\n\n    for period in range(1, num_periods + 1):\n        coupon_payment = face_value * coupon_rate / 100\n        interest_expense = book_value * market_rate / 100\n        amortization = interest_expense - coupon_payment\n        book_value += amortization\n\n        amortization_schedule.append((coupon_payment, interest_expense, amortization))\n\n    return amortization_schedule",
            "def calculate_adjusted_mcclellan_oscillator(ana: float, prior_19_day_ema: float, prior_39_day_ema: float) -> float:\n    \"\"\"\n    Calculate the Adjusted McClellan Oscillator using Adjusted Net Advances (ANA).\n\n    This version of the McClellan Oscillator adjusts for changes in the number of \n    stocks listed by using ANA instead of raw advances/declines, offering a more \n    reliable long-term indicator.\n\n    Args:\n        ana (float): Adjusted Net Advances, a normalized measure of market breadth.\n        prior_19_day_ema (float): The previous day's 19-day EMA of ANA.\n        prior_39_day_ema (float): The previous day's 39-day EMA of ANA.\n\n    Returns:\n        adjusted_mcclellan_oscillator (float): The value of the adjusted McClellan Oscillator.\n\n    Notes:\n        - This version provides consistency across periods with varying numbers of listed stocks.\n        - Ensure prior EMA values are initialized based on historical 19- and 39-day averages.\n        - Reflects the overall trend direction in the market adjusted for breadth.\n    \"\"\"\n    ema_19_day = (ana * 0.10) + (prior_19_day_ema * (1 - 0.10))\n    ema_39_day = (ana * 0.05) + (prior_39_day_ema * (1 - 0.05))\n    adjusted_mcclellan_oscillator = ema_19_day - ema_39_day\n    \n    return adjusted_mcclellan_oscillator"
        ],
        "usage": {
            "completion_tokens": 740,
            "prompt_tokens": 1544,
            "total_tokens": 2284,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-990",
        "article_title": "3/27 Adjustable-Rate Mortgage (ARM)",
        "function": "def calculate_monthly_payment(principal: float, annual_interest_rate: float, years: int) -> float:\n    \"\"\"\n    Calculate the monthly mortgage payment for a fixed-rate period.\n\n    This function computes the monthly payment for a mortgage based on the loan\n    principal, annual fixed interest rate, and duration of the loan in years.\n\n    Args:\n        principal (float): The loan amount (principal) in dollars.\n        annual_interest_rate (float): The annual fixed interest rate as a percentage (e.g., 3.5 for 3.5%).\n        years (int): The number of years for the fixed-rate period.\n\n    Returns:\n        monthly_payment (float): The monthly mortgage payment in dollars.\n\n    Notes:\n        - This function assumes a fixed interest rate for the specified period.\n        - The interest rate should be provided as a percentage, not a decimal.\n        - The result will be a positive float representing the payment amount.\n        - This calculation does not include taxes, insurance, or other fees.\n    \"\"\"\n    monthly_interest_rate = annual_interest_rate / 100 / 12\n    number_of_payments = years * 12\n    if annual_interest_rate == 0:\n        return principal / number_of_payments\n    monthly_payment = (principal * monthly_interest_rate) / \\\n                      (1 - (1 + monthly_interest_rate) ** -number_of_payments)\n    return monthly_payment\n\ndef calculate_adjusted_monthly_payment(principal: float, years: int, index_rate: float, margin: float) -> float:\n    \"\"\"\n    Calculate the adjusted monthly mortgage payment after the fixed-rate period.\n\n    This function computes the monthly payment for a mortgage based on the loan\n    principal, remaining years, indexed rate, and bank margin, after the initial\n    fixed rate period has ended.\n\n    Args:\n        principal (float): The remaining loan amount (principal) in dollars.\n        years (int): The remaining number of years on the loan.\n        index_rate (float): The current index rate as a percentage (e.g., 3 for 3%).\n        margin (float): The bank's margin as a percentage.\n\n    Returns:\n        adjusted_monthly_payment (float): The adjusted monthly payment in dollars.\n\n    Notes:\n        - The function assumes the interest rate is adjusted based on an index rate plus a margin.\n        - The rates should be provided as percentages, not decimals.\n        - This calculation does not account for potential rate caps.\n        - The function is meant for transition from fixed to adjustable rates.\n    \"\"\"\n    adjusted_annual_rate = index_rate + margin\n    monthly_interest_rate = adjusted_annual_rate / 100 / 12\n    number_of_payments = years * 12\n    if adjusted_annual_rate == 0:\n        return principal / number_of_payments\n    adjusted_monthly_payment = (principal * monthly_interest_rate) / \\\n                               (1 - (1 + monthly_interest_rate) ** -number_of_payments)\n    return adjusted_monthly_payment",
        "statistics": {
            "number_statistics": {
                "args_numbers": 3,
                "question_numbers": 1,
                "context_numbers": 7,
                "total_numbers": 8
            },
            "operator_statistics": {
                "operators": {
                    "+": 1,
                    "-": 3,
                    "*": 2,
                    "/": 4,
                    "%": 0,
                    "**": 1
                },
                "total_operators": 11
            },
            "code_statistics": {
                "lines": 9,
                "parentheses": 8
            }
        },
        "difficulty": 4.962844630259907,
        "context": "Alice took a 15-year fixed-rate mortgage with a principal amount of $250,000 at an annual interest rate of 4.5%. After the fixed-rate period ended, the remaining principal balance was $150,000. Her mortgage transitioned to an adjustable-rate with the current index rate at 2% and a bank margin of 1.5%. She wants to calculate her new monthly payment for the remaining 10 years of the mortgage under these new terms, assuming there are no rate caps.",
        "question": "What is Alice's new adjusted monthly mortgage payment after the fixed-rate period for the remaining 10 years? Answer in dollars, rounded to the nearest cent.",
        "python_solution": "def solution():\n    # Given values\n    principal = 150000  # Remaining principal after fixed-rate period in dollars\n    years = 10  # Remaining years\n    index_rate = 2.0  # Index rate in percentage\n    margin = 1.5  # Bank margin in percentage\n\n    # Calculate the adjusted annual interest rate\n    adjusted_annual_rate = index_rate + margin\n\n    # Convert the annual interest rate to a monthly interest rate\n    monthly_interest_rate = adjusted_annual_rate / 100 / 12\n\n    # Calculate the total number of payments\n    number_of_payments = years * 12\n\n    # Calculate the adjusted monthly payment using the formula for an annuity\n    adjusted_monthly_payment = (principal * monthly_interest_rate) / \\\n                               (1 - (1 + monthly_interest_rate) ** -number_of_payments)\n\n    # Return the adjusted monthly payment rounded to the nearest cent\n    return round(adjusted_monthly_payment, 2)",
        "ground_truth": 1483.29,
        "source": "FinanceReasoning-test-116",
        "question_id": "test-2151",
        "level": "hard",
        "output": [
            "### Step-by-Step Solution with Emphasizing Constraints (EC):\n\nLet's solve the problem using the \"Emphasizing Constraints (EC)\" reasoning technique:\n\n#### Constraints:\n1. Mortgage Transition:\n   - The loan transitions from a fixed-rate to an adjustable-rate mortgage (ARM).\n   - The adjustable annual interest rate (fully indexed rate) is calculated as the `index_rate` plus the `bank_margin`.\n\n2. Adjusted Monthly Payment Formula:\n   - The formula must account for:\n     - Remaining principal.\n     - Remaining years (10 years).\n     - Fully indexed rate as a percentage, converted to a decimal.\n   - Ensure accurate monthly compounding in the formula.\n\n3. Financial Precision:\n   - All results must be in dollars and rounded to the nearest cent.\n\n4. Valid Inputs:\n   - The principal, rates (`index_rate`, `margin`), and time must be non-negative.\n\n#### Step-by-Step Problem Solving:\n1. Determine the **remaining principal (loan amount)**: $150,000.\n2. Calculate the **fully indexed rate**:\n   - Fully Indexed Rate = Index Rate + Bank Margin = `2% + 1.5% = 3.5%`.\n3. Determine the **remaining loan term in months**:\n   - Remaining Term = 10 years \u00d7 12 months = 120 months.\n4. Use the formula for an adjustable-rate loan's monthly payment:\n   - Adjusted Monthly Payment = `P \u00d7 (r \u00d7 (1 + r)\u207f) / ((1 + r)\u207f - 1)`\n     - `P`: Principal = $150,000\n     - `r`: Monthly interest rate = Fully Indexed Rate \u00f7 12 = `3.5% \u00f7 12`\n     - `n`: Number of payments = Remaining Term = 120 months.\n5. Perform the calculations ensuring adherence to the constraints.\n\n---\n\nHere is the Python program to calculate the new adjusted monthly mortgage payment:\n\n```python\ndef solution():\n    # Define variables\n    principal = 150000  # Remaining principal amount in dollars\n    index_rate = 2.0    # Current index rate as a percentage\n    margin = 1.5        # Bank's margin as a percentage\n    remaining_years = 10  # Remaining loan term in years\n    \n    # Calculate parameters\n    fully_indexed_rate = index_rate + margin  # Fully indexed annual interest rate in percent\n    monthly_interest_rate = fully_indexed_rate / 100 / 12  # Convert annual percent rate to monthly decimal rate\n    total_months = remaining_years * 12  # Total number of payments\n    \n    # Calculate adjusted monthly payment\n    adjusted_monthly_payment = (principal * monthly_interest_rate) / \\\n                                (1 - (1 + monthly_interest_rate) ** -total_months)\n    \n    # Round the answer to the nearest cent\n    return round(adjusted_monthly_payment, 2)\n```"
        ],
        "retrieval_query": "What is Alice's new adjusted monthly mortgage payment after the fixed-rate period for the remaining 10 years? Answer in dollars, rounded to the nearest cent.",
        "useful_functions": [
            "def calculate_adjustable_payment(principal: float, fully_indexed_rate: float, loan_term_months: int) -> float:\n    \"\"\"\n    Calculate the monthly payment for a period of an adjustable-rate mortgage (ARM) based on \n    the fully indexed rate.\n\n    This function determines the monthly payment amount for a given loan principal and fully\n    indexed interest rate using a specified loan term in months.\n\n    Args:\n        principal (float): The remaining principal amount of the loan.\n        fully_indexed_rate (float): The fully indexed interest rate as a decimal (e.g., 0.07 for 7%).\n        loan_term_months (int): The number of months remaining in the loan term.\n\n    Returns:\n        monthly_payment (float): The calculated monthly payment amount.\n\n    Notes:\n        - Applicability: Useful for calculating payments after the fixed period ends in an ARM.\n        - Constraints: Principal and fully indexed rate must be non-negative; term must be greater than 0.\n        - Considerations: Fully indexed rate should be adjusted for monthly compounding in the calculation.\n    \"\"\"\n    if principal < 0 or fully_indexed_rate < 0 or loan_term_months <= 0:\n        raise ValueError(\"Principal, fully indexed rate must be non-negative and term must be positive.\")\n\n    monthly_rate = fully_indexed_rate / 12\n    monthly_payment = principal * (monthly_rate * (1 + monthly_rate) ** loan_term_months) / \\\n                      ((1 + monthly_rate) ** loan_term_months - 1)\n    \n    return monthly_payment",
            "def calculate_monthly_payment(loan_amount: float, annual_interest_rate: float, number_of_payments: int) -> float:\n    \"\"\"\n    Calculate the total monthly payment for an amortized loan.\n\n    This function computes the monthly payment required to fully amortize a loan\n    over a specified term, given the loan's amount, the annual interest rate,\n    and the number of payments. It uses the standard amortization formula for loans.\n\n    Args:\n        loan_amount (float): The total amount of the loan.\n        annual_interest_rate (float): The annual interest rate as a decimal (e.g., 0.03 for 3%).\n        number_of_payments (int): The total number of payments over the life of the loan.\n\n    Returns:\n        total_payment (float): The calculated total monthly payment.\n\n    Notes:\n        - Applicability: Use this function to calculate monthly payments for fixed-rate loans.\n        - Constraints: The annual_interest_rate should be divided by 12 for monthly rate calculation.\n        - Considerations: Ensure the interest rate and number of payments are greater than zero.\n    \"\"\"\n    monthly_rate = annual_interest_rate / 12\n    if monthly_rate == 0:\n        return loan_amount / number_of_payments\n    total_payment = loan_amount * (monthly_rate * (1 + monthly_rate) ** number_of_payments) / ((1 + monthly_rate) ** number_of_payments - 1)\n    \n    return total_payment",
            "def calculate_monthly_payment(principal: float, annual_interest_rate: float, years: int) -> float:\n    \"\"\"\n    Calculate the monthly mortgage payment for a fixed-rate period.\n\n    This function computes the monthly payment for a mortgage based on the loan\n    principal, annual fixed interest rate, and duration of the loan in years.\n\n    Args:\n        principal (float): The loan amount (principal) in dollars.\n        annual_interest_rate (float): The annual fixed interest rate as a percentage (e.g., 3.5 for 3.5%).\n        years (int): The number of years for the fixed-rate period.\n\n    Returns:\n        monthly_payment (float): The monthly mortgage payment in dollars.\n\n    Notes:\n        - This function assumes a fixed interest rate for the specified period.\n        - The interest rate should be provided as a percentage, not a decimal.\n        - The result will be a positive float representing the payment amount.\n        - This calculation does not include taxes, insurance, or other fees.\n    \"\"\"\n    monthly_interest_rate = annual_interest_rate / 100 / 12\n    number_of_payments = years * 12\n    if annual_interest_rate == 0:\n        return principal / number_of_payments\n    monthly_payment = (principal * monthly_interest_rate) / \\\n                      (1 - (1 + monthly_interest_rate) ** -number_of_payments)\n    return monthly_payment\n\ndef calculate_adjusted_monthly_payment(principal: float, years: int, index_rate: float, margin: float) -> float:\n    \"\"\"\n    Calculate the adjusted monthly mortgage payment after the fixed-rate period.\n\n    This function computes the monthly payment for a mortgage based on the loan\n    principal, remaining years, indexed rate, and bank margin, after the initial\n    fixed rate period has ended.\n\n    Args:\n        principal (float): The remaining loan amount (principal) in dollars.\n        years (int): The remaining number of years on the loan.\n        index_rate (float): The current index rate as a percentage (e.g., 3 for 3%).\n        margin (float): The bank's margin as a percentage.\n\n    Returns:\n        adjusted_monthly_payment (float): The adjusted monthly payment in dollars.\n\n    Notes:\n        - The function assumes the interest rate is adjusted based on an index rate plus a margin.\n        - The rates should be provided as percentages, not decimals.\n        - This calculation does not account for potential rate caps.\n        - The function is meant for transition from fixed to adjustable rates.\n    \"\"\"\n    adjusted_annual_rate = index_rate + margin\n    monthly_interest_rate = adjusted_annual_rate / 100 / 12\n    number_of_payments = years * 12\n    if adjusted_annual_rate == 0:\n        return principal / number_of_payments\n    adjusted_monthly_payment = (principal * monthly_interest_rate) / \\\n                               (1 - (1 + monthly_interest_rate) ** -number_of_payments)\n    return adjusted_monthly_payment"
        ],
        "usage": {
            "completion_tokens": 608,
            "prompt_tokens": 1713,
            "total_tokens": 2321,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "The time-to-maturity for Bond D is 3 years and it has a coupon rate of 8%. The bond has a face value of 100. The annual payments of interest can be seen. Given the depicted spot rates, what would be the price of Bond D using these spot rates? Answer to three decimal places.",
        "python_solution": "def solution():\n    PMT = 8\n    Par = 100\n    S1 = 0.07\n    S2 = 0.08\n    S3 = 0.09\n    PV = PMT/(1+S1) + PMT/((1+S2)**2) + (PMT+Par)/((1+S3)**3)\n    return PV",
        "ground_truth": 97.731,
        "topic": "Asset Classes & Derivatives",
        "statistics": {
            "number_statistics": {
                "args_numbers": 4,
                "question_numbers": 3,
                "context_numbers": 6,
                "total_numbers": 9
            },
            "operator_statistics": {
                "operators": {
                    "+": 6,
                    "-": 0,
                    "*": 0,
                    "/": 3,
                    "%": 0,
                    "**": 2
                },
                "total_operators": 11
            },
            "code_statistics": {
                "lines": 7,
                "parentheses": 12
            }
        },
        "difficulty": 4.962844630259907,
        "source": "FinanceMath-validation-104",
        "context": "['| Time-to-Maturity | Spot rates |\\n|-----------------|------------|\\n| 1-year            | 7%             |\\n| 2-year            | 8%             |\\n| 3-year            | 9%             |']",
        "question_id": "test-2152",
        "level": "hard",
        "output": [
            "To solve the problem, let\u2019s first carefully break it down step-by-step and ensure that we adhere to all relevant constraints using the **Emphasizing Constraints (EC)** technique. \n\n### Step-by-step Analysis:\n\n#### 1. Understand the Bond's Characteristics:\n   - **Face Value**: 100 \n   - **Coupon Rate**: 8% (annual)\n   - **Time-to-Maturity**: 3 years\n   - **Spot Rates**: \n     - 1-year = 7% = 0.07 (as a decimal)\n     - 2-year = 8% = 0.08 (as a decimal)\n     - 3-year = 9% = 0.09 (as a decimal)\n   - **Coupon Payment Calculation**:\n     - Coupon Payment = Face Value \u00d7 Coupon Rate\n     - Coupon Payment = 100 \u00d7 0.08 = 8 annually.\n\n#### 2. Understanding Constraints:\n   - We must calculate the bond price by discounting each cash flow (coupons + face value at maturity) using its respective year\u2019s spot rate.\n   - Constraints:\n     - Use provided financial formulas.\n     - Outputs must be rounded to **three decimal places**.\n     - Ensure spot rates are used correctly for discounting all cash flows.\n\n#### 3. Method to Solve:\n   - The bond price is the sum of the present value of:\n     - Annual coupon payments discounted at respective year's spot rate.\n     - Face Value of the bond discounted at the 3-year spot rate.\n   - For each year:\n     - **Year 1**: Discount first coupon payment (8) with the 1-year spot rate (7%).\n     - **Year 2**: Discount second coupon payment (8) with the 2-year spot rate (8%).\n     - **Year 3**: Discount third coupon payment (8) + face value (100) with the 3-year spot rate (9%).\n\n#### 4. Formula Summary:\n   - Bond Price = \u03a3 (Coupon Payment / (1 + Spot Rate)^Year) + (Face Value / (1 + Spot Rate)^Year-for-Maturity)\n   - This translates to the summation over time-to-maturity.\n\n---\n\n### Python Program:\nUsing the structured understanding, we can now translate this into a Python program.\n\n```python\ndef solution():\n    # Define variables: face value, coupon rate, time to maturity, spot rates\n    face_value = 100\n    coupon_rate = 0.08\n    time_to_maturity = 3\n    spot_rates = [0.07, 0.08, 0.09]  # Spot rates for the respective years\n    \n    # Calculate coupon payment\n    coupon_payment = face_value * coupon_rate  # Annual coupon payment\n    \n    # Initialize bond price\n    bond_price = 0.0\n    \n    # Loop through each year to sum up present values of cash flows\n    for year in range(1, time_to_maturity + 1):\n        cash_flow = coupon_payment  # Each year's cash flow starts with the coupon payment\n        if year == time_to_maturity:  # Add face value at maturity\n            cash_flow += face_value\n        # Discount cash flow to present value using the respective spot rate\n        bond_price += cash_flow / ((1 + spot_rates[year - 1]) ** year)\n    \n    # Return the calculated bond price rounded to 3 decimal places\n    return round(bond_price, 3)\n```\n\n### Explanation of Code:\n1. The **variables** are defined at the beginning with face value, coupon rate, time-to-maturity, and spot rates.\n2. The **coupon payment formula** computes the annual cash flow from interest payments.\n3. A **loop iterates** through each year to compute the **present value (PV)** of coupon payments.\n4. For the third year, it incorporates the **face value** into the cash flow, as the bond matures.\n5. Each cash flow is discounted using its respective **spot rate**, converted into PV, and summed.\n6. The final price is rounded to **three decimal places** for precision.\n\nThis program adheres to all specified constraints and efficiently computes the bond price.\n\n---\n\n"
        ],
        "retrieval_query": "The time-to-maturity for Bond D is 3 years and it has a coupon rate of 8%. The bond has a face value of 100. The annual payments of interest can be seen. Given the depicted spot rates, what would be the price of Bond D using these spot rates? Answer to three decimal places.",
        "useful_functions": [
            "def calculate_bond_price(face_value: float, coupon_rate: float, years: int, spot_rates: list) -> float:\n    \"\"\"\n    Calculate the price of a bond using its face value, annual coupon rate, and spot rates for each year.\n\n    This function computes the present value of the bond's future cash flows, \n    which include regular coupon payments and the face value at maturity. Each \n    cash flow is discounted using the specified spot rate for its corresponding year.\n\n    Args:\n        face_value (float): The face value of the bond.\n        coupon_rate (float): The annual coupon rate of the bond as a decimal (e.g., 0.05 for 5%).\n        years (int): The number of years until the bond matures.\n        spot_rates (list): A list of annual spot rates as decimals (one for each year up to maturity).\n\n    Returns:\n        bond_price (float): The calculated price of the bond.\n\n    Notes:\n        - Applicability: This function is used for bonds with annual coupon payments.\n        - Constraints: The length of spot_rates must equal the number of years.\n        - Considerations: Ensure that spot_rates contain realistic values \n          (greater than -1) to prevent calculation errors in the discounting process.\n    \"\"\"\n    if len(spot_rates) != years:\n        raise ValueError(\"The number of spot rates must match the number of years.\")\n\n    bond_price = 0.0\n    coupon_payment = face_value * coupon_rate\n\n    for year in range(1, years + 1):\n        cash_flow = coupon_payment\n        if year == years:\n            cash_flow += face_value  # Add face value at maturity\n        bond_price += cash_flow / ((1 + spot_rates[year - 1]) ** year)\n\n    return round(bond_price, 2)"
        ],
        "usage": {
            "completion_tokens": 881,
            "prompt_tokens": 836,
            "total_tokens": 1717,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "Considering the provided financial statement information, what is the cash conversion cycle (net operating cycle) of this specific business? Answer to three decimal places.",
        "python_solution": "def solution():\n    inventory_days = ((2000 + 1500)/2)/(30000/365)\n    receivables_days = 3000/(40000/365)\n    operating_cycle = inventory_days + receivables_days\n    purchases = 30000 + 2000 - 1500\n    payables_days = 4000/(purchases/365)\n    net_operating_cycle = operating_cycle - payables_days\n    return net_operating_cycle",
        "ground_truth": 0.798,
        "topic": "Corporate & Securities Issuance",
        "statistics": {
            "number_statistics": {
                "args_numbers": 1,
                "question_numbers": 0,
                "context_numbers": 6,
                "total_numbers": 6
            },
            "operator_statistics": {
                "operators": {
                    "+": 3,
                    "-": 2,
                    "*": 0,
                    "/": 7,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 12
            },
            "code_statistics": {
                "lines": 7,
                "parentheses": 10
            }
        },
        "difficulty": 4.969813299576001,
        "source": "FinanceMath-validation-72",
        "context": "['|                                            | In Millions ($) |\\n|--------------------------------------------|----------------:|\\n| Credit sales                               |          40,000 |\\n| Cost of goods sold                         |          30,000 |\\n| Accounts receivable                        |           3,000 |\\n| Inventory-Beginning balance                |           1,500 |\\n| Inventory- Ending balance                  |           2,000 |\\n| Accounts payable                           |           4,000 |']",
        "question_id": "test-2153",
        "level": "hard",
        "output": [
            "To answer the question of calculating the Cash Conversion Cycle (CCC), we follow a step-by-step approach:\n\n### Breakdown of Calculation\nThe formula for the Cash Conversion Cycle is as follows:\n\\[\nCCC = DIO + DSO - DPO\n\\]\nWhere:\n- **DIO**: Days Inventory Outstanding, calculated as:\n\\[\nDIO = \\frac{\\text{Average Inventory}}{\\text{Cost of Goods Sold}} \\times 365\n\\]\n- **DSO**: Days Sales Outstanding, calculated as:\n\\[\nDSO = \\frac{\\text{Accounts Receivable}}{\\text{Credit Sales}} \\times 365\n\\]\n- **DPO**: Days Payable Outstanding, calculated as:\n\\[\nDPO = \\frac{\\text{Accounts Payable}}{\\text{Cost of Goods Sold}} \\times 365\n\\]\n\n### Inputs from the Table\nFrom the provided information:\n- Credit Sales = $40,000 million\n- Cost of Goods Sold = $30,000 million\n- Accounts Receivable = $3,000 million\n- Inventory (Beginning Balance) = $1,500 million\n- Inventory (Ending Balance) = $2,000 million\n- Accounts Payable = $4,000 million\n\n### Constraints\n1. Use monetary values in millions.\n2. Calculate average inventory:\n\\[\n\\text{Average Inventory} = \\frac{\\text{Beginning Inventory} + \\text{Ending Inventory}}{2}\n\\]\n3. Final answer should be returned to three decimal places.\n\n### Plan of Calculation\n1. Compute **Average Inventory**.\n2. Compute each of the DIO, DSO, and DPO metrics using the formulas.\n3. Substitute these values into the CCC formula.\n4. Return the CCC rounded to three decimal places.\n\nHere is the Python program to arrive at the answer.\n\n```python\ndef solution():\n    # Input variables (in millions)\n    credit_sales = 40000\n    cost_of_goods_sold = 30000\n    accounts_receivable = 3000\n    inventory_beginning = 1500\n    inventory_ending = 2000\n    accounts_payable = 4000\n    \n    # Calculate Average Inventory\n    average_inventory = (inventory_beginning + inventory_ending) / 2\n    \n    # Calculate DIO (Days Inventory Outstanding)\n    DIO = (average_inventory / cost_of_goods_sold) * 365\n    \n    # Calculate DSO (Days Sales Outstanding)\n    DSO = (accounts_receivable / credit_sales) * 365\n    \n    # Calculate DPO (Days Payable Outstanding)\n    DPO = (accounts_payable / cost_of_goods_sold) * 365\n    \n    # Calculate Cash Conversion Cycle (CCC)\n    CCC = DIO + DSO - DPO\n    \n    # Return the result rounded to three decimal places\n    return round(CCC, 3)\n```"
        ],
        "retrieval_query": "Considering the provided financial statement information, what is the cash conversion cycle (net operating cycle) of this specific business? Answer to three decimal places.",
        "useful_functions": [
            "def calculate_net_change_in_liability(beginning_balance: float, ending_balance: float) -> float:\n    \"\"\"\n    Calculate the net change in a financial liability over a period.\n\n    This function calculates the net change in a specified liability by\n    subtracting the beginning balance from the ending balance. This calculation\n    is often used to determine how a financial obligation has evolved over a \n    given timeframe.\n\n    Args:\n        beginning_balance (float): The balance of the liability at the start of the period.\n        ending_balance (float): The balance of the liability at the end of the period.\n\n    Returns:\n        net_change (float): The net change in the liability over the given period.\n\n    Notes:\n        - Applicability: This function is applicable to any financial metrics that have \n          distinct starting and ending balances, such as liabilities, assets, or equity.\n        - Constraints: The balances should be monetary values, and both must be\n          non-negative.\n        - Considerations: The result represents the absolute change and may not indicate \n          profit or loss (a negative result indicates a reduction in the liability).\n    \"\"\"\n    net_change = ending_balance - beginning_balance\n    \n    return net_change"
        ],
        "usage": {
            "completion_tokens": 601,
            "prompt_tokens": 707,
            "total_tokens": 1308,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "Bradley took over a Spanish packaging firm. The Spanish venture included Bradley purchasing 200,000 shares at a rate of EUR90 each from a packaging company. He elected to entirely hedge the position with a six month USD/EUR forward contract. Further details of the euro hedge at the beginning and three months later are displayed in Exhibit 1. Using the information in Exhibit 1, if the Spanish shares were sold after three months, what is the mark-to-market value (in US dollars) that the manager would report? Answer to three decimal places.",
        "python_solution": "def solution():\n    num_shares = 200000\n    price_per_share_eur = 90\n    total_value_eur = num_shares * price_per_share_eur\n    \n    init_forward_rate = 1.3935 - 19/10000\n    settling_forward_rate = 1.4210 - 21/10000\n    \n    diff_rate = init_forward_rate - settling_forward_rate\n    \n    notional_value_usd = diff_rate * total_value_eur\n    \n    libor = 1.266 / 100\n    investment_period = 90\n    \n    mark_to_market_usd = notional_value_usd / (1 + libor * investment_period / 360)\n    \n    return mark_to_market_usd",
        "ground_truth": -489849.626,
        "topic": "Asset Classes & Derivatives",
        "statistics": {
            "number_statistics": {
                "args_numbers": 4,
                "question_numbers": 3,
                "context_numbers": 22,
                "total_numbers": 25
            },
            "operator_statistics": {
                "operators": {
                    "+": 1,
                    "-": 3,
                    "*": 3,
                    "/": 5,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 12
            },
            "code_statistics": {
                "lines": 11,
                "parentheses": 2
            }
        },
        "difficulty": 4.969813299576001,
        "source": "FinanceMath-validation-80",
        "context": "['| Maturity         | At Initiation | Three Months Later | At Maturity |\\n|------------------|--------------|---------------------|------------|\\n| Spot (USD/EUR)   | 1.3935/1.3983 | 1.4106/1.4210      | 1.4189/1.4289 |\\n| 3-month forward  | -8.1/-7.6      | -21.6/-21.0           |          |\\n| 6-month forward  | -19.0/-18.3   | -27.0/-26.2           |          |\\n| USD Libor       | 1.266%        | 1.266%               | 1.266%   |\\n| EUR Libor       | 1.814%        | 1.814%               | 1.814%   |']",
        "question_id": "test-2154",
        "level": "hard",
        "output": [
            "To compute the mark-to-market value of the position using the provided information, I will break down the process step by step using the provided `calculate_mark_to_market_value` function. I will adhere to any constraints as specified.\n\n---\n\n### Problem Analysis and Constraints:\n1. **Initial Inputs**:\n    - **Shares Purchased**: 200,000\n    - **Price Per Share (\u20ac)**: 90 EUR\n    - **Initial Spot Bid Rate (USD/EUR)**: 1.3935 (from Exhibit 1)\n    - **Initial 6-Month Forward Pips**: -19.0 (forward premium/discount is in pips)\n    - **3-Month Spot Ask Rate (USD/EUR)**: 1.4210\n    - **3-Month Forward Pips**: -21.0\n2. **LIBOR Rate**:\n    - **USD LIBOR (Annual, %) = 1.266**\n    - To adjust for 3 months, LIBOR should be scaled to `period_days`/360.\n3. **Duration**:\n    - Period of calculation: The shares were sold **3 months** into the hedge, which is equivalent to 90 days.\n4. **Calculation Goals**:\n    - Adhere to a precision of **three decimal places** for the answer.\n    - Use inputs provided in Exhibit 1 for spot rates, forward pips, and LIBOR.\n\n---\n\n### Steps for Solution:\n1. Using the formula outlined in the provided `calculate_mark_to_market_value` function:\n   - **Initial Forward Rate** = Initial Spot Bid - (Initial Forward Pips / 10,000)\n   - **Settling Forward Rate** = Spot Ask Rate After 3 Months - (Forward Pips After 3 Months / 10,000)\n\n2. Calculate the **difference in rates**:\n   - Difference = Initial Forward Rate \u2212 Settling Forward Rate\n\n3. Determine the **total value of shares in EUR**:\n   - Total Value (\u20ac) = Shares \u00d7 Share Price (\u20ac)\n\n4. Convert the difference to the **notional value in USD**:\n   - Notional Value (USD) = Difference \u00d7 Total Value (\u20ac)\n\n5. Apply the **present value adjustment using LIBOR**:\n   - Adjust for present value using 90 days and LIBOR annual rate scaled to the period.\n\n6. Return the Mark-to-Market Value rounded to three decimal places.\n\n---\n\n### Python Program:\n```python\ndef solution():\n    # Define variables name and value\n    total_shares = 200000\n    share_price_eur = 90\n    init_spot_bid = 1.3935\n    init_forward_pips = -19.0\n    later_spot_ask = 1.4210\n    later_forward_pips = -21.0\n    annual_usd_libor = 1.266  # LIBOR in percent\n    period_days = 90  # 3 months\n    \n    # Perform calculations as per the steps\n    # 1. Calculate the initial forward rate\n    init_forward_rate = init_spot_bid - (init_forward_pips / 10000)\n    \n    # 2. Calculate the settling forward rate after 3 months\n    settling_forward_rate = later_spot_ask - (later_forward_pips / 10000)\n    \n    # 3. Calculate difference in rates\n    diff_rate = init_forward_rate - settling_forward_rate\n    \n    # 4. Calculate total value in Euros\n    total_value_eur = total_shares * share_price_eur\n    \n    # 5. Notional value in USD\n    notional_value_usd = diff_rate * total_value_eur\n    \n    # 6. Present value adjustment\n    mark_to_market_value = notional_value_usd / (1 + (annual_usd_libor / 100) * (period_days / 360))\n    \n    # 7. Return the final Mark-to-Market Value rounded to three decimal places\n    return round(mark_to_market_value, 3)\n```"
        ],
        "retrieval_query": "Bradley took over a Spanish packaging firm. The Spanish venture included Bradley purchasing 200,000 shares at a rate of EUR90 each from a packaging company. He elected to entirely hedge the position with a six month USD/EUR forward contract. Further details of the euro hedge at the beginning and three months later are displayed in Exhibit 1. Using the information in Exhibit 1, if the Spanish shares were sold after three months, what is the mark-to-market value (in US dollars) that the manager would report? Answer to three decimal places.",
        "useful_functions": [
            "def calculate_mark_to_market_value(total_shares: int, \n                                   share_price_eur: float, \n                                   init_spot_bid: float, \n                                   init_forward_pips: float, \n                                   later_spot_ask: float, \n                                   later_forward_pips: float, \n                                   annual_usd_libor: float, \n                                   period_days: int) -> float:\n    \"\"\"\n    Calculate the mark-to-market value of a hedged foreign investment.\n\n    This function computes the mark-to-market value of a position initially hedged with a forward \n    contract, after a given period, using the initial and later forward rates.\n\n    Args:\n        total_shares (int): The total number of shares purchased.\n        share_price_eur (float): The price per share in Euros.\n        init_spot_bid (float): The initial spot bid rate in USD/EUR.\n        init_forward_pips (float): The initial forward rate premium/discount in pips.\n        later_spot_ask (float): The spot ask rate at a later time in USD/EUR.\n        later_forward_pips (float): The forward rate premium/discount at a later time in pips.\n        annual_usd_libor (float): The annual USD Libor rate as a percentage.\n        period_days (int): The number of days for the investment period.\n\n    Returns:\n        mark_to_market_value (float): The mark-to-market value in USD.\n\n    Notes:\n        - This function assumes a forward contract with a linear distribution of pips.\n        - The notional value is adjusted based on the difference between forward rates.\n        - The annual USD Libor rate is applied proportionally to the investment period.\n        - Ensure that all percentages and pips are converted to decimal form where necessary.\n    \"\"\"\n    # Calculate initial forward rate\n    init_forward_rate = init_spot_bid - init_forward_pips / 10000\n    \n    # Calculate settling forward rate\n    settling_forward_rate = later_spot_ask - later_forward_pips / 10000\n    \n    # Calculate the difference in rates\n    diff_rate = init_forward_rate - settling_forward_rate\n    \n    # Calculate the total value in Euros\n    total_value_eur = total_shares * share_price_eur\n    \n    # Calculate the notional value in USD\n    notional_value_usd = diff_rate * total_value_eur\n    \n    # Calculate the present value of the mark-to-market difference\n    mark_to_market_value = notional_value_usd / (1 + (annual_usd_libor / 100) * (period_days / 360))\n    \n    return mark_to_market_value"
        ],
        "usage": {
            "completion_tokens": 841,
            "prompt_tokens": 1179,
            "total_tokens": 2020,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "Recently, Mr. Lee purchased a property in Shanghai and made a down payment of \u00a5 5,000,000. He took out a loan for the remaining balance of \u00a55,000,000 from the bank which he will repay monthly over a period of 10 years. Given that the yearly discount rate is 5.8%, what will the initial mortgage repayment be at the end of this month? Answer to three decimal places.",
        "python_solution": "def solution():\n    N = 10 * 12\n    I_Y = 5.8 / 12 / 100\n    PV = 5000000\n    FV = 0\n    PMT = -PV * (I_Y * ((1 + I_Y)**N)) / ((1+I_Y)**N - 1)\n    return abs(PMT)",
        "ground_truth": 55009.405,
        "topic": "Quantitative Analysis & Valuation",
        "statistics": {
            "number_statistics": {
                "args_numbers": 2,
                "question_numbers": 4,
                "context_numbers": 0,
                "total_numbers": 4
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 2,
                    "*": 3,
                    "/": 3,
                    "%": 0,
                    "**": 2
                },
                "total_operators": 12
            },
            "code_statistics": {
                "lines": 6,
                "parentheses": 12
            }
        },
        "difficulty": 4.969813299576001,
        "source": "FinanceMath-validation-89",
        "context": "[]",
        "question_id": "test-2155",
        "level": "hard",
        "output": [
            "### Step-by-Step Solution Using Emphasizing Constraints (EC):\n\n1. **Understand the Problem**:\n    - Mr. Lee needs to calculate how much his initial (monthly) mortgage repayment will be for a \u00a55,000,000 loan when amortized over a period of 10 years.\n    - The annual interest rate is 5.8%.\n    - The loan is a fully amortized loan, meaning the principal and interest are included in fixed monthly payments.\n\n2. **Constraints**:\n    - Adhere to the requirement of expressing the annual interest rate as a percentage.\n    - Ensure the monthly interest rate is derived appropriately.\n    - The repayment period must be converted from years into months.\n    - The output needs to be rounded to three decimal places for accuracy.\n\n3. **Key Formula**:\n    - The monthly payment can be calculated using the formula for amortizing loans:\n      \\[\n      M = P \\times \\frac{i \\times (1 + i)^n}{(1 + i)^n - 1}\n      \\]\n      Where:\n      - \\(M\\): Monthly Payment\n      - \\(P\\): Loan Amount (\u00a55,000,000)\n      - \\(i\\): Monthly Interest Rate (\\( \\text{annual interest rate} / 12 / 100 \\))\n      - \\(n\\): Total Number of Payments (\\( \\text{years} \\times 12 \\))\n\n4. **Implementation**:\n    - Calculate the monthly interest rate by dividing the annual interest rate by 12 and convert it to a decimal.\n    - Compute the total number of payments as the loan's term in years multiplied by 12.\n    - Use the amortizing loan formula to compute the monthly payment.\n    - Return the calculated value rounded to three decimal places.\n\n### Python Program:\n```python\ndef solution():\n    # Define variables for the problem\n    loan_amount = 5000000  # \u00a55,000,000 loan\n    annual_interest_rate = 5.8  # 5.8% yearly interest rate\n    loan_term_years = 10  # Loan term is 10 years\n    \n    # Calculations\n    monthly_interest_rate = annual_interest_rate / 12 / 100  # Monthly interest rate as decimal\n    total_months = loan_term_years * 12  # Total number of payments (in months)\n\n    # Monthly payment formula for a fixed amortized loan\n    monthly_payment = loan_amount * (monthly_interest_rate * (1 + monthly_interest_rate) ** total_months) / \\\n                      ((1 + monthly_interest_rate) ** total_months - 1)\n    \n    # Round the result to three decimal places\n    answer = round(monthly_payment, 3)\n    \n    # Return the calculated answer\n    return answer\n```"
        ],
        "retrieval_query": "Recently, Mr. Lee purchased a property in Shanghai and made a down payment of \u00a5 5,000,000. He took out a loan for the remaining balance of \u00a55,000,000 from the bank which he will repay monthly over a period of 10 years. Given that the yearly discount rate is 5.8%, what will the initial mortgage repayment be at the end of this month? Answer to three decimal places.",
        "useful_functions": [
            "def calculate_monthly_mortgage_payment(loan_amount: float, annual_interest_rate: float, loan_term_years: int) -> float:\n    \"\"\"\n    Calculate the monthly mortgage payment for an amortizing loan.\n\n    This function computes the monthly payment amount for a fixed-rate mortgage,\n    given the loan amount, annual interest rate, and the term of the loan in years.\n    It uses the formula for calculating payments on an amortizing loan.\n\n    Args:\n        loan_amount (float): The total amount of the loan.\n        annual_interest_rate (float): The annual interest rate as a percentage (e.g., 5.8 for 5.8%).\n        loan_term_years (int): The loan term in years.\n\n    Returns:\n        monthly_payment (float): The calculated monthly payment amount.\n\n    Notes:\n        - Applicability: Suitable for fixed-rate mortgages where payments are made monthly.\n        - Constraints: The annual interest rate should be positive and expressed as a percentage.\n        - Considerations: This calculation assumes a fully amortizing loan with no additional fees or insurance.\n    \"\"\"\n    monthly_interest_rate = annual_interest_rate / 12 / 100\n    number_of_payments = loan_term_years * 12\n    \n    # Calculate the monthly payment using the formula for an amortizing loan\n    monthly_payment = loan_amount * (monthly_interest_rate * (1 + monthly_interest_rate) ** number_of_payments) / \\\n                      ((1 + monthly_interest_rate) ** number_of_payments - 1)\n\n    return monthly_payment"
        ],
        "usage": {
            "completion_tokens": 578,
            "prompt_tokens": 741,
            "total_tokens": 1319,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "V-Tex Monetary Fund is one of the best performing hedge funds in the U.S. The fund has $350 million of assets under management and a '2 and 30' fee structure. Last year, the fund earned a return of 20% and the ending capital position was established as a high water mark. This year, the fund value stood at $320 million before the payment of any fees. Management fees and incentive fees are calculated independently using end-of-period values. What will be the ending capital position at the end of this year? Answer in millions of dollars to one decimal place.",
        "context": "",
        "statistics": {
            "number_statistics": {
                "question_numbers": 5,
                "context_numbers": 0,
                "total_numbers": 5
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 2,
                    "*": 4,
                    "/": 1,
                    "%": 0,
                    "**": 1
                },
                "total_operators": 10
            },
            "code_statistics": {
                "lines": 13,
                "parentheses": 4
            }
        },
        "difficulty": 5.0106352940962555,
        "ground_truth": 313.6,
        "source": "FinCode-test-10",
        "python_solution": "total_assets = 350000000\nreturn_last_year = 0.2\ncurrent_fund_value = 320000000\nmanagement_fee_rate = 0.02\nincentive_fee_rate = 0.3\nprofit = total_assets * return_last_year\ntotal_after_profit = total_assets + profit\nmanagement_fee = total_after_profit * management_fee_rate\nincentive_fee =  profit * incentive_fee_rate\nhigh_water_mark = total_assets - (management_fee + incentive_fee)\ncurrent_management_fee = current_fund_value * management_fee_rate\nending_position = current_fund_value - current_management_fee\nround(ending_position / 10**6, 1)\n",
        "question_id": "test-2156",
        "level": "hard",
        "output": [
            "### Step-by-Step Analysis Using Emphasizing Constraints (EC)\n\n1. **Constraints**:\n    - Management and incentive fees are to be calculated independently using end-of-period values.\n    - Incentive fees are only applied if the current fund value exceeds the high-water mark.\n    - The high-water mark is established from the previous year's ending capital position after deducting both management and incentive fees.\n    - Management fees are 2% (0.02) and incentive fees are 30% (0.30).\n    - Report the ending capital position of this year in millions and round to one decimal place.\n\n2. **Calculations Needed**:\n    - **Step 1**: Compute the high-water mark from the previous year's performance.\n        - Starting assets last year: $350 million.\n        - Last year\u2019s return: 20% (0.20).\n        - Last year\u2019s profit: $350 million \u00d7 0.20 = $70 million.\n        - Last year's fund value before fees: $350 million + $70 million = $420 million.\n        - Management fee last year: $420 million \u00d7 0.02 = $8.4 million.\n        - Incentive fee on last year\u2019s profit: $70 million \u00d7 0.30 = $21 million.\n        - High-water mark: $420 million - ($8.4 million + $21 million) = $390.6 million.\n\n    - **Step 2**: Compute the current year's ending capital position:\n        - Current year's fund value before fees: $320 million.\n        - Management fee for the current year: $320 million \u00d7 0.02 = $6.4 million.\n        - Check if the current fund value exceeds the high-water mark:\n            - $320 million < $390.6 million.\n            - Since the current fund value is below the high-water mark, no incentive fee applies.\n        - Ending capital: $320 million - $6.4 million = $313.6 million.\n\n    - **Step 3**: Convert the result into millions and round to one decimal place.\n\n3. **Program Implementation**:\nThe following Python program will calculate the ending capital position:\n\n```python\ndef solution():\n    # Define variables\n    initial_assets = 350  # in millions\n    last_year_return = 0.20\n    current_fund_value = 320  # in millions\n    management_fee_rate = 0.02\n    incentive_fee_rate = 0.30\n\n    # Step 1: Calculate last year's high-water mark\n    last_year_profit = initial_assets * last_year_return\n    last_year_value_before_fees = initial_assets + last_year_profit\n    last_year_management_fee = last_year_value_before_fees * management_fee_rate\n    last_year_incentive_fee = last_year_profit * incentive_fee_rate\n    high_water_mark = last_year_value_before_fees - (last_year_management_fee + last_year_incentive_fee)\n\n    # Step 2: Calculate the current year's ending capital position\n    current_management_fee = current_fund_value * management_fee_rate\n    current_incentive_fee = 0  # No incentive fee applied since fund value < high-water mark\n    if current_fund_value > high_water_mark:\n        current_incentive_fee = (current_fund_value - high_water_mark) * incentive_fee_rate\n    ending_capital = current_fund_value - current_management_fee - current_incentive_fee\n\n    # Return in millions to one decimal place\n    return round(ending_capital, 1)\n```"
        ],
        "retrieval_query": "V-Tex Monetary Fund is one of the best performing hedge funds in the U.S. The fund has $350 million of assets under management and a '2 and 30' fee structure. Last year, the fund earned a return of 20% and the ending capital position was established as a high water mark. This year, the fund value stood at $320 million before the payment of any fees. Management fees and incentive fees are calculated independently using end-of-period values. What will be the ending capital position at the end of this year? Answer in millions of dollars to one decimal place.",
        "useful_functions": [
            "def calculate_ending_capital_position(initial_assets: float, last_year_return: float, \n                                      current_fund_value: float, management_fee_rate: float, \n                                      incentive_fee_rate: float) -> float:\n    \"\"\"\n    Calculate the ending capital position of a hedge fund after applying management and incentive fees.\n\n    This function computes the ending capital position of a hedge fund given its initial assets, \n    last year's return, current fund value, and specified fee structure. The management fee is calculated \n    based on the current fund value and the incentive fee is applicable only if the current fund value \n    exceeds the high water mark established from the previous year.\n\n    Args:\n        initial_assets (float): The assets under management at the start of the previous year.\n        last_year_return (float): The return rate achieved by the fund last year.\n        current_fund_value (float): The value of the fund at the end of the current year before any fees \n                                    are deducted.\n        management_fee_rate (float): The rate at which management fees are calculated (e.g., 0.02 for 2%).\n        incentive_fee_rate (float): The rate at which incentive fees are calculated on profits exceeding \n                                    the high water mark (e.g., 0.3 for 30%).\n\n    Returns:\n        ending_capital (float): The ending capital position after applying relevant fees.\n\n    Notes:\n        - Applicability: This function is applicable for hedge funds with a specified fee structure \n                         involving management and incentive fees.\n        - Constraints: The incentive fee is only applied if the fund's current value exceeds the high water mark.\n        - Considerations: Ensure the rates are provided in decimal form (e.g., 0.02 for 2%).\n    \"\"\"\n    profit = initial_assets * last_year_return\n    total_after_profit = initial_assets + profit\n    management_fee_last_year = total_after_profit * management_fee_rate\n    incentive_fee_last_year = profit * incentive_fee_rate\n    high_water_mark = total_after_profit - (management_fee_last_year + incentive_fee_last_year)\n    \n    current_management_fee = current_fund_value * management_fee_rate\n    current_incentive_fee = 0\n    if current_fund_value > high_water_mark:\n        current_incentive_fee = (current_fund_value - high_water_mark) * incentive_fee_rate\n    \n    ending_capital = current_fund_value - current_management_fee - current_incentive_fee\n    return round(ending_capital / 10**6, 1)"
        ],
        "usage": {
            "completion_tokens": 737,
            "prompt_tokens": 966,
            "total_tokens": 1703,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "Given that the spot exchange rate from the \"Kiwi\" (NZD) to sterling (GBP) is 2.0979, the Libor interest rate for the sterling is 1.6025%, and for the \"Kiwi\" it's 3.2875%, all being quoted on a 360-day year basis, what are the 180-day forward points in NZD/GBP (in basis points)? Answer to three decimal places.",
        "python_solution": "def solution():\n    spot_rate = 2.0979\n    gbp_interest_rate = 1.6025/100\n    nzd_interest_rate = 3.2875/100\n    time_in_years = 180/360\n\n    gbp_investment = 1 * (1 + gbp_interest_rate * time_in_years)\n    nzd_investment = spot_rate * (1 + nzd_interest_rate * time_in_years)\n    \n    forward_rate = nzd_investment / gbp_investment\n    \n    forward_points = (forward_rate - spot_rate) * 10000\n\n    return round(forward_points, 3)",
        "ground_truth": 175.343,
        "topic": "Market Analysis & Economics",
        "statistics": {
            "number_statistics": {
                "args_numbers": 4,
                "question_numbers": 5,
                "context_numbers": 0,
                "total_numbers": 5
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 1,
                    "*": 5,
                    "/": 4,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 12
            },
            "code_statistics": {
                "lines": 9,
                "parentheses": 8
            }
        },
        "difficulty": 5.049856007249537,
        "source": "FinanceMath-validation-1",
        "context": "[]",
        "question_id": "test-2157",
        "level": "hard",
        "output": [
            "Step 1: **Understand the Problem and Constraints (EC)**\n- We are required to calculate the 180-day forward points in NZD/GBP based on the given interest rates and spot exchange rate.\n- Exchange rates and interest rates are given on a 360-day year basis.\n- The forward points will be expressed in basis points (1 basis point = 0.0001 of exchange rate movement).\n- The final result needs precision up to three decimal places.\n\nStep 2: **Formula for Calculating Forward Rates**\n- The forward rate (F) is derived using:\n  \\[\n  F = S \\cdot e^{(i_{NZD} - i_{GBP}) \\cdot t}\n  \\]\n  Where:\n  - \\( S \\): Spot exchange rate (NZD/GBP)\n  - \\( i_{NZD} \\): Interest rate for NZD (Kiwi)\n  - \\( i_{GBP} \\): Interest rate for GBP (Sterling)\n  - \\( t \\): Time period in fractions of a year (here, \\( t = \\frac{180}{360} = 0.5 \\)).\n\n- Forward points are calculated based on:\n  \\[\n  \\text{Forward Points} = (F - S) \\times 10,000\n  \\]\n\nStep 3: **Steps for Calculations**\n1. Convert interest rates from percentages to decimals.\n2. Plug values into the forward rate formula to compute \\( F \\).\n3. Calculate forward points using \\( (F - S) \\times 10,000 \\).\n4. Round the result to three decimal places.\n\nNow, let's implement the solution in Python.\n\n```python\nimport math\n\ndef solution():\n    # Define variables\n    S = 2.0979  # Spot exchange rate (NZD/GBP)\n    i_NZD = 3.2875 / 100  # NZD interest rate in decimal\n    i_GBP = 1.6025 / 100  # GBP interest rate in decimal\n    t = 180 / 360  # Time in years\n    \n    # Calculate forward rate (F)\n    F = S * math.exp((i_NZD - i_GBP) * t)\n    \n    # Calculate forward points\n    forward_points = (F - S) * 10000\n    \n    # Round to three decimal places\n    answer = round(forward_points, 3)\n    \n    return answer\n```"
        ],
        "retrieval_query": "Given that the spot exchange rate from the \"Kiwi\" (NZD) to sterling (GBP) is 2.0979, the Libor interest rate for the sterling is 1.6025%, and for the \"Kiwi\" it's 3.2875%, all being quoted on a 360-day year basis, what are the 180-day forward points in NZD/GBP (in basis points)? Answer to three decimal places.",
        "useful_functions": [],
        "usage": {
            "completion_tokens": 509,
            "prompt_tokens": 419,
            "total_tokens": 928,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "As an arbitrage trader, Bob wishes to determine the continuous implied dividend yield of a stock. He is studying the over-the-counter price of a five-year European put and call on this particular stock. The data he has includes: S = $85, K = $90, r = 5%, c = $10, p = $15. What would be the implied dividend yield of the stock (expressed as a percentage)? Answer to three decimal places.",
        "python_solution": "def solution():\n    import math\n    \n    S = 85  # The stock is currently trading at\n    K = 90  # The strike price of the option\n    r = 5/100  # Interest rate\n    c = 10  # Price of a call option\n    p = 15  # Price of a put option\n    tau = 5  # time to maturity (in years)\n\n    S_tau = c - p + K * math.exp(-r * tau)  # From put-call parity\n    y = -1/tau * math.log(S_tau / S)  # Dividend yield\n\n    return y*100  # convert it to percentage and return",
        "ground_truth": 5.337,
        "topic": "Market Analysis & Economics",
        "statistics": {
            "number_statistics": {
                "args_numbers": 1,
                "question_numbers": 5,
                "context_numbers": 0,
                "total_numbers": 5
            },
            "operator_statistics": {
                "operators": {
                    "+": 1,
                    "-": 4,
                    "*": 4,
                    "/": 3,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 12
            },
            "code_statistics": {
                "lines": 10,
                "parentheses": 6
            }
        },
        "difficulty": 5.049856007249537,
        "source": "FinanceMath-validation-98",
        "context": "[]",
        "question_id": "test-2158",
        "level": "hard",
        "output": [
            "### Step-by-Step Reasoning Using Emphasizing Constraints (EC)\nThe problem involves finding the implied continuous dividend yield (\\( q \\)) of a stock based on the given values and the put-call parity for European options. Let\u2019s think through the problem systematically:\n\n#### Step 1: Understand the formula for European Option Put-Call Parity\nThe formula for European options is:\n\\[\nc + K e^{-rT} = p + S e^{-qT}\n\\]\nWhere:\n- \\( c \\): Price of the call option.\n- \\( p \\): Price of the put option.\n- \\( S \\): Spot price of the stock.\n- \\( K \\): Strike price of the option.\n- \\( r \\): Continuously compounded risk-free rate.\n- \\( q \\): Continuous dividend yield we want to calculate.\n- \\( T \\): Time to maturity (in years).\n\nThe goal is to solve the above equation for \\( q \\), the implied dividend yield. Rearranging the formula:\n\\[\nq = \\frac{1}{T} \\ln\\left(\\frac{K e^{-rT} + c - p}{S}\\right)\n\\]\n\n#### Step 2: Identify constraints\n1. **Precision Requirement**: The implied dividend yield should be expressed as a percentage with three decimals.\n2. **Units Consistency**: Time \\( T \\) is given in years. Ensure all inputs adhere to the correct units.\n3. **Mathematical Validity**: The logarithm (\\( \\ln \\)) and divisions must only operate on positive numbers.\n\n#### Step 3: Define the variables\nFrom the problem, substituting the known values:\n- \\( S = 85 \\) (Spot price).\n- \\( K = 90 \\) (Strike price).\n- \\( r = 0.05 \\) (Risk-free rate as a decimal).\n- \\( c = 10 \\) (Call price).\n- \\( p = 15 \\) (Put price).\n- \\( T = 5 \\) (Years to maturity).\n\n#### Step 4: Perform the calculation step-by-step\n1. Calculate \\( K e^{-rT} \\), the discounted strike price.\n2. Add \\( c - p \\) to the discounted strike price.\n3. Divide the result by \\( S \\).\n4. Apply the natural logarithm (\\( \\ln \\)).\n5. Divide by \\( T \\) to solve for \\( q \\).\n\nNow, let me write the Python program to compute the implied continuous dividend yield step-by-step.\n\n```python\nimport math\n\ndef solution():\n    # Step 1: Define variables\n    S = 85  # Spot price of stock\n    K = 90  # Strike price\n    r = 0.05  # Risk-free interest rate (as a decimal)\n    c = 10  # Call price\n    p = 15  # Put price\n    T = 5  # Time to maturity in years\n\n    # Step 2: Perform calculations for q\n    # Calculate K * e^(-rT)\n    discounted_strike = K * math.exp(-r * T)\n    \n    # Add (c - p) to discounted strike price\n    numerator = discounted_strike + c - p\n    \n    # Divide by spot price (S)\n    fraction = numerator / S\n    \n    # Apply natural logarithm and divide by T\n    q = -math.log(fraction) / T\n    \n    # Step 3: Format answer as percentage with 3 decimal places\n    return round(q * 100, 3)\n```"
        ],
        "retrieval_query": "As an arbitrage trader, Bob wishes to determine the continuous implied dividend yield of a stock. He is studying the over-the-counter price of a five-year European put and call on this particular stock. The data he has includes: S = $85, K = $90, r = 5%, c = $10, p = $15. What would be the implied dividend yield of the stock (expressed as a percentage)? Answer to three decimal places.",
        "useful_functions": [
            "def calculate_beta(stock_returns: list, market_returns: list) -> float:\n    \"\"\"\n    Calculate the beta of a stock, indicating its volatility relative to the market.\n\n    Beta is a measure of a stock's volatility in relation to the overall market.\n    A beta of 1 indicates that the stock's price tends to move with the market.\n    A beta greater than 1 indicates greater volatility than the market, while a beta less\n    than 1 indicates less volatility.\n\n    Args:\n        stock_returns (list): A list of periodic return rates for the stock.\n        market_returns (list): A list of periodic return rates for the market benchmark,\n                               such as the S&P 500. Must be of the same length as stock_returns.\n\n    Returns:\n        beta (float): The beta of the stock relative to the market.\n\n    Notes:\n        - Applicability: Used in assessing the risk and expected return of a stock or portfolio.\n        - Constraints: The input lists must represent returns for the same periods and must have\n          the same length.\n        - Considerations: Beta reflects past volatility and may not predict future volatility.\n          Values could be affected by outliers in the historical data.\n    \"\"\"\n    if len(stock_returns) != len(market_returns):\n        raise ValueError(\"Both input lists must have the same number of elements.\")\n\n    market_variance = sum((r - (sum(market_returns) / len(market_returns))) ** 2 for r in market_returns)\n    covariance = sum((s - (sum(stock_returns) / len(stock_returns))) * \n                     (m - (sum(market_returns) / len(market_returns))) for s, m in zip(stock_returns, market_returns))\n\n    if market_variance == 0:\n        raise ValueError(\"Market variance is zero, cannot calculate beta.\")\n    \n    beta = covariance / market_variance\n    \n    return beta"
        ],
        "usage": {
            "completion_tokens": 743,
            "prompt_tokens": 819,
            "total_tokens": 1562,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-1815",
        "article_title": "Tax Benefit",
        "function": "def calculate_tax_liability(taxable_income: float, tax_brackets: list, tax_rates: list) -> float:\n    \"\"\"\n    Calculate the tax liability based on taxable income and tax brackets.\n\n    This function calculates the tax liability using a progressive tax system,\n    where different portions of income are taxed at different rates.\n\n    Args:\n        taxable_income (float): The taxable income on which taxes are to be calculated.\n        tax_brackets (list): The income thresholds for each tax rate.\n        tax_rates (list): The tax rates corresponding to each tax bracket.\n\n    Returns:\n        tax_liability (float): The total tax liability.\n\n    Notes:\n        - Applicability: Useful for determining taxes using U.S.-style progressive tax systems.\n        - Constraints: Tax brackets and tax rates should have the same length.\n        - Considerations: Ensure that tax brackets are ordered in ascending order.\n    \"\"\"\n    if len(tax_brackets) != len(tax_rates):\n        raise ValueError(\"Tax brackets and tax rates must have the same length.\")\n    \n    tax_liability = 0.0\n    for i, rate in enumerate(tax_rates):\n        if i == 0:\n            lower_bound = 0\n        else:\n            lower_bound = tax_brackets[i-1]\n        \n        upper_bound = tax_brackets[i]\n        \n        if taxable_income > lower_bound:\n            amount_to_tax = min(taxable_income, upper_bound) - lower_bound\n            tax_liability += amount_to_tax * rate\n    \n    if taxable_income > tax_brackets[-1]:\n        tax_liability += (taxable_income - tax_brackets[-1]) * tax_rates[-1]\n    \n    return tax_liability",
        "statistics": {
            "number_statistics": {
                "args_numbers": 3,
                "question_numbers": 0,
                "context_numbers": 11,
                "total_numbers": 11
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 6,
                    "*": 2,
                    "/": 0,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 10
            },
            "code_statistics": {
                "lines": 13,
                "parentheses": 6
            }
        },
        "difficulty": 5.075173815233827,
        "context": "John is reviewing his annual tax bill. His taxable income for the year is $82,000. The government applies a progressive tax system with the following tax brackets and corresponding rates:\n\n- Up to $10,000: 10%\n- $10,001 to $30,000: 20%\n- $30,001 to $60,000: 30%\n- Above $60,000: 40%\n\nJohn wants to know how much tax he owes for the year based on his given taxable income and the tax brackets provided by the government.",
        "question": "What is John's total tax liability for the year? Answer in dollars to the nearest integer.",
        "python_solution": "def solution():\n    # Define income and tax brackets/rates\n    taxable_income = 82000\n    tax_brackets = [10000, 30000, 60000]\n    tax_rates = [0.10, 0.20, 0.30, 0.40]  # Note, 40% is for above $60,000\n\n    # Initialize tax liability\n    tax_liability = 0.0\n\n    # Loop through each percentage rate to calculate total tax liability\n    for i, rate in enumerate(tax_rates):\n        if i == 0:\n            lower_bound = 0\n        else:\n            lower_bound = tax_brackets[i-1]\n\n        # Define upper bound, which is respective bracket (except for the final rate)\n        upper_bound = tax_brackets[i] if i < len(tax_brackets) else float('inf')\n        \n        # Calculate tax for current bracket\n        if taxable_income > lower_bound:\n            amount_to_tax = min(taxable_income, upper_bound) - lower_bound\n            tax_liability += amount_to_tax * rate\n            \n    # Return the calculated tax liability rounded to nearest integer\n    return round(tax_liability)",
        "ground_truth": 22800,
        "source": "FinanceReasoning-test-118",
        "question_id": "test-2159",
        "level": "hard",
        "output": [
            "### Step-by-Step Analysis Using Advanced Reasoning Techniques:\n\n#### **1. Emphasizing Constraints (EC):**\n- **Tax brackets and rates** must be followed strictly, with no deviation from the 10%, 20%, 30%, and 40% rates for the respective income ranges provided.\n- The tax brackets must be applied progressively, meaning:\n  - The first $10,000 is taxed at 10%.\n  - The next $20,000 (from $10,001 to $30,000) is taxed at 20%.\n  - The next $30,000 (from $30,001 to $60,000) is taxed at 30%.\n  - Any amount above $60,000 is taxed at 40%.\n- **Precision:** The tax owed must be calculated in dollars and rounded to the nearest integer.\n\n#### **2. Plan of Action:**\n- Divide John's taxable income into segments corresponding to the tax brackets.\n- Calculate the tax owed for each segment by multiplying the taxable amount in that segment by the respective tax rate.\n- Sum up the tax for all segments to determine the total tax liability.\n\n#### **3. Key Variables and Functions:**\n- `income` will represent John's total taxable income.\n- `calculate_tax` will compute the total liability based on the progressive tax structure.\n\n#### **4. Implement the Calculation:**\nWe will iterate through the tax brackets, calculate the tax for each applicable segment, and sum up the results.\n\n---\n\n### Python Program:\n```python\ndef solution():\n    # Define variables name and value\n    taxable_income = 82000  # John's taxable income\n    tax_brackets = [10000, 30000, 60000]  # Upper limits of the tax brackets\n    tax_rates = [0.10, 0.20, 0.30, 0.40]  # Corresponding tax rates\n    \n    # Initialize variables\n    total_tax = 0\n    previous_bracket_limit = 0  # Lower bound of each tax bracket\n    \n    # Iterate over tax brackets and rates\n    for i, upper_limit in enumerate(tax_brackets):\n        if taxable_income > upper_limit:\n            # Calculate tax for the current bracket\n            taxable_amount = upper_limit - previous_bracket_limit\n            total_tax += taxable_amount * tax_rates[i]\n        else:\n            # If income is within this bracket, calculate tax for the remaining income\n            taxable_amount = taxable_income - previous_bracket_limit\n            total_tax += taxable_amount * tax_rates[i]\n            return round(total_tax)  # Return result immediately as all taxable income is processed\n        \n        # Update the lower bound for the next bracket\n        previous_bracket_limit = upper_limit\n\n    # If income exceeds the highest tax bracket\n    total_tax += (taxable_income - previous_bracket_limit) * tax_rates[-1]\n    \n    # Return answer rounded to nearest integer\n    return round(total_tax)\n```"
        ],
        "retrieval_query": "What is John's total tax liability for the year? Answer in dollars to the nearest integer.",
        "useful_functions": [
            "def calculate_tax_liability(taxable_income: float, tax_brackets: list, tax_rates: list) -> float:\n    \"\"\"\n    Calculate the tax liability based on taxable income and tax brackets.\n\n    This function calculates the tax liability using a progressive tax system,\n    where different portions of income are taxed at different rates.\n\n    Args:\n        taxable_income (float): The taxable income on which taxes are to be calculated.\n        tax_brackets (list): The income thresholds for each tax rate.\n        tax_rates (list): The tax rates corresponding to each tax bracket.\n\n    Returns:\n        tax_liability (float): The total tax liability.\n\n    Notes:\n        - Applicability: Useful for determining taxes using U.S.-style progressive tax systems.\n        - Constraints: Tax brackets and tax rates should have the same length.\n        - Considerations: Ensure that tax brackets are ordered in ascending order.\n    \"\"\"\n    if len(tax_brackets) != len(tax_rates):\n        raise ValueError(\"Tax brackets and tax rates must have the same length.\")\n    \n    tax_liability = 0.0\n    for i, rate in enumerate(tax_rates):\n        if i == 0:\n            lower_bound = 0\n        else:\n            lower_bound = tax_brackets[i-1]\n        \n        upper_bound = tax_brackets[i]\n        \n        if taxable_income > lower_bound:\n            amount_to_tax = min(taxable_income, upper_bound) - lower_bound\n            tax_liability += amount_to_tax * rate\n    \n    if taxable_income > tax_brackets[-1]:\n        tax_liability += (taxable_income - tax_brackets[-1]) * tax_rates[-1]\n    \n    return tax_liability",
            "def apply_marginal_tax_rate(income: float, tax_brackets: list) -> float:\n    \"\"\"\n    Calculate tax liability using marginal tax rates.\n\n    This function applies the appropriate marginal tax rates to calculate the total\n    tax liability for a given income based on provided tax brackets.\n\n    Args:\n        income (float): The total income to be taxed.\n        tax_brackets (list): A list of tuples where each tuple contains the income limit\n                             and the tax rate (e.g., [(limit1, rate1), (limit2, rate2), ...]).\n\n    Returns:\n        tax_liability (float): The total tax liability based on the income and tax brackets.\n\n    Notes:\n        - Applicability: Useful for calculating taxes for individuals and businesses.\n        - Constraints: Ensure the tax brackets are sorted in ascending order of income limits.\n        - Considerations: This does not account for tax deductions or credits.\n    \"\"\"\n    tax_liability = 0.0\n    previous_limit = 0.0\n\n    for limit, rate in tax_brackets:\n        if income > limit:\n            tax_liability += (limit - previous_limit) * rate\n            previous_limit = limit\n        else:\n            tax_liability += (income - previous_limit) * rate\n            break\n\n    return tax_liability"
        ],
        "usage": {
            "completion_tokens": 608,
            "prompt_tokens": 1091,
            "total_tokens": 1699,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-514",
        "article_title": "Kurtosis",
        "function": "def calculate_kurtosis(data: list) -> float:\n    \"\"\"\n    Calculate the kurtosis of a given dataset.\n\n    This function computes the kurtosis of a dataset, which indicates the \"tailedness\" \n    of the probability distribution. It measures the degree to which data are \n    characterized by long tails extending far from the mean, suggesting the potential \n    for extreme values.\n\n    Args:\n        data (list): A list of numerical data points for which kurtosis is computed.\n\n    Returns:\n        kurtosis (float): The kurtosis of the dataset.\n\n    Notes:\n        - Applicability: This function is applicable to financial and statistical \n          analysis where kurtosis conveys information about the distribution's tails \n          and potential for extreme outcomes.\n        - Constraints: The dataset must contain at least four data points to compute \n          sample kurtosis.\n        - Considerations: The function assumes that the dataset is a sample from a \n          larger population. The result is adjusted to interpret excess kurtosis \n          (i.e., comparison against a normal distribution's kurtosis of 3).\n    \"\"\"\n    n = len(data)\n    if n < 4:\n        raise ValueError(\"Dataset must contain at least four data points.\")\n\n    mean = sum(data) / n\n    s2 = sum((x - mean) ** 2 for x in data)\n    s4 = sum((x - mean) ** 4 for x in data)\n    \n    if s2 == 0:\n        raise ValueError(\"Variance should not be zero.\")\n\n    m2 = s2 / n\n    m4 = s4 / n\n    \n    kurtosis = (m4 / (m2 ** 2)) - 3\n    \n    return kurtosis",
        "statistics": {
            "number_statistics": {
                "args_numbers": 1,
                "question_numbers": 0,
                "context_numbers": 5,
                "total_numbers": 5
            },
            "operator_statistics": {
                "operators": {
                    "+": 0,
                    "-": 3,
                    "*": 0,
                    "/": 4,
                    "%": 0,
                    "**": 3
                },
                "total_operators": 10
            },
            "code_statistics": {
                "lines": 8,
                "parentheses": 16
            }
        },
        "difficulty": 5.075173815233827,
        "context": "An investment analyst is studying the stock returns of a newly listed tech company to understand the potential risk and extreme fluctuations in share prices. By analyzing the daily return data for a week, they aim to assess the kurtosis of the returns, which will help determine the degree to which the return distribution exhibits fat tails compared to a normal distribution. The daily returns for the past week (in percentage) are as follows: Monday: 1.5%, Tuesday: -0.5%, Wednesday: 3.2%, Thursday: -2.0%, and Friday: 0.8%.",
        "question": "What is the kurtosis of the tech company's daily stock returns over the past week, accounting for excess kurtosis? Answer to two decimal places.",
        "python_solution": "def solution():\n    # Define the dataset of daily returns as percentages\n    returns = [1.5, -0.5, 3.2, -2.0, 0.8]\n    \n    # Number of data points\n    n = len(returns)\n    \n    # Calculate the mean of the returns\n    mean = sum(returns) / n\n    \n    # Calculate the sum of squares of differences from the mean (s2)\n    s2 = sum((x - mean) ** 2 for x in returns)\n    \n    # Calculate the sum of fourth powers of differences from the mean (s4)\n    s4 = sum((x - mean) ** 4 for x in returns)\n    \n    # Second moment (variance)\n    m2 = s2 / n\n    \n    # Fourth moment\n    m4 = s4 / n\n    \n    # Calculate kurtosis using the formula for excess kurtosis\n    kurtosis = (m4 / (m2 ** 2)) - 3\n    \n    # Return the result rounded to two decimal places\n    return round(kurtosis, 2)\n\n# Call the solution function to see the result\nsolution()",
        "ground_truth": -1.07,
        "source": "FinanceReasoning-test-196",
        "question_id": "test-2160",
        "level": "hard",
        "output": [
            "To solve the problem, let's follow the reasoning process step-by-step:\n\n### Step-by-Step Analysis Using Emphasizing Constraints (EC)\n1. **Understand the Context and Objective**:  \n   The objective is to calculate the kurtosis of the daily returns of the tech company's stock. Importantly, the focus is on \"excess kurtosis\"\u2014this indicates how the distribution's tails differ from a normal distribution.\n\n2. **Constraints**:  \n   - The dataset provided contains five daily return values (Monday through Friday).\n   - Kurtosis must be computed to compare the stock returns' distribution with a normal distribution (normal distribution's kurtosis is 3, so excess kurtosis accounts for this by subtracting 3 from the calculated kurtosis).\n   - The result must be rounded to **two decimal places**.\n   - Edge cases like division by zero (variance being zero) or insufficient data points are not relevant, as the data set meets the requirements.\n\n3. **Mathematical Procedure**:\n   - Use the formula for calculating kurtosis, as provided in the function `calculate_kurtosis`. It involves computing the second and fourth moments of the data around the mean.\n   - Incorporate excess kurtosis adjustment by subtracting 3 from the calculated kurtosis.\n   - Return the computed kurtosis rounded to two decimal places.\n\n4. **Input Data & Conversion**:\n   - The daily returns are expressed in percentages: [1.5, -0.5, 3.2, -2.0, 0.8].\n   - To simplify computation, the values will be used as fractions: [0.015, -0.005, 0.032, -0.020, 0.008].\n\n5. **Implementation**:\n   - Define a function to calculate kurtosis using the formula provided.\n   - Substitute the daily return data into the function.\n   - Output the result.\n\nNow, we move on to the Python program.\n\n```python\ndef solution():\n    # Define the daily returns\n    daily_returns = [1.5, -0.5, 3.2, -2.0, 0.8]\n    \n    # Convert percentage returns to fractions\n    returns_fraction = [x / 100 for x in daily_returns]\n    \n    # Calculate the kurtosis using the given function\n    def calculate_kurtosis(data):\n        n = len(data)\n        if n < 4:\n            raise ValueError(\"Dataset must contain at least four data points.\")\n        \n        mean = sum(data) / n\n        s2 = sum((x - mean) ** 2 for x in data)\n        s4 = sum((x - mean) ** 4 for x in data)\n        \n        if s2 == 0:\n            raise ValueError(\"Variance should not be zero.\")\n        \n        m2 = s2 / n\n        m4 = s4 / n\n        \n        # Calculate and return excess kurtosis\n        kurtosis = (m4 / (m2 ** 2)) - 3\n        return kurtosis\n\n    # Compute the kurtosis of the returns\n    kurtosis_result = calculate_kurtosis(returns_fraction)\n    \n    # Return the result rounded to two decimal places\n    return round(kurtosis_result, 2)\n```"
        ],
        "retrieval_query": "What is the kurtosis of the tech company's daily stock returns over the past week, accounting for excess kurtosis? Answer to two decimal places.",
        "useful_functions": [
            "def calculate_kurtosis(data: list) -> float:\n    \"\"\"\n    Calculate the kurtosis of a given dataset.\n\n    This function computes the kurtosis of a dataset, which indicates the \"tailedness\" \n    of the probability distribution. It measures the degree to which data are \n    characterized by long tails extending far from the mean, suggesting the potential \n    for extreme values.\n\n    Args:\n        data (list): A list of numerical data points for which kurtosis is computed.\n\n    Returns:\n        kurtosis (float): The kurtosis of the dataset.\n\n    Notes:\n        - Applicability: This function is applicable to financial and statistical \n          analysis where kurtosis conveys information about the distribution's tails \n          and potential for extreme outcomes.\n        - Constraints: The dataset must contain at least four data points to compute \n          sample kurtosis.\n        - Considerations: The function assumes that the dataset is a sample from a \n          larger population. The result is adjusted to interpret excess kurtosis \n          (i.e., comparison against a normal distribution's kurtosis of 3).\n    \"\"\"\n    n = len(data)\n    if n < 4:\n        raise ValueError(\"Dataset must contain at least four data points.\")\n\n    mean = sum(data) / n\n    s2 = sum((x - mean) ** 2 for x in data)\n    s4 = sum((x - mean) ** 4 for x in data)\n    \n    if s2 == 0:\n        raise ValueError(\"Variance should not be zero.\")\n\n    m2 = s2 / n\n    m4 = s4 / n\n    \n    kurtosis = (m4 / (m2 ** 2)) - 3\n    \n    return kurtosis"
        ],
        "usage": {
            "completion_tokens": 681,
            "prompt_tokens": 840,
            "total_tokens": 1521,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-2109",
        "article_title": "Lehman Formula",
        "function": "def calculate_lehman_fee(transaction_amount: float, tiers: list, rates: list) -> float:\n    \"\"\"\n    Calculate the Lehman fee for a given transaction amount using tiered percentages.\n\n    This function computes the commission or fee based on a tiered fee structure,\n    as defined by the Lehman formula. It applies different percentage rates to different\n    tiers of the transaction amount.\n\n    Args:\n        transaction_amount (float): The total dollar amount of the transaction.\n        tiers (list): A list of tier limits, in dollars, defining the boundaries for each rate.\n                      This list should be in ascending order.\n        rates (list): A list of percentage rates corresponding to each tier.\n                      Each rate applies to the segment of the transaction amount within its tier.\n\n    Returns:\n        total_fee (float): The total fee calculated according to the tiered structure.\n\n    Notes:\n        - Applicability: This function can be used in investment banking transactions or\n          other financial transactions where tiered fees are applicable.\n        - Constraints: The lengths of `tiers` and `rates` lists must match, and they must\n          each have at least one element.\n        - Considerations: The `tiers` list should include an implicit final tier where all\n          remaining transaction amounts beyond the last specified tier are subject to the last\n          rate in the `rates` list.\n    \"\"\"\n    if len(tiers) != len(rates) or not tiers:\n        raise ValueError(\"Tiers and rates lists must match in length and must not be empty.\")\n    \n    total_fee = 0.0\n    remaining_amount = transaction_amount\n    \n    for i, tier in enumerate(tiers):\n        if remaining_amount <= 0:\n            break\n        if transaction_amount > tier:\n            tier_amount = tier if i == 0 else tier - tiers[i - 1]\n        else:\n            tier_amount = remaining_amount\n            \n        fee_for_tier = tier_amount * rates[i] / 100\n        total_fee += fee_for_tier\n        \n        remaining_amount -= tier_amount\n\n    if remaining_amount > 0:\n        total_fee += remaining_amount * rates[-1] / 100\n    \n    return total_fee",
        "statistics": {
            "number_statistics": {
                "args_numbers": 3,
                "question_numbers": 1,
                "context_numbers": 13,
                "total_numbers": 14
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 4,
                    "*": 2,
                    "/": 2,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 10
            },
            "code_statistics": {
                "lines": 15,
                "parentheses": 2
            }
        },
        "difficulty": 5.075173815233827,
        "context": "A boutique investment bank is handling a transaction for a merger worth $12,000,000. The bank charges a tiered fee based on the Lehman formula, with the following tiers and corresponding rates: \n\n- For the first $1,000,000, the fee is 5%.\n- For the next $4,000,000 (from $1,000,001 to $5,000,000), the fee is 4%.\n- For the next $5,000,000 (from $5,000,001 to $10,000,000), the fee is 3%.\n- For any amount above $10,000,000, the fee is 2%.\n\nCalculate the total Lehman fee charged by the bank for this transaction.",
        "question": "What is the total Lehman fee that the boutique investment bank charges for the $12,000,000 transaction? Answer to the nearest dollar.",
        "python_solution": "def solution():\n    # Define the transaction amount\n    transaction_amount = 12000000\n\n    # Define the tiers and corresponding rates\n    tiers = [1000000, 5000000, 10000000]\n    rates = [5, 4, 3, 2]\n\n    # Initialize the total fee\n    total_fee = 0\n    remaining_amount = transaction_amount\n\n    # Calculate the fee for each tier\n    for i, tier in enumerate(tiers):\n        if remaining_amount <= 0:\n            break\n        if transaction_amount > tier:\n            tier_amount = tier if i == 0 else tier - tiers[i - 1]\n        else:\n            tier_amount = remaining_amount\n        \n        fee_for_tier = tier_amount * rates[i] / 100\n        total_fee += fee_for_tier\n        \n        remaining_amount -= tier_amount\n\n    # Calculate the fee for any remaining amount above the last tier\n    if remaining_amount > 0:\n        total_fee += remaining_amount * rates[-1] / 100\n\n    # Return the total fee rounded to the nearest dollar\n    return round(total_fee)\n\n# Print the solution to invoke the function and display the fee\nprint(solution())",
        "ground_truth": 400000,
        "source": "FinanceReasoning-test-237",
        "question_id": "test-2161",
        "level": "hard",
        "output": [
            "To calculate the total Lehman fee charged by the boutique investment bank for the $12,000,000 transaction, let us move step by step:\n\n---\n\n### Step 1: Understand the Tiered Fee Structure\nEach portion of the transaction is charged a specific percentage:\n- **5% on the first $1,000,000**\n- **4% on the next $4,000,000** ($1,000,001 to $5,000,000)\n- **3% on the next $5,000,000** ($5,000,001 to $10,000,000)\n- **2% on any amount above $10,000,000** \n\n---\n\n### Step 2: Define Constraints and Clarify the Calculation\n- We need to sum up the fees for each tier, based on the provided Lehman formula.\n- The constraints to ensure:\n  - The fee is calculated for tiers sequentially, starting from the lowest to the highest.\n  - Proper handling of rounding, with the final result being rounded to the nearest dollar.\n\n---\n\n### Step 3: Break Down the Transaction Amount\nTransaction tiers are defined as follows:\n- First $1,000,000 charged at 5%.\n- Next $4,000,000 charged at 4%.\n- Next $5,000,000 charged at 3%.\n- Remaining $2,000,000 ($12,000,000 - $10,000,000) charged at 2%.\n\n---\n\n### Step 4: Plan the Computational Approach\n1. Define the `tiers` and their corresponding `rates`.\n2. Use a cumulative approach to calculate the fee for each tier.\n3. Sum the fees and format the result as a whole number (nearest dollar).\n\n---\n\n### Python Program:\n```python\ndef solution():\n    # Define variables: transaction amount, tiers, and rates\n    transaction_amount = 12000000  # Total transaction amount\n    tiers = [1000000, 5000000, 10000000]  # Tier limits in dollars\n    rates = [5, 4, 3, 2]  # Percentage rates corresponding to tiers\n    \n    # Initialize total fee\n    total_fee = 0.0\n    remaining_amount = transaction_amount\n    \n    # Calculate fee tier by tier\n    for i, tier in enumerate(tiers):\n        if remaining_amount <= 0:\n            break\n        if i == 0:  # First tier\n            tier_amount = min(remaining_amount, tier)\n        else:  # Subsequent tiers\n            tier_amount = min(remaining_amount, tier - tiers[i - 1])\n            \n        fee_for_tier = tier_amount * rates[i] / 100\n        total_fee += fee_for_tier\n        remaining_amount -= tier_amount\n\n    # For any remaining amount above the last defined tier\n    if remaining_amount > 0:\n        total_fee += remaining_amount * rates[-1] / 100  # Apply last rate\n    \n    # Return the total fee, rounded to the nearest dollar\n    return round(total_fee)\n```\n\nThis program adheres strictly to the constraints and ensures accurate computation of fees tier by tier. Let me know if you need further clarification!"
        ],
        "retrieval_query": "What is the total Lehman fee that the boutique investment bank charges for the $12,000,000 transaction? Answer to the nearest dollar.",
        "useful_functions": [
            "def calculate_lehman_fee(transaction_amount: float, tiers: list, rates: list) -> float:\n    \"\"\"\n    Calculate the Lehman fee for a given transaction amount using tiered percentages.\n\n    This function computes the commission or fee based on a tiered fee structure,\n    as defined by the Lehman formula. It applies different percentage rates to different\n    tiers of the transaction amount.\n\n    Args:\n        transaction_amount (float): The total dollar amount of the transaction.\n        tiers (list): A list of tier limits, in dollars, defining the boundaries for each rate.\n                      This list should be in ascending order.\n        rates (list): A list of percentage rates corresponding to each tier.\n                      Each rate applies to the segment of the transaction amount within its tier.\n\n    Returns:\n        total_fee (float): The total fee calculated according to the tiered structure.\n\n    Notes:\n        - Applicability: This function can be used in investment banking transactions or\n          other financial transactions where tiered fees are applicable.\n        - Constraints: The lengths of `tiers` and `rates` lists must match, and they must\n          each have at least one element.\n        - Considerations: The `tiers` list should include an implicit final tier where all\n          remaining transaction amounts beyond the last specified tier are subject to the last\n          rate in the `rates` list.\n    \"\"\"\n    if len(tiers) != len(rates) or not tiers:\n        raise ValueError(\"Tiers and rates lists must match in length and must not be empty.\")\n    \n    total_fee = 0.0\n    remaining_amount = transaction_amount\n    \n    for i, tier in enumerate(tiers):\n        if remaining_amount <= 0:\n            break\n        if transaction_amount > tier:\n            tier_amount = tier if i == 0 else tier - tiers[i - 1]\n        else:\n            tier_amount = remaining_amount\n            \n        fee_for_tier = tier_amount * rates[i] / 100\n        total_fee += fee_for_tier\n        \n        remaining_amount -= tier_amount\n\n    if remaining_amount > 0:\n        total_fee += remaining_amount * rates[-1] / 100\n    \n    return total_fee"
        ],
        "usage": {
            "completion_tokens": 665,
            "prompt_tokens": 969,
            "total_tokens": 1634,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "Smith demonstrates to Harmonica the total return of a recent transaction performed by the Zenith Fund. Smith explains that the Zenith Fund entered a fully collateralized long position in nearby soybean futures contracts at the quoted futures price of 865.0 (US cents/bushel). Three months afterward, the whole futures position was rolled when the short-term futures price was 877.0 and the long-term futures price was 883.0. What is the Zenith Fund\u2019s three-month total return on the soybean futures transaction, factoring in that the collateral earned an annualized rate of 0.60% during the three-month period between when the initial long position was established and the rolling of the contract (expressed as a percentage)? Answer to three decimal places.",
        "python_solution": "def solution():\n    previous_price = 865.0\n    current_price_short_term = 877.0\n    current_price_long_term = 883.0\n    collateral_rate = 0.60\n    months = 3\n    \n    # Calculating each return\n    price_return = (current_price_short_term - previous_price) / previous_price\n    roll_return = (current_price_short_term - current_price_long_term) / current_price_short_term\n    collateral_return = (months/12) * (collateral_rate/100)\n    \n    # Calculating total return\n    total_return = price_return + roll_return + collateral_return\n    \n    return total_return * 100",
        "ground_truth": 0.853,
        "topic": "Asset Classes & Derivatives",
        "statistics": {
            "number_statistics": {
                "args_numbers": 3,
                "question_numbers": 4,
                "context_numbers": 0,
                "total_numbers": 4
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 2,
                    "*": 2,
                    "/": 4,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 10
            },
            "code_statistics": {
                "lines": 12,
                "parentheses": 8
            }
        },
        "difficulty": 5.075173815233827,
        "source": "FinanceMath-validation-60",
        "context": "[]",
        "question_id": "test-2162",
        "level": "hard",
        "output": [
            "To solve the problem step by step, I will analyze it considering the constraints and using the provided financial functions effectively.\n\n### Analyzing the Problem:\n1. **Initial Futures Price:** This is the quoted price when the initial long position was established, which is 865.0 (US cents/bushel).\n2. **Short-term Futures Price:** The price at the end of the three months is 877.0 (US cents/bushel).\n3. **Long-term Futures Price:** This is the price of the newly acquired long-term futures contract, which is 883.0 (US cents/bushel).\n4. **Collateral Annual Rate:** An annualized rate of 0.60% is earned on the collateral.\n5. **Investment Duration:** This duration is three months, equivalent to 3/12 of a year.\n\n### Constraints:\n- The function inputs must all be positive, as futures prices and interest rates cannot be negative.\n- The return must be calculated and expressed to three decimal places to ensure accuracy and compliance with the question prompt.\n- The total return incorporates price return, roll return, and collateral return.\n\n### Steps to Solve:\n1. **Price Return Component:** \\((\\text{short-term futures price} - \\text{initial futures price}) / \\text{initial futures price}\\).\n2. **Roll Return Component:** \\((\\text{short-term futures price} - \\text{long-term futures price}) / \\text{short-term futures price}\\).\n3. **Collateral Return Component:** This is based on the fraction of the year over which the investment is held \\((\\frac{\\text{duration (months)}}{12})\\) and the annualized collateral rate.\n4. **Total Return Calculation:** Combine the above three components and multiply by 100 to express the result as a percentage.\n5. **Final Output:** The total return value should be rounded to three decimal places.\n\nNow I will generate the Python code for the solution:\n\n```python\ndef solution():\n    # Define variables name and value\n    initial_futures_price = 865.0\n    short_term_futures_price = 877.0\n    long_term_futures_price = 883.0\n    collateral_annual_rate = 0.60  # expressed as a percentage\n    investment_duration_months = 3\n\n    # Calculate price return\n    price_return = (short_term_futures_price - initial_futures_price) / initial_futures_price\n    \n    # Calculate roll return\n    roll_return = (short_term_futures_price - long_term_futures_price) / short_term_futures_price\n    \n    # Calculate collateral return over the investment duration\n    collateral_return = (investment_duration_months / 12) * (collateral_annual_rate / 100)\n    \n    # Calculate the total return as a percentage\n    total_return = (price_return + roll_return + collateral_return) * 100\n    \n    # Return total return rounded to three decimal places\n    return round(total_return, 3)\n```"
        ],
        "retrieval_query": "Smith demonstrates to Harmonica the total return of a recent transaction performed by the Zenith Fund. Smith explains that the Zenith Fund entered a fully collateralized long position in nearby soybean futures contracts at the quoted futures price of 865.0 (US cents/bushel). Three months afterward, the whole futures position was rolled when the short-term futures price was 877.0 and the long-term futures price was 883.0. What is the Zenith Fund\u2019s three-month total return on the soybean futures transaction, factoring in that the collateral earned an annualized rate of 0.60% during the three-month period between when the initial long position was established and the rolling of the contract (expressed as a percentage)? Answer to three decimal places.",
        "useful_functions": [
            "def calculate_futures_total_return(initial_futures_price: float, short_term_futures_price: float,\n                                   long_term_futures_price: float, collateral_annual_rate: float,\n                                   investment_duration_months: float) -> float:\n    \"\"\"\n    Calculate the total return on a futures transaction including price return,\n    roll return, and collateral return.\n\n    This function computes the total return percentage from a fully collateralized\n    futures transaction during a specified investment duration. The return is\n    calculated by taking into account the price return from initial to short-term\n    roll, the roll yield, and the return on collateral.\n\n    Args:\n        initial_futures_price (float): The initial futures contract price.\n        short_term_futures_price (float): The futures price at the time of rolling the contract.\n        long_term_futures_price (float): The futures price for the newly acquired long term contract.\n        collateral_annual_rate (float): The annualized interest rate earned on the collateral,\n                                        expressed as a percentage (e.g., 0.60 for 0.60%).\n        investment_duration_months (float): The duration of the investment in months.\n\n    Returns:\n        total_return (float): The total return percentage of the futures transaction,\n                              expressed to three decimal places.\n\n    Notes:\n        - Applicability: This function is applicable for calculating returns on\n          fully collateralized futures transactions over a defined period.\n        - Constraints: Ensure that all prices are positive numbers and the\n          investment duration is appropriate.\n        - Considerations: The collateral return assumes simple interest over the\n          specified duration.\n    \"\"\"\n    # Calculate price return\n    price_return = (short_term_futures_price - initial_futures_price) / initial_futures_price\n    \n    # Calculate roll yield\n    roll_return = (short_term_futures_price - long_term_futures_price) / short_term_futures_price\n    \n    # Calculate collateral return over the investment duration\n    collateral_return = (investment_duration_months / 12) * (collateral_annual_rate / 100)\n    \n    # Calculate the total return as a percentage\n    total_return = (price_return + roll_return + collateral_return) * 100\n    \n    return round(total_return, 3)"
        ],
        "usage": {
            "completion_tokens": 622,
            "prompt_tokens": 947,
            "total_tokens": 1569,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-2502",
        "article_title": "Writer",
        "function": "def calculate_option_writer_profit_or_loss(contracts: int, premium_received: float, strike_price: float, market_price: float, covered: bool, shares_bought_price: float = 0) -> float:\n    \"\"\"\n    Calculate the profit or loss for an option writer based on current market conditions.\n\n    This function determines the profit or loss for an option writer when a call or put option is exercised or expires,\n    considering whether the position is covered or uncovered.\n\n    Args:\n        contracts (int): The number of option contracts written (typically 1 contract = 100 shares).\n        premium_received (float): The premium received per share from writing the option.\n        strike_price (float): The strike price at which the option can be exercised.\n        market_price (float): The current market price of the underlying security.\n        covered (bool): Indicates whether the option position is covered (i.e., the writer owns the underlying shares).\n        shares_bought_price (float, optional): The price at which the shares were bought if the position is covered.\n\n    Returns:\n        profit_or_loss (float): The total profit or loss of the option writing position.\n\n    Notes:\n        - Applicability: Use when evaluating the financial outcome of an options writing strategy.\n        - Constraints: Assumes each option contract is for 100 shares. Prices should be non-negative.\n        - Considerations: If position is uncovered and the option is exercised, potential losses could be substantial.\n          If the shares_bought_price is not provided for covered options, it is assumed to be zero, reflecting a scenario\n          where shares were previously owned or initial purchase price is disregarded.\n    \"\"\"\n    shares = contracts * 100\n    total_premium_received = premium_received * shares\n\n    if covered:\n        intrinsic_value = max(0, market_price - strike_price)\n        profit_or_loss = total_premium_received - (intrinsic_value * shares) + ((market_price - shares_bought_price) * shares)\n    else:\n        intrinsic_value = min(0, market_price - strike_price)\n        profit_or_loss = total_premium_received + (intrinsic_value * shares)\n\n    return profit_or_loss",
        "statistics": {
            "number_statistics": {
                "args_numbers": 6,
                "question_numbers": 0,
                "context_numbers": 5,
                "total_numbers": 5
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 4,
                    "*": 5,
                    "/": 0,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 11
            },
            "code_statistics": {
                "lines": 9,
                "parentheses": 12
            }
        },
        "difficulty": 5.105945473900581,
        "context": "An investor, Linda, writes 5 call option contracts for a tech company's stock. She receives a premium of $2.50 per share. The options have a strike price of $150 per share. At the expiration date, the market price of the stock is $158 per share. Linda's position is covered as she already owns the underlying shares, which she purchased at $140 per share.",
        "question": "What is Linda's total profit or loss from this options writing strategy? Answer to the nearest integer.",
        "python_solution": "def solution():\n    # Define variables based on the problem context\n    contracts = 5\n    premium_received_per_share = 2.50\n    strike_price = 150\n    market_price = 158\n    shares_bought_price = 140\n    covered = True\n    \n    # Calculate the number of shares based on the number of contracts\n    shares = contracts * 100\n    \n    # Calculate the total premium received for all the contracts\n    total_premium_received = premium_received_per_share * shares\n    \n    # Calculate the intrinsic value of the option\n    intrinsic_value = max(0, market_price - strike_price)\n    \n    # Calculate the profit or loss for covered call option\n    profit_or_loss = (total_premium_received \n                      - (intrinsic_value * shares) \n                      + ((market_price - shares_bought_price) * shares))\n    \n    # Return the rounded result\n    return round(profit_or_loss)\n\n# Call the function to get the solution\nsolution()",
        "ground_truth": 6250,
        "source": "FinanceReasoning-test-62",
        "question_id": "test-2163",
        "level": "hard",
        "output": [
            "To solve the problem, let us break it down step by step and use the \"Emphasizing Constraints (EC)\" technique to ensure that all constraints and details are fully accounted for:\n\n1. **Constraints Identification**:\n   - Linda writes 5 call option contracts, each contract represents 100 shares.\n   - She receives a premium of $2.50 per share, i.e., total premium received is $2.50 multiplied by the total number of shares.\n   - The strike price is $150 per share, and the market price at expiration is $158 per share.\n   - Linda already owns the shares (a covered position), and the cost basis for her is $140 per share (the price at which she purchased the shares).\n   - We must calculate the total profit or loss for Linda's position, considering all sources of profit and loss (premiums, intrinsic value of options, and changes in stock value). Prices should be non-negative.\n\n2. **Key Formulas**:\n   - **Total Premium Received** = premium per share \u00d7 total number of shares.\n   - **Intrinsic Value of Options** (the amount the options are \"in-the-money\") = max(0, market price - strike price).\n   - **Net Proceeds from Shares Sold** (if exercised) = strike price \u00d7 total shares.\n   - Profit/Loss from Owning and Selling Shares = Net Proceeds from Shares Sold - Cost Basis of the Shares (shares bought price \u00d7 total number of shares).\n   - Total Profit or Loss = Total Premium Received - Total Intrinsic Value Loss (if exercised) + Profit/Loss from Owning and Selling Shares.\n\n3. **Special Considerations**:\n   - The question requests rounding the profit or loss to the nearest integer.\n\n4. **Final Steps**:\n   - Calculate the total number of shares (5 contracts \u00d7 100 shares per contract).\n   - Determine the total premium received from writing the options.\n   - Calculate the intrinsic value of the options based on the market price and the strike price.\n   - Calculate the total intrinsic value loss when the options are exercised.\n   - Finally, account for changes in the value of owning the shares and sum up all components for the total profit or loss.\n\nNow, let's create the Python program to answer this.\n\n```python\ndef solution():\n    # Define variables\n    contracts = 5\n    premium_received = 2.50\n    strike_price = 150\n    market_price = 158\n    shares_bought_price = 140\n    covered = True  # This is a covered position\n    \n    # Calculate number of shares in total\n    total_shares = contracts * 100\n    \n    # Calculate total premium received\n    total_premium_received = premium_received * total_shares\n    \n    # Calculate intrinsic value and total intrinsic value loss\n    intrinsic_value = max(0, market_price - strike_price)\n    total_intrinsic_value_loss = intrinsic_value * total_shares  # Loss from options being exercised\n    \n    # Calculate profit or loss from owning and selling shares\n    net_proceeds_from_shares = strike_price * total_shares\n    cost_of_shares = shares_bought_price * total_shares\n    profit_from_owning_shares = net_proceeds_from_shares - cost_of_shares\n    \n    # Total profit or loss\n    total_profit_or_loss = total_premium_received - total_intrinsic_value_loss + profit_from_owning_shares\n    \n    # Return the result rounded to the nearest integer\n    return round(total_profit_or_loss)\n```"
        ],
        "retrieval_query": "What is Linda's total profit or loss from this options writing strategy? Answer to the nearest integer.",
        "useful_functions": [
            "def calculate_option_writer_profit_or_loss(contracts: int, premium_received: float, strike_price: float, market_price: float, covered: bool, shares_bought_price: float = 0) -> float:\n    \"\"\"\n    Calculate the profit or loss for an option writer based on current market conditions.\n\n    This function determines the profit or loss for an option writer when a call or put option is exercised or expires,\n    considering whether the position is covered or uncovered.\n\n    Args:\n        contracts (int): The number of option contracts written (typically 1 contract = 100 shares).\n        premium_received (float): The premium received per share from writing the option.\n        strike_price (float): The strike price at which the option can be exercised.\n        market_price (float): The current market price of the underlying security.\n        covered (bool): Indicates whether the option position is covered (i.e., the writer owns the underlying shares).\n        shares_bought_price (float, optional): The price at which the shares were bought if the position is covered.\n\n    Returns:\n        profit_or_loss (float): The total profit or loss of the option writing position.\n\n    Notes:\n        - Applicability: Use when evaluating the financial outcome of an options writing strategy.\n        - Constraints: Assumes each option contract is for 100 shares. Prices should be non-negative.\n        - Considerations: If position is uncovered and the option is exercised, potential losses could be substantial.\n          If the shares_bought_price is not provided for covered options, it is assumed to be zero, reflecting a scenario\n          where shares were previously owned or initial purchase price is disregarded.\n    \"\"\"\n    shares = contracts * 100\n    total_premium_received = premium_received * shares\n\n    if covered:\n        intrinsic_value = max(0, market_price - strike_price)\n        profit_or_loss = total_premium_received - (intrinsic_value * shares) + ((market_price - shares_bought_price) * shares)\n    else:\n        intrinsic_value = min(0, market_price - strike_price)\n        profit_or_loss = total_premium_received + (intrinsic_value * shares)\n\n    return profit_or_loss"
        ],
        "usage": {
            "completion_tokens": 726,
            "prompt_tokens": 880,
            "total_tokens": 1606,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "A risk manager specializing in market risk is looking to determine the cost of a 2-year zero-coupon bond. The current 1-year interest rate is 8.0%. There's a chance of 50% that the 1-year interest rate will reach 10.0% after one year and an equal probability of its falling to 6.0% in the same period. Suppose the yearly risk premium for duration risk is 40 bps, and the bond faces a value of EUR 1,000. What should be the zero-coupon bond's valuation? Answer to three decimal places.",
        "python_solution": "def solution():\n    bond_face_value = 1000\n    risk_free_rate = 0.08\n    risk_premium = 0.004\n    up_interest_rate = 0.10\n    down_interest_rate = 0.06\n    probability_up = 0.5\n    probability_down = 0.5\n\n    up_price_date1 = bond_face_value / (1 + up_interest_rate + risk_premium)\n    down_price_date1 = bond_face_value / (1 + down_interest_rate + risk_premium)\n\n    expected_price_date1 = probability_up * up_price_date1 + probability_down * down_price_date1\n    zero_coupon_bond_price = expected_price_date1 / (1 + risk_free_rate)\n    \n    return zero_coupon_bond_price",
        "ground_truth": 854.466,
        "topic": "Risk Management",
        "statistics": {
            "number_statistics": {
                "args_numbers": 6,
                "question_numbers": 9,
                "context_numbers": 0,
                "total_numbers": 9
            },
            "operator_statistics": {
                "operators": {
                    "+": 6,
                    "-": 0,
                    "*": 2,
                    "/": 3,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 11
            },
            "code_statistics": {
                "lines": 12,
                "parentheses": 6
            }
        },
        "difficulty": 5.105945473900581,
        "source": "FinanceMath-validation-23",
        "context": "[]",
        "question_id": "test-2164",
        "level": "hard",
        "output": [
            "### Step-by-Step Reasoning Using Emphasizing Constraints (EC)\n\n1. **Understanding the Problem**:\n   - We are valuing a 2-year zero-coupon bond.\n   - The face value of the bond is EUR 1,000.\n   - The current 1-year interest rate is 8% (0.08 as a decimal).\n   - In year two, there are two possibilities: the 1-year interest rate might rise to 10% (50% probability) or fall to 6% (50% probability).\n   - There is a risk premium of 40 basis points (0.004 as a decimal) to be added to the discount rate of future cash flows.\n\n2. **Zero-Coupon Bond Valuation**:\n   - The value of a zero-coupon bond is calculated as the present value of its face value discounted at the appropriate discount rate(s).\n   - The discount rate includes the expected interest rate and a risk premium for duration risk.\n\n3. **Decomposing the Calculation**:\n   - For the first year:\n     - The current 1-year interest rate is 8%.\n   - For the second year:\n     - The discount rate is determined by the weighted average of the possible second-year rates:\n       - Weighted average rate = Probability \u00d7 Rate + Probability \u00d7 Rate\n   - Factor in the risk premium:\n     - Total discount rate = Weighted average rate + Risk premium.\n\n4. **Constraints**:\n   - Ensure all rates are represented as decimals (e.g., 8% = 0.08).\n   - Output the bond valuation to three decimal places.\n\n5. **Final Steps**:\n   - Compute the bond's value using the discounted cash flows at appropriate interest rates, ensuring accuracy with compounding for the multi-period bond.\n\n---\n\n### Python Program Solution:\n```python\ndef solution():\n    # Define variables\n    face_value = 1000  # EUR\n    current_1yr_rate = 0.08  # Current 1-year interest rate (8%)\n    future_rate_high = 0.10  # Future 1-year rate (high case, 10%)\n    future_rate_low = 0.06  # Future 1-year rate (low case, 6%)\n    prob_high = 0.5  # Probability of the high interest rate (50%)\n    prob_low = 0.5  # Probability of the low interest rate (50%)\n    risk_premium = 0.004  # Risk premium for duration risk (40 basis points)\n\n    # Step 1: Calculate the expected second-year rate\n    expected_2yr_rate = (prob_high * future_rate_high) + (prob_low * future_rate_low) + risk_premium\n\n    # Step 2: Include the risk premium in the effective second-year rate\n    total_discount_rate = expected_2yr_rate\n\n    # Step 3: Calculate the bond's valuation\n    bond_value = face_value / ((1 + current_1yr_rate) * (1 + total_discount_rate))\n\n    # Step 4: Return the value rounded to three decimal places\n    return round(bond_value, 3)\n```"
        ],
        "retrieval_query": "A risk manager specializing in market risk is looking to determine the cost of a 2-year zero-coupon bond. The current 1-year interest rate is 8.0%. There's a chance of 50% that the 1-year interest rate will reach 10.0% after one year and an equal probability of its falling to 6.0% in the same period. Suppose the yearly risk premium for duration risk is 40 bps, and the bond faces a value of EUR 1,000. What should be the zero-coupon bond's valuation? Answer to three decimal places.",
        "useful_functions": [
            "def calculate_risk_neutral_default_probability(face_value: float, current_price: float, recovery_rate: float, risk_free_rate: float) -> float:\n    \"\"\"\n    Calculate the risk-neutral probability of default using a binomial tree methodology.\n\n    This function determines the risk-neutral probability of default for a bond,\n    given its face value, current trading price, recovery rate (in the event of default),\n    and the continuously-compounded risk-free rate.\n\n    Args:\n        face_value (float): The face value of the bond.\n        current_price (float): The current trading price of the bond.\n        recovery_rate (float): The recovery rate in the event of default, expressed as a decimal (0 to 1).\n        risk_free_rate (float): The continuously-compounded risk-free rate, expressed as a decimal (e.g., 0.03 for 3%).\n\n    Returns:\n        default_probability (float): The risk-neutral probability of default, expressed as a percentage.\n\n    Notes:\n        - Applicability: This function applies to zero-coupon bonds with no recovery in case of default.\n        - Constraints: The recovery rate should be between 0 and 1.\n        - Considerations: The bond should be the only debt of the firm for accurate risk-neutral assessment. This function does not account for market risk factors beyond risk-free rates.\n    \"\"\"\n    from math import exp\n\n    # Convert face value to expected payoff by accounting for recovery rate\n    expected_payoff = (1 - recovery_rate) * face_value * exp(-risk_free_rate)\n\n    # Calculate the risk-neutral survival probability\n    survival_probability = current_price / (expected_payoff)\n\n    # Calculate the risk-neutral default probability\n    default_probability = (1 - survival_probability) * 100\n\n    return default_probability"
        ],
        "usage": {
            "completion_tokens": 653,
            "prompt_tokens": 825,
            "total_tokens": 1478,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "What is the anticipated standard deviation for the following portfolio, assuming a correlation of 0.25 between the two securities (expressed as a percentage)? Answer to three decimal places.",
        "python_solution": "def solution():\n    w1 = 0.4\n    w2 = 0.6\n    sigma1 = 0.3\n    sigma2 = 0.15\n    rho = 0.25\n    sigma_port = ((w1**2 * sigma1**2) + (w2**2 * sigma2**2) + (2*w1*w2*sigma1*sigma2*rho))**0.5\n    return sigma_port*100",
        "ground_truth": 16.703,
        "topic": "Portfolio Management & Strategy",
        "statistics": {
            "number_statistics": {
                "args_numbers": 7,
                "question_numbers": 1,
                "context_numbers": 6,
                "total_numbers": 7
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 0,
                    "*": 8,
                    "/": 0,
                    "%": 0,
                    "**": 5
                },
                "total_operators": 15
            },
            "code_statistics": {
                "lines": 7,
                "parentheses": 8
            }
        },
        "difficulty": 5.105945473900581,
        "source": "FinanceMath-validation-123",
        "context": "['| Security | Security Weight(%) | Expected Standard Deviation(%) |\\n|----------|-------------------|--------------------------------|\\n| 1        | 40                | 30                             |\\n| 2        | 60                | 15                             |']",
        "question_id": "test-2165",
        "level": "hard",
        "output": [
            "To solve this problem and calculate the anticipated standard deviation of the portfolio, we will use the given function `calculate_portfolio_standard_deviation`. Here's how we'll proceed:\n\n### Step-by-Step Reasoning Using EC (Emphasizing Constraints)\n1. **Input Requirements and Constraints**:\n   - There are two securities in the portfolio.\n   - The weights of the securities are provided in percentages (i.e., 40% and 60%).\n   - The expected standard deviations of the securities are given in percentages (i.e., 30% and 15%).\n   - The correlation between the two securities is provided as 0.25.\n   - The weights must sum to 1, and the standard deviations must be converted to decimals.\n\n2. **Mathematical Formula**:\n   The formula for portfolio variance and standard deviation is given by:\n   \\[\n   \\sigma_p^2 = w_1^2 \\cdot \\sigma_1^2 + w_2^2 \\cdot \\sigma_2^2 + 2 \\cdot w_1 \\cdot w_2 \\cdot \\sigma_1 \\cdot \\sigma_2 \\cdot \\rho \n   \\]\n   Where:\n   - \\( \\sigma_p \\) is the portfolio standard deviation.\n   - \\( w_1, w_2 \\) are the weights of securities 1 and 2.\n   - \\( \\sigma_1, \\sigma_2 \\) are the standard deviations of securities 1 and 2.\n   - \\( \\rho \\) is the correlation coefficient between the two securities.\n\n   Finally, the portfolio standard deviation (\\( \\sigma_p \\)) is the square root of the portfolio variance.\n\n3. **Conversion and Constraints**:\n   - Convert weights and percentages to decimal form by dividing by 100.\n   - Return the final answer as a percentage rounded to three decimal places.\n\n4. **Preparation**:\n   - Input the given weights, standard deviations (as decimals), and the correlation coefficient into the function `calculate_portfolio_standard_deviation`.\n\nBelow is the Python program:\n\n```python\ndef solution():\n    # Define the inputs\n    weights = [40 / 100, 60 / 100]  # Convert weights to decimal form\n    std_devs = [30 / 100, 15 / 100]  # Convert standard deviations to decimal form\n    correlation = 0.25  # Given correlation between the two securities\n    \n    # Using the function provided to calculate portfolio standard deviation\n    portfolio_std_dev = calculate_portfolio_standard_deviation(weights, std_devs, correlation)\n    \n    # Convert the result to percentage and round to three decimal places\n    answer = round(portfolio_std_dev * 100, 3)\n    \n    # Return the result\n    return answer\n```\n\nThis program takes the weights, standard deviations, and correlation as inputs, calculates the anticipated portfolio standard deviation using the given `calculate_portfolio_standard_deviation` function, and outputs the result as a percentage rounded to three decimal places."
        ],
        "retrieval_query": "What is the anticipated standard deviation for the following portfolio, assuming a correlation of 0.25 between the two securities (expressed as a percentage)? Answer to three decimal places.",
        "useful_functions": [
            "def calculate_portfolio_standard_deviation(weights: list, std_devs: list, correlation: float) -> float:\n    \"\"\"\n    Calculate the expected standard deviation of a two-asset portfolio.\n\n    This function computes the standard deviation of a portfolio consisting of\n    two assets, given their respective weights, standard deviations, and the \n    correlation between them. It is useful for understanding the risk associated\n    with a portfolio of two securities or investments.\n\n    Args:\n        weights (list): A list of two floats representing the weights of the \n                        securities in the portfolio. Should sum to 1.\n        std_devs (list): A list of two floats representing the expected standard \n                         deviations of the securities as fractions.\n        correlation (float): The correlation coefficient between the two securities, \n                             which should be between -1 and 1.\n\n    Returns:\n        portfolio_std_dev (float): The standard deviation of the portfolio as a \n                                   fraction of the portfolio value.\n\n    Notes:\n        - This function assumes there are exactly two assets in the portfolio.\n        - Weights in the `weights` list should sum to 1.\n        - Values in `std_devs` should be expressed as fractions (e.g., 30% as 0.3).\n        - The correlation coefficient should be between -1 and 1.\n        - This function does not account for more complex portfolio constraints \n          such as transaction costs or liquidity factors.\n    \"\"\"\n    if len(weights) != 2 or len(std_devs) != 2:\n        raise ValueError(\"Both weights and std_devs must be lists of length 2.\")\n\n    w1, w2 = weights\n    sigma1, sigma2 = std_devs\n\n    if not (0 <= w1 <= 1 and 0 <= w2 <= 1 and abs(w1 + w2 - 1) < 1e-6):\n        raise ValueError(\"The sum of weights must equal 1.\")\n\n    portfolio_variance = (w1**2 * sigma1**2) + (w2**2 * sigma2**2) + (2 * w1 * w2 * sigma1 * sigma2 * correlation)\n    portfolio_std_dev = portfolio_variance ** 0.5\n    \n    return portfolio_std_dev",
            "def calculate_williams_r(high_prices: list, low_prices: list, closing_prices: list, period: int = 14) -> list:\n    \"\"\"\n    Calculate the Williams %R for a given set of high, low, and closing prices.\n\n    This function computes the Williams %R, a momentum oscillator that \n    measures overbought and oversold conditions in the market. It is used \n    to identify potential reversal points by comparing the current closing \n    price to the high-low range over a specified period.\n\n    Args:\n        high_prices (list): A list of high prices for each period.\n        low_prices (list): A list of low prices for each period.\n        closing_prices (list): A list of closing prices for each period.\n        period (int): The number of periods to include in the calculation \n                      (default is 14).\n\n    Returns:\n        williams_r_values (list): A list of calculated Williams %R values \n                                  corresponding to each period.\n\n    Notes:\n        - Applicability: Suitable for technical analysis in financial markets \n          to identify overbought or oversold conditions.\n        - Constraints: The lists high_prices, low_prices, and closing_prices must \n          be of the same length and length should be greater than or equal to `period`.\n        - Considerations: Williams %R is particularly effective in rangebound markets \n          but may produce false signals in trending markets. It is often \n          advisable to use it alongside other indicators for confirmation.\n    \"\"\"\n    if not (len(high_prices) == len(low_prices) == len(closing_prices)):\n        raise ValueError(\"All input lists must have the same length.\")\n    if len(high_prices) < period:\n        raise ValueError(\"Input lists must be longer than the specified period.\")\n    \n    williams_r_values = []\n    for i in range(len(closing_prices) - period + 1):\n        highest_high = max(high_prices[i:i + period])\n        lowest_low = min(low_prices[i:i + period])\n        current_close = closing_prices[i + period - 1]\n        \n        williams_r = ((highest_high - current_close) / (highest_high - lowest_low)) * -100\n        williams_r_values.append(williams_r)\n    \n    return williams_r_values"
        ],
        "usage": {
            "completion_tokens": 630,
            "prompt_tokens": 1365,
            "total_tokens": 1995,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-463",
        "article_title": "Intrinsic Value",
        "function": "def calculate_intrinsic_value(cash_flows: list, discount_rate: float, terminal_value_multiple: float) -> float:\n    \"\"\"\n    Calculate the intrinsic value of a company using the discounted cash flow (DCF) method.\n\n    This function estimates the intrinsic value of a company by discounting\n    its expected future cash flows and terminal value back to the present value.\n\n    Args:\n        cash_flows (list): A list of expected future cash flows.\n        discount_rate (float): The discount rate used for discounting future cash flows.\n                               Typically, a risk-free rate or weighted average cost of capital.\n        terminal_value_multiple (float): The multiple used to estimate the terminal value\n                                         from the final year's cash flow.\n\n    Returns:\n        intrinsic_value (float): The estimated intrinsic value of the company.\n\n    Notes:\n        - Applicability: This function is applicable to value investors seeking the intrinsic\n                         worth of a company using cash flow projections.\n        - Constraints: Requires accurate estimation of future cash flows and an appropriate\n                       discount rate.\n        - Considerations: Terminal values significantly influence intrinsic valuation; this should\n                          be carefully assessed.\n    \"\"\"\n    n = len(cash_flows)\n    present_value_of_cash_flows = sum(cf / ((1 + discount_rate) ** (i + 1)) for i, cf in enumerate(cash_flows))\n    \n    if n > 0:\n        terminal_value = cash_flows[-1] * terminal_value_multiple\n        present_value_of_terminal_value = terminal_value / ((1 + discount_rate) ** n)\n    else:\n        present_value_of_terminal_value = 0\n\n    intrinsic_value = present_value_of_cash_flows + present_value_of_terminal_value\n    \n    return intrinsic_value",
        "statistics": {
            "number_statistics": {
                "args_numbers": 3,
                "question_numbers": 0,
                "context_numbers": 14,
                "total_numbers": 14
            },
            "operator_statistics": {
                "operators": {
                    "+": 4,
                    "-": 1,
                    "*": 1,
                    "/": 2,
                    "%": 0,
                    "**": 2
                },
                "total_operators": 10
            },
            "code_statistics": {
                "lines": 9,
                "parentheses": 16
            }
        },
        "difficulty": 5.135798437050262,
        "context": "A financial analyst is tasked with evaluating the intrinsic value of a company that is expected to generate future cash flows over the next 5 years. The predicted cash flows (in millions) for each of these years are as follows: Year 1 - 8 million, Year 2 - 10 million, Year 3 - 12 million, Year 4 - 15 million, and Year 5 - 18 million. The analyst decides to use a discount rate of 8% to calculate the present value of these cash flows. Additionally, the analyst estimates the terminal value using a terminal value multiple of 4 applied to the cash flow of Year 5.",
        "question": "What is the intrinsic value of the company based on these projections? Answer in millions and round to two decimal places.",
        "python_solution": "def solution():\n    # Define the cash flows for each year\n    cash_flows = [8, 10, 12, 15, 18]  # in millions\n    \n    # Set the discount rate\n    discount_rate = 0.08  # 8%\n    \n    # Set the terminal value multiple\n    terminal_value_multiple = 4\n    \n    # Calculate the present value of the cash flows\n    present_value_of_cash_flows = sum(cf / ((1 + discount_rate) ** (i + 1)) for i, cf in enumerate(cash_flows))\n    \n    # Calculate the terminal value based on the last cash flow\n    terminal_value = cash_flows[-1] * terminal_value_multiple\n    present_value_of_terminal_value = terminal_value / ((1 + discount_rate) ** len(cash_flows))\n    \n    # Add the present values to get the intrinsic value\n    intrinsic_value = present_value_of_cash_flows + present_value_of_terminal_value\n    \n    # Return the intrinsic value rounded to two decimal places\n    return round(intrinsic_value, 2)",
        "ground_truth": 97.78,
        "source": "FinanceReasoning-test-91",
        "question_id": "test-2166",
        "level": "hard",
        "output": [
            "To solve the given problem and find the intrinsic value of the company, let's break it down systematically:\n\n### Step-by-Step Calculation:\n1. **Constraints and Assumptions (EC):**\n   - All cash flows are in millions.\n   - Discount rate is 8% (0.08 as a decimal).\n   - Terminal value is calculated using the terminal value multiple of 4 applied to the cash flow of Year 5.\n   - Final answer should be rounded to two decimal places.\n\n2. **Net Present Value (NPV) of Cash Flows:**\n   - Formula: \\( PV = \\frac{FV}{(1 + r)^t} \\), where:\n     - \\( FV \\) is the future value (cash flow for the year).\n     - \\( r \\) is the discount rate.\n     - \\( t \\) is the time period.\n   - For each year's cash flow, we will calculate the present value using the above formula and sum them up.\n\n3. **Terminal Value:**\n   - Terminal value is calculated as \\( TV = CF_{5} \\times \\text{Terminal Value Multiple} \\), where:\n     - \\( CF_{5} \\) is the cash flow in Year 5.\n     - Terminal value multiple = 4.\n   - The present value of the terminal value is then discounted to Year 0 using the formula:\n     \\( PV_{TV} = \\frac{TV}{(1 + r)^5} \\).\n\n4. **Intrinsic Value:**\n   - Sum the present values of all five years' cash flows and the present value of the terminal value.\n\n5. **Rounding to Two Decimal Places:**\n   - Final intrinsic value should be reported to two decimal places for clarity and precision.\n\nNow, we will implement this step-by-step calculation in Python.\n\n```python\ndef solution():\n    # Define variables for cash flows (in millions) and discount rate\n    cash_flows = [8, 10, 12, 15, 18]  # Yearly cash flows in millions\n    discount_rate = 0.08  # 8% discount rate\n    terminal_value_multiple = 4\n    \n    # Step 1: Calculate the present value of cash flows (Year 1 to Year 5)\n    present_value_cash_flows = 0\n    for year, cash_flow in enumerate(cash_flows, start=1):\n        present_value_cash_flows += cash_flow / ((1 + discount_rate) ** year)\n    \n    # Step 2: Calculate the terminal value and its present value\n    terminal_value = cash_flows[-1] * terminal_value_multiple  # Cash Flow of Year 5 * Terminal Value Multiple\n    present_value_terminal_value = terminal_value / ((1 + discount_rate) ** 5)\n    \n    # Step 3: Calculate the total intrinsic value\n    intrinsic_value = present_value_cash_flows + present_value_terminal_value\n    \n    # Step 4: Round the result to two decimal places\n    return round(intrinsic_value, 2)\n```\n\nThis program will compute the intrinsic value of the company based on the provided cash flows, discount rate, and terminal value multiple. The final result is returned in millions and rounded to two decimal places."
        ],
        "retrieval_query": "What is the intrinsic value of the company based on these projections? Answer in millions and round to two decimal places.",
        "useful_functions": [
            "def calculate_relative_strength(price_changes: list) -> float:\n    \"\"\"\n    Calculate the Relative Strength Index (RSI) based on recent price changes.\n\n    This function computes the RSI, a momentum indicator that measures the \n    magnitude of recent price changes to evaluate overbought or oversold \n    conditions in the price of an asset. RSI values range from 0 to 100.\n\n    Args:\n        price_changes (list): A list of recent price changes, where positive\n                              values indicate price increases and negative values\n                              indicate price decreases.\n\n    Returns:\n        rsi (float): The calculated RSI value.\n\n    Notes:\n        - Applicability: This function is applicable in technical analysis of stocks\n          or other assets to determine overbought or oversold conditions.\n        - Constraints: The list of price changes should not be empty.\n        - Considerations: Traditional interpretations are that RSI values >= 70 indicate\n          overbought conditions, and values <= 30 indicate oversold conditions.\n    \"\"\"\n    if not price_changes:\n        raise ValueError(\"Price changes list cannot be empty.\")\n    \n    gain = sum(change for change in price_changes if change > 0) / len(price_changes)\n    loss = -sum(change for change in price_changes if change < 0) / len(price_changes)\n    \n    if loss == 0:\n        return 100.0  # Return maximum RSI value if no losses\n\n    rs = gain / loss\n    rsi = 100 - (100 / (1 + rs))\n    \n    return rsi"
        ],
        "usage": {
            "completion_tokens": 671,
            "prompt_tokens": 811,
            "total_tokens": 1482,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-2485",
        "article_title": "Worden Stochastics",
        "function": "def calculate_worden_stochastic(closing_prices: list, lookback_period: int) -> list:\n    \"\"\"\n    Calculate the Worden Stochastic indicator for a series of closing prices.\n\n    This function computes the Worden Stochastic, which indicates the percentile\n    rank of the most recent closing price compared to the other closing values\n    over a specified lookback period. It helps traders determine overbought or\n    oversold conditions in a security.\n\n    Args:\n        closing_prices (list): A list of closing prices for the security.\n        lookback_period (int): The number of periods to consider for the calculation.\n\n    Returns:\n        worden_stochastics (list): A list of Worden Stochastic values for each\n                                   price in the series.\n\n    Notes:\n        - Applicability: Useful for technical analysis to identify price extremes.\n        - Constraints: The lookback period must be less than or equal to the length\n                       of the closing_prices list and greater than 0.\n        - Considerations: This function does not account for any additional trading\n                          signals or filters; it computes only the raw stochastic\n                          values.\n    \"\"\"\n    if lookback_period <= 0 or lookback_period > len(closing_prices):\n        raise ValueError(\"Invalid lookback period: must be > 0 and <= number of closing prices.\")\n\n    worden_stochastics = []\n    \n    for i in range(len(closing_prices)):\n        if i >= lookback_period - 1:\n            # Slice the current lookback window of closing prices\n            window = closing_prices[i-lookback_period+1:i+1]\n            # Calculate rank of the most recent closing price in the sorted window\n            rank = sorted(window).index(closing_prices[i]) + 1\n            # Calculate the Worden Stochastic\n            worden_stochastic = (100 / (lookback_period - 1)) * (rank - 1)\n            worden_stochastics.append(worden_stochastic)\n\n    return worden_stochastics",
        "statistics": {
            "number_statistics": {
                "args_numbers": 2,
                "question_numbers": 1,
                "context_numbers": 14,
                "total_numbers": 15
            },
            "operator_statistics": {
                "operators": {
                    "+": 3,
                    "-": 4,
                    "*": 1,
                    "/": 1,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 9
            },
            "code_statistics": {
                "lines": 11,
                "parentheses": 16
            }
        },
        "difficulty": 5.14166355650266,
        "context": "A stock trader is analyzing historical closing prices of a technology company's stock to determine potential buying or selling opportunities. The trader has the closing prices for the last 12 trading days, which are: [150, 152, 155, 151, 154, 156, 157, 158, 160, 162, 161, 159]. The trader uses a 5-day lookback period to calculate the Worden Stochastic, which helps in identifying the stock's momentum and suggests potential overbought or oversold conditions. The trader is specifically interested in the Worden Stochastic value for the last trading day.",
        "question": "What is the Worden Stochastic value for the last trading day using a 5-day lookback period? Answer as a percentage to two decimal places.",
        "python_solution": "def solution():\n    # Define the closing prices and lookback period\n    closing_prices = [150, 152, 155, 151, 154, 156, 157, 158, 160, 162, 161, 159]\n    lookback_period = 5\n    \n    # Calculate Worden Stochastic for the last trading day\n    recent_window = closing_prices[-lookback_period:]\n    last_closing_price = closing_prices[-1]\n    \n    # Calculate rank of the last closing price in sorted window\n    sorted_window = sorted(recent_window)\n    rank = sorted_window.index(last_closing_price) + 1\n    \n    # Calculate the Worden Stochastic value\n    worden_stochastic = (100 / (lookback_period - 1)) * (rank - 1)\n\n    # Return the result rounded to two decimal places\n    return round(worden_stochastic, 2)\n\nprint(solution())",
        "ground_truth": 25.0,
        "source": "FinanceReasoning-test-104",
        "question_id": "test-2167",
        "level": "hard",
        "output": [
            "To solve the problem, let's break it down step by step and apply the **Emphasizing Constraints (EC)** technique to ensure all constraints are adhered to for accuracy:\n\n### Step 1: Understand the Worden Stochastic Formula\n- The Worden Stochastic value of a price is calculated as:\n  \\[\n  \\text{Worden Stochastic} = \\left( \\frac{100}{\\text{lookback period} - 1} \\right) \\times (\\text{rank of most recent price in the sorted window} - 1)\n  \\]\n- Here, the rank is determined by sorting the values in the lookback window (including the current day), and the current closing price's position within that sorted list determines the rank.\n- We need the Worden Stochastic for the last trading day's closing price.\n\n### Step 2: Identify the Lookback Period and Relevant Data\n- The lookback period: **5 days**.\n- Closing prices: \\([150, 152, 155, 151, 154, 156, 157, 158, 160, 162, 161, 159]\\).\n- On the last trading day (12th trading day), the lookback window consists of the prices: \\([158, 160, 162, 161, 159]\\).\n\n### Step 3: Apply Constraints\n- **Constraint 1**: The lookback period must be less than or equal to the number of closing prices. With 12 prices and a 5-day lookback, this constraint is satisfied.\n- **Constraint 2**: The percentage answer should be given to two decimal places.\n\n### Step 4: Calculate for the Last Trading Day\n- For the last trading day (closing price = 159), the 5-day lookback period includes prices: \\([158, 160, 162, 161, 159]\\).\n- Sort the lookback window: \\([158, 159, 160, 161, 162]\\).\n- The rank of 159 in the sorted list is **2**.\n- Substituting into the Worden Stochastic formula:\n  \\[\n  \\text{Worden Stochastic} = \\left( \\frac{100}{5 - 1} \\right) \\times (2 - 1) = \\left( \\frac{100}{4} \\right) \\times 1 = 25.00\n  \\]\n\n### Step 5: Write the Python Program\nHere\u2019s the program to compute the result:\n\n```python\ndef solution():\n    # Define variables name and value\n    closing_prices = [150, 152, 155, 151, 154, 156, 157, 158, 160, 162, 161, 159]\n    lookback_period = 5\n\n    # Slice the last 5-day lookback window\n    lookback_window = closing_prices[-lookback_period:]\n    \n    # Calculate rank of the last day's closing price\n    sorted_window = sorted(lookback_window)\n    rank = sorted_window.index(closing_prices[-1]) + 1\n\n    # Calculate Worden Stochastic\n    worden_stochastic = (100 / (lookback_period - 1)) * (rank - 1)\n    \n    # Return the result rounded to 2 decimal places\n    return round(worden_stochastic, 2)\n```"
        ],
        "retrieval_query": "What is the Worden Stochastic value for the last trading day using a 5-day lookback period? Answer as a percentage to two decimal places.",
        "useful_functions": [
            "def calculate_worden_stochastic(closing_prices: list, lookback_period: int) -> list:\n    \"\"\"\n    Calculate the Worden Stochastic indicator for a series of closing prices.\n\n    This function computes the Worden Stochastic, which indicates the percentile\n    rank of the most recent closing price compared to the other closing values\n    over a specified lookback period. It helps traders determine overbought or\n    oversold conditions in a security.\n\n    Args:\n        closing_prices (list): A list of closing prices for the security.\n        lookback_period (int): The number of periods to consider for the calculation.\n\n    Returns:\n        worden_stochastics (list): A list of Worden Stochastic values for each\n                                   price in the series.\n\n    Notes:\n        - Applicability: Useful for technical analysis to identify price extremes.\n        - Constraints: The lookback period must be less than or equal to the length\n                       of the closing_prices list and greater than 0.\n        - Considerations: This function does not account for any additional trading\n                          signals or filters; it computes only the raw stochastic\n                          values.\n    \"\"\"\n    if lookback_period <= 0 or lookback_period > len(closing_prices):\n        raise ValueError(\"Invalid lookback period: must be > 0 and <= number of closing prices.\")\n\n    worden_stochastics = []\n    \n    for i in range(len(closing_prices)):\n        if i >= lookback_period - 1:\n            # Slice the current lookback window of closing prices\n            window = closing_prices[i-lookback_period+1:i+1]\n            # Calculate rank of the most recent closing price in the sorted window\n            rank = sorted(window).index(closing_prices[i]) + 1\n            # Calculate the Worden Stochastic\n            worden_stochastic = (100 / (lookback_period - 1)) * (rank - 1)\n            worden_stochastics.append(worden_stochastic)\n\n    return worden_stochastics"
        ],
        "usage": {
            "completion_tokens": 710,
            "prompt_tokens": 911,
            "total_tokens": 1621,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-2638",
        "article_title": "Stochastic RSI (StochRSI)",
        "function": "def calculate_stochastic_rsi(rsi_values: list, lookback_period: int) -> list:\n    \"\"\"\n    Calculate the Stochastic RSI (StochRSI) for a given set of RSI values.\n\n    This function computes the StochRSI, an indicator that measures the RSI\n    level relative to its high-low range over a specified lookback period.\n    It produces values oscillating between 0 and 1, highlighting overbought\n    or oversold conditions.\n\n    Args:\n        rsi_values (list): A list of RSI values over time.\n        lookback_period (int): The number of periods over which the RSI should\n                               be analyzed. It determines the period for the\n                               high-low range calculation.\n\n    Returns:\n        stoch_rsi (list): A list containing the StochRSI values, aligned with\n                          the input RSI values, excluding the initial periods\n                          where calculation is not possible due to lack of data.\n\n    Notes:\n        - Applicability: This function is useful in technical analysis for\n                         determining momentum shifts and potential reversal\n                         points.\n        - Constraints: The length of rsi_values must be greater than the\n                       lookback_period to produce meaningful results.\n        - Considerations: StochRSI is highly sensitive; consider smoothing with\n                          a moving average for a more stable signal.\n    \"\"\"\n    if len(rsi_values) <= lookback_period:\n        raise ValueError(\"The length of rsi_values must be greater than the lookback_period.\")\n\n    stoch_rsi = []\n    for i in range(len(rsi_values) - lookback_period + 1):\n        window = rsi_values[i:i + lookback_period]\n        min_rsi = min(window)\n        max_rsi = max(window)\n        if max_rsi - min_rsi == 0:\n            stoch_rsi.append(0)  # Avoid division by zero\n        else:\n            stoch_rsi_value = (rsi_values[i + lookback_period - 1] - min_rsi) / (max_rsi - min_rsi)\n            stoch_rsi.append(stoch_rsi_value)\n\n    return stoch_rsi",
        "statistics": {
            "number_statistics": {
                "args_numbers": 2,
                "question_numbers": 3,
                "context_numbers": 17,
                "total_numbers": 20
            },
            "operator_statistics": {
                "operators": {
                    "+": 3,
                    "-": 5,
                    "*": 0,
                    "/": 1,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 9
            },
            "code_statistics": {
                "lines": 11,
                "parentheses": 16
            }
        },
        "difficulty": 5.14166355650266,
        "context": "A stock trader is analyzing the momentum shifts of a particular stock using the Stochastic Relative Strength Index (StochRSI) indicator. The trader has collected a series of RSI values for 15 consecutive trading days as follows: [40.5, 42.3, 41.8, 45.2, 47.6, 49.0, 51.3, 48.7, 46.8, 44.9, 42.1, 39.5, 37.2, 36.4, 35.0]. The trader wants to calculate the StochRSI for a lookback period of 5 days to identify potential overbought or oversold conditions for making trading decisions.",
        "question": "What is the Stochastic RSI value on the last day (15th day) of the given data series, using a 5-day lookback period? Express the result as a value between 0 and 1, rounded to two decimal places.",
        "python_solution": "def solution():\n    # Define the RSI values and the lookback period\n    rsi_values = [40.5, 42.3, 41.8, 45.2, 47.6, 49.0, 51.3, 48.7, 46.8, 44.9, 42.1, 39.5, 37.2, 36.4, 35.0]\n    lookback_period = 5\n\n    # Prepare to compute the StochRSI\n    last_index = len(rsi_values) - lookback_period\n    current_window = rsi_values[last_index:last_index + lookback_period]\n    \n    # Calculate minimum and maximum RSI in the current window\n    min_rsi = min(current_window)\n    max_rsi = max(current_window)\n    last_rsi = rsi_values[last_index + lookback_period - 1]  # RSI on the last day\n\n    # Calculate Stochastic RSI for the last day\n    if max_rsi - min_rsi == 0:\n        stoch_rsi_value = 0  # Avoid division by zero\n    else:\n        stoch_rsi_value = (last_rsi - min_rsi) / (max_rsi - min_rsi)\n\n    # Return the StochRSI value for the last day rounded to two decimal places\n    return round(stoch_rsi_value, 2)\n\n# Invoke the solution function\nprint(solution())",
        "ground_truth": 0.0,
        "source": "FinanceReasoning-test-105",
        "question_id": "test-2168",
        "level": "hard",
        "output": [
            "Let's analyze the problem step by step:\n\n### Step 1: Understanding Stochastic RSI Calculation\nThe Stochastic RSI is calculated as follows:\n\\[\n\\text{StochRSI} = \\frac{\\text{RSI} - \\text{Min RSI (lookback period)}}{\\text{Max RSI (lookback period)} - \\text{Min RSI (lookback period)}}\n\\]\n- **RSI Values:** We are given the RSI values for 15 consecutive trading days.\n- **Lookback Period:** A 5-day lookback period is specified.\n- **Constraints:** The result must be a value between 0 and 1 and expressed to 2 decimal places.\n\n### Step 2: Applying the Formula on the Last Day\nOn the 15th day, the 5-day lookback period includes RSI values from day 11 to day 15:\n\\[\n\\text{Window RSI values} = [42.1, 39.5, 37.2, 36.4, 35.0]\n\\]\n- **Min RSI (lookback period):** Minimum RSI in the 5-day window = 35.0\n- **Max RSI (lookback period):** Maximum RSI in the 5-day window = 42.1\n- **RSI on Day 15:** 35.0\n\nSubstitute into the formula:\n\\[\n\\text{StochRSI on Day 15} = \\frac{35.0 - 35.0}{42.1 - 35.0} = 0\n\\]\n\n### Step 3: Constraints Validation\n1. **Values within Range:** The result must be between 0 and 1. The calculation (0) respects this constraint.\n2. **Rounded to Two Decimal Places:** The value is already in the required precision.\n\n### Step 4: Program Implementation\nWe'll now implement a Python program to automate this calculation. Here's the solution:\n\n```python\ndef solution():\n    # Define variables name and value\n    rsi_values = [40.5, 42.3, 41.8, 45.2, 47.6, 49.0, 51.3, 48.7, 46.8, 44.9, 42.1, 39.5, 37.2, 36.4, 35.0]\n    lookback_period = 5\n\n    # Extract the last 5-day window for the calculation\n    window = rsi_values[-lookback_period:]  # Last 5 days: [42.1, 39.5, 37.2, 36.4, 35.0]\n    \n    # Compute the min and max in the lookback window\n    min_rsi = min(window)\n    max_rsi = max(window)\n    \n    # Use the RSI value on the last day\n    last_rsi = rsi_values[-1]\n    \n    # Calculate the Stochastic RSI\n    if max_rsi - min_rsi == 0:\n        stoch_rsi_value = 0  # Avoid division by zero\n    else:\n        stoch_rsi_value = (last_rsi - min_rsi) / (max_rsi - min_rsi)\n    \n    # Round the result to two decimal places\n    return round(stoch_rsi_value, 2)\n```"
        ],
        "retrieval_query": "What is the Stochastic RSI value on the last day (15th day) of the given data series, using a 5-day lookback period? Express the result as a value between 0 and 1, rounded to two decimal places.",
        "useful_functions": [
            "def calculate_stochastic_rsi(rsi_values: list, lookback_period: int) -> list:\n    \"\"\"\n    Calculate the Stochastic RSI (StochRSI) for a given set of RSI values.\n\n    This function computes the StochRSI, an indicator that measures the RSI\n    level relative to its high-low range over a specified lookback period.\n    It produces values oscillating between 0 and 1, highlighting overbought\n    or oversold conditions.\n\n    Args:\n        rsi_values (list): A list of RSI values over time.\n        lookback_period (int): The number of periods over which the RSI should\n                               be analyzed. It determines the period for the\n                               high-low range calculation.\n\n    Returns:\n        stoch_rsi (list): A list containing the StochRSI values, aligned with\n                          the input RSI values, excluding the initial periods\n                          where calculation is not possible due to lack of data.\n\n    Notes:\n        - Applicability: This function is useful in technical analysis for\n                         determining momentum shifts and potential reversal\n                         points.\n        - Constraints: The length of rsi_values must be greater than the\n                       lookback_period to produce meaningful results.\n        - Considerations: StochRSI is highly sensitive; consider smoothing with\n                          a moving average for a more stable signal.\n    \"\"\"\n    if len(rsi_values) <= lookback_period:\n        raise ValueError(\"The length of rsi_values must be greater than the lookback_period.\")\n\n    stoch_rsi = []\n    for i in range(len(rsi_values) - lookback_period + 1):\n        window = rsi_values[i:i + lookback_period]\n        min_rsi = min(window)\n        max_rsi = max(window)\n        if max_rsi - min_rsi == 0:\n            stoch_rsi.append(0)  # Avoid division by zero\n        else:\n            stoch_rsi_value = (rsi_values[i + lookback_period - 1] - min_rsi) / (max_rsi - min_rsi)\n            stoch_rsi.append(stoch_rsi_value)\n\n    return stoch_rsi"
        ],
        "usage": {
            "completion_tokens": 706,
            "prompt_tokens": 991,
            "total_tokens": 1697,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-2477",
        "article_title": "Williams %R",
        "function": "def calculate_williams_r(high_prices: list, low_prices: list, closing_prices: list, period: int = 14) -> list:\n    \"\"\"\n    Calculate the Williams %R for a given set of high, low, and closing prices.\n\n    This function computes the Williams %R, a momentum oscillator that \n    measures overbought and oversold conditions in the market. It is used \n    to identify potential reversal points by comparing the current closing \n    price to the high-low range over a specified period.\n\n    Args:\n        high_prices (list): A list of high prices for each period.\n        low_prices (list): A list of low prices for each period.\n        closing_prices (list): A list of closing prices for each period.\n        period (int): The number of periods to include in the calculation \n                      (default is 14).\n\n    Returns:\n        williams_r_values (list): A list of calculated Williams %R values \n                                  corresponding to each period.\n\n    Notes:\n        - Applicability: Suitable for technical analysis in financial markets \n          to identify overbought or oversold conditions.\n        - Constraints: The lists high_prices, low_prices, and closing_prices must \n          be of the same length and length should be greater than or equal to `period`.\n        - Considerations: Williams %R is particularly effective in rangebound markets \n          but may produce false signals in trending markets. It is often \n          advisable to use it alongside other indicators for confirmation.\n    \"\"\"\n    if not (len(high_prices) == len(low_prices) == len(closing_prices)):\n        raise ValueError(\"All input lists must have the same length.\")\n    if len(high_prices) < period:\n        raise ValueError(\"Input lists must be longer than the specified period.\")\n    \n    williams_r_values = []\n    for i in range(len(closing_prices) - period + 1):\n        highest_high = max(high_prices[i:i + period])\n        lowest_low = min(low_prices[i:i + period])\n        current_close = closing_prices[i + period - 1]\n        \n        williams_r = ((highest_high - current_close) / (highest_high - lowest_low)) * -100\n        williams_r_values.append(williams_r)\n    \n    return williams_r_values",
        "statistics": {
            "number_statistics": {
                "args_numbers": 4,
                "question_numbers": 1,
                "context_numbers": 63,
                "total_numbers": 64
            },
            "operator_statistics": {
                "operators": {
                    "+": 4,
                    "-": 5,
                    "*": 1,
                    "/": 1,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 11
            },
            "code_statistics": {
                "lines": 8,
                "parentheses": 16
            }
        },
        "difficulty": 5.170483995038152,
        "context": "A trader is analyzing the performance of stock ABC over the past 20 days to identify potential reversal points using the Williams %R indicator. The trader has recorded the following prices for the past 20 trading days:\n\nHigh Prices: [120, 122, 121, 119, 123, 125, 126, 127, 126, 124, 123, 122, 121, 120, 119, 118, 120, 121, 122, 123]\n\nLow Prices: [115, 116, 117, 115, 118, 119, 120, 121, 122, 120, 119, 118, 116, 115, 114, 113, 114, 115, 116, 118]\n\nClosing Prices: [117, 118, 119, 117, 120, 123, 124, 122, 123, 121, 120, 119, 118, 117, 116, 115, 118, 120, 121, 122]\n\nThe trader decides to use a 14-day period to calculate the Williams %R to determine whether the stock is currently overbought or oversold. The trader is particularly interested in the Williams %R value of the most recent period (the 20th day).",
        "question": "What is the Williams %R value for stock ABC on the 20th day, using the 14-day period? Answer as a percentage to two decimal places.",
        "python_solution": "def solution():\n    # Input data for the problem\n    high_prices = [120, 122, 121, 119, 123, 125, 126, 127, 126, 124, 123, 122, 121, 120, 119, 118, 120, 121, 122, 123]\n    low_prices = [115, 116, 117, 115, 118, 119, 120, 121, 122, 120, 119, 118, 116, 115, 114, 113, 114, 115, 116, 118]\n    closing_prices = [117, 118, 119, 117, 120, 123, 124, 122, 123, 121, 120, 119, 118, 117, 116, 115, 118, 120, 121, 122]\n    period = 14\n    \n    # Calculate Williams %R for the last period\n    index = len(closing_prices) - period  # Starting index for the last 14-day period\n    highest_high = max(high_prices[index:index + period])\n    lowest_low = min(low_prices[index:index + period])\n    current_close = closing_prices[index + period - 1]\n    \n    # Calculate Williams %R\n    williams_r = ((highest_high - current_close) / (highest_high - lowest_low)) * -100\n\n    # Return the answer as a percentage to two decimal places\n    return round(williams_r, 2)",
        "ground_truth": -35.71,
        "source": "FinanceReasoning-test-77",
        "question_id": "test-2169",
        "level": "hard",
        "output": [
            "### Step-by-step Analysis:\n\n1. **Understand Problem:**  \n   The trader wants to calculate the Williams %R value for stock ABC using a 14-day period (default setting for the indicator), focusing specifically on the 20th day. Williams %R is expressed as a percentage and allows us to determine if the stock is overbought or oversold.\n\n2. **Input Data:**  \n   - High Prices: [120, 122, 121, 119, 123, 125, 126, 127, 126, 124, 123, 122, 121, 120, 119, 118, 120, 121, 122, 123]\n   - Low Prices: [115, 116, 117, 115, 118, 119, 120, 121, 122, 120, 119, 118, 116, 115, 114, 113, 114, 115, 116, 118]\n   - Closing Prices: [117, 118, 119, 117, 120, 123, 124, 122, 123, 121, 120, 119, 118, 117, 116, 115, 118, 120, 121, 122]\n   - Period: 14 days\n\n3. **Constraints:**  \n   - Constraint (1): The lengths of `high_prices`, `low_prices`, and `closing_prices` must be the same.\n   - Constraint (2): The input lists must have at least 14 values (matching the period).\n   - Constraint (3): Output value should be returned as a percentage with 2 decimal places.\n\n4. **Methodology:**  \n   To calculate the Williams %R value for the 20th day:\n   - Extract the last 14 days of relevant data (day 7 to 20 inclusively in a zero-indexed array).\n   - Identify the highest high during these 14 days.\n   - Identify the lowest low during these 14 days.\n   - Calculate Williams %R using the formula:  \n     \\[\n     \\text{Williams \\%R} = \\dfrac{\\text{Highest\\_High} - \\text{Current\\_Close}}{\\text{Highest\\_High} - \\text{Lowest\\_Low}} \\times -100\n     \\]\n\n5. **Verification:**  \n   - The given high, low, and closing prices should match in length.\n   - Extract the correct range of indices for the 14-day period.\n   - Calculate to 2 decimal places as required.\n\nNow let's implement the solution in Python:\n\n```python\ndef solution():\n    # Define variables name and value\n    high_prices = [120, 122, 121, 119, 123, 125, 126, 127, 126, 124, 123, 122, 121, 120, 119, 118, 120, 121, 122, 123]\n    low_prices = [115, 116, 117, 115, 118, 119, 120, 121, 122, 120, 119, 118, 116, 115, 114, 113, 114, 115, 116, 118]\n    closing_prices = [117, 118, 119, 117, 120, 123, 124, 122, 123, 121, 120, 119, 118, 117, 116, 115, 118, 120, 121, 122]\n    period = 14\n    \n    # Extract the 14-day period leading up to and including the 20th day\n    start_index = len(high_prices) - period\n    end_index = len(high_prices)  # this is exclusive, so it correctly ends at the 20th day\n    recent_highs = high_prices[start_index:end_index]\n    recent_lows = low_prices[start_index:end_index]\n    recent_closes = closing_prices[start_index:end_index]\n    \n    # Calculate the necessary values for the Williams %R on the 20th day\n    highest_high = max(recent_highs)\n    lowest_low = min(recent_lows)\n    current_close = recent_closes[-1]  # the closing price on the 20th day\n    \n    williams_r = ((highest_high - current_close) / (highest_high - lowest_low)) * -100\n    \n    # Return the Williams %R value rounded to two decimal places\n    return round(williams_r, 2)\n```"
        ],
        "retrieval_query": "What is the Williams %R value for stock ABC on the 20th day, using the 14-day period? Answer as a percentage to two decimal places.",
        "useful_functions": [
            "def calculate_williams_r(high_prices: list, low_prices: list, closing_prices: list, period: int = 14) -> list:\n    \"\"\"\n    Calculate the Williams %R for a given set of high, low, and closing prices.\n\n    This function computes the Williams %R, a momentum oscillator that \n    measures overbought and oversold conditions in the market. It is used \n    to identify potential reversal points by comparing the current closing \n    price to the high-low range over a specified period.\n\n    Args:\n        high_prices (list): A list of high prices for each period.\n        low_prices (list): A list of low prices for each period.\n        closing_prices (list): A list of closing prices for each period.\n        period (int): The number of periods to include in the calculation \n                      (default is 14).\n\n    Returns:\n        williams_r_values (list): A list of calculated Williams %R values \n                                  corresponding to each period.\n\n    Notes:\n        - Applicability: Suitable for technical analysis in financial markets \n          to identify overbought or oversold conditions.\n        - Constraints: The lists high_prices, low_prices, and closing_prices must \n          be of the same length and length should be greater than or equal to `period`.\n        - Considerations: Williams %R is particularly effective in rangebound markets \n          but may produce false signals in trending markets. It is often \n          advisable to use it alongside other indicators for confirmation.\n    \"\"\"\n    if not (len(high_prices) == len(low_prices) == len(closing_prices)):\n        raise ValueError(\"All input lists must have the same length.\")\n    if len(high_prices) < period:\n        raise ValueError(\"Input lists must be longer than the specified period.\")\n    \n    williams_r_values = []\n    for i in range(len(closing_prices) - period + 1):\n        highest_high = max(high_prices[i:i + period])\n        lowest_low = min(low_prices[i:i + period])\n        current_close = closing_prices[i + period - 1]\n        \n        williams_r = ((highest_high - current_close) / (highest_high - lowest_low)) * -100\n        williams_r_values.append(williams_r)\n    \n    return williams_r_values"
        ],
        "usage": {
            "completion_tokens": 969,
            "prompt_tokens": 1120,
            "total_tokens": 2089,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "Xerox Technologies (XETECH) is a well-established firm in the gaming industry of the United States. Just recently, XETECH upgraded its gaming device and increased its price to $250. The production of this device cost the firm $65/unit in variable costs. The total fixed operating costs equaled $10,000,000. If the firm changes its output from 200,000 units to 220,000 units, what will operating income change by? Answer as a percentage to two decimal places.",
        "context": "",
        "statistics": {
            "number_statistics": {
                "question_numbers": 5,
                "context_numbers": 0,
                "total_numbers": 5
            },
            "operator_statistics": {
                "operators": {
                    "+": 0,
                    "-": 5,
                    "*": 5,
                    "/": 1,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 11
            },
            "code_statistics": {
                "lines": 12,
                "parentheses": 8
            }
        },
        "difficulty": 5.170483995038152,
        "ground_truth": 13.7,
        "source": "FinCode-test-0",
        "python_solution": "price = 250\nvariable_cost = 65\nold_output = 200000\nnew_output = 220000\nold_total_cost = variable_cost * old_output\nnew_total_cost = variable_cost * new_output\nfixed_cost = 10000000\nold_operating_income = (price * old_output) - old_total_cost - fixed_cost\nnew_operating_income = (price * new_output) - new_total_cost - fixed_cost\nchange_in_operating_income = new_operating_income - old_operating_income\npercent_change = 100.0 * (change_in_operating_income / old_operating_income)\nround(percent_change, 2)",
        "question_id": "test-2170",
        "level": "hard",
        "output": [
            "### Step-by-step Reasoning Using Emphasizing Constraints (EC):\n\n#### Step 1: Problem Breakdown\nWe are asked to calculate the change in operating income as a percentage when the output increases from **200,000 units to 220,000 units.**\n\n#### Step 2: Operating Income Formula\nOperating income can be calculated using:\n\\[\n\\text{Operating Income} = (\\text{Price per Unit} - \\text{Variable Cost per Unit}) \\times \\text{Quantity Produced} - \\text{Fixed Costs}.\n\\]\n\n#### Step 3: Change in Operating Income\nThe change in operating income is simply the difference in operating income between the two production levels (220,000 units and 200,000 units).\n\n#### Step 4: Expressing the Change as a Percentage\nThe percentage change in operating income is given by:\n\\[\n\\text{Percentage Change} = \\left(\\frac{\\Delta \\text{Operating Income}}{\\text{Initial Operating Income}}\\right) \\times 100.\n\\]\nWhere:\n\\[\n\\Delta \\text{Operating Income} = \\text{New Operating Income} - \\text{Initial Operating Income}.\n\\]\n\n#### Step 5: Constraints\n- The price per unit is $250.\n- The variable cost per unit is $65.\n- Fixed costs are $10,000,000.\n- Initial production is 200,000 units.\n- New production is 220,000 units.\n- Final answer should be expressed as a percentage and rounded to two decimal places.\n\nWith this understanding, let us now construct the Python program.\n\n```python\ndef solution():\n    # Define variables for the parameters\n    price_per_unit = 250\n    variable_cost_per_unit = 65\n    fixed_costs = 10_000_000\n    initial_quantity = 200_000\n    new_quantity = 220_000\n    \n    # Calculate contribution margin per unit\n    contribution_margin_per_unit = price_per_unit - variable_cost_per_unit\n    \n    # Calculate initial and new operating income\n    initial_operating_income = (contribution_margin_per_unit * initial_quantity) - fixed_costs\n    new_operating_income = (contribution_margin_per_unit * new_quantity) - fixed_costs\n    \n    # Calculate the change in operating income\n    change_in_operating_income = new_operating_income - initial_operating_income\n    \n    # Calculate the percentage change\n    percentage_change = (change_in_operating_income / initial_operating_income) * 100\n    \n    # Return the percentage change rounded to two decimal places\n    return round(percentage_change, 2)\n\n```"
        ],
        "retrieval_query": "Xerox Technologies (XETECH) is a well-established firm in the gaming industry of the United States. Just recently, XETECH upgraded its gaming device and increased its price to $250. The production of this device cost the firm $65/unit in variable costs. The total fixed operating costs equaled $10,000,000. If the firm changes its output from 200,000 units to 220,000 units, what will operating income change by? Answer as a percentage to two decimal places.",
        "useful_functions": [],
        "usage": {
            "completion_tokens": 537,
            "prompt_tokens": 419,
            "total_tokens": 956,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-734",
        "article_title": "Bond Discount",
        "function": "def calculate_present_value_of_bond(par_value: float, coupon_rate: float, market_rate: float, years_to_maturity: int, payments_per_year: int = 2) -> float:\n    \"\"\"\n    Calculate the present value of a bond.\n\n    This function computes the present value of a bond by considering both\n    the present value of the future coupon payments and the present value of\n    the principal repayment at maturity. It assumes that coupon payments are\n    made periodically.\n\n    Args:\n        par_value (float): The face value or principal amount of the bond.\n        coupon_rate (float): The annual coupon rate as a decimal. \n        market_rate (float): The annual market interest rate as a decimal.\n        years_to_maturity (int): The number of years until the bond matures.\n        payments_per_year (int): The number of coupon payments per year. Defaults to 2 (semi-annual).\n\n    Returns:\n        market_price (float): The present value of the bond, representing its market price.\n\n    Notes:\n        - This function assumes that the coupon payment rate remains constant over the bond's term.\n        - The market rate is expressed annually and adjusted per period within the function.\n        - This calculation does not account for taxes or fees related to bond purchase.\n    \"\"\"\n    period_rate = market_rate / payments_per_year\n    coupon_payment = (coupon_rate / payments_per_year) * par_value\n    total_payments = years_to_maturity * payments_per_year\n\n    pv_coupons = sum(coupon_payment / ((1 + period_rate) ** (t + 1)) for t in range(total_payments))\n    pv_principal = par_value / ((1 + period_rate) ** total_payments)\n    \n    market_price = pv_coupons + pv_principal\n    \n    return market_price",
        "statistics": {
            "number_statistics": {
                "args_numbers": 5,
                "question_numbers": 0,
                "context_numbers": 4,
                "total_numbers": 4
            },
            "operator_statistics": {
                "operators": {
                    "+": 4,
                    "-": 0,
                    "*": 2,
                    "/": 4,
                    "%": 0,
                    "**": 2
                },
                "total_operators": 12
            },
            "code_statistics": {
                "lines": 7,
                "parentheses": 16
            }
        },
        "difficulty": 5.19295685089021,
        "context": "An investment firm is evaluating a government bond for potential purchase. The bond has a face value of $100,000 and offers an annual coupon rate of 5%. The firm estimates the current market interest rate relevant for bonds with similar risk and maturity profiles to be 4%. The bond matures in 10 years, and coupon payments are made semi-annually. The firm is interested in determining the present value of this bond to inform their investment decision.",
        "question": "What is the present value of the bond, rounded to the nearest dollar?",
        "python_solution": "def solution():\n    # Define variables\n    par_value = 100000  # Face value of the bond\n    coupon_rate = 0.05  # Annual coupon rate\n    market_rate = 0.04  # Annual market interest rate\n    years_to_maturity = 10  # Number of years to maturity\n    payments_per_year = 2  # Semi-annual payments\n\n    # Calculate the periodic rate and other payment attributes\n    period_rate = market_rate / payments_per_year\n    coupon_payment = (coupon_rate / payments_per_year) * par_value\n    total_payments = years_to_maturity * payments_per_year\n\n    # Calculate the present value of coupons\n    pv_coupons = sum(coupon_payment / ((1 + period_rate) ** (t + 1)) for t in range(total_payments))\n\n    # Calculate the present value of the principal\n    pv_principal = par_value / ((1 + period_rate) ** total_payments)\n\n    # Market price is the sum of discounted coupons and principal\n    market_price = pv_coupons + pv_principal\n\n    # Round the result to the nearest dollar\n    return round(market_price)",
        "ground_truth": 108176,
        "source": "FinanceReasoning-test-64",
        "question_id": "test-2171",
        "level": "hard",
        "output": [
            "To compute the present value of the bond, let's work through the problem step-by-step using the \"Emphasizing Constraints (EC)\" method to ensure all constraints and details are adhered to.\n\n---\n\n**Step 1: Understand the Constraints and Inputs**\n\n1. Face value (par value) of the bond: **$100,000**.\n2. Coupon rate: **5% annually**.\n3. Market interest rate (required rate of return): **4% annually**.\n4. Maturity: **10 years**.\n5. Semiannual coupon payments: Coupons are paid **twice a year**.\n\n**Derived Parameters:**\n- **Coupon payment per period** = (`coupon_rate` x `par_value`) \u00f7 `periods_per_year`.\n- There are **20 coupon payments**, because the bond matures in 10 years and payments are made semiannually.\n- The **discount rate per period** = (`required_rate` \u00f7 `periods_per_year`) since the market interest rate is annualized.\n- **Present value formula:** We will compute the present value of both the coupon payments and the face value discounted to the present.\n\n---\n\n**Step 2: Apply Formula**\n1. **Periodic Coupon Payment (Period Coupon):**\n   - Semiannual coupon payment = (5% \u00d7 100,000) / 2 = $2,500.\n\n2. **Total Periods:**\n   - Total periods = (10 years \u00d7 2 semiannual periods) = 20 periods.\n\n3. **Rate per Period:**\n   - Required rate per period = (4% \u00f7 2) = 2% or 0.02 as a decimal.\n\n4. **Present Value of Coupons:** For bonds, the coupon payments are discounted for all periods using the formula:  \n   \\[\n   PV_coupons = C \\times \\left(1 - \\frac{1}{(1 + r)^n}\\right) / r\n   \\]\n   where:\n   - \\( C \\) = coupon payment,\n   - \\( r \\) = rate per period (0.02),  \n   - \\( n \\) = total periods.\n\n5. **Present Value of Face Value:** The repayment of the face value occurs at the end and is discounted as:\n   \\[\n   PV_{face} = \\frac{FV}{(1 + r)^n}\n   \\]\n\n6. **Total Present Value:** The bond's price = \\( PV_{coupons} + PV_{face} \\).\n\n7. Ensure the final result is **rounded to the nearest dollar**.\n\n---\n\n**Step 3: Implement in Python**\n\nBelow is the Python program to calculate and return the bond price.\n\n```python\ndef solution():\n    # Define inputs and constants\n    par_value = 100000  # Face value of the bond\n    coupon_rate = 5  # Annual coupon rate in percentage\n    required_rate = 4  # Annual required return in percentage\n    years_to_maturity = 10  # Years until maturity\n    periods_per_year = 2  # Semiannual payments\n    \n    # Convert rates to per period values\n    rate_per_period = (required_rate / 100) / periods_per_year  # Discount rate per period\n    period_coupon = (coupon_rate / 100) * par_value / periods_per_year  # Coupon payment per period\n    total_periods = periods_per_year * years_to_maturity  # Total number of periods\n    \n    # Calculate Present Value of Coupons\n    pv_coupons = sum(period_coupon / ((1 + rate_per_period) ** i) for i in range(1, total_periods + 1))\n    \n    # Calculate Present Value of Face Value\n    pv_face_value = par_value / ((1 + rate_per_period) ** total_periods)\n    \n    # Total bond price\n    bond_price = pv_coupons + pv_face_value\n    \n    # Return rounded result\n    return round(bond_price)\n```"
        ],
        "retrieval_query": "What is the present value of the bond, rounded to the nearest dollar?",
        "useful_functions": [
            "def calculate_bond_price(coupon_rate: float, periods_per_year: int, years_to_maturity: int, \n                         required_rate: float, par_value: float) -> float:\n    \"\"\"\n    Calculate the price of a bond given its parameters.\n\n    This function calculates the present value of a bond's future cash flows, which include\n    periodic coupon payments and the repayment of the par value at maturity. The present value is\n    obtained by discounting these cash flows at the bond's required rate of return.\n\n    Args:\n        coupon_rate (float): The annual coupon rate of the bond as a percentage (e.g., 3 for 3%).\n        periods_per_year (int): Number of coupon payments per year (e.g., 2 for semiannual).\n        years_to_maturity (int): The number of years until the bond matures.\n        required_rate (float): The annual required rate of return as a percentage (e.g., 5 for 5%).\n        par_value (float): The par value of the bond.\n\n    Returns:\n        bond_price (float): The calculated price of the bond.\n\n    Notes:\n        - Applicability: Use this function to calculate the price of fixed-rate bonds with \n          periodic coupon payments.\n        - Constraints: \n          - `coupon_rate`, `required_rate` should be input as percentages (e.g., 5 for 5%).\n          - `periods_per_year` should reflect how many times coupon payments occur in a year.\n        - Considerations: Make sure interest rates and periods are in consistent units (e.g., \n          semiannual periods require halving the annual rates).\n    \"\"\"\n    # Convert annual rates to per period rates\n    period_rate = (required_rate / 100) / periods_per_year\n    period_coupon = (coupon_rate / 100) * par_value / periods_per_year\n    total_periods = periods_per_year * years_to_maturity\n    \n    # Calculate the present value of coupons\n    pv_coupons = sum(period_coupon / ((1 + period_rate) ** i) for i in range(1, total_periods + 1))\n    \n    # Calculate the present value of the par value\n    pv_par_value = par_value / ((1 + period_rate) ** total_periods)\n    \n    # Calculate total bond price\n    bond_price = pv_coupons + pv_par_value\n    \n    return round(bond_price, 3)",
            "def calculate_annual_interest_expense(total_interest_expense: float, total_years: int) -> int:\n    \"\"\"\n    Calculate the annual interest expense using the straight-line method.\n\n    This function divides the total interest expense incurred over the entire\n    duration of a bond or similar financial instrument evenly across each\n    year using the straight-line method. The annual interest expense is rounded\n    to the nearest dollar.\n\n    Args:\n        total_interest_expense (float): The total interest expense over the\n                                        full duration of the bond or instrument.\n        total_years (int): The total number of years over which the expense is\n                           allocated.\n\n    Returns:\n        annual_interest_expense (int): The annual interest expense, rounded to\n                                       the nearest dollar.\n\n    Notes:\n        - This function assumes a straight-line allocation of interest over the\n          specified number of years.\n        - The coupon rate or interest rate is not needed when the total interest\n          expense is given.\n        - Ensure total_years is a positive integer to prevent division errors.\n    \"\"\"\n    if total_years <= 0:\n        raise ValueError(\"Total years must be a positive integer.\")\n\n    annual_interest_expense = total_interest_expense / total_years\n    return round(annual_interest_expense)",
            "def calculate_future_value(principal: float, annual_rate: float, years: int, compounding_periods_per_year: int) -> float:\n    \"\"\"\n    Calculate the future value of an investment with compound interest.\n\n    This function computes the future value (FV) of an initial investment \n    (principal) over a specified number of years, given an annual interest \n    rate and the number of compounding periods per year.\n\n    Args:\n        principal (float): The initial amount of money invested.\n        annual_rate (float): The annual interest rate expressed as a decimal \n                             (e.g., 7% should be 0.07).\n        years (int): The number of years the money is invested for.\n        compounding_periods_per_year (int): The number of times that interest \n                                            is compounded per year.\n\n    Returns:\n        future_value (float): The future value of the investment, rounded \n                              to one decimal place.\n\n    Notes:\n        - Applicability: This function assumes compound interest with a fixed \n          rate and compounding frequency.\n        - Constraints: Requires compounding_periods_per_year > 0.\n        - Considerations: The function returns the future value rounded to one \n          decimal place. Be mindful of floating-point arithmetic limitations.\n    \"\"\"\n    if compounding_periods_per_year <= 0:\n        raise ValueError(\"Compounding periods per year must be greater than 0.\")\n\n    growth_factor = (1 + annual_rate / compounding_periods_per_year) ** (compounding_periods_per_year * years)\n    future_value = principal * growth_factor\n    \n    return round(future_value, 1)"
        ],
        "usage": {
            "completion_tokens": 822,
            "prompt_tokens": 1547,
            "total_tokens": 2369,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-1296",
        "article_title": "Positive Correlation",
        "function": "def calculate_beta(stock_returns: list, market_returns: list) -> float:\n    \"\"\"\n    Calculate the beta of a stock, indicating its volatility relative to the market.\n\n    Beta is a measure of a stock's volatility in relation to the overall market.\n    A beta of 1 indicates that the stock's price tends to move with the market.\n    A beta greater than 1 indicates greater volatility than the market, while a beta less\n    than 1 indicates less volatility.\n\n    Args:\n        stock_returns (list): A list of periodic return rates for the stock.\n        market_returns (list): A list of periodic return rates for the market benchmark,\n                               such as the S&P 500. Must be of the same length as stock_returns.\n\n    Returns:\n        beta (float): The beta of the stock relative to the market.\n\n    Notes:\n        - Applicability: Used in assessing the risk and expected return of a stock or portfolio.\n        - Constraints: The input lists must represent returns for the same periods and must have\n          the same length.\n        - Considerations: Beta reflects past volatility and may not predict future volatility.\n          Values could be affected by outliers in the historical data.\n    \"\"\"\n    if len(stock_returns) != len(market_returns):\n        raise ValueError(\"Both input lists must have the same number of elements.\")\n\n    market_variance = sum((r - (sum(market_returns) / len(market_returns))) ** 2 for r in market_returns)\n    covariance = sum((s - (sum(stock_returns) / len(stock_returns))) * \n                     (m - (sum(market_returns) / len(market_returns))) for s, m in zip(stock_returns, market_returns))\n\n    if market_variance == 0:\n        raise ValueError(\"Market variance is zero, cannot calculate beta.\")\n    \n    beta = covariance / market_variance\n    \n    return beta",
        "statistics": {
            "number_statistics": {
                "args_numbers": 2,
                "question_numbers": 1,
                "context_numbers": 14,
                "total_numbers": 15
            },
            "operator_statistics": {
                "operators": {
                    "+": 0,
                    "-": 3,
                    "*": 1,
                    "/": 4,
                    "%": 0,
                    "**": 1
                },
                "total_operators": 9
            },
            "code_statistics": {
                "lines": 5,
                "parentheses": 30
            }
        },
        "difficulty": 5.19295685089021,
        "context": "In assessing the volatility of TechCo's stock relative to the S&P 500 market index, you have collected data for the past 5 months. The monthly return rates for TechCo's stock and the S&P 500 index are listed below:\n\nTechCo's stock returns: [0.05, -0.02, 0.04, 0.03, -0.01]\n\nS&P 500 index returns: [0.04, -0.01, 0.03, 0.02, 0.00]\n\nYou aim to calculate TechCo's stock beta to understand its price movement tendency relative to the market.",
        "question": "What is the beta of TechCo's stock relative to the S&P 500 index? Answer to two decimal places.",
        "python_solution": "def solution():\n    # Define the returns for both TechCo's stock and the market (S&P 500)\n    stock_returns = [0.05, -0.02, 0.04, 0.03, -0.01]\n    market_returns = [0.04, -0.01, 0.03, 0.02, 0.00]\n    \n    # Calculate the average returns\n    average_stock_return = sum(stock_returns) / len(stock_returns)\n    average_market_return = sum(market_returns) / len(market_returns)\n    \n    # Calculate the market variance\n    market_variance = sum((r - average_market_return) ** 2 for r in market_returns)\n    \n    # Calculate the covariance between TechCo's stock returns and market returns\n    covariance = sum((s - average_stock_return) * \n                     (m - average_market_return) for s, m in zip(stock_returns, market_returns))\n    \n    # Calculate the beta of TechCo's stock\n    if market_variance == 0:\n        raise ValueError(\"Market variance is zero, cannot calculate beta.\")\n    \n    beta = covariance / market_variance\n    \n    # Return the final answer, rounded to two decimal places\n    return round(beta, 2)\n\n# Call the solution function\nsolution()",
        "ground_truth": 1.49,
        "source": "FinanceReasoning-test-112",
        "question_id": "test-2172",
        "level": "hard",
        "output": [
            "To determine the beta of TechCo's stock relative to the S&P 500 index, I will carefully think through the problem step by step using the required advanced reasoning technique:\n\n---\n\n### Step-by-Step Thoughts Using **Emphasizing Constraints (EC):**\n\n1. **Objective Explanation**:\n   - Beta measures the tendency of a stock's returns to respond to swings in the broader market. It is a key metric in finance to assess risk.\n   - Beta is calculated using the formula:\n     \\[\n     \\beta = \\frac{\\text{Covariance(Stock Returns, Market Returns)}}{\\text{Variance(Market Returns)}}\n     \\]\n2. **Constraints**:\n   - Monthly returns for TechCo's stock and S&P 500 must be used to calculate beta based on the given formulas.\n   - The answer must be rounded to two decimal places.\n3. **Details Needed**:\n   - We need to compute:\n     a. Covariance of TechCo's returns and the S&P 500 index returns,\n     b. Variance of the S&P 500 index returns.\n   - The covariance formula is:\n     \\[\n     \\text{Cov}(X, Y) = \\frac{\\sum_{i=1}^{n} (X_i - \\bar{X})(Y_i - \\bar{Y})}{n}\n     \\]\n     where \\(X\\) is TechCo's returns, \\(Y\\) is S&P 500 returns, \\(n\\) is the number of months, and \\(\\bar{X}\\) and \\(\\bar{Y}\\) are their respective means.\n   - The variance formula is:\n     \\[\n     \\text{Var}(X) = \\frac{\\sum_{i=1}^{n} (X_i - \\bar{X})^2}{n}\n     \\]\n4. **Methodology**:\n   - Calculate the mean of TechCo's returns (\\(\\bar{X}\\)) and the mean of S&P 500 returns (\\(\\bar{Y}\\)).\n   - Calculate covariance by summing the product of deviations of each monthly return from the means, then dividing by the number of data points.\n   - Calculate variance of the S&P 500 returns (sum of squared deviations from the mean divided by the number of data points).\n   - Divide covariance by variance to get beta.\n5. **Accuracy**:\n   - Perform final rounding to 2 decimal places.\n   - Ensure all calculations are correct and respect constraints.\n\n---\n\nNow, I will provide a Python program that implements these steps and returns the beta of TechCo's stock.\n\n```python\ndef solution():\n    # Define variables: returns for TechCo's stock and the S&P 500 index\n    techco_returns = [0.05, -0.02, 0.04, 0.03, -0.01]\n    sp500_returns = [0.04, -0.01, 0.03, 0.02, 0.00]\n    \n    # Calculate means\n    mean_techco = sum(techco_returns) / len(techco_returns)\n    mean_sp500 = sum(sp500_returns) / len(sp500_returns)\n    \n    # Calculate covariance (TechCo's returns and S&P 500)\n    covariance = sum((techco_returns[i] - mean_techco) * (sp500_returns[i] - mean_sp500) for i in range(len(techco_returns))) / len(techco_returns)\n    \n    # Calculate variance (S&P 500 returns)\n    variance_sp500 = sum((sp500_returns[i] - mean_sp500) ** 2 for i in range(len(sp500_returns))) / len(sp500_returns)\n    \n    # Calculate beta\n    beta = covariance / variance_sp500\n    \n    # Return the result rounded to 2 decimal places\n    return round(beta, 2)\n\n```"
        ],
        "retrieval_query": "What is the beta of TechCo's stock relative to the S&P 500 index? Answer to two decimal places.",
        "useful_functions": [],
        "usage": {
            "completion_tokens": 805,
            "prompt_tokens": 482,
            "total_tokens": 1287,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "Given the 2017 and 2018 financial reports provided by the firm, how does Jacques assess the Free Cash Flow to Equity (FCFE) of PZ Inc. for 2018, measured in millions? Answer to a single decimal place.",
        "python_solution": "def solution():\n    NI = 875 \n    NCC = 400 \n    FCInv = 750 \n    WCInv = (800 - 750) + (850 - 720) - (400 - 300) - (120 - 90) \n    Net_borrowing = (550 - 500) + (1500 - 1400) \n\n    FCFE = NI + NCC - FCInv - WCInv + Net_borrowing\n    return FCFE",
        "ground_truth": 625.0,
        "topic": "Asset Classes & Derivatives",
        "statistics": {
            "number_statistics": {
                "args_numbers": 1,
                "question_numbers": 0,
                "context_numbers": 18,
                "total_numbers": 18
            },
            "operator_statistics": {
                "operators": {
                    "+": 4,
                    "-": 10,
                    "*": 0,
                    "/": 0,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 14
            },
            "code_statistics": {
                "lines": 7,
                "parentheses": 12
            }
        },
        "difficulty": 5.204006687076795,
        "source": "FinanceMath-validation-110",
        "context": "['\\n|   |   | 2018 |   | 2017 |\\n|---|---|------|---|------|\\n|   |   |      |   |      |\\n| Assets  |   |      |   |      |\\n| Current assets |   |      |   |      |\\n| Accounts receivable |   | 800  |   | 750  |\\n| Inventories |   | 850  |   | 720  |\\n| Gross fixed assets |   | 5000 |   | 4250 |\\n| Accounts payable |   | $400  |   | $300 |\\n| Accrued taxes and expenses  |  | 120  |   | 90  |\\n| Notes payable  |  | 550  |   | 500  |\\n| Long-term debt  |  | 1,500  |   | 1,400  |\\n| Income Statement for the Year Ended 31 December 2018 |   |      |   |      |\\n| EBITDA  |  |    |   | 2000 |\\n| Depreciation expense  |   |    |   | 400 |\\n| EBIT  |  |    |   | 1600 |\\n| Interest expense  |  |    |   | 350 |\\n| Pretax income  |  |    |   | 1250 |\\n| Income tax (at 30 percent)  |  |    |   | 375 |\\n| Net income  |   |    |   | $875 |\\n']",
        "question_id": "test-2173",
        "level": "hard",
        "output": [
            "To solve this problem, let's go through the steps meticulously:\n\n1. **Understand the Data**:\n   - The financial data provided covers two years: 2017 and 2018.\n   - We are asked to calculate the Free Cash Flow to Equity (FCFE) for the year 2018.\n\n2. **Select the Right Formula**:\n   - From the reference, the appropriate FCFE formula for calculations is:\n     ```python\n     fcfe = net_income + depreciation - capex - change_in_working_capital + net_borrowing\n     ```\n   - Here:\n     - `net_income` is provided in the 2018 Income Statement.\n     - `depreciation` is given in the 2018 Income Statement.\n     - `capex` is calculated as the change in gross fixed assets between 2017 and 2018.\n     - `change_in_working_capital` is the change in current assets minus the change in current liabilities (both are derived from the balance sheets for 2017 and 2018). Current liabilities consist of accounts payable and accrued taxes and expenses.\n     - `net_borrowing` equals the change in long-term debt plus the change in notes payable.\n\n3. **Constraints and Assumptions (EC)**:\n   - All financial values are in millions.\n   - Calculate FCFE for the year 2018 with single decimal place accuracy.\n\n4. **Step-by-Step Calculation**:\n   - `capex = gross_fixed_assets_2018 - gross_fixed_assets_2017`\n   - `change_in_working_capital = (current_assets_2018 - current_assets_2017) - (current_liabilities_2018 - current_liabilities_2017)`\n     - `current_assets` includes accounts receivable and inventories.\n     - `current_liabilities` includes accounts payable and accrued taxes and expenses.\n   - `net_borrowing = (notes_payable_2018 - notes_payable_2017) + (long_term_debt_2018 - long_term_debt_2017)`\n   - Calculate FCFE using the formula.\n\nNow, let's design the Python program to compute FCFE.\n\n```python\ndef solution():\n    # Define variables for calculations\n    net_income = 875  # Net income for 2018 in millions\n    depreciation = 400  # Depreciation expense for 2018 in millions\n    \n    # Gross fixed assets (in millions)\n    gross_fixed_assets_2018 = 5000\n    gross_fixed_assets_2017 = 4250\n    capex = gross_fixed_assets_2018 - gross_fixed_assets_2017  # Capital Expenditures\n    \n    # Current assets (in millions)\n    accounts_receivable_2018 = 800\n    accounts_receivable_2017 = 750\n    inventories_2018 = 850\n    inventories_2017 = 720\n    current_assets_2018 = accounts_receivable_2018 + inventories_2018\n    current_assets_2017 = accounts_receivable_2017 + inventories_2017\n    \n    # Current liabilities (in millions)\n    accounts_payable_2018 = 400\n    accounts_payable_2017 = 300\n    accrued_taxes_expenses_2018 = 120\n    accrued_taxes_expenses_2017 = 90\n    current_liabilities_2018 = accounts_payable_2018 + accrued_taxes_expenses_2018\n    current_liabilities_2017 = accounts_payable_2017 + accrued_taxes_expenses_2017\n    \n    # Working capital investment\n    change_in_working_capital = (current_assets_2018 - current_assets_2017) - (current_liabilities_2018 - current_liabilities_2017)\n    \n    # Net borrowing (in millions)\n    notes_payable_2018 = 550\n    notes_payable_2017 = 500\n    long_term_debt_2018 = 1500\n    long_term_debt_2017 = 1400\n    net_borrowing = (notes_payable_2018 - notes_payable_2017) + (long_term_debt_2018 - long_term_debt_2017)\n    \n    # Calculate FCFE\n    fcfe = net_income + depreciation - capex - change_in_working_capital + net_borrowing\n    \n    # Return the result rounded to a single decimal place\n    return round(fcfe, 1)\n```"
        ],
        "retrieval_query": "Given the 2017 and 2018 financial reports provided by the firm, how does Jacques assess the Free Cash Flow to Equity (FCFE) of PZ Inc. for 2018, measured in millions? Answer to a single decimal place.",
        "useful_functions": [
            "def calculate_fcfe(net_income: float, non_cash_charges: float, \n                   gross_fixed_assets_end: float, gross_fixed_assets_start: float, \n                   total_current_assets_end: float, total_current_assets_start: float,\n                   total_current_liabilities_end: float, total_current_liabilities_start: float,\n                   notes_payable_end: float, notes_payable_start: float,\n                   long_term_debt_end: float, long_term_debt_start: float) -> float:\n    \"\"\"\n    Calculate the Free Cash Flow to Equity (FCFE).\n\n    This function computes the FCFE, which is a measure of the cash available to the company's equity holders after all expenses, reinvestment, and debt repayment. It is crucial for valuation models based on free cash flows to equity.\n\n    Args:\n        net_income (float): Net income available to equity holders for the period.\n        non_cash_charges (float): Non-cash charges such as depreciation and amortization.\n        gross_fixed_assets_end (float): Gross fixed assets at the end of the period.\n        gross_fixed_assets_start (float): Gross fixed assets at the beginning of the period.\n        total_current_assets_end (float): Total current assets at the end of the period.\n        total_current_assets_start (float): Total current assets at the beginning of the period.\n        total_current_liabilities_end (float): Total current liabilities at the end of the period.\n        total_current_liabilities_start (float): Total current liabilities at the beginning of the period.\n        notes_payable_end (float): Notes payable at the end of the period.\n        notes_payable_start (float): Notes payable at the beginning of the period.\n        long_term_debt_end (float): Long-term debt at the end of the period.\n        long_term_debt_start (float): Long-term debt at the beginning of the period.\n\n    Returns:\n        fcfe (float): The Free Cash Flow to Equity.\n\n    Notes:\n        - Applicability: Useful for equity valuation models and performance analysis.\n        - Constraints: Requires accurate financial data; assumptions about net borrowing.\n        - Considerations: Assumes all given data are in the same currency and on a comparable accounting basis.\n    \"\"\"\n    fc_inv = gross_fixed_assets_end - gross_fixed_assets_start\n    wc_inv = (total_current_assets_end - total_current_assets_start) - (total_current_liabilities_end - total_current_liabilities_start)\n    net_borrowing = (notes_payable_end - notes_payable_start) + (long_term_debt_end - long_term_debt_start)\n    \n    fcfe = net_income + non_cash_charges - fc_inv - wc_inv + net_borrowing\n    \n    return fcfe",
            "def calculate_fcfe(net_income: float, depreciation: float, capex: float, \n                   change_in_working_capital: float, net_borrowing: float) -> float:\n    \"\"\"\n    Calculate the Free Cash Flow to Equity (FCFE).\n\n    This function calculates the Free Cash Flow to Equity (FCFE) for a firm \n    based on its net income, non-cash charges (such as depreciation), \n    capital expenditures (CAPEX), changes in working capital, and net borrowing.\n\n    Args:\n        net_income (float): The net income reported on the income statement.\n        depreciation (float): The total depreciation expense, a non-cash charge.\n        capex (float): The capital expenditures, calculated as the change in gross fixed assets.\n        change_in_working_capital (float): The net change in working capital, calculated \n                                           as the change in current assets minus the change in current liabilities.\n        net_borrowing (float): The total new borrowing, calculated as changes in long-term debt \n                               and notes payable.\n\n    Returns:\n        fcfe (float): The Free Cash Flow to Equity, indicating the cash available to equity holders \n                      after accounting for operations, capital expenditures, and financing activities.\n\n    Notes:\n        - Applicability: This function is applicable for calculating FCFE when given proper \n          financial statement data for a specific period, typically annually.\n        - Constraints: Ensure that all inputs reflect the same period's financial data.\n        - Considerations: Be mindful of non-cash items and financing activities, as they can \n          significantly impact the FCFE calculation. Also, changes should be computed correctly \n          to reflect accurate balance sheet movements.\n    \"\"\"\n    fcfe = net_income + depreciation - capex - change_in_working_capital + net_borrowing\n    return fcfe"
        ],
        "usage": {
            "completion_tokens": 935,
            "prompt_tokens": 1659,
            "total_tokens": 2594,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "Imagine a portfolio that contains two components. The first component, Component X, makes up 25% of the portfolio and possesses a standard deviation of 17.9%. The second component, Component Y, makes up the rest of the portfolio at 75% and has a standard deviation of 6.2%. If the correlation between these two components is 0.5, what would the portfolio's standard deviation be (expressed as a percentage)? Answer to three decimal places.",
        "python_solution": "def solution():\n    import math\n    weight_X = 0.25\n    weight_Y = 0.75\n    standard_deviation_X = 0.179\n    standard_deviation_Y = 0.062\n    correlation_XY = 0.5\n\n    portfolio_variance = (weight_X**2 * standard_deviation_X**2) + (weight_Y**2 * standard_deviation_Y**2) + (2 * weight_X * weight_Y * correlation_XY * standard_deviation_X * standard_deviation_Y)\n    portfolio_standard_deviation = math.sqrt(portfolio_variance)\n\n    return portfolio_standard_deviation*100",
        "ground_truth": 7.903,
        "topic": "Portfolio Management & Strategy",
        "statistics": {
            "number_statistics": {
                "args_numbers": 6,
                "question_numbers": 5,
                "context_numbers": 0,
                "total_numbers": 5
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 0,
                    "*": 8,
                    "/": 0,
                    "%": 0,
                    "**": 4
                },
                "total_operators": 14
            },
            "code_statistics": {
                "lines": 9,
                "parentheses": 8
            }
        },
        "difficulty": 5.204006687076795,
        "source": "FinanceMath-validation-196",
        "context": "[]",
        "question_id": "test-2174",
        "level": "hard",
        "output": [
            "### Step-by-Step Reasoning:\n\n**1. Emphasizing Constraints (EC):**\n   - **Constraint 1:** The weights of the portfolio components must sum to 1. Therefore, Component X has a weight of 0.25, and Component Y has a weight of 0.75.\n   - **Constraint 2:** Standard deviations are provided in percentages (17.9% for X and 6.2% for Y) and should be converted to decimal form for calculation.\n   - **Constraint 3:** The correlation between the components is given as 0.5, which lies in the valid range of [-1, 1].\n   - **Constraint 4:** The portfolio standard deviation must be rounded to three decimal places and expressed as a percentage.\n   - **Constraint 5:** The formula for the portfolio variance with two assets is:\n     \\[\n     \\text{Portfolio Variance} = (w_X^2 \\cdot \\sigma_X^2) + (w_Y^2 \\cdot \\sigma_Y^2) + 2 \\cdot w_X \\cdot w_Y \\cdot \\sigma_X \\cdot \\sigma_Y \\cdot \\rho_{XY}\n     \\]\n     - \\(w_X, w_Y\\) = weights of components X and Y.\n     - \\(\\sigma_X, \\sigma_Y\\) = standard deviations of components X and Y.\n     - \\(\\rho_{XY}\\) = correlation between components X and Y.\n     - Portfolio standard deviation is the square root of the variance.\n\n**2. Steps for Calculation:**\n   1. Define the weights:\n      - \\(w_X = 0.25\\), \\(w_Y = 0.75\\).\n   2. Convert standard deviations to decimals:\n      - \\(\\sigma_X = 17.9\\% = 0.179\\), \\(\\sigma_Y = 6.2\\% = 0.062\\).\n   3. Use the given correlation:\n      - \\(\\rho_{XY} = 0.5\\).\n   4. Calculate the portfolio variance using the formula above.\n   5. Calculate the portfolio standard deviation by taking the square root of the variance.\n   6. Convert the portfolio standard deviation back to a percentage and round to three decimal places.\n\nNow, let\u2019s implement the solution in Python.\n\n```python\ndef solution():\n    # Define variables name and value\n    w_X = 0.25  # Weight of Component X\n    w_Y = 0.75  # Weight of Component Y\n    sigma_X = 17.9 / 100  # Standard deviation of Component X (in decimal form)\n    sigma_Y = 6.2 / 100   # Standard deviation of Component Y (in decimal form)\n    rho_XY = 0.5  # Correlation between X and Y\n\n    # Calculate portfolio variance\n    variance = (w_X**2 * sigma_X**2) + (w_Y**2 * sigma_Y**2) + (2 * w_X * w_Y * sigma_X * sigma_Y * rho_XY)\n    \n    # Calculate portfolio standard deviation\n    portfolio_std = variance ** 0.5\n\n    # Convert to percentage and round to three decimal places\n    portfolio_std_percentage = round(portfolio_std * 100, 3)\n\n    # Return the answer\n    return portfolio_std_percentage\n```"
        ],
        "retrieval_query": "Imagine a portfolio that contains two components. The first component, Component X, makes up 25% of the portfolio and possesses a standard deviation of 17.9%. The second component, Component Y, makes up the rest of the portfolio at 75% and has a standard deviation of 6.2%. If the correlation between these two components is 0.5, what would the portfolio's standard deviation be (expressed as a percentage)? Answer to three decimal places.",
        "useful_functions": [
            "def calculate_portfolio_standard_deviation(weights: list, std_deviations: list, cov_matrix: list) -> float:\n    \"\"\"\n    Calculate the standard deviation of a portfolio's returns.\n\n    This function computes the overall standard deviation (volatility) of a portfolio,\n    which is a measure of risk. It takes into account both the individual asset \n    standard deviations and the covariances between different assets.\n\n    Args:\n        weights (list): A list of the weights of the assets in the portfolio. \n                        The sum of weights should equal 1.\n        std_deviations (list): A list of standard deviations of the individual assets.\n        cov_matrix (list): A matrix (2D list) of covariances between the assets. \n                           The matrix must be square and symmetric.\n\n    Returns:\n        portfolio_std_dev (float): The standard deviation of the portfolio, \n                                   representing its risk.\n\n    Notes:\n        - Applicability: This function is used in financial analysis to assess the \n          risk of an investment portfolio.\n        - Constraints: The length of weights and std_deviations lists should be \n          equal to the number of assets. The covariance matrix should be of the same size.\n        - Considerations: Ensure that all inputs are properly scaled and in matching \n          units (e.g., all in percentage terms).\n    \"\"\"\n    if not (len(weights) == len(std_deviations) == len(cov_matrix)):\n        raise ValueError(\"Input lists must have the same length.\")\n\n    if sum(weights) != 1:\n        raise ValueError(\"Sum of weights must be equal to 1.\")\n\n    n = len(weights)\n    portfolio_variance = 0.0\n\n    for i in range(n):\n        for j in range(n):\n            portfolio_variance += weights[i] * weights[j] * (\n                (std_deviations[i] * std_deviations[j]) if i == j else cov_matrix[i][j]\n            )\n    \n    portfolio_std_dev = portfolio_variance ** 0.5\n    return portfolio_std_dev",
            "def calculate_portfolio_risk(weights: list, variances: list, correlations: list) -> float:\n    \"\"\"\n    Calculate the risk of a portfolio based on asset variances and correlations.\n\n    This function computes the overall risk (standard deviation) of a portfolio\n    using the variances of individual assets and their correlations. The risk is\n    calculated according to the principles of Modern Portfolio Theory (MPT).\n\n    Args:\n        weights (list): A list of weights representing the proportion of the total\n                        portfolio value that is invested in each asset.\n        variances (list): A list of variances for each asset in the portfolio.\n        correlations (list): A list of lists representing the correlation matrix\n                             of the assets. Each sublist should contain the correlation\n                             values for one asset with all other assets.\n\n    Returns:\n        portfolio_risk (float): The standard deviation of the portfolio, representing its risk.\n\n    Notes:\n        - Applicability: Relevant for forming a diversified portfolio with balanced risk and return.\n        - Constraints: The correlation matrix must be symmetric and the diagonal should contain ones.\n        - Considerations: Ensure that weights, variances, and correlation matrix dimensions match.\n    \"\"\"\n    num_assets = len(weights)\n    if len(variances) != num_assets or len(correlations) != num_assets or any(len(row) != num_assets for row in correlations):\n        raise ValueError(\"The dimensions of weights, variances, and correlations must be consistent.\")\n\n    portfolio_variance = 0.0\n    for i in range(num_assets):\n        for j in range(num_assets):\n            portfolio_variance += weights[i] * weights[j] * correlations[i][j] * (variances[i] ** 0.5) * (variances[j] ** 0.5)\n\n    portfolio_risk = portfolio_variance ** 0.5\n    \n    return portfolio_risk",
            "def calculate_portfolio_standard_deviation(weights: list, standard_deviations: list, correlation_matrix: list) -> float:\n    \"\"\"\n    Calculate the standard deviation of a two-asset investment portfolio.\n\n    This function computes the standard deviation of a portfolio consisting of\n    two assets given their respective weights, standard deviations, and the\n    correlation coefficient between them.\n\n    Args:\n        weights (list): A list containing the weights of two assets in the portfolio\n                        as decimal fractions [w_X, w_Y].\n        standard_deviations (list): A list of the standard deviations of these two\n                                    assets as decimal fractions [\u03c3_X, \u03c3_Y].\n        correlation_matrix (list): A list containing the correlation coefficient\n                                   between the two assets [\u03c1_XY].\n\n    Returns:\n        portfolio_standard_deviation (float): The portfolio's standard deviation as\n                                              a decimal fraction.\n\n    Notes:\n        - This function is applicable for a portfolio with exactly two assets.\n        - The weights should sum to 1, and both the weights and standard deviations\n          should be provided in decimal form, not percentages.\n        - The correlation coefficient should be in the range [-1, 1].\n        - The order of inputs in the lists should be consistent across weights,\n          standard deviations, and correlation_matrix.\n    \"\"\"\n    w_X, w_Y = weights\n    \u03c3_X, \u03c3_Y = standard_deviations\n    \u03c1_XY = correlation_matrix[0]\n\n    variance = (w_X ** 2) * (\u03c3_X ** 2) + (w_Y ** 2) * (\u03c3_Y ** 2) + \\\n               2 * w_X * w_Y * \u03c3_X * \u03c3_Y * \u03c1_XY\n\n    portfolio_standard_deviation = variance ** 0.5\n\n    return portfolio_standard_deviation"
        ],
        "usage": {
            "completion_tokens": 714,
            "prompt_tokens": 1630,
            "total_tokens": 2344,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "Based on Exhibit 1, what is the five-year spot rate for Steve, a bond trader at a financial institution (expressed as a percentage)? Keep in mind that par and spot rates are derived from annual-coupon sovereign bonds. Answer to three decimal places.",
        "python_solution": "def solution():\n    # given spot rates and swap rate\n    spot_rates = [0.025, 0.03, 0.035, 0.04]\n    swap_rate = 0.0437\n\n    # calculate the sum of discounted swap rate payments \n    sum_discounted_payments = sum([swap_rate / ((1 + rate) ** i) for i, rate in enumerate(spot_rates, start=1)])\n\n    # calculate the 5-year spot rate solving the formula above for S5\n    S5 = ((1 + swap_rate) / (1 - sum_discounted_payments))**(1/5) - 1\n\n    # return S5 in percentage\n    return S5 * 100",
        "ground_truth": 4.453,
        "topic": "Asset Classes & Derivatives",
        "statistics": {
            "number_statistics": {
                "args_numbers": 6,
                "question_numbers": 1,
                "context_numbers": 9,
                "total_numbers": 10
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 3,
                    "*": 1,
                    "/": 3,
                    "%": 0,
                    "**": 2
                },
                "total_operators": 11
            },
            "code_statistics": {
                "lines": 9,
                "parentheses": 16
            }
        },
        "difficulty": 5.231108616854587,
        "source": "FinanceMath-validation-22",
        "context": "['|Maturity   | Par Rate | Spot rate |\\n|---|---|---|\\n| One-Year  | 2.50%  | 2.50%  |\\n| Two-Year  | 2.99%  | 3.00%  |\\n| Three-Year  | 3.48%  | 3.50%  |\\n| Four-Year  | 3.95%  | 4.00%  |\\n| Five-Year  | 4.37%  |   |']",
        "question_id": "test-2175",
        "level": "hard",
        "output": [
            "To find the five-year spot rate, we need to compute it based on the provided bond pricing data. The spot rate computation for a multi-year bond assumes that the bond is priced such that its present value equals its par value (since they are annual-coupon sovereign bonds at par). Here's the step-by-step process:\n\n---\n\n### Step 1: Understand the Given Data\n- **Par rate** is the bond's coupon rate when issued at par value.\n- **Spot rate** is the yield on zero-coupon bonds for each maturity.\n- The challenge is to calculate the **unknown five-year spot rate** based on the given table and bond pricing. Answer should be given **to three decimal places**.\n\n### Step 2: Key Values from Problem\n- Maturity = 5 years.\n- Coupon rate (par rate for five years) = 4.37% (it implies annual coupon payments of 4.37% of par value).\n- Spot rates for one to four years are known:\n  - \\( r_1 = 2.50\\% \\)\n  - \\( r_2 = 3.00\\% \\)\n  - \\( r_3 = 3.50\\% \\)\n  - \\( r_4 = 4.00\\% \\)\n\n### Step 3: Formula for Bond Price\nFor a bond with annual coupon payments and a given par value \\( P \\), all cash flows (coupon payments and face value) are discounted using the respective spot rates:\n\\[\nP = \\frac{C}{(1 + r_1)} + \\frac{C}{(1 + r_2)^2} + \\frac{C}{(1 + r_3)^3} + \\frac{C}{(1 + r_4)^4} + \\frac{C + F}{(1 + r_5)^5}\n\\]\nWhere:\n- \\( C \\) = coupon payment = 4.37% of par (assume par = 100 for simplicity).\n- \\( F \\) = face value = 100.\n- \\( r_1, r_2, r_3, r_4, r_5 \\) = spot rates for years 1 to 5.\n- We are solving for \\( r_5 \\), the five-year spot rate.\n\n### Step 4: Rearrange to Find \\( r_5 \\)\nRearranging the formula:\n\\[\n\\frac{C + F}{(1 + r_5)^5} = P - \\left(\\frac{C}{(1 + r_1)} + \\frac{C}{(1 + r_2)^2} + \\frac{C}{(1 + r_3)^3} + \\frac{C}{(1 + r_4)^4}\\right)\n\\]\n\nFinally:\n\\[\nr_5 = \\left(\\frac{F + C}{\\text{Remaining Terms}}\\right)^{\\frac{1}{5}} - 1\n\\]\n\n### Step 5: Emphasizing Constraints (EC)\n1. Calculations must use **percentage rates converted to decimals**.\n2. Result must be expressed as a **percentage rounded to three decimal places**.\n\n---\n\nUsing this method, we generate the Python program:\n\n```python\ndef solution():\n    # Define variables\n    par_value = 100  # Face value of the bond\n    coupon_rate = 4.37 / 100  # Annual coupon rate as a decimal\n    coupon_payment = par_value * coupon_rate  # Annual coupon payment\n    known_spots = [2.50 / 100, 3.00 / 100, 3.50 / 100, 4.00 / 100]  # Spot rates for years 1 to 4\n    \n    # Calculate the present value of coupon payments using known spot rates\n    pv_coupons = 0\n    for i in range(len(known_spots)):\n        pv_coupons += coupon_payment / ((1 + known_spots[i]) ** (i + 1))\n    \n    # Calculate the remaining bond price (PV of year-5 cash flows)\n    bond_price = par_value  # since it's issued at par\n    remaining_pv = bond_price - pv_coupons\n    \n    # Solve for the five-year spot rate (r5)\n    final_cash_flow = par_value + coupon_payment  # Coupon + face value at maturity\n    r5 = (final_cash_flow / remaining_pv) ** (1 / 5) - 1\n    \n    # Convert r5 to percentage and round to three decimal places\n    r5_percentage = round(r5 * 100, 3)\n    \n    # Return the answer\n    return r5_percentage\n```"
        ],
        "retrieval_query": "Based on Exhibit 1, what is the five-year spot rate for Steve, a bond trader at a financial institution (expressed as a percentage)? Keep in mind that par and spot rates are derived from annual-coupon sovereign bonds. Answer to three decimal places.",
        "useful_functions": [],
        "usage": {
            "completion_tokens": 988,
            "prompt_tokens": 495,
            "total_tokens": 1483,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "What would be the expected standard deviation of the portfolio constructed by a fund manager if the correlation of returns between the two securities is 0.40 (expressed as a percentage)? Answer to three decimal places.",
        "python_solution": "def solution():\n    w1 = 0.3\n    w2 = 0.7\n    sigma1 = 20 / 100    # converting the percentage to a decimal\n    sigma2 = 12 / 100    # converting the percentage to a decimal\n    rho12 = 0.40         # correlation of returns between two securities\n\n    sigma_port = ((w1 ** 2 * sigma1 ** 2) + (w2 ** 2 * sigma2 ** 2) + (2 * w1 * w2 * rho12 * sigma1 * sigma2)) ** 0.5\n\n    return sigma_port * 100    # converting the decimal to a percentage",
        "ground_truth": 12.119,
        "topic": "Portfolio Management & Strategy",
        "statistics": {
            "number_statistics": {
                "args_numbers": 5,
                "question_numbers": 1,
                "context_numbers": 6,
                "total_numbers": 7
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 0,
                    "*": 8,
                    "/": 2,
                    "%": 0,
                    "**": 5
                },
                "total_operators": 17
            },
            "code_statistics": {
                "lines": 7,
                "parentheses": 8
            }
        },
        "difficulty": 5.231108616854587,
        "source": "FinanceMath-validation-91",
        "context": "['| Security | Security Weight(%) | Expected Standard Deviation(%) |\\n|----------|-------------------|-------------------------------|\\n| 1        | 30                | 20                            |\\n| 2        | 70                | 12                            |']",
        "question_id": "test-2176",
        "level": "hard",
        "output": [
            "To determine the expected standard deviation of the portfolio, the formula for the standard deviation of a two-security portfolio is used:\n\n\\[\n\\sigma_p = \\sqrt{w_1^2 \\cdot \\sigma_1^2 + w_2^2 \\cdot \\sigma_2^2 + 2 \\cdot w_1 \\cdot w_2 \\cdot \\sigma_1 \\cdot \\sigma_2 \\cdot \\rho}\n\\]\n\nWhere:\n- \\( \\sigma_p \\): Portfolio standard deviation (what we are solving for).\n- \\( w_1, w_2 \\): Weights of securities 1 and 2 in the portfolio.\n- \\( \\sigma_1, \\sigma_2 \\): Standard deviations of securities 1 and 2 (in percentage form, they will be converted as needed).\n- \\( \\rho \\): Correlation coefficient between the two securities.\n\n### Step-by-Step Approach:\n1. **Identify constraints (EC)**:\n    a. Ensure all percentages are correctly converted into decimals where necessary. \n    b. Answer must be calculated to three decimal places.\n    c. Only two securities; no additional complexities.\n    \n2. **Assign values**:\n   - Weight (\\( w_1 = 0.30, w_2 = 0.70 \\)); Convert percentages to decimals: \\( 30\\% = 0.30 \\) and \\( 70\\% = 0.70 \\).\n   - Standard deviations (\\( \\sigma_1 = 20\\%, \\sigma_2 = 12\\%\\)); Convert to decimals: \\( 20\\% = 0.20 \\) and \\( 12\\% = 0.12 \\).\n   - Correlation (\\( \\rho = 0.40 \\)).\n\n3. **Apply the formula step by step**:\n   - Expand the terms under the square root.\n   - Plug in the weights, standard deviations, and correlation coefficient into the formula:\n   \\[\n   \\sigma_p = \\sqrt{w_1^2 \\cdot \\sigma_1^2 + w_2^2 \\cdot \\sigma_2^2 + 2 \\cdot w_1 \\cdot w_2 \\cdot \\sigma_1 \\cdot \\sigma_2 \\cdot \\rho}\n   \\]\n\n4. **Compute to three decimal places**.\n\nHere is the Python program to compute the portfolio standard deviation:\n\n```python\ndef solution():\n    # Define variables\n    w1 = 0.30  # Weight of Security 1\n    w2 = 0.70  # Weight of Security 2\n    sigma1 = 0.20  # Standard deviation of Security 1\n    sigma2 = 0.12  # Standard deviation of Security 2\n    correlation = 0.40  # Correlation coefficient between securities\n    \n    # Portfolio standard deviation formula\n    portfolio_variance = (w1**2 * sigma1**2) + (w2**2 * sigma2**2) + (2 * w1 * w2 * sigma1 * sigma2 * correlation)\n    portfolio_std_dev = portfolio_variance**0.5  # Square root to find standard deviation\n    \n    # Convert to percentage and round to three decimal places\n    answer = round(portfolio_std_dev * 100, 3)\n    \n    return answer\n```"
        ],
        "retrieval_query": "What would be the expected standard deviation of the portfolio constructed by a fund manager if the correlation of returns between the two securities is 0.40 (expressed as a percentage)? Answer to three decimal places.",
        "useful_functions": [],
        "usage": {
            "completion_tokens": 713,
            "prompt_tokens": 423,
            "total_tokens": 1136,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-2135",
        "article_title": "LIFO Liquidation",
        "function": "def calculate_lifo_liquidation_sales(unit_sales: int, inventory_levels: list, unit_costs: list, unit_revenue: float) -> dict:\n    \"\"\"\n    Calculate the impact of a LIFO liquidation on revenues, COGS, and gross profit.\n\n    This function calculates the revenue, cost of goods sold (COGS), and gross profit\n    result from a LIFO liquidation given the unit sales, inventory levels at different costs,\n    and per unit sales revenue.\n\n    Args:\n        unit_sales (int): The number of units sold during the period.\n        inventory_levels (list of int): A list of inventory quantities available from oldest to newest.\n        unit_costs (list of float): A list of unit costs corresponding to each inventory level from oldest to newest.\n        unit_revenue (float): The revenue generated per unit sold.\n\n    Returns:\n        liquidation_results (dict): A dictionary containing 'total_revenue', 'total_cogs', and 'total_gross_profit'.\n\n    Notes:\n        - Applicability: This function is applicable when analyzing financial periods with excess inventory liquidated \n          using the LIFO method.\n        - Constraints: The length of `inventory_levels` must be equal to `unit_costs`.\n        - Considerations: Ensure unit costs and revenues are accurately represented. In cases of multiple periods or \n          dynamic costs, databases may be required for accurate results.\n    \"\"\"\n    if len(inventory_levels) != len(unit_costs):\n        raise ValueError(\"Length of inventory_levels and unit_costs must be equal.\")\n    \n    total_revenue = 0\n    total_cogs = 0\n\n    for i in range(len(inventory_levels) - 1, -1, -1):\n        if unit_sales <= 0:\n            break\n\n        available_units = inventory_levels[i]\n        units_to_sell = min(unit_sales, available_units)\n        cogs = units_to_sell * unit_costs[i]\n        revenue = units_to_sell * unit_revenue\n\n        total_revenue += revenue\n        total_cogs += cogs\n        unit_sales -= units_to_sell\n\n    total_gross_profit = total_revenue - total_cogs\n\n    return {\n        'total_revenue': total_revenue,\n        'total_cogs': total_cogs,\n        'total_gross_profit': total_gross_profit\n    }",
        "statistics": {
            "number_statistics": {
                "args_numbers": 4,
                "question_numbers": 1,
                "context_numbers": 8,
                "total_numbers": 9
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 5,
                    "*": 2,
                    "/": 0,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 9
            },
            "code_statistics": {
                "lines": 18,
                "parentheses": 6
            }
        },
        "difficulty": 5.241747015059643,
        "context": "A small retail company is experiencing a high sales season and decides to liquidate some of its older inventory to maximize cash flow. The company uses the LIFO (Last In, First Out) method to manage its inventory. At the start of the period, the company's inventory consists of three different batches varying in cost:\n\n- 100 units available at $20 per unit (purchased first).\n- 150 units available at $25 per unit (purchased second).\n- 200 units available at $30 per unit (purchased last).\n\nDuring the sales period, the company manages to sell 350 units at a price of $40 per unit. The financial manager wants to analyze the impact on revenue, cost of goods sold (COGS), and gross profit as a result of this LIFO liquidation.",
        "question": "What is the total gross profit from the sale of 350 units during this sales period? Answer in dollars to the nearest integer.",
        "python_solution": "def solution():\n    # Define the inventory levels, costs, and sales information\n    unit_sales = 350\n    inventory_levels = [100, 150, 200]\n    unit_costs = [20, 25, 30]\n    unit_revenue = 40\n    \n    # Initialize revenue, COGS, and gross profit\n    total_revenue = 0\n    total_cogs = 0\n    \n    # Iterate from the most recent inventory to the oldest (LIFO method)\n    for i in range(len(inventory_levels) - 1, -1, -1):\n        if unit_sales <= 0:\n            break\n        \n        available_units = inventory_levels[i]\n        units_to_sell = min(unit_sales, available_units)\n        cogs = units_to_sell * unit_costs[i]\n        revenue = units_to_sell * unit_revenue\n        \n        # Calculate total revenue and COGS\n        total_revenue += revenue\n        total_cogs += cogs\n        unit_sales -= units_to_sell\n    \n    # Calculate gross profit\n    total_gross_profit = total_revenue - total_cogs\n    \n    # Return the total gross profit, rounded to the nearest integer\n    return round(total_gross_profit)",
        "ground_truth": 4250,
        "source": "FinanceReasoning-test-96",
        "question_id": "test-2177",
        "level": "hard",
        "output": [
            "To solve this, we need to calculate the total Gross Profit from selling 350 units under the LIFO (Last In, First Out) inventory method. Here's how we break down the process step by step:\n\n### Steps:\n1. **Understand Inputs and Outputs**:\n    - Inventory is in three batches (chronologically ordered):\n        1. 100 units @ $20/unit\n        2. 150 units @ $25/unit\n        3. 200 units @ $30/unit\n    - Units sold = 350\n    - Selling price per unit = $40\n\n2. **Constraints**:\n   - Use LIFO (Last In, First Out):\n        - Units sold come first from the \"last purchased\" batch.\n        - Continue utilizing earlier batches until all units sold are accounted for.\n   - All calculations must adhere to the constraints of LIFO and ensure accuracy.\n\n3. **Calculations**:\n    - Calculate the **Cost of Goods Sold (COGS)** using LIFO:\n        - Start from the most recently purchased units (Batch 3 @ $30).\n        - Consume Batch 3 first, followed by Batch 2, and finally Batch 1 if necessary.\n        - Compute the total cost (COGS) of the 350 units sold.\n    - Compute **Total Revenue**:\n        - Revenue = Units Sold \u00d7 Selling Price\n    - Compute **Gross Profit**:\n        - Gross Profit = Total Revenue - COGS\n\n4. **Adherence to Units**:\n    - Sell 350 units while adhering strictly to the constraints that:\n        - LIFO method is followed.\n        - Each batch's available inventory is considered finite.\n\nWith this understanding, let's implement the solution.\n\n```python\ndef solution():\n    # Define variables for inventory and selling price\n    purchases = [(100, 20), (150, 25), (200, 30)]  # (units available, cost per unit)\n    units_sold = 350\n    selling_price_per_unit = 40\n    \n    # Calculate COGS using LIFO method\n    def calculate_lifo_cogs(units_sold, purchases):\n        total_units = 0\n        cogs = 0\n        for units, cost in reversed(purchases):\n            if total_units + units <= units_sold:  # Can use the entire batch\n                cogs += units * cost\n                total_units += units\n            else:  # Can only partially use the batch\n                remaining_units = units_sold - total_units\n                cogs += remaining_units * cost\n                break\n        return cogs\n    \n    # Calculate COGS for the 350 sold units\n    cogs = calculate_lifo_cogs(units_sold, purchases)\n    \n    # Calculate total revenue\n    total_revenue = units_sold * selling_price_per_unit\n    \n    # Calculate gross profit\n    gross_profit = total_revenue - cogs\n\n    # Return gross profit as an integer\n    return round(gross_profit)  # Nearest integer as required\n```"
        ],
        "retrieval_query": "What is the total gross profit from the sale of 350 units during this sales period? Answer in dollars to the nearest integer.",
        "useful_functions": [
            "def calculate_lifo_cogs(units_sold: int, purchases: list) -> float:\n    \"\"\"\n    Calculate the cost of goods sold using the LIFO method in a periodic inventory system.\n\n    This function determines the cost of goods sold (COGS) under the Last-In, First-Out (LIFO)\n    method, given the total units sold and a list of purchase transactions, where each purchase \n    contains the number of units and the cost per unit in tuple format.\n\n    Args:\n        units_sold (int): The total number of units sold during the period.\n        purchases (list): A list of tuples, each tuple containing the number of units purchased \n                          and the cost per unit, in the format (units_purchased, unit_cost).\n\n    Returns:\n        cogs (float): The cost of goods sold calculated using LIFO.\n\n    Notes:\n        - Purchases should be listed in chronological order.\n        - The function assumes that all units in purchases can cover the units sold.\n        - If units_sold exceeds the total units in the given purchases, the function may not \n          handle such cases.\n    \"\"\"\n    total_units = 0\n    cogs = 0\n    for units, cost in reversed(purchases):\n        if total_units + units <= units_sold:\n            cogs += units * cost\n            total_units += units\n        else:\n            remaining_units = units_sold - total_units\n            cogs += remaining_units * cost\n            break\n\n    return cogs"
        ],
        "usage": {
            "completion_tokens": 630,
            "prompt_tokens": 833,
            "total_tokens": 1463,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "Rector Incorporated is a manufacturing firm with a capital structure comprising of equity and debt. The current market value of equity is $2.0 million and the beta of the stock is 1.2. The company has $4 million face value of bonds outstanding, which pay semi-annual coupons at an annual rate of 8%. The yield-to-maturity is 9% and the remaining term to maturity is 5 years. The corporate pays tax at a rate of 25%. The equity risk premium and risk-free rate is 4% and 2%, respectively. What is Rector Incorporated's weighted average cost of capital (WACC)? Answer as a percentage to two decimal places.",
        "context": "",
        "statistics": {
            "number_statistics": {
                "question_numbers": 9,
                "context_numbers": 0,
                "total_numbers": 9
            },
            "operator_statistics": {
                "operators": {
                    "+": 3,
                    "-": 1,
                    "*": 5,
                    "/": 1,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 10
            },
            "code_statistics": {
                "lines": 13,
                "parentheses": 12
            }
        },
        "difficulty": 5.247024072160486,
        "ground_truth": 6.77,
        "source": "FinCode-test-6",
        "python_solution": "market_value_of_equity = 2000000\nbeta = 1.2\nface_value_of_bonds = 4000000\ncoupon_rate = 0.08\nyield_to_maturity = 0.09\nremaining_term_to_maturity = 5\ntax_rate = 0.25\nequity_risk_premium = 0.04\nrisk_free_rate = 0.02\ncost_of_equity = risk_free_rate + beta * equity_risk_premium\ncost_of_debt = yield_to_maturity * (1 - tax_rate)\nweighted_average_cost_of_capital = ((market_value_of_equity * cost_of_equity) + (face_value_of_bonds * cost_of_debt)) / (market_value_of_equity + face_value_of_bonds)\nround(weighted_average_cost_of_capital * 100, 2)",
        "question_id": "test-2178",
        "level": "hard",
        "output": [
            "### Step-by-Step Analysis:\n1. **Emphasizing Constraints (EC)**:\n   - The WACC needs to be expressed as a percentage value with two decimal places.\n   - Inputs related to financial metrics such as equity market value, bond coupon rate, yield-to-maturity, etc., must be respected with appropriate precision.\n   - The calculation utilizes semi-annual coupon payments and proper discounting techniques for the bond market value.\n\n2. **Key Variables and Equations**:\n   - **Cost of Equity (CAPM)**:\n     \\( \\text{Cost of Equity} = \\text{Risk-Free Rate} + \\beta \\times \\text{Equity Risk Premium} \\)\n   - **Market Value of Debt Calculation**:\n     Discount bond coupon payments and the face value using the yield-to-maturity on a semi-annual basis:\n     \\[\n     \\text{Market Value of Debt} = \\sum_{i=1}^{N} \\frac{\\text{Coupon Payment}}{(1 + r)^i} + \\frac{\\text{Face Value}}{(1 + r)^N}\n     \\]\n   - **After-Tax Cost of Debt**:\n     \\[ \\text{After Tax Cost of Debt} = \\text{Yield-to-Maturity} \\times (1 - \\text{Tax Rate}) \\]\n   - **Weighted Average Cost of Capital**:\n     \\[\n     \\text{WACC} = \\left( \\frac{\\text{Equity Market Value}}{\\text{Total Firm Value}} \\times \\text{Cost of Equity} \\right) + \\left( \\frac{\\text{Debt Market Value}}{\\text{Total Firm Value}} \\times \\text{After-Tax Cost of Debt} \\right)\n     \\]\n\n3. **Constraints**:\n   - Bond pays semi-annual coupons, so we divide rates by 2 and multiply coupon payments accordingly.\n   - Calculations should be rounded only at the end to ensure maximum precision.\n\n### Python Program Solution:\n```python\ndef solution():\n    # Define variables\n    equity_market_value = 2_000_000  # in dollars\n    bond_face_value = 4_000_000  # in dollars\n    bond_coupon_rate = 0.08  # 8% annual coupon rate\n    bond_yield_to_maturity = 0.09  # 9% annual yield-to-maturity\n    bond_term_years = 5  # in years\n    tax_rate = 0.25  # 25% tax rate\n    equity_beta = 1.2  # beta of the equity\n    equity_risk_premium = 0.04  # 4% equity risk premium\n    risk_free_rate = 0.02  # 2% risk-free rate\n    \n    # Calculate Cost of Equity using CAPM\n    cost_of_equity = risk_free_rate + equity_beta * equity_risk_premium\n    \n    # Calculate market value of debt using discounted cash flows\n    periods = bond_term_years * 2  # semi-annual periods\n    semi_annual_coupon = bond_coupon_rate * bond_face_value / 2\n    semi_annual_yield = bond_yield_to_maturity / 2\n    \n    # Summing up the present value of the coupon payments\n    pv_coupons = sum(semi_annual_coupon / (1 + semi_annual_yield) ** i for i in range(1, periods + 1))\n    \n    # Present value of the face value\n    pv_face_value = bond_face_value / (1 + semi_annual_yield) ** periods\n    \n    # Total market value of debt\n    market_value_of_debt = pv_coupons + pv_face_value\n    \n    # Calculate after-tax cost of debt\n    after_tax_cost_of_debt = bond_yield_to_maturity * (1 - tax_rate)\n    \n    # Total market value of the firm\n    total_firm_value = equity_market_value + market_value_of_debt\n    \n    # Weights of equity and debt\n    equity_weight = equity_market_value / total_firm_value\n    debt_weight = market_value_of_debt / total_firm_value\n    \n    # Calculate WACC\n    wacc = (equity_weight * cost_of_equity) + (debt_weight * after_tax_cost_of_debt)\n    \n    # Return the WACC as a percentage to two decimal places\n    return round(wacc * 100, 2)\n```"
        ],
        "retrieval_query": "Rector Incorporated is a manufacturing firm with a capital structure comprising of equity and debt. The current market value of equity is $2.0 million and the beta of the stock is 1.2. The company has $4 million face value of bonds outstanding, which pay semi-annual coupons at an annual rate of 8%. The yield-to-maturity is 9% and the remaining term to maturity is 5 years. The corporate pays tax at a rate of 25%. The equity risk premium and risk-free rate is 4% and 2%, respectively. What is Rector Incorporated's weighted average cost of capital (WACC)? Answer as a percentage to two decimal places.",
        "useful_functions": [
            "def calculate_wacc(equity_market_value: float, debt_face_value: float, bond_coupon_rate: float, \n                   bond_yield_to_maturity: float, bond_term_years: int, tax_rate: float, \n                   equity_beta: float, equity_risk_premium: float, risk_free_rate: float) -> float:\n    \"\"\"\n    Calculate the Weighted Average Cost of Capital (WACC) for a company.\n\n    This function computes the WACC, which represents a firm's overall cost of capital, taking into account \n    the cost of equity and after-tax cost of debt, weighted by their respective proportions in the company's \n    capital structure. It is a critical measurement in financial management for evaluating an investment's \n    return relative to its cost.\n\n    Args:\n        equity_market_value (float): The market value of the firm's equity.\n        debt_face_value (float): The face (par) value of the firm's debt.\n        bond_coupon_rate (float): The annual coupon rate for the firm's bonds.\n        bond_yield_to_maturity (float): The annual yield to maturity for the bonds.\n        bond_term_years (int): The number of years remaining until bond maturity.\n        tax_rate (float): The corporate tax rate applicable to the firm.\n        equity_beta (float): The beta of the company's stock, a measure of market risk.\n        equity_risk_premium (float): The equity risk premium, representing the expected return \n                                      of the market over the risk-free rate.\n        risk_free_rate (float): The risk-free interest rate, typically the yield on government bonds.\n\n    Returns:\n        wacc (float): The weighted average cost of capital, expressed as a decimal.\n\n    Notes:\n        - The function assumes semi-annual coupon payments for the bonds.\n        - The WACC is expressed as a percentage; multiply by 100 if needed for actual percentage representation.\n        - Values for beta, risk-free rate, and market premium should be based on prevailing market data.\n        - Debt is valued at market by discounting coupon and face values by the yield-to-maturity.\n    \"\"\"\n    # Calculate cost of equity using CAPM\n    cost_of_equity = risk_free_rate + equity_beta * equity_risk_premium\n    \n    # Calculate present value of debt (market value of debt)\n    periods = bond_term_years * 2  # semi-annual\n    semi_annual_coupon = bond_coupon_rate * debt_face_value / 2\n    discount_rate = bond_yield_to_maturity / 2\n    market_value_of_debt = sum(semi_annual_coupon / (1 + discount_rate) ** i for i in range(1, periods + 1)) + \\\n                           debt_face_value / (1 + discount_rate) ** periods\n    \n    # Calculate after-tax cost of debt\n    after_tax_cost_of_debt = bond_yield_to_maturity * (1 - tax_rate)\n    \n    # Total market value of the firm's capital\n    total_firm_value = equity_market_value + market_value_of_debt\n    \n    # Weights of equity and debt\n    equity_weight = equity_market_value / total_firm_value\n    debt_weight = market_value_of_debt / total_firm_value\n    \n    # Calculate WACC\n    wacc = (equity_weight * cost_of_equity) + (debt_weight * after_tax_cost_of_debt)\n    \n    return wacc",
            "def calculate_wacc(equity_market_value: float, debt_market_value: float, cost_of_equity: float, \n                   cost_of_debt: float, tax_rate: float) -> float:\n    \"\"\"\n    Calculate the Weighted Average Cost of Capital (WACC) for a company.\n\n    This function computes the WACC, which represents a company's average after-tax\n    cost of capital from all sources, including equity and debt. It combines the cost \n    of both equity and debt, weighted by their respective proportions in the total \n    capital used by the company.\n\n    Args:\n        equity_market_value (float): Market value of the firm's equity.\n        debt_market_value (float): Market value of the firm's debt.\n        cost_of_equity (float): Cost of equity, representing the required rate \n                                of return for equity investors.\n        cost_of_debt (float): Cost of debt, representing the effective rate paid \n                              on the company's issued debt.\n        tax_rate (float): Corporate tax rate, used to calculate the after-tax cost of debt.\n\n    Returns:\n        wacc (float): The calculated Weighted Average Cost of Capital (WACC).\n\n    Notes:\n        - Applicability: Useful for assessing the cost of capital for businesses \n          that use both equity and debt financing.\n        - Constraints: The equity and debt market values should be positive and \n          represent the total financing. The tax rate should be between 0 and 1.\n        - Considerations: It assumes taxes are constant and ignores complications \n          such as different classes of equity with different costs.\n    \"\"\"\n    total_value = equity_market_value + debt_market_value\n    equity_weight = equity_market_value / total_value\n    debt_weight = debt_market_value / total_value\n    after_tax_cost_of_debt = cost_of_debt * (1 - tax_rate)\n\n    wacc = (equity_weight * cost_of_equity) + (debt_weight * after_tax_cost_of_debt)\n    \n    return wacc",
            "def calculate_weighted_average_cost_of_capital(weight_equity: float, cost_equity: float, weight_debt: float, \n                                               pretax_cost_debt: float, tax_rate: float) -> float:\n    \"\"\"\n    Calculate the weighted average cost of capital (WACC) for a company.\n\n    This function computes the WACC by weighting the cost of equity and the after-tax cost of debt\n    according to their respective proportions in the company's capital structure.\n\n    Args:\n        weight_equity (float): The proportion of capital financed by common equity. Must be between 0 and 1.\n        cost_equity (float): The cost of common equity as a decimal. Must be between 0 and 1.\n        weight_debt (float): The proportion of capital financed by debt. Must be between 0 and 1.\n        pretax_cost_debt (float): The pretax cost of debt as a decimal. Must be between 0 and 1.\n        tax_rate (float): The corporate tax rate as a decimal. Must be between 0 and 1.\n\n    Returns:\n        wacc (float): The weighted average cost of capital as a decimal.\n\n    Notes:\n        - This function assumes the sum of `weight_equity` and `weight_debt` equals 1.\n        - The WACC is returned as a decimal and may be converted to a percentage by multiplying by 100.\n        - The function assumes all inputs are provided as decimals (e.g., 10% should be input as 0.10).\n    \"\"\"\n    cost_debt_after_tax = pretax_cost_debt * (1 - tax_rate)\n    wacc = (weight_equity * cost_equity) + (weight_debt * cost_debt_after_tax)\n    return wacc"
        ],
        "usage": {
            "completion_tokens": 932,
            "prompt_tokens": 1947,
            "total_tokens": 2879,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-1091",
        "article_title": "Human Development Index (HDI)",
        "function": "def calculate_hdi(life_expectancy: float, mean_years_school: float, expected_years_school: float, gni_per_capita: float) -> float:\n    \"\"\"\n    Calculate the Human Development Index (HDI) for a country.\n\n    This function computes the HDI based on normalized scores for life expectancy,\n    education, and GNI per capita. HDI is a measure used to evaluate the social and\n    economic development levels of a country.\n\n    Args:\n        life_expectancy (float): The life expectancy at birth in years.\n        mean_years_school (float): The mean number of years of schooling a country's residents have undergone.\n        expected_years_school (float): The expected number of years of schooling that a child will receive.\n        gni_per_capita (float): The gross national income per capita adjusted for purchasing power parity (PPP).\n\n    Returns:\n        hdi (float): The Human Development Index, a value between 0 and 1.\n\n    Notes:\n        - Applicability: HDI is used to compare development levels across countries.\n        - Constraints:\n            - Life expectancy should be between 20 (value of zero) and 85 (value of one).\n            - Mean years of schooling should be between 0 and 15 years.\n            - Expected years of schooling should be between 0 and 18 years.\n            - GNI per capita should be evaluated with $100 as a value of zero and $75,000 as a value of one.\n        - Considerations: HDI is a basic summary measure and should be considered alongside other factors for comprehensive analysis.\n    \"\"\"\n    life_expectancy_index = (life_expectancy - 20) / (85 - 20) if 20 <= life_expectancy <= 85 else 0\n    education_index = ((mean_years_school / 15) + (expected_years_school / 18)) / 2\n    gni_index = (gni_per_capita - 100) / (75000 - 100) if 100 <= gni_per_capita <= 75000 else 0\n\n    hdi = (life_expectancy_index * education_index * gni_index) ** (1/3)\n    \n    return hdi",
        "statistics": {
            "number_statistics": {
                "args_numbers": 4,
                "question_numbers": 2,
                "context_numbers": 4,
                "total_numbers": 6
            },
            "operator_statistics": {
                "operators": {
                    "+": 1,
                    "-": 4,
                    "*": 2,
                    "/": 6,
                    "%": 0,
                    "**": 1
                },
                "total_operators": 14
            },
            "code_statistics": {
                "lines": 5,
                "parentheses": 18
            }
        },
        "difficulty": 5.278114659230517,
        "context": "The United Nations is evaluating the development status of Country Z by analyzing its social and economic indicators through the Human Development Index (HDI). Country Z has a life expectancy of 75 years, an average education level where the mean years of schooling is 10 years, and children are expected to complete 16 years of education. The Gross National Income (GNI) per capita, adjusted for purchasing power parity, is $35,000. The UN seeks to understand Country Z's position in terms of development relative to global standards.",
        "question": "Calculate the Human Development Index (HDI) for Country Z. Provide your answer as a value between 0 and 1, rounded to three decimal places.",
        "python_solution": "def solution():\n    # Define given values for Country Z\n    life_expectancy = 75\n    mean_years_school = 10\n    expected_years_school = 16\n    gni_per_capita = 35000\n\n    # Calculate Life Expectancy Index, Education Index, and GNI Index\n    life_expectancy_index = (life_expectancy - 20) / (85 - 20)\n    education_index = ((mean_years_school / 15) + (expected_years_school / 18)) / 2\n    gni_index = (gni_per_capita - 100) / (75000 - 100)\n\n    # Calculate the Human Development Index (HDI)\n    hdi = (life_expectancy_index * education_index * gni_index) ** (1/3)\n\n    # Return the HDI rounded to three decimal places\n    return round(hdi, 3)",
        "ground_truth": 0.674,
        "source": "FinanceReasoning-test-83",
        "question_id": "test-2179",
        "level": "hard",
        "output": [
            "Alright, let's solve the problem step by step using the **Emphasizing Constraints (EC)** reasoning technique:\n\n### Step-by-Step Problem Analysis:\n\n1. **Understand Inputs**: The HDI computation depends on four variables:\n   - Life expectancy: \\( 75 \\) years (given)\n   - Mean years of schooling: \\( 10 \\) years (given)\n   - Expected years of schooling: \\( 16 \\) years (given)\n   - GNI per capita: \\( 35,000 \\) dollars (given)\n\n2. **Understand Outputs**: HDI is a score between \\( 0 \\) and \\( 1 \\), representing the development index, rounded to three decimal places.\n\n3. **HDI Calculation Formula**:\n   - The HDI is computed as:\n     \\[\n     HDI = \\Big(Life\\ Expectancy\\ Index \\cdot Education\\ Index \\cdot GNI\\ Index\\Big)^{\\frac{1}{3}}\n     \\]\n\n   - Each component is normalized based on its respective constraints:\n     - **Life Expectancy Index**:\n       \\[\n       \\text{Life Expectancy Index} = \\frac{\\text{life expectancy} - 20}{85 - 20},\\ \\text{if } 20 \\leq \\text{life expectancy} \\leq 85\n       \\]\n     - **Education Index**:\n       \\[\n       \\text{Education Index} = \\frac{\\text{mean years of schooling}}{15} + \\frac{\\text{expected years of schooling}}{18} \\text{, averaged over 2}.\n       \\]\n     - **GNI Index**:\n       \\[\n       \\text{GNI Index} = \\frac{\\text{GNI per capita} - 100}{75000 - 100},\\ \\text{if } 100 \\leq \\text{GNI per capita} \\leq 75000\n       \\]\n\n4. **Constraints**: Ensure each component falls within the range described above:\n   - Life expectancy: Between \\( 20 \\) and \\( 85 \\).\n   - Mean years of schooling: Between \\( 0 \\) and \\( 15 \\).\n   - Expected years of schooling: Between \\( 0 \\) and \\( 18 \\).\n   - GNI per capita: Between \\( 100 \\) and \\( 75000 \\).\n\n5. **Expected Precision**: The final HDI value should be rounded to three decimal places.\n\n---\n\nNow, let's write the Python program:\n\n```python\ndef solution():\n    # Define variables and given values\n    life_expectancy = 75\n    mean_years_school = 10\n    expected_years_school = 16\n    gni_per_capita = 35000\n\n    # Calculate each index based on the constraints\n    life_expectancy_index = (life_expectancy - 20) / (85 - 20)\n    education_index = ((mean_years_school / 15) + (expected_years_school / 18)) / 2\n    gni_index = (gni_per_capita - 100) / (75000 - 100)\n\n    # Calculate the HDI using the geometric mean\n    hdi = (life_expectancy_index * education_index * gni_index) ** (1/3)\n\n    # Round the result to three decimal places\n    return round(hdi, 3)\n```"
        ],
        "retrieval_query": "Calculate the Human Development Index (HDI) for Country Z. Provide your answer as a value between 0 and 1, rounded to three decimal places.",
        "useful_functions": [
            "def calculate_hdi(life_expectancy: float, mean_years_school: float, expected_years_school: float, gni_per_capita: float) -> float:\n    \"\"\"\n    Calculate the Human Development Index (HDI) for a country.\n\n    This function computes the HDI based on normalized scores for life expectancy,\n    education, and GNI per capita. HDI is a measure used to evaluate the social and\n    economic development levels of a country.\n\n    Args:\n        life_expectancy (float): The life expectancy at birth in years.\n        mean_years_school (float): The mean number of years of schooling a country's residents have undergone.\n        expected_years_school (float): The expected number of years of schooling that a child will receive.\n        gni_per_capita (float): The gross national income per capita adjusted for purchasing power parity (PPP).\n\n    Returns:\n        hdi (float): The Human Development Index, a value between 0 and 1.\n\n    Notes:\n        - Applicability: HDI is used to compare development levels across countries.\n        - Constraints:\n            - Life expectancy should be between 20 (value of zero) and 85 (value of one).\n            - Mean years of schooling should be between 0 and 15 years.\n            - Expected years of schooling should be between 0 and 18 years.\n            - GNI per capita should be evaluated with $100 as a value of zero and $75,000 as a value of one.\n        - Considerations: HDI is a basic summary measure and should be considered alongside other factors for comprehensive analysis.\n    \"\"\"\n    life_expectancy_index = (life_expectancy - 20) / (85 - 20) if 20 <= life_expectancy <= 85 else 0\n    education_index = ((mean_years_school / 15) + (expected_years_school / 18)) / 2\n    gni_index = (gni_per_capita - 100) / (75000 - 100) if 100 <= gni_per_capita <= 75000 else 0\n\n    hdi = (life_expectancy_index * education_index * gni_index) ** (1/3)\n    \n    return hdi"
        ],
        "usage": {
            "completion_tokens": 715,
            "prompt_tokens": 936,
            "total_tokens": 1651,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "The following information pertains to a bond, what will be the bond's price? Answer to three decimal places.",
        "python_solution": "def solution():\n\n    N = 2 * 3\n    I_Y = 5 / 2\n    PMT = 3 / 2\n    FV = 100\n\n    PV = 0\n\n    for i in range(1, N + 1):\n        PV += PMT / ((1 + I_Y/100) ** i)\n    PV += FV / ((1 + I_Y/100) ** N)\n\n    return PV",
        "ground_truth": 94.492,
        "topic": "Asset Classes & Derivatives",
        "statistics": {
            "number_statistics": {
                "args_numbers": 1,
                "question_numbers": 0,
                "context_numbers": 4,
                "total_numbers": 4
            },
            "operator_statistics": {
                "operators": {
                    "+": 5,
                    "-": 0,
                    "*": 1,
                    "/": 6,
                    "%": 0,
                    "**": 2
                },
                "total_operators": 14
            },
            "code_statistics": {
                "lines": 9,
                "parentheses": 10
            }
        },
        "difficulty": 5.278114659230517,
        "source": "FinanceMath-validation-15",
        "context": "['| Coupon rate            | 3%                   |\\n|------------------------|---------------------|\\n| Interest paid          | Semiannually        |\\n| Mature time            | 3 years             |\\n| Required rate of return| 5%                  |\\n| Par value of the bond  | 100                 |']",
        "question_id": "test-2180",
        "level": "hard",
        "output": [
            "To solve the problem at hand, let's analyze it step by step.\n\n### Step-by-step analysis:\n\n1. **Identify Constraints from the problem:**\n   - **Coupon rate:** 3% (Noted that the rate should be used as a percentage).\n   - **Interest paid frequency:** Semiannually (2 periods per year).\n   - **Maturity time:** 3 years, meaning a total of 6 periods (3 years * 2 periods/year).\n   - **Required rate of return:** 5% (Should be used as a percentage).\n   - **Par value of the bond:** 100.\n\n2. **Key financial formula:**\n   - The bond price is computed by summing the present value of the periodic coupon payments and the present value of the par value at maturity. The present value calculations are discounted by the per-period required rate of return.\n\n   This has two components:\n   - Present value of periodic coupon payments.\n   - Present value of the repayment of the par value at maturity.\n\n3. **Convert inputs where necessary to compatible units:**\n   - Convert annual coupon rate (3%) into semiannual coupon payment:\n     \\( \\text{Coupon payment per period} = \\frac{\\text{Coupon rate}}{\\text{Periods per year}} \\times \\text{Par value} \\).\n   - Convert annual required rate of return (5%) into semiannual discount rate:\n     \\( \\text{Per period rate} = \\frac{\\text{Required rate}}{\\text{Periods per year}} \\).\n\n4. **Apply calculations:**\n   - Calculate the present value of coupon payments over the 6 periods.\n   - Calculate the present value of the par value (discounted to present from the 6th period).\n\n5. **Round off**:\n   - The final answer must be rounded to **three decimal places**.\n\n### Python Program:\nUsing the above breakdown, the implementation is straightforward.\n\n```python\ndef solution():\n    # Define variables name and value\n    coupon_rate = 3  # Annual coupon rate as a percentage\n    periods_per_year = 2  # Semiannual interest payments\n    years_to_maturity = 3  # Maturity time in years\n    required_rate = 5  # Annual required rate of return as a percentage\n    par_value = 100  # Par value of the bond\n    \n    # Convert annual rates to per period rates and calculate other parameters\n    period_rate = (required_rate / 100) / periods_per_year  # Semiannual rate\n    period_coupon = (coupon_rate / 100) * par_value / periods_per_year  # Semiannual coupon payment\n    total_periods = periods_per_year * years_to_maturity  # Total number of periods\n    \n    # Calculate the present value of coupons\n    pv_coupons = sum(period_coupon / ((1 + period_rate) ** i) for i in range(1, total_periods + 1))\n    \n    # Calculate the present value of the par value\n    pv_par_value = par_value / ((1 + period_rate) ** total_periods)\n    \n    # Calculate total bond price\n    bond_price = pv_coupons + pv_par_value\n    \n    # Round to three decimal places\n    return round(bond_price, 3)\n```\n\nThis program will accurately calculate the bond price by following the required constraints and rounding as specified."
        ],
        "retrieval_query": "The following information pertains to a bond, what will be the bond's price? Answer to three decimal places.",
        "useful_functions": [
            "def calculate_bond_price(coupon_rate: float, periods_per_year: int, years_to_maturity: int, \n                         required_rate: float, par_value: float) -> float:\n    \"\"\"\n    Calculate the price of a bond given its parameters.\n\n    This function calculates the present value of a bond's future cash flows, which include\n    periodic coupon payments and the repayment of the par value at maturity. The present value is\n    obtained by discounting these cash flows at the bond's required rate of return.\n\n    Args:\n        coupon_rate (float): The annual coupon rate of the bond as a percentage (e.g., 3 for 3%).\n        periods_per_year (int): Number of coupon payments per year (e.g., 2 for semiannual).\n        years_to_maturity (int): The number of years until the bond matures.\n        required_rate (float): The annual required rate of return as a percentage (e.g., 5 for 5%).\n        par_value (float): The par value of the bond.\n\n    Returns:\n        bond_price (float): The calculated price of the bond.\n\n    Notes:\n        - Applicability: Use this function to calculate the price of fixed-rate bonds with \n          periodic coupon payments.\n        - Constraints: \n          - `coupon_rate`, `required_rate` should be input as percentages (e.g., 5 for 5%).\n          - `periods_per_year` should reflect how many times coupon payments occur in a year.\n        - Considerations: Make sure interest rates and periods are in consistent units (e.g., \n          semiannual periods require halving the annual rates).\n    \"\"\"\n    # Convert annual rates to per period rates\n    period_rate = (required_rate / 100) / periods_per_year\n    period_coupon = (coupon_rate / 100) * par_value / periods_per_year\n    total_periods = periods_per_year * years_to_maturity\n    \n    # Calculate the present value of coupons\n    pv_coupons = sum(period_coupon / ((1 + period_rate) ** i) for i in range(1, total_periods + 1))\n    \n    # Calculate the present value of the par value\n    pv_par_value = par_value / ((1 + period_rate) ** total_periods)\n    \n    # Calculate total bond price\n    bond_price = pv_coupons + pv_par_value\n    \n    return round(bond_price, 3)"
        ],
        "usage": {
            "completion_tokens": 697,
            "prompt_tokens": 930,
            "total_tokens": 1627,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-1282",
        "article_title": "Pivot Point",
        "function": "def calculate_pivot_points(high: float, low: float, close: float) -> dict:\n    \"\"\"\n    Calculate the pivot point and associated support and resistance levels.\n\n    This function computes the pivot point and its associated levels of support\n    (S1, S2) and resistance (R1, R2) based on the high, low, and closing prices.\n    These points are used to identify potential levels of support/resistance in \n    trading.\n\n    Args:\n        high (float): The highest price from the previous trading day.\n        low (float): The lowest price from the previous trading day.\n        close (float): The closing price from the previous trading day.\n\n    Returns:\n        levels (dict): A dictionary containing the calculated pivot point ('P'), \n                       resistance levels ('R1', 'R2'), and support levels ('S1', 'S2').\n\n    Notes:\n        - Applicability: Commonly used by day traders and in technical analysis.\n        - Constraints: Assumes the input prices are from the same trading day.\n        - Considerations: Pivot points do not guarantee market movements, and should \n                          be combined with other indicators for more reliable analysis.\n    \"\"\"\n    P = (high + low + close) / 3\n    R1 = (P * 2) - low\n    R2 = P + (high - low)\n    S1 = (P * 2) - high\n    S2 = P - (high - low)\n\n    levels = {\n        \"P\": P,\n        \"R1\": R1,\n        \"R2\": R2,\n        \"S1\": S1,\n        \"S2\": S2\n    }\n    \n    return levels",
        "statistics": {
            "number_statistics": {
                "args_numbers": 3,
                "question_numbers": 0,
                "context_numbers": 3,
                "total_numbers": 3
            },
            "operator_statistics": {
                "operators": {
                    "+": 3,
                    "-": 5,
                    "*": 2,
                    "/": 1,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 11
            },
            "code_statistics": {
                "lines": 13,
                "parentheses": 10
            }
        },
        "difficulty": 5.288267030694535,
        "context": "A stock trader is analyzing a particular stock to determine potential trading strategies for the next day. The previous trading day's highest price of the stock was $152.75, the lowest price was $148.30, and it closed at $150.10. The trader uses pivot points to identify key support and resistance levels, which help in planning entry and exit points for trades.",
        "question": "Calculate the pivot point for the stock based on the high, low, and close prices from the previous day. What is the pivot point? Answer to two decimal places.",
        "python_solution": "def solution():\n    # Define the previous day's high, low, and close prices\n    high = 152.75\n    low = 148.30\n    close = 150.10\n\n    # Calculate the pivot point\n    P = (high + low + close) / 3\n\n    # Return the pivot point rounded to two decimal places\n    return round(P, 2)\n\n# Execute the solution function to get the pivot point\nsolution()",
        "ground_truth": 150.38,
        "source": "FinanceReasoning-test-92",
        "question_id": "test-2181",
        "level": "hard",
        "output": [
            "### Step-by-Step Reasoning Using Emphasizing Constraints (EC)\n\n1. **Understanding the Problem (EC)**:\n   - The pivot point needs to be calculated using the formula:  \n     \\[\n     \\text{Pivot Point} = \\frac{\\text{High Price} + \\text{Low Price} + \\text{Close Price}}{3}\n     \\]\n   - The problem specifies the high price as \\(152.75\\), low price as \\(148.30\\), and close price as \\(150.10\\).\n   - The result should be rounded to **two decimal places** as specified.\n\n2. **Constraints and Steps to Solve (EC)**:\n   - Inputs must be treated as floating-point numbers to allow for decimal precision during arithmetic calculations.\n   - The output (pivot point) should be a number rounded to two decimal places.\n   - Perform the addition of the three prices and divide the total by \\(3\\).\n   - Ensure the solution meets accuracy requirements for financial analysis.\n\n3. **Plan for Python Implementation (EC)**:\n   - Define variables for the high, low, and close prices as per the problem statement.\n   - Use the given formula to calculate the pivot point.\n   - Round the answer to two decimal places and return it as the final result.\n\n### Python Program\n```python\ndef solution():\n    # Define variables name and value\n    high_price = 152.75\n    low_price = 148.30\n    close_price = 150.10\n    \n    # Do math calculation to get the pivot point\n    pivot_point = (high_price + low_price + close_price) / 3\n    answer = round(pivot_point, 2)\n    \n    # Return the answer\n    return answer\n```"
        ],
        "retrieval_query": "Calculate the pivot point for the stock based on the high, low, and close prices from the previous day. What is the pivot point? Answer to two decimal places.",
        "useful_functions": [
            "def calculate_total_issuable_securities(short_term_debt: float, tax_exempt_bonds: float, long_term_securities: float) -> int:\n    \"\"\"\n    Calculate the total value of issuable long-term securities in millions.\n\n    This function sums up the values of short-term debt, tax-exempt bonds, and\n    other long-term securities to find the total issuable amount. It rounds the \n    result to the nearest integer to represent the value in millions of dollars.\n\n    Args:\n        short_term_debt (float): The amount of short-term debt issuable.\n        tax_exempt_bonds (float): The amount of tax-exempt bonds issuable.\n        long_term_securities (float): The amount of other long-term securities issuable.\n\n    Returns:\n        total_securities (int): Total issuable securities value in millions, rounded to the nearest integer.\n\n    Notes:\n        - Applicability: This is applicable to financial analysis involving debt and securities issuance.\n        - Constraints: Ensure all inputs represent amounts in consistent units (e.g., millions).\n        - Considerations: Values should be non-negative as negative issuances are not realistic.\n    \"\"\"\n    total_securities = round(short_term_debt + tax_exempt_bonds + long_term_securities)\n    \n    return total_securities"
        ],
        "usage": {
            "completion_tokens": 363,
            "prompt_tokens": 712,
            "total_tokens": 1075,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "If an investment company starts the year with a value of $160 million and follows a \"2 and 20\" fee scheme, the management fee depends on the end-of-year asset value. With a soft hurdle rate of 10% net of management fee for calculating the incentive fee, and a prior high-water mark of $198 million, how much is the total fees collected if the assets increase by 25% in the coming year (in millions)? Answer to a single decimal place.",
        "python_solution": "def solution():\n    initial_aum = 160\n    growth_rate = 0.25\n    management_fee_rate = 0.02\n    soft_hurdle_rate = 0.10\n    high_water_mark = 198\n    incentive_rate = 0.2\n    \n    end_year_aum = initial_aum * (1 + growth_rate)\n    \n    management_fee = end_year_aum * management_fee_rate\n    \n    net_year_end = end_year_aum - management_fee\n    \n    if net_year_end < high_water_mark * (1 + soft_hurdle_rate):\n        total_fees = management_fee\n    else:\n        total_fees = management_fee + (net_year_end - high_water_mark * (1 + soft_hurdle_rate)) * incentive_rate\n\n    return total_fees",
        "ground_truth": 4.0,
        "topic": "Asset Classes & Derivatives",
        "statistics": {
            "number_statistics": {
                "args_numbers": 5,
                "question_numbers": 6,
                "context_numbers": 0,
                "total_numbers": 6
            },
            "operator_statistics": {
                "operators": {
                    "+": 4,
                    "-": 2,
                    "*": 5,
                    "/": 0,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 11
            },
            "code_statistics": {
                "lines": 14,
                "parentheses": 8
            }
        },
        "difficulty": 5.288267030694535,
        "source": "FinanceMath-validation-197",
        "context": "[]",
        "question_id": "test-2182",
        "level": "hard",
        "output": [
            "To solve the problem, let's analyze it step by step using the \"Emphasizing Constraints (EC)\" reasoning technique.\n\n### Step 1: Understand the \"2 and 20\" Fee Scheme\n- **Management Fee**: 2% of the end-of-year AUM (Assets Under Management).\n- **Incentive Fee**: 20% of returns surpassing the \"soft hurdle\" and the high-water mark threshold.\n\n### Step 2: Define Constraints and Inputs\n1. **Starting AUM**: $160 million.\n2. **Growth Rate**: A 25% increase in assets (e.g., starting AUM becomes $160 million \u00d7 1.25).\n3. **Management Fee Rate**: 2% (0.02 in decimal).\n4. **Soft Hurdle Rate**: 10% (0.10 in decimal), based on net AUM after the management fee.\n5. **High-Water Mark**: $198 million.\n6. **Incentive Fee Rate**: 20% (0.20 in decimal).\n\n### Step 3: Compute Fees\n1. **Year-End AUM Before Fees**: Compute the AUM including the 25% increase.\n   \\[\n   \\text{Year-End AUM} = \\text{Starting AUM} \\times (1 + \\text{Growth Rate})\n   \\]\n2. **Management Fee**:\n   \\[\n   \\text{Management Fee} = \\text{Year-End AUM} \\times \\text{Management Fee Rate}\n   \\]\n3. **Post-Management Fee AUM**:\n   \\[\n   \\text{Post-Management AUM} = \\text{Year-End AUM} - \\text{Management Fee}\n   \\]\n4. **Soft Hurdle Threshold**:\n   \\[\n   \\text{Soft Hurdle Threshold} = \\text{Starting AUM} \\times (1 + \\text{Soft Hurdle Rate})\n   \\]\n5. **Determine Incentive Fee Eligibility**:\n   - The incentive fee applies if both:\n     - Post-Management AUM exceeds the high-water mark ($198 million).\n     - Post-Management AUM surpasses the soft hurdle threshold.\n   - If eligible:\n     \\[\n     \\text{Incentive Fee} = (\\text{Post-Management AUM} - \\text{High-Water Mark}) \\times \\text{Incentive Rate}\n     \\]\n6. **Total Fees**:\n   \\[\n   \\text{Total Fees} = \\text{Management Fee} + \\text{Incentive Fee}\n   \\]\n\n### Step 4: Solve Step-by-Step to Adhere to Constraints\nThe solution will calculate all the above components step-by-step and ensure all constraints (e.g., fee structure percentages and thresholds) are respected.\n\nLet's implement the solution as a Python program:\n\n```python\ndef solution():\n    # Define variables name and value\n    starting_aum = 160  # in millions\n    growth_rate = 0.25  # 25% increase\n    management_fee_rate = 0.02  # 2% fee\n    soft_hurdle_rate = 0.10  # 10% hurdle\n    high_water_mark = 198  # in millions\n    incentive_rate = 0.20  # 20% incentive\n    \n    # Calculate Year-End AUM before fees\n    year_end_aum = starting_aum * (1 + growth_rate)\n    \n    # Calculate Management Fee\n    management_fee = year_end_aum * management_fee_rate\n    \n    # Calculate Post-Management AUM\n    post_management_aum = year_end_aum - management_fee\n    \n    # Calculate Soft Hurdle Threshold\n    soft_hurdle_threshold = starting_aum * (1 + soft_hurdle_rate)\n    \n    # Calculate Incentive Fee (if applicable)\n    incentive_fee = 0\n    if post_management_aum > high_water_mark and post_management_aum > soft_hurdle_threshold:\n        incentive_fee = (post_management_aum - high_water_mark) * incentive_rate\n    \n    # Calculate Total Fees\n    total_fees = management_fee + incentive_fee\n    \n    # Return total fees (rounded to 1 decimal place)\n    return round(total_fees, 1)\n```"
        ],
        "retrieval_query": "If an investment company starts the year with a value of $160 million and follows a \"2 and 20\" fee scheme, the management fee depends on the end-of-year asset value. With a soft hurdle rate of 10% net of management fee for calculating the incentive fee, and a prior high-water mark of $198 million, how much is the total fees collected if the assets increase by 25% in the coming year (in millions)? Answer to a single decimal place.",
        "useful_functions": [
            "def calculate_investor_net_return(aum_end_of_year: float, high_water_mark: float, \n                                  management_fee_rate: float, previous_assets_value: float, \n                                  incentive_fee_rate: float, hurdle_rate: float) -> float:\n    \"\"\"\n    Calculate the net return for an investor under a \"2 and 20\" fee arrangement.\n\n    This function determines the net return for an investor, given the end-of-year\n    assets under management (AUM), a high-water mark, management and incentive fee rates, \n    a hurdle rate, and the initial value of assets. It accounts for management fees and \n    calculates incentive fees only if the AUM surpasses the high-water mark adjusted by the hurdle rate.\n\n    Args:\n        aum_end_of_year (float): The assets under management at the end of the year.\n        high_water_mark (float): The benchmark value of assets before fees can be collected.\n        management_fee_rate (float): The rate applied to AUM for management fees.\n        previous_assets_value (float): The value of assets at the start of the year.\n        incentive_fee_rate (float): The rate applied to returns above the high-water mark.\n        hurdle_rate (float): The minimum rate of return required before incentive fees apply.\n\n    Returns:\n        net_return_percentage (float): The net return for the investor, expressed as a percentage.\n\n    Notes:\n        - Applicability: Suitable for investment firms using \"2 and 20\" fee structures.\n        - Constraints: Assumes positive values for all inputs.\n        - Considerations: Always round the final result to three decimal places for percentage representation.\n    \"\"\"\n    management_fee = aum_end_of_year * management_fee_rate\n    \n    if aum_end_of_year < high_water_mark * (1 + hurdle_rate):\n        total_fee = management_fee\n    else:\n        total_fee = management_fee + (aum_end_of_year - high_water_mark * (1 + hurdle_rate)) * incentive_fee_rate\n\n    net_return = (aum_end_of_year - total_fee) / previous_assets_value - 1\n\n    return round(net_return * 100, 3)",
            "def calculate_total_fees(starting_aum: float, fund_yield: float, management_fee_rate: float, \n                         soft_hurdle_rate: float, high_water_mark: float) -> float:\n    \"\"\"\n    Calculate the total fees garnered by a fund for a particular year.\n\n    This function computes the overall fees including management fees and potentially incentive fees \n    charged by a fund. The calculation is based on the fund's assets under management (AUM), its annual yield,\n    a pre-defined management fee rate, soft hurdle rate, and high-water mark for incentive fees.\n\n    Args:\n        starting_aum (float): The assets under management at the beginning of the year (in millions).\n        fund_yield (float): The yield of the fund for the year (expressed as a decimal).\n        management_fee_rate (float): The percentage management fee charged on year-end AUM (expressed as a decimal).\n        soft_hurdle_rate (float): The performance benchmark rate that must be exceeded for an incentive fee to be applied (expressed as a decimal).\n        high_water_mark (float): The minimum year-end AUM value to trigger incentive fees (in millions).\n\n    Returns:\n        total_fees (float): The total fees garnered by the fund for the year (in millions).\n\n    Notes:\n        - Applicability: This function is useful for funds that charge management and incentive fees\n          based on returns and benchmarks.\n        - Constraints: The incentive fee calculation here assumes no incentive fee is charged if the\n          year-end AUM is below the high-water mark.\n        - Considerations: Ensure starting_aum and high_water_mark are given in the same units (e.g., millions).\n    \"\"\"\n    # Calculate the year-end AUM before fees\n    end_of_year_aum = starting_aum * (1 + fund_yield)\n    \n    # Compute the management fee\n    management_fee = end_of_year_aum * management_fee_rate\n    \n    # Calculate post-management fee AUM\n    post_management_aum = end_of_year_aum - management_fee\n    \n    # Determine eligibility for incentive fees\n    incentive_fee = 0\n    profit_after_management_fee = post_management_aum - starting_aum\n    soft_hurdle_threshold = starting_aum * soft_hurdle_rate\n    \n    if profit_after_management_fee > soft_hurdle_threshold and post_management_aum > high_water_mark:\n        # Normally, calculate incentive fee percentage (if applicable) here\n        pass  # Placeholder, as incentive fee percentage is not provided in this general context\n    \n    # Calculate total fees\n    total_fees = management_fee + incentive_fee\n    \n    return total_fees",
            "def calculate_total_fees(initial_aum: float, growth_rate: float, management_fee_rate: float, \n                         soft_hurdle_rate: float, high_water_mark: float, incentive_rate: float) -> float:\n    \"\"\"\n    Calculate the total management and incentive fees for an investment fund.\n\n    This function calculates the total fees collected by an investment company \n    following a \"2 and 20\" fee scheme, considering management fees and potential \n    incentive fees based on performance against a soft hurdle rate and any high-water mark.\n\n    Args:\n        initial_aum (float): The initial value of assets under management (AUM) at the start of the year.\n        growth_rate (float): The growth rate of the assets over the year.\n        management_fee_rate (float): The management fee rate as a decimal (e.g., 2% as 0.02).\n        soft_hurdle_rate (float): The soft hurdle rate for performance calculation as a decimal (e.g., 10% as 0.10).\n        high_water_mark (float): The high-water mark value for calculating the incentive fee.\n        incentive_rate (float): The incentive fee rate as a decimal if applicable (e.g., 20% as 0.20).\n\n    Returns:\n        total_fees (float): The total fees collected, including management and any incentive fees.\n\n    Notes:\n        - Applicability: This function is applicable in scenarios where investment management fees follow\n          a structure based on performance and set benchmarks.\n        - Constraints: The initial_aum, high_water_mark, and rates must be positive values. \n        - Considerations: Ensure correct timing and order of fee assessments according to fund policies. \n          Assumes fees are applied at year-end and based on year-end valuations.\n    \"\"\"\n    # Calculate end-of-year asset value\n    end_year_aum = initial_aum * (1 + growth_rate)\n    \n    # Calculate management fee\n    management_fee = end_year_aum * management_fee_rate\n    \n    # Calculate net year-end asset value after management fee\n    net_year_end = end_year_aum - management_fee\n    \n    # Determine if incentive fee applies and calculate total fees\n    incentive_fee = 0\n    if net_year_end > high_water_mark * (1 + soft_hurdle_rate):\n        incentive_fee = (net_year_end - high_water_mark * (1 + soft_hurdle_rate)) * incentive_rate\n    \n    total_fees = management_fee + incentive_fee\n    \n    return total_fees"
        ],
        "usage": {
            "completion_tokens": 901,
            "prompt_tokens": 1943,
            "total_tokens": 2844,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-1279",
        "article_title": "Piotroski Score",
        "function": "def calculate_piotroski_score(net_income: float, roas: float, op_cash_flow: float, prev_op_cash_flow: float, \n                              long_term_debt: float, prev_long_term_debt: float, current_ratio: float, \n                              prev_current_ratio: float, new_shares_issued: bool, gross_margin: float, \n                              prev_gross_margin: float, asset_turnover: float, prev_asset_turnover: float) -> int:\n    \"\"\"\n    Calculate the Piotroski score for a company based on its financial statements.\n\n    This function computes the Piotroski score, which is a measure of a company's financial strength,\n    by evaluating profitability, leverage, liquidity, and operating efficiency using 9 predefined criteria.\n    Each criterion awards one point if the condition is met. The maximum possible score is 9.\n\n    Args:\n        net_income (float): The net income of the company for the current period.\n        roas (float): The return on assets for the current year.\n        op_cash_flow (float): The operating cash flow for the current period.\n        prev_op_cash_flow (float): The operating cash flow for the previous period.\n        long_term_debt (float): The amount of long-term debt for the current period.\n        prev_long_term_debt (float): The amount of long-term debt for the previous period.\n        current_ratio (float): The current ratio for the current period.\n        prev_current_ratio (float): The current ratio for the previous period.\n        new_shares_issued (bool): Whether new shares were issued in the current period (True if issued, False otherwise).\n        gross_margin (float): The gross margin for the current year.\n        prev_gross_margin (float): The gross margin for the previous year.\n        asset_turnover (float): The asset turnover ratio for the current year.\n        prev_asset_turnover (float): The asset turnover ratio for the previous year.\n\n    Returns:\n        piotroski_score (int): The Piotroski score, an integer between 0 and 9.\n\n    Notes:\n        - Applicability: Suitable for evaluating the financial strength of value stocks.\n        - Constraints: Assumes availability of the required financial data for both the current and previous periods.\n        - Considerations: This function is a simple method and does not capture all factors affecting financial health.\n    \"\"\"\n    score = 0\n\n    # Profitability criteria\n    if net_income > 0:\n        score += 1\n    if roas > 0:\n        score += 1\n    if op_cash_flow > 0:\n        score += 1\n    if op_cash_flow > net_income:\n        score += 1\n\n    # Leverage, liquidity, and source of funds criteria\n    if long_term_debt < prev_long_term_debt:\n        score += 1\n    if current_ratio > prev_current_ratio:\n        score += 1\n    if not new_shares_issued:\n        score += 1\n\n    # Operating efficiency criteria\n    if gross_margin > prev_gross_margin:\n        score += 1\n    if asset_turnover > prev_asset_turnover:\n        score += 1\n\n    return score",
        "statistics": {
            "number_statistics": {
                "args_numbers": 13,
                "question_numbers": 0,
                "context_numbers": 12,
                "total_numbers": 12
            },
            "operator_statistics": {
                "operators": {
                    "+": 9,
                    "-": 0,
                    "*": 0,
                    "/": 0,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 9
            },
            "code_statistics": {
                "lines": 23,
                "parentheses": 0
            }
        },
        "difficulty": 5.33271879326537,
        "context": "A financial analyst is reviewing the financial statements of XYZ Corporation to determine its financial health using the Piotroski score method for the fiscal year 2023. The following data is available:\n\n- Net income for 2023 is $1,200,000.\n- Return on assets (ROA) for 2023 is 4.5%.\n- Operating cash flow for 2023 is $1,500,000, while it was $1,200,000 in 2022.\n- Long-term debt has decreased from $5,000,000 in 2022 to $4,800,000 in 2023.\n- The current ratio improved from 1.3 in 2022 to 1.5 in 2023.\n- No new shares were issued in 2023.\n- Gross margin increased from 35% in 2022 to 38% in 2023.\n- Asset turnover ratio improved from 1.1 in 2022 to 1.2 in 2023.\n\nThe analyst wants to determine the Piotroski score for XYZ Corporation.",
        "question": "What is the Piotroski score for XYZ Corporation based on the given financial data for 2023? Provide your answer as an integer.",
        "python_solution": "def solution():\n    # Define variables from the problem statement\n    net_income = 1200000\n    roas = 0.045  # ROA as decimal\n    op_cash_flow = 1500000\n    prev_op_cash_flow = 1200000\n    long_term_debt = 4800000\n    prev_long_term_debt = 5000000\n    current_ratio = 1.5\n    prev_current_ratio = 1.3\n    new_shares_issued = False\n    gross_margin = 0.38  # Gross margin as decimal\n    prev_gross_margin = 0.35\n    asset_turnover = 1.2\n    prev_asset_turnover = 1.1\n\n    # Calculate Piotroski score\n    score = 0\n\n    # Profitability criteria\n    if net_income > 0:\n        score += 1\n    if roas > 0:\n        score += 1\n    if op_cash_flow > 0:\n        score += 1\n    if op_cash_flow > net_income:\n        score += 1\n\n    # Leverage, liquidity, and source of funds criteria\n    if long_term_debt < prev_long_term_debt:\n        score += 1\n    if current_ratio > prev_current_ratio:\n        score += 1\n    if not new_shares_issued:\n        score += 1\n\n    # Operating efficiency criteria\n    if gross_margin > prev_gross_margin:\n        score += 1\n    if asset_turnover > prev_asset_turnover:\n        score += 1\n\n    # Return the final score\n    return score",
        "ground_truth": 9,
        "source": "FinanceReasoning-test-341",
        "question_id": "test-2183",
        "level": "hard",
        "output": [
            "To solve this problem step by step, we'll adhere to the following constraints and reasoning:\n\n### Emphasizing Constraints (EC):\n1. Each of the nine criteria in the Piotroski score is evaluated independently and provides a score of 1 if the condition is satisfied, otherwise 0.\n2. Input parameters must match the types and intent of the calculation function provided (e.g., profitability, leverage, and efficiency must translate correctly based on the given data).\n3. The Piotroski score is an integer output within the range [0, 9]. Each criterion must be explicitly calculated and checked.\n\n### Step-by-Step Approach:\n1. **Profitability Criteria:**\n   - `Net income > 0`: Check if the company had positive net income in 2023.\n   - `ROA > 0`: Check if the return on assets for 2023 is positive.\n   - `Operating cash flow > 0`: Check if the operating cash flow for 2023 is positive.\n   - `Operating cash flow > Net income`: Determine if operating cash flow exceeds net income.\n\n2. **Leverage, Liquidity, and Source of Funds Criteria:**\n   - `Long-term debt has decreased`: Verify that the long-term debt in 2023 is less than in 2022.\n   - `Current ratio improvement`: Ensure that the current ratio in 2023 is greater than in 2022.\n   - `No new shares issued`: Confirm that no new shares were issued in 2023.\n\n3. **Operating Efficiency Criteria:**\n   - `Gross margin has increased`: Ensure that the gross margin in 2023 is higher than in 2022.\n   - `Asset turnover ratio has improved`: Check if the asset turnover ratio in 2023 is higher than in 2022.\n\n4. After analyzing all the criteria, the sum of all satisfied criteria will yield the Piotroski score.\n\nThe method ensures every parameter is verified according to its condition and adheres to the constraints.\n\nHere is the Python program to calculate the Piotroski score based on the given data:\n\n```python\ndef solution():\n    # Define variables name and value\n    net_income = 1200000  # Current net income (positive)\n    roas = 4.5  # Return on assets (positive)\n    op_cash_flow = 1500000  # Current operating cash flow\n    prev_op_cash_flow = 1200000  # Previous operating cash flow\n    long_term_debt = 4800000  # Current long-term debt\n    prev_long_term_debt = 5000000  # Previous long-term debt\n    current_ratio = 1.5  # Current ratio\n    prev_current_ratio = 1.3  # Previous current ratio\n    new_shares_issued = False  # No new shares issued\n    gross_margin = 38  # Current gross margin percentage\n    prev_gross_margin = 35  # Previous gross margin percentage\n    asset_turnover = 1.2  # Current asset turnover\n    prev_asset_turnover = 1.1  # Previous asset turnover\n\n    # Do math calculation to get the answer\n    score = 0\n\n    # Profitability criteria\n    if net_income > 0:\n        score += 1\n    if roas > 0:\n        score += 1\n    if op_cash_flow > 0:\n        score += 1\n    if op_cash_flow > net_income:\n        score += 1\n\n    # Leverage, liquidity, and source of funds criteria\n    if long_term_debt < prev_long_term_debt:\n        score += 1\n    if current_ratio > prev_current_ratio:\n        score += 1\n    if not new_shares_issued:\n        score += 1\n\n    # Operating efficiency criteria\n    if gross_margin > prev_gross_margin:\n        score += 1\n    if asset_turnover > prev_asset_turnover:\n        score += 1\n\n    # return answer\n    return score\n```"
        ],
        "retrieval_query": "What is the Piotroski score for XYZ Corporation based on the given financial data for 2023? Provide your answer as an integer.",
        "useful_functions": [
            "def calculate_piotroski_score(net_income: float, roas: float, op_cash_flow: float, prev_op_cash_flow: float, \n                              long_term_debt: float, prev_long_term_debt: float, current_ratio: float, \n                              prev_current_ratio: float, new_shares_issued: bool, gross_margin: float, \n                              prev_gross_margin: float, asset_turnover: float, prev_asset_turnover: float) -> int:\n    \"\"\"\n    Calculate the Piotroski score for a company based on its financial statements.\n\n    This function computes the Piotroski score, which is a measure of a company's financial strength,\n    by evaluating profitability, leverage, liquidity, and operating efficiency using 9 predefined criteria.\n    Each criterion awards one point if the condition is met. The maximum possible score is 9.\n\n    Args:\n        net_income (float): The net income of the company for the current period.\n        roas (float): The return on assets for the current year.\n        op_cash_flow (float): The operating cash flow for the current period.\n        prev_op_cash_flow (float): The operating cash flow for the previous period.\n        long_term_debt (float): The amount of long-term debt for the current period.\n        prev_long_term_debt (float): The amount of long-term debt for the previous period.\n        current_ratio (float): The current ratio for the current period.\n        prev_current_ratio (float): The current ratio for the previous period.\n        new_shares_issued (bool): Whether new shares were issued in the current period (True if issued, False otherwise).\n        gross_margin (float): The gross margin for the current year.\n        prev_gross_margin (float): The gross margin for the previous year.\n        asset_turnover (float): The asset turnover ratio for the current year.\n        prev_asset_turnover (float): The asset turnover ratio for the previous year.\n\n    Returns:\n        piotroski_score (int): The Piotroski score, an integer between 0 and 9.\n\n    Notes:\n        - Applicability: Suitable for evaluating the financial strength of value stocks.\n        - Constraints: Assumes availability of the required financial data for both the current and previous periods.\n        - Considerations: This function is a simple method and does not capture all factors affecting financial health.\n    \"\"\"\n    score = 0\n\n    # Profitability criteria\n    if net_income > 0:\n        score += 1\n    if roas > 0:\n        score += 1\n    if op_cash_flow > 0:\n        score += 1\n    if op_cash_flow > net_income:\n        score += 1\n\n    # Leverage, liquidity, and source of funds criteria\n    if long_term_debt < prev_long_term_debt:\n        score += 1\n    if current_ratio > prev_current_ratio:\n        score += 1\n    if not new_shares_issued:\n        score += 1\n\n    # Operating efficiency criteria\n    if gross_margin > prev_gross_margin:\n        score += 1\n    if asset_turnover > prev_asset_turnover:\n        score += 1\n\n    return score"
        ],
        "usage": {
            "completion_tokens": 834,
            "prompt_tokens": 1246,
            "total_tokens": 2080,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-729",
        "article_title": "Black Scholes Model",
        "function": "import math\nfrom scipy.stats import norm\n\ndef calculate_black_scholes_call_price(S: float, K: float, t: float, r: float, sigma: float) -> float:\n    \"\"\"\n    Calculate the Black-Scholes price of a European call option.\n\n    This function computes the theoretical price of a European call option using the Black-Scholes \n    model. The model estimates option prices by considering the following variables: the current \n    stock price, the option's strike price, the time to option expiration, the risk-free interest rate, \n    and the volatility of the underlying asset.\n\n    Args:\n        S (float): The current price of the underlying asset.\n        K (float): The strike price of the option.\n        t (float): The time to expiration in years.\n        r (float): The annual risk-free interest rate, expressed as a decimal.\n        sigma (float): The volatility of the underlying asset, expressed as a decimal.\n\n    Returns:\n        C (float): The estimated price of the European call option.\n\n    Notes:\n        - Applicability: This function is used only for pricing European call options which \n          can only be exercised at expiration.\n        - Constraints: The function assumes that the underlying asset pays no dividends, \n          volatility and risk-free rate are constant, and the asset returns are normally distributed.\n        - Considerations: This model may not be accurate for American options or in volatile markets \n          that deviate from its assumptions.\n    \"\"\"\n    if t <= 0 or S <= 0 or K <= 0 or sigma <= 0:\n        raise ValueError(\"Time to expiration, stock price, strike price, and volatility must be positive.\")\n    \n    d1 = (math.log(S / K) + (r + 0.5 * sigma ** 2) * t) / (sigma * math.sqrt(t))\n    d2 = d1 - sigma * math.sqrt(t)\n    \n    C = S * norm.cdf(d1) - K * math.exp(-r * t) * norm.cdf(d2)\n    \n    return C",
        "statistics": {
            "number_statistics": {
                "args_numbers": 5,
                "question_numbers": 0,
                "context_numbers": 5,
                "total_numbers": 5
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 3,
                    "*": 8,
                    "/": 2,
                    "%": 0,
                    "**": 1
                },
                "total_operators": 16
            },
            "code_statistics": {
                "lines": 4,
                "parentheses": 18
            }
        },
        "difficulty": 5.337538079701318,
        "context": "A financial analyst is evaluating the investment potential of European call options on a technology company's stock, which is currently trading at $120 per share. The options have a strike price of $130 and expire in 6 months. The current annual risk-free interest rate is 2.5%, while the stock's annual volatility is projected to be 25%. The analyst needs to estimate the theoretical price of these call options using the Black-Scholes model to make informed investment decisions.",
        "question": "What is the estimated price of the European call option based on the Black-Scholes model? Answer to two decimal places.",
        "python_solution": "def solution():\n    import math\n    from scipy.stats import norm\n\n    # Given parameters\n    S = 120  # Current stock price\n    K = 130  # Strike price\n    t = 0.5  # Time to expiration in years (6 months)\n    r = 0.025  # Annual risk-free interest rate (2.5%)\n    sigma = 0.25  # Volatility (25%)\n\n    # Calculate d1 and d2 using the Black-Scholes formula\n    d1 = (math.log(S / K) + (r + 0.5 * sigma ** 2) * t) / (sigma * math.sqrt(t))\n    d2 = d1 - sigma * math.sqrt(t)\n\n    # Calculate the call option price\n    C = S * norm.cdf(d1) - K * math.exp(-r * t) * norm.cdf(d2)\n\n    # Return the result rounded to two decimal places\n    return round(C, 2)\n\nsolution()",
        "ground_truth": 5.18,
        "source": "FinanceReasoning-test-75",
        "question_id": "test-2184",
        "level": "hard",
        "output": [
            "To calculate the theoretical price of the European call option based on the Black-Scholes option pricing model, we need to adhere to the constraints and perform the necessary calculations. Let's follow the step-by-step reasoning:\n\n### Step-by-Step Solution:\n\n1. **Emphasizing Constraints (EC)**:\n   - The inputs must be in the correct units and format:\n     - Stock price (S), strike price (K), and volatility (\u03c3) must be positive values.\n     - The risk-free interest rate (r) and time to maturity (T) must also be positive.\n   - Volatility and interest rate values must be expressed as decimals (e.g., 25% as 0.25).\n   - Time to expiration (T) must be in years, so 6 months will be converted to 0.5 years.\n   - The output should be rounded to two decimal places.\n\n2. **Inputs**:\n   - Stock price (S): $120\n   - Strike price (K): $130\n   - Risk-free interest rate (r): 2.5% = 0.025\n   - Time to maturity (T): 6 months = 0.5 years\n   - Volatility (\u03c3): 25% = 0.25\n\n3. **Formula**:\n   - Use the Black-Scholes formula for a call option:\n     \\[\n     C = S \\cdot N(d1) - K \\cdot e^{-rT} \\cdot N(d2)\n     \\]\n   - Where:\n     \\[\n     d1 = \\frac{\\ln(S / K) + \\left(r + \\frac{1}{2} \\cdot \\sigma^2\\right) \\cdot T}{\\sigma \\cdot \\sqrt{T}}\n     \\]\n     \\[\n     d2 = d1 - \\sigma \\cdot \\sqrt{T}\n     \\]\n   - \\(N(x)\\) is the cumulative distribution function (CDF) of the standard normal distribution.\n\n4. **Steps to Solve**:\n   - Compute \\(d1\\) using the given inputs.\n   - Compute \\(d2 = d1 - \\sigma \\cdot \\sqrt{T}\\).\n   - Use the CDF of the normal distribution to calculate \\(N(d1)\\) and \\(N(d2)\\).\n   - Plug the values into the Black-Scholes formula to compute the call option price \\(C\\).\n\n5. **Implementation**:\n   - Use Python's `math` and `scipy.stats.norm` libraries for log operations and normal distribution CDF.\n\nHere is the Python program to calculate the theoretical price of the European call option:\n\n```python\ndef solution():\n    from math import log, sqrt, exp\n    from scipy.stats import norm\n\n    # Define variables\n    S = 120  # Current stock price\n    K = 130  # Strike price\n    r = 0.025  # Risk-free annual interest rate (decimal)\n    T = 0.5  # Time to expiration in years (6 months = 0.5 years)\n    sigma = 0.25  # Annual volatility (decimal)\n\n    # Step 1: Calculate d1 and d2\n    d1 = (log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * sqrt(T))\n    d2 = d1 - sigma * sqrt(T)\n\n    # Step 2: Calculate the call option price using the Black-Scholes formula\n    call_price = S * norm.cdf(d1) - K * exp(-r * T) * norm.cdf(d2)\n\n    # Step 3: Return the price rounded to two decimal places\n    return round(call_price, 2)\n```"
        ],
        "retrieval_query": "What is the estimated price of the European call option based on the Black-Scholes model? Answer to two decimal places.",
        "useful_functions": [
            "def calculate_black_scholes_call_price(S: float, K: float, r: float, T: float, volatility: float) -> float:\n    \"\"\"\n    Calculate the European call option price using the Black-Scholes model.\n\n    This function computes the price of a European call option based on the Black-Scholes\n    option pricing model. It considers the option's underlying stock price, strike price,\n    risk-free interest rate, time to maturity, and volatility.\n\n    Args:\n        S (float): Current stock price.\n        K (float): Strike price of the option.\n        r (float): Risk-free interest rate (as a decimal).\n        T (float): Time to maturity in years.\n        volatility (float): Annualized volatility of the stock's returns (as a decimal).\n\n    Returns:\n        call_price (float): The calculated call option price.\n\n    Notes:\n        - This function assumes that the underlying stock does not pay dividends.\n        - European options can only be exercised at the expiration date.\n        - The volatility parameter should be the annualized standard deviation of returns.\n    \"\"\"\n    from math import log, sqrt, exp\n    from scipy.stats import norm\n\n    d1 = (log(S / K) + (r + 0.5 * volatility ** 2) * T) / (volatility * sqrt(T))\n    d2 = d1 - volatility * sqrt(T)\n\n    call_price = S * norm.cdf(d1) - K * exp(-r * T) * norm.cdf(d2)\n    \n    return call_price",
            "import math\nfrom scipy.stats import norm\n\ndef calculate_black_scholes_call_price(S: float, K: float, t: float, r: float, sigma: float) -> float:\n    \"\"\"\n    Calculate the Black-Scholes price of a European call option.\n\n    This function computes the theoretical price of a European call option using the Black-Scholes \n    model. The model estimates option prices by considering the following variables: the current \n    stock price, the option's strike price, the time to option expiration, the risk-free interest rate, \n    and the volatility of the underlying asset.\n\n    Args:\n        S (float): The current price of the underlying asset.\n        K (float): The strike price of the option.\n        t (float): The time to expiration in years.\n        r (float): The annual risk-free interest rate, expressed as a decimal.\n        sigma (float): The volatility of the underlying asset, expressed as a decimal.\n\n    Returns:\n        C (float): The estimated price of the European call option.\n\n    Notes:\n        - Applicability: This function is used only for pricing European call options which \n          can only be exercised at expiration.\n        - Constraints: The function assumes that the underlying asset pays no dividends, \n          volatility and risk-free rate are constant, and the asset returns are normally distributed.\n        - Considerations: This model may not be accurate for American options or in volatile markets \n          that deviate from its assumptions.\n    \"\"\"\n    if t <= 0 or S <= 0 or K <= 0 or sigma <= 0:\n        raise ValueError(\"Time to expiration, stock price, strike price, and volatility must be positive.\")\n    \n    d1 = (math.log(S / K) + (r + 0.5 * sigma ** 2) * t) / (sigma * math.sqrt(t))\n    d2 = d1 - sigma * math.sqrt(t)\n    \n    C = S * norm.cdf(d1) - K * math.exp(-r * t) * norm.cdf(d2)\n    \n    return C",
            "def black_scholes_option_price(stock_price: float, strike_price: float, time_to_expiration: float, \n                               risk_free_rate: float, volatility: float, option_type: str = 'call') -> float:\n    \"\"\"\n    Calculate the theoretical price of a European option using the Black-Scholes model.\n\n    This function computes the price of European call or put options using the Black-Scholes formula\n    based on input variables such as the underlying stock price, strike price, time to expiration,\n    risk-free rate, and volatility. It assumes a log-normal distribution of stock prices.\n\n    Args:\n        stock_price (float): The current price of the underlying stock.\n        strike_price (float): The strike price of the option.\n        time_to_expiration (float): Time to expiration in years.\n        risk_free_rate (float): The risk-free interest rate as a decimal.\n        volatility (float): The standard deviation of the stock's returns (volatility).\n        option_type (str, optional): The type of option to price ('call' or 'put'). Default is 'call'.\n\n    Returns:\n        option_price (float): The theoretical price of the option.\n\n    Notes:\n        - Applicability: Applies to European options only; not applicable to American options.\n        - Constraints: Assumes constant volatility and risk-free rate, no dividends.\n        - Considerations: Option type must be 'call' or 'put'; otherwise, raises ValueError.\n    \"\"\"\n    from math import log, sqrt, exp\n    from scipy.stats import norm\n\n    if option_type not in ['call', 'put']:\n        raise ValueError(\"Option type must be either 'call' or 'put'.\")\n\n    d1 = (log(stock_price / strike_price) + (risk_free_rate + 0.5 * volatility ** 2) * time_to_expiration) / (volatility * sqrt(time_to_expiration))\n    d2 = d1 - volatility * sqrt(time_to_expiration)\n\n    if option_type == 'call':\n        option_price = (stock_price * norm.cdf(d1)) - (strike_price * exp(-risk_free_rate * time_to_expiration) * norm.cdf(d2))\n    else:  # 'put'\n        option_price = (strike_price * exp(-risk_free_rate * time_to_expiration) * norm.cdf(-d2)) - (stock_price * norm.cdf(-d1))\n\n    return option_price"
        ],
        "usage": {
            "completion_tokens": 785,
            "prompt_tokens": 1708,
            "total_tokens": 2493,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-911",
        "article_title": "Merton Model",
        "function": "import math\nfrom scipy.stats import norm\n\ndef calculate_merton_equity_value(V_t: float, K: float, r: float, sigma_v: float, delta_T: float) -> float:\n    \"\"\"\n    Calculate the theoretical value of a company's equity using the Merton model.\n\n    The Merton model assesses the structural credit risk of a company by modeling its\n    equity as a call option on its assets, where the equity valuation takes into account\n    the volatility of the company's assets and the risk-free rate.\n\n    Args:\n        V_t (float): The current value of the company's assets.\n        K (float): The value of the company's debt.\n        r (float): The risk-free interest rate.\n        sigma_v (float): The standard deviation of the company's asset returns.\n        delta_T (float): The time to maturity, expressed in years.\n\n    Returns:\n        E (float): The theoretical value of the company's equity.\n\n    Notes:\n        - Applicability: This function is applicable for companies looking to evaluate\n          their structural credit risk using the Merton model framework.\n        - Constraints: Assumes no dividends are paid out and constant risk-free\n          rates and volatility.\n        - Considerations: The model is based on the assumption of efficient markets\n          and European-style option exercise at expiration.\n    \"\"\"\n    d1 = (math.log(V_t / K) + (r + 0.5 * sigma_v**2) * delta_T) / (sigma_v * math.sqrt(delta_T))\n    d2 = d1 - sigma_v * math.sqrt(delta_T)\n\n    E = V_t * norm.cdf(d1) - K * math.exp(-r * delta_T) * norm.cdf(d2)\n\n    return E",
        "statistics": {
            "number_statistics": {
                "args_numbers": 5,
                "question_numbers": 0,
                "context_numbers": 5,
                "total_numbers": 5
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 3,
                    "*": 8,
                    "/": 2,
                    "%": 0,
                    "**": 1
                },
                "total_operators": 16
            },
            "code_statistics": {
                "lines": 4,
                "parentheses": 18
            }
        },
        "difficulty": 5.337538079701318,
        "context": "A company is evaluating its risk exposure and needs to determine the theoretical value of its equity using the Merton model. Currently, the company's assets are valued at 150 million dollars. It has outstanding debt amounting to 100 million dollars, which will mature in 3 years. The risk-free interest rate is 5% per annum. Given the market conditions, the annual volatility of the company's assets is estimated to be 20%. The company assumes no dividends will be paid over this period and seeks to evaluate the equity value under these parameters.",
        "question": "What is the theoretical value of the company's equity according to the Merton model? Answer in million dollars to two decimal places.",
        "python_solution": "def solution():\n    import math\n    from scipy.stats import norm\n\n    # Given parameters\n    V_t = 150  # Current value of company's assets in million dollars\n    K = 100    # Value of the company's debt in million dollars\n    r = 0.05   # Risk-free interest rate (5%)\n    sigma_v = 0.20  # Standard deviation of the company's asset returns (20%)\n    delta_T = 3     # Time to maturity in years\n\n    # Merton model calculations\n    d1 = (math.log(V_t / K) + (r + 0.5 * sigma_v**2) * delta_T) / (sigma_v * math.sqrt(delta_T))\n    d2 = d1 - sigma_v * math.sqrt(delta_T)\n\n    E = V_t * norm.cdf(d1) - K * math.exp(-r * delta_T) * norm.cdf(d2)\n\n    # Return the theoretical value of the company's equity\n    return round(E, 2)\n\n# Example usage:\n# print(solution())  # Expected result should be the theoretical value in million dollars",
        "ground_truth": 64.83,
        "source": "FinanceReasoning-test-76",
        "question_id": "test-2185",
        "level": "hard",
        "output": [
            "### Step-by-Step Reasoning using Advanced Reasoning Techniques:\n\n#### 1. Emphasizing Constraints (EC):\n   - **Constraint 1:** The calculation of theoretical equity value must adhere strictly to the Merton model formula provided.\n   - **Constraint 2:** The final equity value must be rounded to **two decimal places** and expressed in **million dollars**.\n   - **Constraint 3:** Inputs such as asset value (150 million), debt (100 million), time (3 years), risk-free rate (5% pa), and volatility (20%) must be represented correctly, matching the requirements for the Merton model.\n   - **Constraint 4:** Ensure no dividends are paid over the period, as stipulated.\n   - **Units and Precision:** Intermediate results should maintain a sufficient level of precision to avoid rounding errors propagating until the final step.\n\n#### 2. Approach:\nThe Merton model treats a company's equity as a call option on its assets. We proceed with the following steps:\n   1. Input the known values: asset value \\(V_t\\), debt \\(K\\), risk-free rate \\(r\\), volatility \\(\\sigma_v\\), and time to maturity \\(\\Delta T\\).\n   2. Calculate \\(d1\\) and \\(d2\\) using their respective formulas:\n      \\[\n      d1 = \\frac{\\ln(V_t / K) + (r + 0.5 \\cdot \\sigma_v^2) \\cdot \\Delta T}{\\sigma_v \\cdot \\sqrt{\\Delta T}}\n      \\]\n      \\[\n      d2 = d1 - \\sigma_v \\cdot \\sqrt{\\Delta T}\n      \\]\n   3. Use the cumulative standard normal distribution (\\(N(d1)\\) and \\(N(d2)\\)) from the `scipy.stats.norm` library.\n   4. Compute the equity value (\\(E\\)):\n      \\[\n      E = V_t \\cdot N(d1) - K \\cdot e^{-r \\cdot \\Delta T} \\cdot N(d2)\n      \\]\n   5. Convert the result to million dollars and round to two decimal places.\n\nNow let\u2019s create the Python program:\n\n```python\nimport math\nfrom scipy.stats import norm\n\ndef solution():\n    # Define variables\n    V_t = 150  # Value of company's assets in million dollars\n    K = 100  # Value of company's debt in million dollars\n    r = 0.05  # Risk-free interest rate (5% per annum)\n    sigma_v = 0.2  # Annual volatility of the company's assets (20%)\n    delta_T = 3  # Time to maturity of debt in years\n    \n    # Calculate d1 and d2\n    d1 = (math.log(V_t / K) + (r + 0.5 * sigma_v**2) * delta_T) / (sigma_v * math.sqrt(delta_T))\n    d2 = d1 - sigma_v * math.sqrt(delta_T)\n    \n    # Calculate equity value (Merton model formula)\n    E = V_t * norm.cdf(d1) - K * math.exp(-r * delta_T) * norm.cdf(d2)\n    \n    # Convert to million dollars and round to two decimal places\n    answer = round(E, 2)\n    \n    # Return the final answer\n    return answer\n```"
        ],
        "retrieval_query": "What is the theoretical value of the company's equity according to the Merton model? Answer in million dollars to two decimal places.",
        "useful_functions": [
            "import math\nfrom scipy.stats import norm\n\ndef calculate_merton_equity_value(V_t: float, K: float, r: float, sigma_v: float, delta_T: float) -> float:\n    \"\"\"\n    Calculate the theoretical value of a company's equity using the Merton model.\n\n    The Merton model assesses the structural credit risk of a company by modeling its\n    equity as a call option on its assets, where the equity valuation takes into account\n    the volatility of the company's assets and the risk-free rate.\n\n    Args:\n        V_t (float): The current value of the company's assets.\n        K (float): The value of the company's debt.\n        r (float): The risk-free interest rate.\n        sigma_v (float): The standard deviation of the company's asset returns.\n        delta_T (float): The time to maturity, expressed in years.\n\n    Returns:\n        E (float): The theoretical value of the company's equity.\n\n    Notes:\n        - Applicability: This function is applicable for companies looking to evaluate\n          their structural credit risk using the Merton model framework.\n        - Constraints: Assumes no dividends are paid out and constant risk-free\n          rates and volatility.\n        - Considerations: The model is based on the assumption of efficient markets\n          and European-style option exercise at expiration.\n    \"\"\"\n    d1 = (math.log(V_t / K) + (r + 0.5 * sigma_v**2) * delta_T) / (sigma_v * math.sqrt(delta_T))\n    d2 = d1 - sigma_v * math.sqrt(delta_T)\n\n    E = V_t * norm.cdf(d1) - K * math.exp(-r * delta_T) * norm.cdf(d2)\n\n    return E"
        ],
        "usage": {
            "completion_tokens": 709,
            "prompt_tokens": 829,
            "total_tokens": 1538,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-1347",
        "article_title": "Principal, Interest, Taxes, Insurance (PITI)",
        "function": "def calculate_piti(principal: float, annual_interest_rate: float, loan_term_years: int, annual_tax: float, annual_insurance: float) -> float:\n    \"\"\"\n    Calculate the monthly PITI (Principal, Interest, Taxes, and Insurance) payment for a mortgage.\n\n    This function computes the monthly mortgage payment including principal, interest, property taxes,\n    and insurance, commonly referred to as PITI. This helps in assessing the affordability of a mortgage.\n\n    Args:\n        principal (float): The original loan amount (principal).\n        annual_interest_rate (float): The annual interest rate as a decimal (e.g., 0.06 for 6%).\n        loan_term_years (int): The term of the loan in years.\n        annual_tax (float): The annual property tax amount.\n        annual_insurance (float): The annual homeowners insurance amount.\n\n    Returns:\n        float: The total monthly PITI payment.\n\n    Notes:\n        - Applicability: This function is applicable for fixed-rate mortgage loans.\n        - Constraints: The loan term should be in whole years, and the interest rate should be in decimal form.\n        - Considerations: Additional monthly costs such as PMI, HOA fees, or variable interest rates are not included.\n    \"\"\"\n    monthly_interest_rate = annual_interest_rate / 12\n    num_payments = loan_term_years * 12\n\n    # Calculate monthly principal and interest payment using the formula for amortizing loans\n    if monthly_interest_rate > 0:\n        monthly_principal_and_interest = (principal * monthly_interest_rate) / (1 - (1 + monthly_interest_rate) ** -num_payments)\n    else:\n        monthly_principal_and_interest = principal / num_payments\n\n    # Calculate monthly tax and insurance\n    monthly_tax = annual_tax / 12\n    monthly_insurance = annual_insurance / 12\n\n    # Total monthly PITI payment\n    total_monthly_piti = monthly_principal_and_interest + monthly_tax + monthly_insurance\n\n    return total_monthly_piti",
        "statistics": {
            "number_statistics": {
                "args_numbers": 5,
                "question_numbers": 0,
                "context_numbers": 5,
                "total_numbers": 5
            },
            "operator_statistics": {
                "operators": {
                    "+": 3,
                    "-": 2,
                    "*": 2,
                    "/": 5,
                    "%": 0,
                    "**": 1
                },
                "total_operators": 13
            },
            "code_statistics": {
                "lines": 13,
                "parentheses": 6
            }
        },
        "difficulty": 5.337538079701318,
        "context": "John is planning to buy a house, and he wants to understand the monthly mortgage payment he would need to manage, including taxes and insurance. He has found a house for $300,000 and plans to take a mortgage for this amount. The bank offers him a fixed annual interest rate of 4.5% for a 30-year loan. Additionally, the annual property tax is estimated to be $3,600, and the annual homeowner's insurance will cost approximately $1,200.",
        "question": "What is the total monthly PITI (Principal, Interest, Taxes, and Insurance) payment John will need to make? Round your answer to the nearest dollar.",
        "python_solution": "def solution():\n    # Inputs based on the problem context\n    principal = 300000  # Loan amount\n    annual_interest_rate = 0.045  # Annual interest rate as a decimal\n    loan_term_years = 30  # Term of the loan in years\n    annual_tax = 3600  # Annual property tax\n    annual_insurance = 1200  # Annual homeowners insurance\n\n    # Calculate monthly interest rate\n    monthly_interest_rate = annual_interest_rate / 12\n\n    # Calculate the number of payments (in months)\n    num_payments = loan_term_years * 12\n\n    # Calculate the monthly principal and interest payment using the formula for amortizing loans\n    monthly_principal_and_interest = (principal * monthly_interest_rate) / (1 - (1 + monthly_interest_rate) ** -num_payments)\n\n    # Calculate monthly tax and insurance\n    monthly_tax = annual_tax / 12\n    monthly_insurance = annual_insurance / 12\n\n    # Calculate the total monthly PITI payment\n    total_monthly_piti = monthly_principal_and_interest + monthly_tax + monthly_insurance\n\n    # Return the result rounded to the nearest dollar\n    return round(total_monthly_piti)",
        "ground_truth": 1920,
        "source": "FinanceReasoning-test-82",
        "question_id": "test-2186",
        "level": "hard",
        "output": [
            "### Step-by-Step Thinking with Emphasizing Constraints (EC):\n\n1. **Understand the Problem**:\n   - John plans to purchase a house that costs $300,000.\n   - He is taking a fixed-rate mortgage loan of $300,000.\n   - Loan term is 30 years, and the annual interest rate is 4.5%.\n   - The monthly mortgage payment includes not just principal and interest but also taxes and insurance, commonly referred to as PITI.\n\n2. **Specified Inputs and Outputs**:\n   - Input Parameters:\n     - Principal (`$300,000`)\n     - Loan Term (`30 years` \u2192 fixed-term)\n     - Annual Interest Rate (`4.5%` \u2192 in decimal: `0.045`)\n     - Annual Property Tax (`$3,600`)\n     - Annual Insurance (`$1,200`)\n   - Output: The total monthly PITI payment rounded to the nearest dollar.\n\n3. **Constraints Relevant to the Problem**:\n   - The interest rate provided is fixed (no variability), and calculations need to use decimal notation (i.e., not 4.5%, but 0.045).\n   - The loan term and payments should be calculated in months, meaning we must consider 12 months per year and calculate the total number of payments.\n   - Monthly property tax and insurance must be derived by dividing annual values by 12.\n   - We should round the final PITI payment to the nearest dollar as per the question's requirement.\n   - Ensure the methodology adheres to formulas for amortizing loans and sum these aspects.\n\n4. **Plan the Solution**:\n   - Calculate the monthly principal and interest payment (`PI`) using the amortization formula:\n     \\[\n     \\text{Monthly Payment (PI)} = \\frac{P \\cdot r}{1 - (1 + r)^{-n}}\n     \\]\n     where:\n     \\(P\\) = Principal (\\$300,000)  \n     \\(r\\) = Monthly Interest Rate (Annual Interest Rate \u00f7 12 \u2192 0.045 \u00f7 12)  \n     \\(n\\) = Total Number of Payments (Loan Term in Years \u00d7 12 \u2192 30 \u00d7 12).\n   - Calculate the monthly property tax (`T`) by dividing annual tax (\\$3,600) by 12.\n   - Calculate the monthly insurance cost (`I`) by dividing annual insurance (\\$1,200) by 12.\n   - Add all components (`PI`, `T`, `I`) together to get the final monthly PITI payment.\n   - Round the result to the nearest dollar as instructed.\n\nHere\u2019s the Python program to implement the solution:\n\n```python\ndef solution():\n    # Define variables name and value\n    principal = 300000  # Loan amount in dollars\n    annual_interest_rate = 0.045  # Annual interest rate in decimal\n    loan_term_years = 30  # Loan term in years\n    annual_tax = 3600  # Annual property tax in dollars\n    annual_insurance = 1200  # Annual homeowner's insurance in dollars\n    \n    # Calculate monthly interest rate and total number of payments\n    monthly_interest_rate = annual_interest_rate / 12  # Monthly interest rate\n    num_payments = loan_term_years * 12  # Total number of monthly payments (n)\n    \n    # Calculate monthly principal and interest payment (PI)\n    if monthly_interest_rate > 0:\n        monthly_principal_and_interest = (principal * monthly_interest_rate) / \\\n                                          (1 - (1 + monthly_interest_rate) ** -num_payments)\n    else:\n        monthly_principal_and_interest = principal / num_payments  # For zero interest\n    \n    # Calculate monthly taxes and insurance\n    monthly_tax = annual_tax / 12  # Monthly tax payment\n    monthly_insurance = annual_insurance / 12  # Monthly insurance payment\n    \n    # Total monthly PITI payment\n    total_monthly_piti = monthly_principal_and_interest + monthly_tax + monthly_insurance\n    \n    # Round the total PITI payment to the nearest dollar\n    return round(total_monthly_piti)\n\n```"
        ],
        "retrieval_query": "What is the total monthly PITI (Principal, Interest, Taxes, and Insurance) payment John will need to make? Round your answer to the nearest dollar.",
        "useful_functions": [
            "def calculate_piti(principal: float, annual_interest_rate: float, loan_term_years: int, annual_tax: float, annual_insurance: float) -> float:\n    \"\"\"\n    Calculate the monthly PITI (Principal, Interest, Taxes, and Insurance) payment for a mortgage.\n\n    This function computes the monthly mortgage payment including principal, interest, property taxes,\n    and insurance, commonly referred to as PITI. This helps in assessing the affordability of a mortgage.\n\n    Args:\n        principal (float): The original loan amount (principal).\n        annual_interest_rate (float): The annual interest rate as a decimal (e.g., 0.06 for 6%).\n        loan_term_years (int): The term of the loan in years.\n        annual_tax (float): The annual property tax amount.\n        annual_insurance (float): The annual homeowners insurance amount.\n\n    Returns:\n        float: The total monthly PITI payment.\n\n    Notes:\n        - Applicability: This function is applicable for fixed-rate mortgage loans.\n        - Constraints: The loan term should be in whole years, and the interest rate should be in decimal form.\n        - Considerations: Additional monthly costs such as PMI, HOA fees, or variable interest rates are not included.\n    \"\"\"\n    monthly_interest_rate = annual_interest_rate / 12\n    num_payments = loan_term_years * 12\n\n    # Calculate monthly principal and interest payment using the formula for amortizing loans\n    if monthly_interest_rate > 0:\n        monthly_principal_and_interest = (principal * monthly_interest_rate) / (1 - (1 + monthly_interest_rate) ** -num_payments)\n    else:\n        monthly_principal_and_interest = principal / num_payments\n\n    # Calculate monthly tax and insurance\n    monthly_tax = annual_tax / 12\n    monthly_insurance = annual_insurance / 12\n\n    # Total monthly PITI payment\n    total_monthly_piti = monthly_principal_and_interest + monthly_tax + monthly_insurance\n\n    return total_monthly_piti"
        ],
        "usage": {
            "completion_tokens": 855,
            "prompt_tokens": 888,
            "total_tokens": 1743,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-2637",
        "article_title": "Stochastic Oscillator",
        "function": "def calculate_stochastic_oscillator(closing_prices: list, low_prices: list, high_prices: list, period: int = 14) -> list:\n    \"\"\"\n    Calculate the stochastic oscillator values for a series of prices.\n\n    This function computes the stochastic oscillator values based on the closing, low,\n    and high prices over a specified period. The stochastic oscillator is used as a \n    momentum indicator to identify overbought or oversold conditions in a security's\n    price movements.\n\n    Args:\n        closing_prices (list): A list of closing prices for the security.\n        low_prices (list): A list of the lowest prices for the security over the given periods.\n        high_prices (list): A list of the highest prices for the security over the given periods.\n        period (int): The number of periods to consider for calculating the oscillator, default is 14.\n\n    Returns:\n        stochastic_values (list): A list of stochastic oscillator values for each period.\n\n    Notes:\n        - Applicability: This function is useful for technical analysis in financial markets.\n        - Constraints: Lists of closing, low, and high prices must be of the same length and at least \n          as long as the specified period.\n        - Considerations: Ensure that all input price lists are synchronized and cover the same time frame.\n    \"\"\"\n    if len(closing_prices) < period or len(low_prices) < period or len(high_prices) < period:\n        raise ValueError(\"Price lists must contain at least 'period' number of elements.\")\n\n    stochastic_values = []\n    for i in range(len(closing_prices) - period + 1):\n        recent_close = closing_prices[i + period - 1]\n        period_low = min(low_prices[i:i + period])\n        period_high = max(high_prices[i:i + period])\n        \n        if period_high - period_low == 0:\n            stochastic_value = 0\n        else:\n            stochastic_value = ((recent_close - period_low) / (period_high - period_low)) * 100\n        \n        stochastic_values.append(stochastic_value)\n    \n    return stochastic_values",
        "statistics": {
            "number_statistics": {
                "args_numbers": 4,
                "question_numbers": 1,
                "context_numbers": 44,
                "total_numbers": 45
            },
            "operator_statistics": {
                "operators": {
                    "+": 4,
                    "-": 5,
                    "*": 1,
                    "/": 1,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 11
            },
            "code_statistics": {
                "lines": 11,
                "parentheses": 16
            }
        },
        "difficulty": 5.342334251964811,
        "context": "An investor is analyzing the stock performance of a company to determine potential buy and sell signals using the stochastic oscillator. They have recorded the following prices over a period of 14 days:\n- Closing Prices: [150, 152, 149, 153, 155, 154, 157, 159, 158, 160, 162, 161, 163, 164].\n- Low Prices: [148, 150, 147, 150, 151, 153, 156, 156, 157, 158, 159, 160, 161, 162].\n- High Prices: [153, 155, 152, 155, 157, 156, 160, 162, 161, 164, 165, 164, 166, 167].\n\nThe investor wants to calculate the stochastic oscillator value at the end of this period to assess if the stock is entering overbought territory (typically considered above 80%).",
        "question": "What is the stochastic oscillator value using the 14-day data provided? Answer as a percentage to two decimal places.",
        "python_solution": "def solution():\n    # Define the given prices\n    closing_prices = [150, 152, 149, 153, 155, 154, 157, 159, 158, 160, 162, 161, 163, 164]\n    low_prices = [148, 150, 147, 150, 151, 153, 156, 156, 157, 158, 159, 160, 161, 162]\n    high_prices = [153, 155, 152, 155, 157, 156, 160, 162, 161, 164, 165, 164, 166, 167]\n    period = 14\n\n    # Calculate the recent close, period low, and period high for the last 14 days\n    recent_close = closing_prices[period - 1]  # 164\n    period_low = min(low_prices[:period])      # 147\n    period_high = max(high_prices[:period])    # 167\n\n    # Calculate the stochastic oscillator value\n    if period_high - period_low == 0:\n        stochastic_value = 0\n    else:\n        stochastic_value = ((recent_close - period_low) / (period_high - period_low)) * 100\n\n    # Return the result rounded to two decimal places\n    return round(stochastic_value, 2)\n\n# Calculate and print the solution\nprint(\"Stochastic Oscillator Value:\", solution())",
        "ground_truth": 85.0,
        "source": "FinanceReasoning-test-59",
        "question_id": "test-2187",
        "level": "hard",
        "output": [
            "To calculate the stochastic oscillator value for the given 14-day data at the end of the period, the following steps will be taken:\n\n### Step-by-step reasoning:\n1. **Understand the Stochastic Oscillator Formula**:\n   The Stochastic Oscillator is calculated using the formula:\n   \\[\n   \\%K = \\frac{\\text{(Closing Price - Lowest Low)}}{\\text{(Highest High - Lowest Low)}} \\times 100\n   \\]\n   Here:\n   - \\( \\text{Closing Price} \\) = The closing price at the end of the period.\n   - \\( \\text{Lowest Low} \\) = The minimum low price over the past 14 days.\n   - \\( \\text{Highest High} \\) = The maximum high price over the past 14 days.\n\n2. **Constraints (EC)**:\n   - The calculation must consider exactly 14-day data based on the provided lists.\n   - Percent value output with two decimal precision is required.\n   - Ensure all prices align (same index positions in lists).\n\n3. **Input Validation**:\n   - Check if the lengths of the provided lists (Closing Prices, Low Prices, High Prices) are equal and at least 14 (as per the problem constraint).\n\n4. **Calculate \\( \\%K \\)**:\n   - Find the closing price on the 14th day.\n   - Compute the minimum low price and maximum high price over the entire 14-day period.\n   - Apply the Stochastic Oscillator formula.\n\n5. **Output the Result**:\n   - Present the result as a percentage rounded to two decimal places.\n\n---\n\nWith this reasoning, we can now formulate the Python program:\n\n```python\ndef solution():\n    # Define variables name and value\n    closing_prices = [150, 152, 149, 153, 155, 154, 157, 159, 158, 160, 162, 161, 163, 164]\n    low_prices = [148, 150, 147, 150, 151, 153, 156, 156, 157, 158, 159, 160, 161, 162]\n    high_prices = [153, 155, 152, 155, 157, 156, 160, 162, 161, 164, 165, 164, 166, 167]\n    period = 14\n\n    # Constraints validation\n    if len(closing_prices) < period or len(low_prices) < period or len(high_prices) < period:\n        raise ValueError(\"Price lists must contain at least 'period' number of elements.\")\n    \n    # Step 1: Get the recent closing price\n    recent_close = closing_prices[-1]  # Closing price on the 14th day\n    \n    # Step 2: Compute period low and high values\n    period_low = min(low_prices[-period:])  # Lowest low over 14 days\n    period_high = max(high_prices[-period:])  # Highest high over 14 days\n    \n    # Step 3: Compute Stochastic Oscillator (%K)\n    if period_high - period_low == 0:\n        stochastic_value = 0  # To avoid division-by-zero error\n    else:\n        stochastic_value = ((recent_close - period_low) / (period_high - period_low)) * 100\n    \n    # Step 4: Return the stochastic oscillator value rounded to two decimal places\n    answer = round(stochastic_value, 2)\n    return answer\n```"
        ],
        "retrieval_query": "What is the stochastic oscillator value using the 14-day data provided? Answer as a percentage to two decimal places.",
        "useful_functions": [
            "def calculate_stochastic_oscillator(closing_prices: list, low_prices: list, high_prices: list, period: int = 14) -> list:\n    \"\"\"\n    Calculate the stochastic oscillator values for a series of prices.\n\n    This function computes the stochastic oscillator values based on the closing, low,\n    and high prices over a specified period. The stochastic oscillator is used as a \n    momentum indicator to identify overbought or oversold conditions in a security's\n    price movements.\n\n    Args:\n        closing_prices (list): A list of closing prices for the security.\n        low_prices (list): A list of the lowest prices for the security over the given periods.\n        high_prices (list): A list of the highest prices for the security over the given periods.\n        period (int): The number of periods to consider for calculating the oscillator, default is 14.\n\n    Returns:\n        stochastic_values (list): A list of stochastic oscillator values for each period.\n\n    Notes:\n        - Applicability: This function is useful for technical analysis in financial markets.\n        - Constraints: Lists of closing, low, and high prices must be of the same length and at least \n          as long as the specified period.\n        - Considerations: Ensure that all input price lists are synchronized and cover the same time frame.\n    \"\"\"\n    if len(closing_prices) < period or len(low_prices) < period or len(high_prices) < period:\n        raise ValueError(\"Price lists must contain at least 'period' number of elements.\")\n\n    stochastic_values = []\n    for i in range(len(closing_prices) - period + 1):\n        recent_close = closing_prices[i + period - 1]\n        period_low = min(low_prices[i:i + period])\n        period_high = max(high_prices[i:i + period])\n        \n        if period_high - period_low == 0:\n            stochastic_value = 0\n        else:\n            stochastic_value = ((recent_close - period_low) / (period_high - period_low)) * 100\n        \n        stochastic_values.append(stochastic_value)\n    \n    return stochastic_values"
        ],
        "usage": {
            "completion_tokens": 736,
            "prompt_tokens": 994,
            "total_tokens": 1730,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-30",
        "article_title": "Yield to Maturity (YTM)",
        "function": "def calculate_yield_to_maturity(price: float, par_value: float, coupon_rate: float, periods: int, guess: float = 0.05) -> float:\n    \"\"\"\n    Calculate the yield to maturity (YTM) of a bond.\n\n    This function computes the yield to maturity, which is the internal rate of return\n    of a bond investment if held until maturity, assuming that all coupon payments are \n    reinvested at the same rate as the bond's current yield.\n\n    Args:\n        price (float): The current market price of the bond.\n        par_value (float): The face or par value of the bond.\n        coupon_rate (float): The coupon rate of the bond as a decimal (e.g., 0.05 for 5%).\n        periods (int): The total number of compounding periods (e.g., semi-annual periods).\n        guess (float): An initial guess for the YTM (default is 0.05 or 5%).\n\n    Returns:\n        ytm (float): The estimated yield to maturity of the bond.\n\n    Notes:\n        - The calculation uses a numerical approach (trial and error with linear interpolation).\n        - This function assumes that the bond's payments are semi-annual.\n        - It may not converge for bonds with very low or negative coupon rates.\n        - Should be used with caution when market conditions change interest rates significantly.\n    \"\"\"\n    from scipy.optimize import fsolve\n    \n    def bond_price(ytm):\n        return sum((coupon_rate * par_value) / (1 + ytm/2) ** (2 * t) for t in range(1, periods + 1)) + par_value / (1 + ytm/2) ** (2 * periods)\n\n    ytm, = fsolve(lambda y: bond_price(y) - price, guess)\n    return ytm",
        "statistics": {
            "number_statistics": {
                "args_numbers": 5,
                "question_numbers": 0,
                "context_numbers": 5,
                "total_numbers": 5
            },
            "operator_statistics": {
                "operators": {
                    "+": 4,
                    "-": 1,
                    "*": 3,
                    "/": 4,
                    "%": 0,
                    "**": 2
                },
                "total_operators": 14
            },
            "code_statistics": {
                "lines": 5,
                "parentheses": 20
            }
        },
        "difficulty": 5.3471075307174685,
        "context": "An investor is considering purchasing a corporate bond currently priced at $950. The bond has a face value of $1,000 and offers a coupon rate of 6% annually, paid semi-annually. The bond matures in 10 years, which means there are 20 semi-annual periods until maturity. The investor wants to determine the yield to maturity (YTM) of this bond to evaluate if it's a worthwhile investment compared to other opportunities in the market.",
        "question": "What is the yield to maturity (YTM) of the bond expressed as an annual percentage rate? Answer as a percentage to two decimal places.",
        "python_solution": "def solution():\n    # Define the variables from the problem statement\n    price = 950.0\n    par_value = 1000.0\n    annual_coupon_rate = 0.06\n    periods = 20\n\n    # Define a function to calculate the bond price for a given YTM\n    def bond_price(ytm):\n        semi_annual_coupon = annual_coupon_rate * par_value / 2  # Semi-annual coupon payment\n        total_coupon_value = sum(semi_annual_coupon / (1 + ytm/2) ** t for t in range(1, periods + 1))\n        present_value_of_par = par_value / (1 + ytm/2) ** periods\n        return total_coupon_value + present_value_of_par\n\n    # Define a method to solve for YTM using numerical approximation\n    def calculate_ytm():\n        guess = 0.05  # Initial guess for YTM\n        \n        # Manual iterative solving process using trial and error\n        lower_bound = 0.0\n        upper_bound = 1.0\n        \n        while upper_bound - lower_bound > 1e-5:  # Tolerance level\n            guess = (lower_bound + upper_bound) / 2\n            calculated_price = bond_price(guess)\n            \n            if calculated_price > price:  # If the guessed YTM results in a higher price, increase YTM\n                lower_bound = guess\n            else:\n                upper_bound = guess\n        \n        return guess\n\n    # Calculate YTM and format as a percentage\n    ytm = calculate_ytm()\n    ytm_as_percentage = ytm * 100\n    \n    # Return the annual YTM percentage up to two decimal places\n    return round(ytm_as_percentage, 2)\n\n# Perform the solution function to get the result\nytm_result = solution()\nytm_result",
        "ground_truth": 6.69,
        "source": "FinanceReasoning-test-63",
        "question_id": "test-2188",
        "level": "hard",
        "output": [
            "To solve this problem, let's use the \"Emphasizing Constraints\" (EC) technique. \n\n### Step 1: Identify Constraints and Problem Elements\n- **The Bond's Information**:\n  - Price today = $950\n  - Face Value (Par Value) = $1,000\n  - Annual coupon rate = 6% (expressed as 0.06 in decimal)\n  - Semi-annual coupon payment = Face Value * Coupon Rate / 2\n  - Number of periods = 10 years * 2 semi-annual periods = 20 periods\n- **Mathematical Constraints**:\n  - Yield to Maturity (YTM) is calculated as the internal rate of return (IRR) of the bond.\n  - YTM must be expressed as an **annual percentage rate** to two decimal places.\n- **Numerical Method**:\n  - Use the `calculate_yield_to_maturity` function provided above, which uses numerical approximation (`fsolve` from `scipy.optimize`) to calculate YTM.\n\n### Step 2: Calculation Method\n- Define all input variables: price, par value, coupon rate, number of periods, and initial guess for the solver.\n- Pass these inputs into the `calculate_yield_to_maturity` function to calculate YTM.\n- Return the calculated YTM as a percentage rounded to two decimal places.\n\nWith this structured reasoning, we can now implement the Python program.\n\n```python\ndef solution():\n    # Define variables name and value\n    price = 950  # Current price of the bond\n    par_value = 1000  # Face value (par value) of the bond\n    annual_coupon_rate = 0.06  # Annual coupon rate as a decimal\n    periods = 20  # Total number of semi-annual periods (10 years * 2)\n    semi_annual_coupon = par_value * annual_coupon_rate / 2  # Semi-annual coupon payment\n    guess = 0.05  # Initial guess for YTM (5%)\n    \n    # Define the YTM calculation function provided\n    def calculate_yield_to_maturity(price: float, par_value: float, coupon_rate: float, periods: int, guess: float = 0.05) -> float:\n        from scipy.optimize import fsolve\n        \n        def bond_price(ytm):\n            return sum((coupon_rate * par_value) / (1 + ytm/2) ** t for t in range(1, periods + 1)) + par_value / (1 + ytm/2) ** periods\n\n        ytm, = fsolve(lambda y: bond_price(y) - price, guess)\n        return ytm\n\n    # Calculate YTM\n    ytm_semi_annual = calculate_yield_to_maturity(\n        price=price,\n        par_value=par_value,\n        coupon_rate=annual_coupon_rate / 2,\n        periods=periods,\n        guess=guess\n    )\n    \n    # YTM as an annual percentage rate\n    ytm_annual = ytm_semi_annual * 2  # Convert semi-annual rate to annual rate\n    ytm_annual_percentage = round(ytm_annual * 100, 2)  # Express as percentage and round to 2 decimals\n    \n    # Return the final result\n    return ytm_annual_percentage\n```"
        ],
        "retrieval_query": "What is the yield to maturity (YTM) of the bond expressed as an annual percentage rate? Answer as a percentage to two decimal places.",
        "useful_functions": [
            "def calculate_yield_to_maturity(price: float, par_value: float, coupon_rate: float, periods: int, guess: float = 0.05) -> float:\n    \"\"\"\n    Calculate the yield to maturity (YTM) of a bond.\n\n    This function computes the yield to maturity, which is the internal rate of return\n    of a bond investment if held until maturity, assuming that all coupon payments are \n    reinvested at the same rate as the bond's current yield.\n\n    Args:\n        price (float): The current market price of the bond.\n        par_value (float): The face or par value of the bond.\n        coupon_rate (float): The coupon rate of the bond as a decimal (e.g., 0.05 for 5%).\n        periods (int): The total number of compounding periods (e.g., semi-annual periods).\n        guess (float): An initial guess for the YTM (default is 0.05 or 5%).\n\n    Returns:\n        ytm (float): The estimated yield to maturity of the bond.\n\n    Notes:\n        - The calculation uses a numerical approach (trial and error with linear interpolation).\n        - This function assumes that the bond's payments are semi-annual.\n        - It may not converge for bonds with very low or negative coupon rates.\n        - Should be used with caution when market conditions change interest rates significantly.\n    \"\"\"\n    from scipy.optimize import fsolve\n    \n    def bond_price(ytm):\n        return sum((coupon_rate * par_value) / (1 + ytm/2) ** (2 * t) for t in range(1, periods + 1)) + par_value / (1 + ytm/2) ** (2 * periods)\n\n    ytm, = fsolve(lambda y: bond_price(y) - price, guess)\n    return ytm"
        ],
        "usage": {
            "completion_tokens": 700,
            "prompt_tokens": 843,
            "total_tokens": 1543,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-1959",
        "article_title": "Trend Analysis",
        "function": "def perform_linear_regression(x_values: list, y_values: list) -> tuple:\n    \"\"\"\n    Perform linear regression to model the relationship between two variables.\n\n    This function fits a linear equation to the observed data points and calculates\n    the slope and intercept of the trend line. It is useful for identifying trends\n    and predicting values.\n\n    Args:\n        x_values (list): A list of independent variable data points.\n        y_values (list): A list of dependent variable data points. Must have the same length as x_values.\n\n    Returns:\n        regression_parameters (tuple): A tuple containing the slope and intercept of the best-fit line.\n\n    Notes:\n        - The input lists must have at least two points and must be of equal length.\n        - The trend line is calculated using the least squares method.\n    \"\"\"\n    if len(x_values) != len(y_values):\n        raise ValueError(\"Input lists must be of the same length.\")\n    \n    if len(x_values) < 2:\n        raise ValueError(\"At least two data points are required for linear regression.\")\n\n    n = len(x_values)\n    sum_x = sum(x_values)\n    sum_y = sum(y_values)\n    sum_x_squared = sum(x ** 2 for x in x_values)\n    sum_xy = sum(x * y for x, y in zip(x_values, y_values))\n\n    # Calculate slope and intercept\n    slope = (n * sum_xy - sum_x * sum_y) / (n * sum_x_squared - sum_x ** 2)\n    intercept = (sum_y - slope * sum_x) / n\n    \n    return slope, intercept",
        "statistics": {
            "number_statistics": {
                "args_numbers": 2,
                "question_numbers": 0,
                "context_numbers": 16,
                "total_numbers": 16
            },
            "operator_statistics": {
                "operators": {
                    "+": 0,
                    "-": 3,
                    "*": 5,
                    "/": 2,
                    "%": 0,
                    "**": 2
                },
                "total_operators": 12
            },
            "code_statistics": {
                "lines": 9,
                "parentheses": 18
            }
        },
        "difficulty": 5.375278407684165,
        "context": "A financial analyst is examining the performance of a mutual fund over the past months to understand how daily changes in market index values impact the fund's net asset value (NAV). The analyst collected data for 5 days, where the market index values (independent variable) and corresponding NAV changes (dependent variable) are as follows:\n\n- Day 1: Market Index = 3, NAV Change = 5\n- Day 2: Market Index = 2, NAV Change = 4\n- Day 3: Market Index = 4, NAV Change = 6\n- Day 4: Market Index = 5, NAV Change = 7\n- Day 5: Market Index = 6, NAV Change = 9\n\nUsing linear regression, the analyst wants to model the relationship between these variables to predict the NAV change for a given market index value.",
        "question": "What is the slope of the linear regression line, representing the change in the fund's NAV per unit change in the market index value? Calculate to two decimal places.",
        "python_solution": "def solution():\n    # Define the data points\n    x_values = [3, 2, 4, 5, 6]  # Market index values\n    y_values = [5, 4, 6, 7, 9]  # NAV changes\n    \n    # Calculate the number of data points\n    n = len(x_values)\n    \n    # Calculate sums needed for the formula\n    sum_x = sum(x_values)\n    sum_y = sum(y_values)\n    sum_x_squared = sum(x ** 2 for x in x_values)\n    sum_xy = sum(x * y for x, y in zip(x_values, y_values))\n    \n    # Apply the linear regression formula to find the slope\n    slope = (n * sum_xy - sum_x * sum_y) / (n * sum_x_squared - sum_x ** 2)\n    \n    # Return the slope rounded to two decimal places\n    return round(slope, 2)",
        "ground_truth": 1.2,
        "source": "FinanceReasoning-test-95",
        "question_id": "test-2189",
        "level": "hard",
        "output": [
            "To solve the problem, I will follow these steps using the EC technique to adhere to all constraints:\n\n### Step-by-Step Analysis:\n1. **Linear Regression Context**:\n    - The linear regression equation is in the form: \\( y = mx + b \\),\n      where \\( m \\) represents the slope of the line.\n    - Slope \\( m \\) is calculated as:\n      \\[\n      m = \\frac{n(\\sum xy) - (\\sum x)(\\sum y)}{n(\\sum x^2) - (\\sum x)^2}\n      \\]\n      Here:\n      - \\( x \\): Independent variable (Market Index Values)\n      - \\( y \\): Dependent variable (NAV Changes)\n\n2. **Extract and Assign Given Data**:\n    - Assign market index and NAV change data: \\( x = [3, 2, 4, 5, 6] \\), \\( y = [5, 4, 6, 7, 9] \\). The sample size \\( n = 5 \\).\n\n3. **Perform Calculations**:\n    - Compute \\(\\sum x\\), \\(\\sum y\\), \\(\\sum xy\\), and \\(\\sum x^2\\), which are required for the slope formula.\n\n4. **Ensure Constraints**:\n    - The slope should be calculated to two decimals of precision.\n    - Use only the given data for deriving the slope (no external library for regression).\n\n5. **Implementation in Python**:\n    - Write the program to compute the slope using the provided formula and constraints.\n\nHere is the Python program:\n\n```python\ndef solution():\n    # Define variables name and value\n    x = [3, 2, 4, 5, 6]  # Market Index Values\n    y = [5, 4, 6, 7, 9]  # NAV Changes\n    n = len(x)  # Number of data points (5 days)\n\n    # Calculate the summations needed for the formula\n    sum_x = sum(x)\n    sum_y = sum(y)\n    sum_xy = sum(x[i] * y[i] for i in range(n))\n    sum_x_squared = sum(x[i] ** 2 for i in range(n))\n\n    # Compute the slope (m) using the formula\n    numerator = n * sum_xy - sum_x * sum_y\n    denominator = n * sum_x_squared - (sum_x ** 2)\n    m = numerator / denominator  # Slope (change in NAV per unit change in Market Index)\n\n    # Return the slope rounded to 2 decimal places\n    return round(m, 2)\n```"
        ],
        "retrieval_query": "What is the slope of the linear regression line, representing the change in the fund's NAV per unit change in the market index value? Calculate to two decimal places.",
        "useful_functions": [],
        "usage": {
            "completion_tokens": 555,
            "prompt_tokens": 534,
            "total_tokens": 1089,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "An investment firm implements a \"2 and 20\" fee arrangement, the current value of assets is $515, the management fee is determined by the value of assets at end of the year, a 5% hurdle rate is established prior to the collection of the incentive fee, and the present high-water mark is $540. After a period of one year, the value of the investment firm is $602.5. What is the investor's net return? Answer to three decimal places.",
        "python_solution": "def solution():\n    AUM_end_of_year = 602.5\n    high_water_mark = 540\n    management_fee_rate = 0.02\n    previous_assets_value = 515\n    incentive_fee_rate = 0.2\n    hurdle_rate = 0.05\n    \n    management_fee = AUM_end_of_year * management_fee_rate\n    \n    if AUM_end_of_year < high_water_mark * (1 + hurdle_rate):\n        total_fee = management_fee\n    else:\n        total_fee = management_fee + (AUM_end_of_year - high_water_mark * (1 + hurdle_rate)) * incentive_fee_rate\n\n    net_return = (AUM_end_of_year - total_fee) / previous_assets_value - 1\n\n    return round(net_return * 100, 3)  # it's usually more intuitive to express return rate in percentage.\n",
        "ground_truth": 13.272,
        "topic": "Asset Classes & Derivatives",
        "statistics": {
            "number_statistics": {
                "args_numbers": 5,
                "question_numbers": 6,
                "context_numbers": 0,
                "total_numbers": 6
            },
            "operator_statistics": {
                "operators": {
                    "+": 3,
                    "-": 3,
                    "*": 5,
                    "/": 1,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 12
            },
            "code_statistics": {
                "lines": 13,
                "parentheses": 10
            }
        },
        "difficulty": 5.375278407684165,
        "source": "FinanceMath-validation-57",
        "context": "[]",
        "question_id": "test-2190",
        "level": "hard",
        "output": [
            "To solve the given problem, let's approach it step by step using the \"Emphasizing Constraints\" (EC) reasoning technique. \n\n### Problem Breakdown Step-by-Step:\n1. **Fee Structure and Constraints**:\n   - **Management Fee**: A flat annual fee calculated as 2% of the year-end assets under management (AUM).\n   - **Incentive Fee**: A performance-based fee (20%) charged only on returns above the hurdle rate (5%) of the high-water mark.\n   - **High-Water Mark**: The minimum value ($540) set as a performance threshold before incentive fees can be applied.\n   - Constraints:\n     - Incentive fees are applicable only if the year-end AUM exceeds both:\n       1. The high-water mark.\n       2. The high-water mark adjusted for the hurdle rate.\n\n2. **Input Data**: \n   - **Initial AUM (beginning of the year)**: $515.\n   - **Year-End AUM**: $602.5.\n   - **High-Water Mark**: $540.\n   - **Management Fee Rate**: 2% or 0.02.\n   - **Incentive Fee Rate**: 20% or 0.20.\n   - **Hurdle Rate**: 5% or 0.05.\n\n3. **Objectives**:\n   - Compute the total fees (management + incentive).\n   - Calculate the investor\u2019s net return after deducting all applicable fees.\n\n4. **Key Calculations**:\n   - **Management Fee**: 2% of the year-end AUM.\n   - **Hurdle Threshold**: High-water mark adjusted by the hurdle rate: \\( \\text{high_water_mark} \\times (1 + \\text{hurdle_rate}) \\).\n   - **Excess Return Threshold**: Year-end AUM - hurdle threshold.\n   - If the year-end AUM surpasses the hurdle threshold, calculate the incentive fee as: \\( \\text{Excess Return Threshold} \\times \\text{incentive_fee_rate} \\).\n   - Compute total return net of fees: \\( \\left( \\frac{\\text{Year-End AUM} - \\text{Total Fees}}{\\text{Initial AUM}} \\right) - 1 \\).\n\n5. **Constraints Application**:\n   - All calculations need to adhere to the input constraints (e.g., percentages and asset values in decimal precision).\n   - Ensure that the final net return is rounded to three decimal places (percentage representation).\n\n### Python Program:\nHere is the Python implementation that adheres to the described steps and constraints:\n\n```python\ndef solution():\n    # Define variables\n    initial_aum = 515\n    year_end_aum = 602.5\n    high_water_mark = 540\n    management_fee_rate = 0.02\n    incentive_fee_rate = 0.20\n    hurdle_rate = 0.05\n    \n    # Step 1: Calculate the management fee\n    management_fee = year_end_aum * management_fee_rate\n    \n    # Step 2: Determine if the incentive fee applies\n    hurdle_threshold = high_water_mark * (1 + hurdle_rate)\n    if year_end_aum > hurdle_threshold:\n        # Calculate incentive fee only on the excess return above hurdle threshold\n        excess_return = year_end_aum - hurdle_threshold\n        incentive_fee = excess_return * incentive_fee_rate\n    else:\n        # No incentive fee applicable\n        incentive_fee = 0\n    \n    # Step 3: Calculate total fees\n    total_fees = management_fee + incentive_fee\n    \n    # Step 4: Calculate net return for the investor (after fees)\n    net_return = (year_end_aum - total_fees) / initial_aum - 1  # As a decimal\n    \n    # Return the result rounded to three decimal places\n    return round(net_return * 100, 3)\n```"
        ],
        "retrieval_query": "An investment firm implements a \"2 and 20\" fee arrangement, the current value of assets is $515, the management fee is determined by the value of assets at end of the year, a 5% hurdle rate is established prior to the collection of the incentive fee, and the present high-water mark is $540. After a period of one year, the value of the investment firm is $602.5. What is the investor's net return? Answer to three decimal places.",
        "useful_functions": [
            "def calculate_investor_net_return(aum_end_of_year: float, high_water_mark: float, \n                                  management_fee_rate: float, previous_assets_value: float, \n                                  incentive_fee_rate: float, hurdle_rate: float) -> float:\n    \"\"\"\n    Calculate the net return for an investor under a \"2 and 20\" fee arrangement.\n\n    This function determines the net return for an investor, given the end-of-year\n    assets under management (AUM), a high-water mark, management and incentive fee rates, \n    a hurdle rate, and the initial value of assets. It accounts for management fees and \n    calculates incentive fees only if the AUM surpasses the high-water mark adjusted by the hurdle rate.\n\n    Args:\n        aum_end_of_year (float): The assets under management at the end of the year.\n        high_water_mark (float): The benchmark value of assets before fees can be collected.\n        management_fee_rate (float): The rate applied to AUM for management fees.\n        previous_assets_value (float): The value of assets at the start of the year.\n        incentive_fee_rate (float): The rate applied to returns above the high-water mark.\n        hurdle_rate (float): The minimum rate of return required before incentive fees apply.\n\n    Returns:\n        net_return_percentage (float): The net return for the investor, expressed as a percentage.\n\n    Notes:\n        - Applicability: Suitable for investment firms using \"2 and 20\" fee structures.\n        - Constraints: Assumes positive values for all inputs.\n        - Considerations: Always round the final result to three decimal places for percentage representation.\n    \"\"\"\n    management_fee = aum_end_of_year * management_fee_rate\n    \n    if aum_end_of_year < high_water_mark * (1 + hurdle_rate):\n        total_fee = management_fee\n    else:\n        total_fee = management_fee + (aum_end_of_year - high_water_mark * (1 + hurdle_rate)) * incentive_fee_rate\n\n    net_return = (aum_end_of_year - total_fee) / previous_assets_value - 1\n\n    return round(net_return * 100, 3)",
            "def calculate_total_fees(starting_aum: float, fund_yield: float, management_fee_rate: float, \n                         soft_hurdle_rate: float, high_water_mark: float) -> float:\n    \"\"\"\n    Calculate the total fees garnered by a fund for a particular year.\n\n    This function computes the overall fees including management fees and potentially incentive fees \n    charged by a fund. The calculation is based on the fund's assets under management (AUM), its annual yield,\n    a pre-defined management fee rate, soft hurdle rate, and high-water mark for incentive fees.\n\n    Args:\n        starting_aum (float): The assets under management at the beginning of the year (in millions).\n        fund_yield (float): The yield of the fund for the year (expressed as a decimal).\n        management_fee_rate (float): The percentage management fee charged on year-end AUM (expressed as a decimal).\n        soft_hurdle_rate (float): The performance benchmark rate that must be exceeded for an incentive fee to be applied (expressed as a decimal).\n        high_water_mark (float): The minimum year-end AUM value to trigger incentive fees (in millions).\n\n    Returns:\n        total_fees (float): The total fees garnered by the fund for the year (in millions).\n\n    Notes:\n        - Applicability: This function is useful for funds that charge management and incentive fees\n          based on returns and benchmarks.\n        - Constraints: The incentive fee calculation here assumes no incentive fee is charged if the\n          year-end AUM is below the high-water mark.\n        - Considerations: Ensure starting_aum and high_water_mark are given in the same units (e.g., millions).\n    \"\"\"\n    # Calculate the year-end AUM before fees\n    end_of_year_aum = starting_aum * (1 + fund_yield)\n    \n    # Compute the management fee\n    management_fee = end_of_year_aum * management_fee_rate\n    \n    # Calculate post-management fee AUM\n    post_management_aum = end_of_year_aum - management_fee\n    \n    # Determine eligibility for incentive fees\n    incentive_fee = 0\n    profit_after_management_fee = post_management_aum - starting_aum\n    soft_hurdle_threshold = starting_aum * soft_hurdle_rate\n    \n    if profit_after_management_fee > soft_hurdle_threshold and post_management_aum > high_water_mark:\n        # Normally, calculate incentive fee percentage (if applicable) here\n        pass  # Placeholder, as incentive fee percentage is not provided in this general context\n    \n    # Calculate total fees\n    total_fees = management_fee + incentive_fee\n    \n    return total_fees",
            "def calculate_total_fees(initial_aum: float, growth_rate: float, management_fee_rate: float, \n                         soft_hurdle_rate: float, high_water_mark: float, incentive_rate: float) -> float:\n    \"\"\"\n    Calculate the total management and incentive fees for an investment fund.\n\n    This function calculates the total fees collected by an investment company \n    following a \"2 and 20\" fee scheme, considering management fees and potential \n    incentive fees based on performance against a soft hurdle rate and any high-water mark.\n\n    Args:\n        initial_aum (float): The initial value of assets under management (AUM) at the start of the year.\n        growth_rate (float): The growth rate of the assets over the year.\n        management_fee_rate (float): The management fee rate as a decimal (e.g., 2% as 0.02).\n        soft_hurdle_rate (float): The soft hurdle rate for performance calculation as a decimal (e.g., 10% as 0.10).\n        high_water_mark (float): The high-water mark value for calculating the incentive fee.\n        incentive_rate (float): The incentive fee rate as a decimal if applicable (e.g., 20% as 0.20).\n\n    Returns:\n        total_fees (float): The total fees collected, including management and any incentive fees.\n\n    Notes:\n        - Applicability: This function is applicable in scenarios where investment management fees follow\n          a structure based on performance and set benchmarks.\n        - Constraints: The initial_aum, high_water_mark, and rates must be positive values. \n        - Considerations: Ensure correct timing and order of fee assessments according to fund policies. \n          Assumes fees are applied at year-end and based on year-end valuations.\n    \"\"\"\n    # Calculate end-of-year asset value\n    end_year_aum = initial_aum * (1 + growth_rate)\n    \n    # Calculate management fee\n    management_fee = end_year_aum * management_fee_rate\n    \n    # Calculate net year-end asset value after management fee\n    net_year_end = end_year_aum - management_fee\n    \n    # Determine if incentive fee applies and calculate total fees\n    incentive_fee = 0\n    if net_year_end > high_water_mark * (1 + soft_hurdle_rate):\n        incentive_fee = (net_year_end - high_water_mark * (1 + soft_hurdle_rate)) * incentive_rate\n    \n    total_fees = management_fee + incentive_fee\n    \n    return total_fees"
        ],
        "usage": {
            "completion_tokens": 819,
            "prompt_tokens": 1944,
            "total_tokens": 2763,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-1744",
        "article_title": "Dispersion",
        "function": "def calculate_beta(asset_returns: list, benchmark_returns: list) -> float:\n    \"\"\"\n    Calculate the beta of a security relative to a benchmark index.\n\n    This function computes the beta, which measures the volatility or systematic\n    risk of a security or portfolio in comparison to the market as a whole.\n\n    Args:\n        asset_returns (list): A list of returns for the asset in question.\n        benchmark_returns (list): A list of returns for the benchmark index,\n                                  such as the S&P 500.\n\n    Returns:\n        beta (float): The beta of the asset relative to the benchmark.\n\n    Notes:\n        - Applicability: Use this function to assess the relative risk of an asset.\n        - Constraints: The lengths of asset_returns and benchmark_returns\n                       must match.\n        - Considerations: A beta of 1 indicates that the asset's price moves\n                          with the market. A beta greater than 1 indicates greater\n                          volatility than the market, and less than 1 indicates\n                          less volatility.\n    \"\"\"\n    if len(asset_returns) != len(benchmark_returns):\n        raise ValueError(\"The returns lists must be of the same length.\")\n\n    covariance = sum((a - sum(asset_returns) / len(asset_returns)) * \n                     (b - sum(benchmark_returns) / len(benchmark_returns)) \n                     for a, b in zip(asset_returns, benchmark_returns)) / len(asset_returns)\n                     \n    variance = sum((b - sum(benchmark_returns) / len(benchmark_returns)) ** 2 for b in benchmark_returns) / len(benchmark_returns)\n    \n    beta = covariance / variance\n\n    return beta",
        "statistics": {
            "number_statistics": {
                "args_numbers": 2,
                "question_numbers": 1,
                "context_numbers": 11,
                "total_numbers": 12
            },
            "operator_statistics": {
                "operators": {
                    "+": 0,
                    "-": 3,
                    "*": 1,
                    "/": 6,
                    "%": 0,
                    "**": 1
                },
                "total_operators": 11
            },
            "code_statistics": {
                "lines": 6,
                "parentheses": 28
            }
        },
        "difficulty": 5.393627546352361,
        "context": "A financial analyst is evaluating the performance of TechInnovate Inc.'s stock compared to the Nasdaq Composite Index over the past 5 months. The monthly returns of TechInnovate Inc.'s stock were 4%, -2%, 3%, 5%, and -1%. During the same period, the returns of the Nasdaq Composite Index were 3%, -1%, 4%, 2%, and 0%. The analyst wants to assess the volatility of TechInnovate Inc.'s stock relative to the market by calculating its beta.",
        "question": "What is the beta of TechInnovate Inc.'s stock relative to the Nasdaq Composite Index based on the past 5 months' returns? Answer as a decimal to two decimal places.",
        "python_solution": "def solution():\n    # Define returns for the asset and the benchmark\n    asset_returns = [0.04, -0.02, 0.03, 0.05, -0.01]  # TechInnovate Inc.\n    benchmark_returns = [0.03, -0.01, 0.04, 0.02, 0.00]  # Nasdaq Composite Index\n\n    # Calculate the means of the asset and benchmark returns\n    mean_asset_returns = sum(asset_returns) / len(asset_returns)\n    mean_benchmark_returns = sum(benchmark_returns) / len(benchmark_returns)\n    \n    # Calculate the covariance between the asset and benchmark returns\n    covariance = sum((a - mean_asset_returns) * (b - mean_benchmark_returns)\n                     for a, b in zip(asset_returns, benchmark_returns)) / len(asset_returns)\n    \n    # Calculate the variance of the benchmark returns\n    variance = sum((b - mean_benchmark_returns) ** 2 for b in benchmark_returns) / len(benchmark_returns)\n    \n    # Compute the beta of the asset\n    beta = covariance / variance\n    \n    # Return the computed beta, rounded to two decimal places\n    return round(beta, 2)",
        "ground_truth": 1.26,
        "source": "FinanceReasoning-test-99",
        "question_id": "test-2191",
        "level": "hard",
        "output": [
            "To calculate the beta of TechInnovate Inc.'s stock relative to the Nasdaq Composite Index, we must consider the constraints and ensure the calculations adhere to the proper methodology:\n\n### Step-by-Step Analysis\n\n1. **Understand Beta**:  \n   Beta is a measure of a stock's volatility in relation to the market. It is calculated as:\n   \\[\n   \\beta = \\frac{\\text{Covariance of Stock and Market Returns}}{\\text{Variance of Market Returns}}\n   \\]\n   - Covariance measures how two variables move together. \n   - Variance measures the dispersion of data around the mean.\n\n2. **Constraints (EC)**:  \n   - The `stock_returns` and `market_returns` must have the same length because they represent returns over the same period.\n   - Variance of the market returns must not be zero; otherwise, beta cannot be calculated.\n\n3. **Given Data**:\n   - **TechInnovate's Stock Returns**: [4%, -2%, 3%, 5%, -1%], which we will represent as decimals: [0.04, -0.02, 0.03, 0.05, -0.01].\n   - **Nasdaq Composite Index Returns**: [3%, -1%, 4%, 2%, 0%], represented as [0.03, -0.01, 0.04, 0.02, 0.0].\n\n4. **Mathematical Approach**:\n   - Calculate the mean of `stock_returns` and `market_returns`.\n   - Compute the **covariance** between the stock and market returns:\n     \\[\n     \\text{Cov}(R_s, R_m) = \\frac{1}{N} \\sum_{i=1}^N (R_{s,i} - \\bar{R}_s)(R_{m,i} - \\bar{R}_m)\n     \\]\n   - Compute the **variance** of market returns:\n     \\[\n     \\text{Var}(R_m) = \\frac{1}{N} \\sum_{i=1}^N (R_{m,i} - \\bar{R}_m)^2\n     \\]\n   - Calculate Beta using the formula:\n     \\[\n     \\beta = \\frac{\\text{Covariance}}{\\text{Variance}}\n     \\]\n\n5. **Precision Requirement**:\n   - The beta value should be returned as a decimal rounded to two decimal places.\n\n### Python Program:\nHere is the Python implementation to calculate the beta based on the above logic:\n\n```python\ndef solution():\n    # Define variables name and value\n    stock_returns = [0.04, -0.02, 0.03, 0.05, -0.01]\n    market_returns = [0.03, -0.01, 0.04, 0.02, 0.0]\n    \n    # Calculate the mean of stock and market returns\n    stock_mean = sum(stock_returns) / len(stock_returns)\n    market_mean = sum(market_returns) / len(market_returns)\n    \n    # Calculate the covariance of stock and market returns\n    covariance = sum((s - stock_mean) * (m - market_mean) for s, m in zip(stock_returns, market_returns)) / len(stock_returns)\n    \n    # Calculate the variance of market returns\n    variance = sum((m - market_mean) ** 2 for m in market_returns) / len(market_returns)\n    \n    # Calculate beta\n    beta = covariance / variance\n    \n    # Round beta to two decimal places\n    return round(beta, 2)\n```"
        ],
        "retrieval_query": "What is the beta of TechInnovate Inc.'s stock relative to the Nasdaq Composite Index based on the past 5 months' returns? Answer as a decimal to two decimal places.",
        "useful_functions": [
            "def calculate_beta(stock_returns: list, market_returns: list) -> float:\n    \"\"\"\n    Calculate the beta of a stock, indicating its volatility relative to the market.\n\n    Beta is a measure of a stock's volatility in relation to the overall market.\n    A beta of 1 indicates that the stock's price tends to move with the market.\n    A beta greater than 1 indicates greater volatility than the market, while a beta less\n    than 1 indicates less volatility.\n\n    Args:\n        stock_returns (list): A list of periodic return rates for the stock.\n        market_returns (list): A list of periodic return rates for the market benchmark,\n                               such as the S&P 500. Must be of the same length as stock_returns.\n\n    Returns:\n        beta (float): The beta of the stock relative to the market.\n\n    Notes:\n        - Applicability: Used in assessing the risk and expected return of a stock or portfolio.\n        - Constraints: The input lists must represent returns for the same periods and must have\n          the same length.\n        - Considerations: Beta reflects past volatility and may not predict future volatility.\n          Values could be affected by outliers in the historical data.\n    \"\"\"\n    if len(stock_returns) != len(market_returns):\n        raise ValueError(\"Both input lists must have the same number of elements.\")\n\n    market_variance = sum((r - (sum(market_returns) / len(market_returns))) ** 2 for r in market_returns)\n    covariance = sum((s - (sum(stock_returns) / len(stock_returns))) * \n                     (m - (sum(market_returns) / len(market_returns))) for s, m in zip(stock_returns, market_returns))\n\n    if market_variance == 0:\n        raise ValueError(\"Market variance is zero, cannot calculate beta.\")\n    \n    beta = covariance / market_variance\n    \n    return beta",
            "def calculate_beta(asset_returns: list, benchmark_returns: list) -> float:\n    \"\"\"\n    Calculate the beta of a security relative to a benchmark index.\n\n    This function computes the beta, which measures the volatility or systematic\n    risk of a security or portfolio in comparison to the market as a whole.\n\n    Args:\n        asset_returns (list): A list of returns for the asset in question.\n        benchmark_returns (list): A list of returns for the benchmark index,\n                                  such as the S&P 500.\n\n    Returns:\n        beta (float): The beta of the asset relative to the benchmark.\n\n    Notes:\n        - Applicability: Use this function to assess the relative risk of an asset.\n        - Constraints: The lengths of asset_returns and benchmark_returns\n                       must match.\n        - Considerations: A beta of 1 indicates that the asset's price moves\n                          with the market. A beta greater than 1 indicates greater\n                          volatility than the market, and less than 1 indicates\n                          less volatility.\n    \"\"\"\n    if len(asset_returns) != len(benchmark_returns):\n        raise ValueError(\"The returns lists must be of the same length.\")\n\n    covariance = sum((a - sum(asset_returns) / len(asset_returns)) * \n                     (b - sum(benchmark_returns) / len(benchmark_returns)) \n                     for a, b in zip(asset_returns, benchmark_returns)) / len(asset_returns)\n                     \n    variance = sum((b - sum(benchmark_returns) / len(benchmark_returns)) ** 2 for b in benchmark_returns) / len(benchmark_returns)\n    \n    beta = covariance / variance\n\n    return beta"
        ],
        "usage": {
            "completion_tokens": 758,
            "prompt_tokens": 1204,
            "total_tokens": 1962,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "Johnson's second investment recommendation is to acquire a futures contract for a 10-year Treasury note. The base 2%, semi-annual 10-year Treasury note has a dirty price of 104.17. There have been 30 days since the last coupon payment of the 10-year Treasury note. The futures contract will terminate in 90 days. The quoted price for the futures contract is 129. The current yearly risk-free rate for three months stands at 1.65%. The conversion factor is 0.7025. Smith asks Johnson to compute the quoted futures contract price equilibrium using the carry arbitrage model. What is the equilibrium quoted 10-year Treasury note futures contract price? Answer to three decimal places.",
        "python_solution": "def solution():\n    B0 = 104.00\n    AI0 = 100 * 0.02 / 12\n    AIT = (120/180 * 0.02 * 100 / 2)\n    FVCI = 0\n    CF = 0.7025\n    rf = 0.0165\n    Ft = (((1 + rf) ** (3 / 12)) * (B0 + AI0) - AIT - FVCI)\n    F_eq = Ft / CF\n    return round(F_eq, 3)",
        "ground_truth": 147.939,
        "topic": "Asset Classes & Derivatives",
        "statistics": {
            "number_statistics": {
                "args_numbers": 5,
                "question_numbers": 11,
                "context_numbers": 0,
                "total_numbers": 11
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 2,
                    "*": 4,
                    "/": 5,
                    "%": 0,
                    "**": 1
                },
                "total_operators": 14
            },
            "code_statistics": {
                "lines": 9,
                "parentheses": 14
            }
        },
        "difficulty": 5.4116460518550396,
        "source": "FinanceMath-validation-85",
        "context": "[]",
        "question_id": "test-2192",
        "level": "hard",
        "output": [
            "### Thought Process:\n\nTo calculate the equilibrium quoted futures contract price for a 10-year Treasury note using the carry arbitrage model, we must adhere to the following constraints:\n\n1. **Constraints (EC):**\n   - **Precision:** The answer should be returned to three decimal places.\n   - **Model Framework:** Use the carry arbitrage model formula to consider the future value of the dirty price, accrued interest, and conversion factor.\n   - **Input Constants:**\n       - **Dirty Price (`spot_dirty_price`)**: 104.17 (Given)\n       - **Risk-free rate (`risk_free_rate`)**: 1.65% yearly = 0.0165 in decimal form.\n       - **Days to Expiration (`days_to_expiration`)**: 90 days (Given)\n       - **Days Since Last Coupon (`days_since_last_coupon`)**: 30 days (Given)\n       - **Conversion Factor (`conversion_factor`)**: 0.7025 (Given)\n       - **Annual Coupon Rate (`annual_coupon_rate`)**: 2% = 0.02 (Assumed as it refers to \"base 2%, semi-annual 10-year Treasury note\").\n       - **Face Value (`face_value`)**: Defaults to 100.\n\n2. **Steps to Calculate:**\n   - **Future Value of Dirty Price:** Use continuous compounding \\(FV = P * e^{r \\cdot t}\\), where \\(t = \\frac{\\text{days\\_to\\_expiration}}{365}\\).\n   - **Accrued Interest at Futures Expiration:** Account for semi-annual coupon interest accrued by the time of expiration (\\(AI = \\frac{\\text{days\\_since\\_last\\_coupon + days\\_to\\_expiration}}{\\text{semi-annual period}} \\times \\frac{\\text{annual coupon rate}}{2} \\times \\text{face value}\\)).\n   - **Futures Clean Price:** Subtract Accrued Interest from Future Dirty Price.\n   - **Quoted Futures Price:** Adjust clean price using the conversion factor (\\(Quoted\\_Price = \\frac{Futures\\_Clean\\_Price}{Conversion\\_Factor}\\)).\n\n### Python Solution:\n```python\ndef solution():\n    # Define variables name and value\n    spot_dirty_price = 104.17  # Dirty price of the 10-year Treasury note\n    risk_free_rate = 0.0165  # Annual risk-free rate (as decimal)\n    days_to_expiration = 90  # Days until the futures contract expires\n    conversion_factor = 0.7025  # Conversion factor\n    days_since_last_coupon = 30  # Days since last coupon payment\n    annual_coupon_rate = 0.02  # Annual coupon rate (as decimal)\n    face_value = 100.0  # Face value of the Treasury note\n    \n    # Constants\n    days_in_coupon_period = 180  # Semi-annual coupon period\n    e = 2.718281828459045  # Base of the natural logarithm\n    \n    # Step 1: Calculate fractional year equivalent for the expiration period\n    fractional_year = days_to_expiration / 365\n    \n    # Step 2: Calculate the future value of the dirty price using continuous compounding\n    future_value_dirty = spot_dirty_price * (e ** (risk_free_rate * fractional_year))\n    \n    # Step 3: Calculate accrued interest at futures expiration\n    total_days = days_since_last_coupon + days_to_expiration\n    accrued_interest_at_expiration = (total_days / days_in_coupon_period) * (annual_coupon_rate / 2) * face_value\n    \n    # Step 4: Calculate the futures clean price\n    futures_clean_price = future_value_dirty - accrued_interest_at_expiration\n    \n    # Step 5: Adjust by the conversion factor to get the quoted futures price\n    quoted_futures_price = futures_clean_price / conversion_factor\n    \n    # Return the rounded quoted futures price to three decimal places\n    return round(quoted_futures_price, 3)\n\n# Call the solution function to compute the quoted futures price\nsolution()\n```"
        ],
        "retrieval_query": "Johnson's second investment recommendation is to acquire a futures contract for a 10-year Treasury note. The base 2%, semi-annual 10-year Treasury note has a dirty price of 104.17. There have been 30 days since the last coupon payment of the 10-year Treasury note. The futures contract will terminate in 90 days. The quoted price for the futures contract is 129. The current yearly risk-free rate for three months stands at 1.65%. The conversion factor is 0.7025. Smith asks Johnson to compute the quoted futures contract price equilibrium using the carry arbitrage model. What is the equilibrium quoted 10-year Treasury note futures contract price? Answer to three decimal places.",
        "useful_functions": [
            "def calculate_treasury_futures_price(spot_dirty_price: float, risk_free_rate: float, \n                                     days_to_expiration: int, conversion_factor: float, \n                                     days_since_last_coupon: int, annual_coupon_rate: float, \n                                     face_value: float=100.0) -> float:\n    \"\"\"\n    Calculate the equilibrium quoted futures contract price for a Treasury note using the \n    carry arbitrage model.\n\n    This function computes the equilibrium futures contract price of a Treasury note\n    futures contract by adjusting the future value of the spot dirty price for accrued \n    interest and the conversion factor.\n\n    Args:\n        spot_dirty_price (float): The current dirty price of the Treasury note.\n        risk_free_rate (float): The annual risk-free interest rate, expressed as a decimal.\n        days_to_expiration (int): The number of days until the futures contract expires.\n        conversion_factor (float): The conversion factor used to adjust the futures price.\n        days_since_last_coupon (int): The number of days since the last coupon payment.\n        annual_coupon_rate (float): The annual coupon rate of the Treasury note (as a decimal).\n        face_value (float): The face value of the Treasury note. Defaults to 100.\n\n    Returns:\n        quoted_futures_price (float): The equilibrium quoted futures contract price.\n\n    Notes:\n        - This function assumes a semi-annual coupon payment schedule.\n        - Days in a year are assumed to be 365 for calculations.\n        - The face value of a Treasury note commonly defaults to 100.\n    \"\"\"\n    # Calculate fractional year equivalent for the expiration period\n    fractional_year = days_to_expiration / 365\n    \n    # Calculate the future value of the dirty price using continuous compounding\n    future_value_dirty = spot_dirty_price * (2.718281828459045 ** (risk_free_rate * fractional_year))\n    \n    # Calculate accrued interest at futures expiration\n    days_in_coupon_period = 180  # Semi-annual period\n    accrued_interest_at_expiration = (days_since_last_coupon + days_to_expiration) / days_in_coupon_period * (annual_coupon_rate / 2) * face_value\n    \n    # Calculate the futures clean price\n    futures_clean_price = future_value_dirty - accrued_interest_at_expiration\n    \n    # Adjust by the conversion factor to get the quoted futures price\n    quoted_futures_price = futures_clean_price / conversion_factor\n    \n    return round(quoted_futures_price, 3)"
        ],
        "usage": {
            "completion_tokens": 863,
            "prompt_tokens": 989,
            "total_tokens": 1852,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "According to the given table, can you compute the value added from the choice of security (expressed as a percentage)? Answer to a single decimal place.",
        "python_solution": "def solution():\n    # Define variables name and value\n    portfolio_return_domestic = 0.25\n    benchmark_return_domestic = 0.15\n    portfolio_weight_domestic = 0.50\n\n    portfolio_return_bond = 0.09\n    benchmark_return_bond = 0.05\n    portfolio_weight_bond = 0.30\n\n    portfolio_return_international = 0.15\n    benchmark_return_international = 0.18\n    portfolio_weight_international = 0.20\n\n    # Security Selection Effect calculation for each segment\n    security_selection_effect_domestic = (portfolio_return_domestic - benchmark_return_domestic) * portfolio_weight_domestic\n    security_selection_effect_bond = (portfolio_return_bond - benchmark_return_bond) * portfolio_weight_bond\n    security_selection_effect_international = (portfolio_return_international - benchmark_return_international) * portfolio_weight_international\n\n    # Total Security Selection Effect across all segments\n    total_security_selection_effect = (security_selection_effect_domestic +\n                                       security_selection_effect_bond +\n                                       security_selection_effect_international)\n\n    # return answer\n    return round(total_security_selection_effect * 100, 1)\n",
        "ground_truth": 5.6,
        "topic": "Portfolio Management & Strategy",
        "statistics": {
            "number_statistics": {
                "args_numbers": 9,
                "question_numbers": 0,
                "context_numbers": 12,
                "total_numbers": 12
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 3,
                    "*": 4,
                    "/": 0,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 9
            },
            "code_statistics": {
                "lines": 20,
                "parentheses": 10
            }
        },
        "difficulty": 5.41610040220442,
        "source": "FinanceMath-validation-44",
        "context": "['|                | Portfolio return | Benchmark return | Portfolio weight | Benchmark weight |\\n|----------------|------------------|------------------|------------------|------------------|\\n| Domestic       | 25%              | 15%              | 50               | 35               |\\n| Bond           | 9%               | 5%               | 30               | 35               |\\n| International  | 15%              | 18%              | 20               | 30               |']",
        "question_id": "test-2193",
        "level": "hard",
        "output": [
            "### Step-by-step reasoning using the Emphasizing Constraints (EC) technique:\n\n1. **Define the Value Added by Security Selection:**  \n   The value added by the choice of security measures the contribution of the portfolio manager to overall performance due to better security selection within the asset categories. The formula to calculate value added from security selection is:\n   \\[\n   \\text{Value Added by Security Selection} = \\sum \\text{(Portfolio Weight)} \\times \\text{(Portfolio Return - Benchmark Return)}\n   \\]\n\n2. **Ensure Adherence to Constraints:**  \n   - Use percentages for return differences directly in calculation.\n   - Portfolio weights are provided as whole percentages (e.g., \"50\" instead of \"0.50\"), so we must convert them to fractional values during computation.\n   - The final result should be expressed as a percentage and accurate to one decimal place.\n\n3. **Identify Variables and Perform Calculation:**  \n   From the table:\n   - For **Domestic**: Portfolio weight = 50%, Portfolio return = 25%, Benchmark return = 15%.\n   - For **Bond**: Portfolio weight = 30%, Portfolio return = 9%, Benchmark return = 5%.\n   - For **International**: Portfolio weight = 20%, Portfolio return = 15%, Benchmark return = 18%.\n\n   The total value added is calculated by summing up contributions for each asset class:\n   \\[\n   \\text{Value Added} = \\left( 0.5 \\times (25 - 15) \\right) + \\left( 0.3 \\times (9 - 5) \\right) + \\left( 0.2 \\times (15 - 18) \\right)\n   \\]\n\nLet\u2019s now translate this into a Python program.\n\n```python\ndef solution():\n    # Define variables\n    domestic_weight = 50 / 100  # Converting to fractional weight\n    bond_weight = 30 / 100      # Converting to fractional weight\n    international_weight = 20 / 100  # Converting to fractional weight\n    \n    # Returns and benchmark differences\n    domestic_difference = 25 - 15  # Portfolio return - Benchmark return\n    bond_difference = 9 - 5\n    international_difference = 15 - 18\n    \n    # Calculate value added by security selection\n    value_added = (\n        domestic_weight * domestic_difference +\n        bond_weight * bond_difference +\n        international_weight * international_difference\n    )\n    \n    # Return the final result rounded to one decimal place\n    return round(value_added, 1)\n```"
        ],
        "retrieval_query": "According to the given table, can you compute the value added from the choice of security (expressed as a percentage)? Answer to a single decimal place.",
        "useful_functions": [],
        "usage": {
            "completion_tokens": 533,
            "prompt_tokens": 459,
            "total_tokens": 992,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-2134",
        "article_title": "Lifetime Learning Credit",
        "function": "def calculate_llc_credit(qualified_expenses: float, magi: float, filing_status: str) -> float:\n    \"\"\"\n    Calculate the Lifetime Learning Credit (LLC) for a taxpayer.\n\n    This function computes the available Lifetime Learning Credit based on \n    qualified education expenses and the modified adjusted gross income (MAGI) \n    of the taxpayer. The credit is worth 20% of the first $10,000 of qualified \n    expenses and is subject to a phase-out based on MAGI.\n\n    Args:\n        qualified_expenses (float): The amount of qualified education expenses (maximum $10,000).\n        magi (float): The modified adjusted gross income of the taxpayer.\n        filing_status (str): Filing status of the taxpayer, either 'individual' or 'joint'.\n\n    Returns:\n        llc_credit (float): The calculated Lifetime Learning Credit. The credit can be up to $2,000.\n\n    Notes:\n        - The maximum qualified expense considered is $10,000, resulting in a maximum credit of $2,000.\n        - MAGI phase-out ranges are $80,000 to $90,000 for individuals and $160,000 to $180,000 for joint filers.\n        - If the MAGI exceeds these phase-out limits, the taxpayer is not eligible for the credit.\n        - The function assumes that the filing status is valid and MAGI limits are not subject to inflation adjustments as of the tax year 2022.\n    \"\"\"\n    max_credit = 2000\n    credit_rate = 0.20\n    phase_out_limit_individual = (80000, 90000)\n    phase_out_limit_joint = (160000, 180000)\n    \n    if filing_status not in {'individual', 'joint'}:\n        raise ValueError(\"Invalid filing status. Must be 'individual' or 'joint'.\")\n    \n    eligible_expenses = min(qualified_expenses, 10000)\n    potential_credit = eligible_expenses * credit_rate\n    \n    if filing_status == 'individual':\n        if magi >= phase_out_limit_individual[1]:\n            return 0.0\n        elif magi > phase_out_limit_individual[0]:\n            potential_credit *= (phase_out_limit_individual[1] - magi) / (phase_out_limit_individual[1] - phase_out_limit_individual[0])\n            \n    elif filing_status == 'joint':\n        if magi >= phase_out_limit_joint[1]:\n            return 0.0\n        elif magi > phase_out_limit_joint[0]:\n            potential_credit *= (phase_out_limit_joint[1] - magi) / (phase_out_limit_joint[1] - phase_out_limit_joint[0])\n    \n    llc_credit = min(max_credit, potential_credit)\n    return llc_credit",
        "statistics": {
            "number_statistics": {
                "args_numbers": 3,
                "question_numbers": 0,
                "context_numbers": 2,
                "total_numbers": 2
            },
            "operator_statistics": {
                "operators": {
                    "+": 0,
                    "-": 4,
                    "*": 3,
                    "/": 2,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 9
            },
            "code_statistics": {
                "lines": 18,
                "parentheses": 16
            }
        },
        "difficulty": 5.455321115357702,
        "context": "Maria is planning to enroll in a series of professional development courses to enhance her skills. She expects to spend $8,500 on qualified educational expenses. Maria, who files her taxes individually, has a modified adjusted gross income (MAGI) of $85,000. She wants to understand how much of the Lifetime Learning Credit she can claim to help offset her education costs in the current tax year.",
        "question": "What is the Lifetime Learning Credit Maria can claim given her educational expenses and MAGI? Answer to two decimal places.",
        "python_solution": "def solution():\n    # Define variables for Maria's financial context\n    qualified_expenses = 8500\n    magi = 85000\n    filing_status = 'individual'\n    \n    # Constants for credit calculation\n    max_credit = 2000\n    credit_rate = 0.20\n    phase_out_start_individual = 80000\n    phase_out_end_individual = 90000\n    \n    # Calculate the eligible expenses (maximum $10,000)\n    eligible_expenses = min(qualified_expenses, 10000)\n    \n    # Calculate the initial potential credit\n    potential_credit = eligible_expenses * credit_rate\n    \n    # Adjust the credit based on the phase-out for individual filing status\n    if magi > phase_out_end_individual:\n        # If MAGI exceeds the phase-out end, no credit is available\n        potential_credit = 0.0\n    elif magi > phase_out_start_individual:\n        # If in the phase-out range, adjust the credit\n        potential_credit *= (phase_out_end_individual - magi) / (phase_out_end_individual - phase_out_start_individual)\n    \n    # The final credit is the lesser of the calculated potential credit and the max credit\n    llc_credit = min(max_credit, potential_credit)\n    \n    # Return the Lifetime Learning Credit rounded to two decimal places\n    return round(llc_credit, 2)",
        "ground_truth": 850.0,
        "source": "FinanceReasoning-test-58",
        "question_id": "test-2194",
        "level": "hard",
        "output": [
            "### Step-by-Step Reasoning Using EC (Emphasizing Constraints):\n\n1. **Understanding the Problem**:\n   - Maria is seeking to claim the Lifetime Learning Credit (LLC), which is designed to help offset qualified education expenses.\n   - We are provided with Maria's MAGI, her educational costs, and her filing status.\n\n2. **Constraints**:\n   - **Qualified education expenses** are capped at $10,000 for the purposes of calculating the credit.\n   - The LLC provides 20% of qualified expenses up to the cap, giving a maximum possible credit of $2,000.\n   - The MAGI phase-out range for individual filers is between $80,000 and $90,000:\n       - If MAGI \u2264 $80,000: Full credit.\n       - If $80,000 < MAGI < $90,000: Credit is reduced proportionally.\n       - If MAGI \u2265 $90,000: No credit.\n   - We need the result to two decimal places.\n\n3. **Key Calculation Steps**:\n   - First, determine the eligible qualified expenses (capped at $10,000).\n   - Calculate the potential maximum credit as 20% of the qualified expenses.\n   - Adjust the credit based on Maria\u2019s MAGI phase-out range:\n       - When MAGI is within the phase-out range, apply a proportional reduction factor.\n   - Ensure the credit does not exceed the maximum cap of $2,000 or go below $0.\n\n4. **Plan**:\n   - Use the provided `calculate_llc_credit` function.\n   - Supply the appropriate arguments: `$8,500` for expenses, `$85,000` for MAGI, and `individual` filing status.\n   - Retrieve the credit amount, adhering to the constraints above.\n\nNow we can implement the Python program based on this plan.\n\n```python\ndef solution():\n    # Use the provided calculator function\n    def calculate_llc_credit(qualified_expenses: float, magi: float, filing_status: str) -> float:\n        max_credit = 2000\n        credit_rate = 0.20\n        phase_out_limit_individual = (80000, 90000)\n        phase_out_limit_joint = (160000, 180000)\n        \n        if filing_status not in {'individual', 'joint'}:\n            raise ValueError(\"Invalid filing status. Must be 'individual' or 'joint'.\")\n        \n        # Qualified expenses are capped at $10,000\n        eligible_expenses = min(qualified_expenses, 10000)\n        potential_credit = eligible_expenses * credit_rate\n        \n        # Handle phase-out for individual filers\n        if filing_status == 'individual':\n            if magi >= phase_out_limit_individual[1]:\n                return 0.0\n            elif magi > phase_out_limit_individual[0]:\n                potential_credit *= (phase_out_limit_individual[1] - magi) / (phase_out_limit_individual[1] - phase_out_limit_individual[0])\n                \n        # Handle phase-out for joint filers\n        elif filing_status == 'joint':\n            if magi >= phase_out_limit_joint[1]:\n                return 0.0\n            elif magi > phase_out_limit_joint[0]:\n                potential_credit *= (phase_out_limit_joint[1] - magi) / (phase_out_limit_joint[1] - phase_out_limit_joint[0])\n        \n        llc_credit = min(max_credit, potential_credit)\n        return llc_credit\n\n    # Define variables\n    qualified_expenses = 8500  # Qualified expenses in dollars\n    magi = 85000  # Maria's MAGI in dollars\n    filing_status = 'individual'  # Maria's filing status\n\n    # Calculate the Lifetime Learning Credit\n    llc_credit = calculate_llc_credit(qualified_expenses, magi, filing_status)\n    \n    # Return the result rounded to two decimal places\n    return round(llc_credit, 2)\n\n```"
        ],
        "retrieval_query": "What is the Lifetime Learning Credit Maria can claim given her educational expenses and MAGI? Answer to two decimal places.",
        "useful_functions": [
            "def calculate_llc_credit(qualified_expenses: float, magi: float, filing_status: str) -> float:\n    \"\"\"\n    Calculate the Lifetime Learning Credit (LLC) for a taxpayer.\n\n    This function computes the available Lifetime Learning Credit based on \n    qualified education expenses and the modified adjusted gross income (MAGI) \n    of the taxpayer. The credit is worth 20% of the first $10,000 of qualified \n    expenses and is subject to a phase-out based on MAGI.\n\n    Args:\n        qualified_expenses (float): The amount of qualified education expenses (maximum $10,000).\n        magi (float): The modified adjusted gross income of the taxpayer.\n        filing_status (str): Filing status of the taxpayer, either 'individual' or 'joint'.\n\n    Returns:\n        llc_credit (float): The calculated Lifetime Learning Credit. The credit can be up to $2,000.\n\n    Notes:\n        - The maximum qualified expense considered is $10,000, resulting in a maximum credit of $2,000.\n        - MAGI phase-out ranges are $80,000 to $90,000 for individuals and $160,000 to $180,000 for joint filers.\n        - If the MAGI exceeds these phase-out limits, the taxpayer is not eligible for the credit.\n        - The function assumes that the filing status is valid and MAGI limits are not subject to inflation adjustments as of the tax year 2022.\n    \"\"\"\n    max_credit = 2000\n    credit_rate = 0.20\n    phase_out_limit_individual = (80000, 90000)\n    phase_out_limit_joint = (160000, 180000)\n    \n    if filing_status not in {'individual', 'joint'}:\n        raise ValueError(\"Invalid filing status. Must be 'individual' or 'joint'.\")\n    \n    eligible_expenses = min(qualified_expenses, 10000)\n    potential_credit = eligible_expenses * credit_rate\n    \n    if filing_status == 'individual':\n        if magi >= phase_out_limit_individual[1]:\n            return 0.0\n        elif magi > phase_out_limit_individual[0]:\n            potential_credit *= (phase_out_limit_individual[1] - magi) / (phase_out_limit_individual[1] - phase_out_limit_individual[0])\n            \n    elif filing_status == 'joint':\n        if magi >= phase_out_limit_joint[1]:\n            return 0.0\n        elif magi > phase_out_limit_joint[0]:\n            potential_credit *= (phase_out_limit_joint[1] - magi) / (phase_out_limit_joint[1] - phase_out_limit_joint[0])\n    \n    llc_credit = min(max_credit, potential_credit)\n    return llc_credit"
        ],
        "usage": {
            "completion_tokens": 828,
            "prompt_tokens": 1017,
            "total_tokens": 1845,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "Smith is a tax consultant who offers tax education advice to individual clients. One of Smith's clients is Sarah. Sarah wants Smith to examine Mutual Fund X, which has an embedded gain of 10% of the closing portfolio value. Sarah requests Smith to compute a post-liquidation return for the last three-year period. Mutual Fund X showed after-tax returns of 9.0% in the first year, 5% in the second year, and 8% in the third year, and capital gains are taxed at a 25% rate. What is the annualized after-tax post-liquidation return worked out by Smith (expressed as a percentage)? Answer to three decimal places.",
        "python_solution": "def solution():\n    # Given\n    returns = [0.09, 0.05, 0.08] # After-tax returns for the three years\n    tax_rate = 0.25 # Capital gains tax rate\n    embedded_gain = 0.10 # Embedded gain of the portfolio\n\n    # Calculate the final after-tax portfolio value\n    portfolio_value = 1\n    for r in returns:\n        portfolio_value *= (1 + r)\n\n    # Account for the unrealized capital gains\n    portfolio_value *= (1 - embedded_gain * tax_rate)\n\n    # Annualize the after-tax post-liquidation return\n    annualized_return = (portfolio_value ** (1 / len(returns))) - 1\n\n    return annualized_return*100 # Converting decimal return to percentage",
        "ground_truth": 6.418,
        "topic": "Accounting",
        "statistics": {
            "number_statistics": {
                "args_numbers": 6,
                "question_numbers": 5,
                "context_numbers": 0,
                "total_numbers": 5
            },
            "operator_statistics": {
                "operators": {
                    "+": 1,
                    "-": 6,
                    "*": 4,
                    "/": 1,
                    "%": 0,
                    "**": 1
                },
                "total_operators": 13
            },
            "code_statistics": {
                "lines": 13,
                "parentheses": 10
            }
        },
        "difficulty": 5.455321115357702,
        "source": "FinanceMath-validation-119",
        "context": "[]",
        "question_id": "test-2195",
        "level": "hard",
        "output": [
            "**Step-by-Step Explanation Using Advanced Reasoning Techniques:**\n\n1. **Emphasizing Constraints (EC)**: \n   - The final answer must be provided as an annualized after-tax post-liquidation return, expressed as a percentage to three decimal places.\n   - Capital gains are taxed at a capital gains rate of 25%, and the embedded gain of 10% in the portfolio must be taxed at the same rate upon liquidation.\n   - The embedded gain impacts the overall growth at the liquidation year and reduces the effective return due to taxation.\n\n2. **Computational Steps**:\n   - Start with the initial portfolio value as 1 (to normalize calculations).\n   - Compute the growth of the portfolio year-over-year based on the after-tax percentage returns given for the three years.\n   - Account for taxation of the embedded gain (10% of closing portfolio value) after the third year.\n   - Convert the total post-liquidation portfolio value into an annualized return using the formula for geometric mean return:\n     \\( Annualized\\:Return = (End\\:Value / Start\\:Value)^{1/Years} - 1 \\).\n   - Since the embedded gain introduces taxation at the end, we deduct the tax on the embedded gain as a final step.\n\n3. **Python Program**: Below is the implementation that calculates the annualized after-tax post-liquidation return following the reasoning process.\n\n```python\ndef solution():\n    # Define tax rate on capital gains\n    tax_rate = 0.25\n    \n    # Define portfolio returns for each year\n    returns = [9.0 / 100, 5.0 / 100, 8.0 / 100]  # Convert percentages to decimals\n    \n    # Define the embedded gain as a fraction of the portfolio closing value\n    embedded_gain_rate = 10.0 / 100  # 10% embedded gain\n    \n    # Start value of portfolio (normalized for calculations)\n    start_value = 1.0\n    \n    # After-tax portfolio value calculation for 3 years\n    portfolio_value = start_value\n    for r in returns:\n        portfolio_value *= (1 + r)  # Apply the after-tax return year by year\n    \n    # Calculate embedded gain and tax on the embedded gain\n    embedded_gain = portfolio_value * embedded_gain_rate\n    tax_on_embedded_gain = embedded_gain * tax_rate\n    \n    # Determine post-liquidation value (deduct the tax on the embedded gain)\n    post_liquidation_value = portfolio_value - tax_on_embedded_gain\n    \n    # Calculate the annualized after-tax post-liquidation return\n    years = 3\n    annualized_return = (post_liquidation_value / start_value) ** (1 / years) - 1\n    \n    # Express as a percentage to three decimal places\n    answer = round(annualized_return * 100, 3)\n    return answer\n```\n\n"
        ],
        "retrieval_query": "Smith is a tax consultant who offers tax education advice to individual clients. One of Smith's clients is Sarah. Sarah wants Smith to examine Mutual Fund X, which has an embedded gain of 10% of the closing portfolio value. Sarah requests Smith to compute a post-liquidation return for the last three-year period. Mutual Fund X showed after-tax returns of 9.0% in the first year, 5% in the second year, and 8% in the third year, and capital gains are taxed at a 25% rate. What is the annualized after-tax post-liquidation return worked out by Smith (expressed as a percentage)? Answer to three decimal places.",
        "useful_functions": [],
        "usage": {
            "completion_tokens": 594,
            "prompt_tokens": 465,
            "total_tokens": 1059,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "An expert has compiled the major forecasts and assumptions for a J REIT. What is the inherent worth of the J REIT per share utilizing the two-step dividend discount model? Answer to three decimal places.",
        "python_solution": "def solution():\n    discount_rate = 0.085\n    dividend_y1 = 1.13\n    dividend_y2 = 1.22\n    growth_rate = 0.05\n\n    stock_price = (dividend_y1 / (1+discount_rate)) + (dividend_y2 / ((1+discount_rate)**2)) + ((dividend_y2*(1+growth_rate))/(discount_rate-growth_rate))/((1+discount_rate)**2)\n    return stock_price",
        "ground_truth": 33.168,
        "topic": "Asset Classes & Derivatives",
        "statistics": {
            "number_statistics": {
                "args_numbers": 5,
                "question_numbers": 0,
                "context_numbers": 9,
                "total_numbers": 9
            },
            "operator_statistics": {
                "operators": {
                    "+": 6,
                    "-": 1,
                    "*": 1,
                    "/": 4,
                    "%": 0,
                    "**": 2
                },
                "total_operators": 14
            },
            "code_statistics": {
                "lines": 6,
                "parentheses": 22
            }
        },
        "difficulty": 5.472270673671474,
        "source": "FinanceMath-validation-178",
        "context": "['| Current risk-free rate | 3.00% |\\n|------------------------|-------|\\n| Beta of the T REIT     | 1.1   |\\n| Market risk premium    | 5.00% |\\n| Expected dividend per share, 1 year from today | $1.13 |\\n| Expected dividend per share, 2 years from today| $1.22 |\\n| Long-term growth rate in dividends, starting in year 3 | 5.00% |']",
        "question_id": "test-2196",
        "level": "hard",
        "output": [
            "To determine the inherent worth of the J REIT per share using the two-step dividend discount model, let's break the problem down step by step, following the advanced reasoning technique \"Emphasizing Constraints\" (EC):\n\n---\n\n### Step 1: Understand the given data and constraints\nThe question provides the following data:\n1. **Risk-free rate (r_f)**: 3.00% = 0.03 (in decimal form).  \n2. **Beta (\u03b2)**: 1.1 (volatility measure relative to the market).\n3. **Market risk premium (MRP)**: 5.00% = 0.05 (in decimal form).\n4. **Expected dividends**:\n    - **Dividend in 1 year (D1)**: $1.13.\n    - **Dividend in 2 years (D2)**: $1.22.\n5. **Long-term growth rate in dividends (starting from year 3)**: 5.00% = 0.05 (in decimal form).\n\n---\n\n#### Use the Two-Step Dividend Discount Model (DDM):\nThis model is divided into two parts:\n1. **Part 1: Present Value of Dividends During Explicit Periods.**  \n   We'll calculate the present value of dividends for the 1st and 2nd years.\n\n2. **Part 2: Terminal Value and its Present Value.**  \n   A terminal value (after the explicit 2-year period) is calculated based on the Gordon Growth Model using the long-term growth rate. We'll discount this terminal value back to today.\n\n### Step 2: Apply formulas and principles\n1. **Required rate of return (`r`)** is calculated using the Capital Asset Pricing Model (CAPM):\n   \\[\n   r = r_f + \\beta \\times MRP\n   \\]\n\n2. **Present Value of Dividends in Year 1 and Year 2** is computed as:\n   \\[\n   PV(D_t) = \\frac{D_t}{(1 + r)^t}\n   \\]\n   where \\( t \\) is the specific year and \\( D_t \\) is the dividend for that year.\n\n3. **Terminal Value** at the end of Year 2 uses the Gordon Growth Model:\n   \\[\n   TV = \\frac{D_3}{r - g}\n   \\]\n   where:\n   - \\( g \\): Long-term growth rate.\n   - \\( D_3 = D_2 \\times (1 + g) \\): The dividend starting from year 3.\n\n   The terminal value is discounted back to present using:\n   \\[\n   PV(TV) = \\frac{TV}{(1 + r)^2}\n   \\]\n\n4. **Inherent Worth (Per Share Value)** is the sum of present values:\n   \\[\n   Inherent \\ Worth = PV(D_1) + PV(D_2) + PV(Terminal \\ Value)\n   \\]\n\n---\n\n### Step 3: Constraints\n1. **Decimal Precision**: Answer should be rounded to 3 decimal places.\n2. All percentages must be converted to decimals when used in calculations.\n3. Ensure compliance with dividend, growth, and CAPM assumptions.\n\n### Step 4: Write the Python Code\nNow that the steps are defined, we'll proceed to calculate them programmatically.\n\n```python\ndef solution():\n    # Define variables\n    risk_free_rate = 0.03  # Risk-free rate (3% in decimal)\n    beta = 1.1            # Beta of J REIT\n    market_risk_premium = 0.05  # Market risk premium (5% in decimal)\n    dividends = [1.13, 1.22]  # Expected dividends for year 1 and 2\n    long_term_growth_rate = 0.05  # Long-term growth rate (5% in decimal)\n    periods = 2  # Explicit periods (Year 1 and 2 dividends)\n\n    # Step 1: Calculate the required rate of return using CAPM\n    required_rate_of_return = risk_free_rate + beta * market_risk_premium\n\n    # Step 2: Calculate the present value of dividends for the first two periods\n    present_value_of_dividends = sum(\n        dividends[i] / ((1 + required_rate_of_return) ** (i + 1))\n        for i in range(periods)\n    )\n\n    # Step 3: Calculate the terminal value at the end of year 2\n    last_dividend = dividends[-1]  # D2\n    dividend_at_steady_growth = last_dividend * (1 + long_term_growth_rate)  # D3\n    terminal_value = dividend_at_steady_growth / (required_rate_of_return - long_term_growth_rate)\n    \n    # Step 4: Calculate the present value of the terminal value\n    present_value_of_terminal_value = terminal_value / ((1 + required_rate_of_return) ** periods)\n\n    # Step 5: Calculate the total inherent worth\n    inherent_worth = present_value_of_dividends + present_value_of_terminal_value\n\n    # Step 6: Return the result rounded to three decimal places\n    return round(inherent_worth, 3)\n```"
        ],
        "retrieval_query": "An expert has compiled the major forecasts and assumptions for a J REIT. What is the inherent worth of the J REIT per share utilizing the two-step dividend discount model? Answer to three decimal places.",
        "useful_functions": [
            "def calculate_inherent_worth(risk_free_rate: float, beta: float, market_risk_premium: float,\n                             dividends: list, long_term_growth_rate: float, periods: int = 2) -> float:\n    \"\"\"\n    Calculate the inherent worth of a company per share using the two-step dividend discount model (DDM).\n\n    This function utilizes the capital asset pricing model (CAPM) to determine the required rate of return\n    and then applies the two-step dividend discount model to evaluate the inherent worth of a company's stock.\n\n    Args:\n        risk_free_rate (float): The current risk-free rate expressed as a decimal.\n        beta (float): The beta of the stock, indicating its volatility compared to the market.\n        market_risk_premium (float): The expected market risk premium expressed as a decimal.\n        dividends (list): A list of expected dividends per share for the initial period(s), starting from year 1.\n                          This should include all dividends up to the end of the specified periods.\n        long_term_growth_rate (float): The growth rate of dividends starting after the specified periods, expressed as a decimal.\n        periods (int, optional): The number of initial periods for which dividends are explicitly provided. Default is 2.\n\n    Returns:\n        inherent_worth (float): The calculated inherent worth of the stock per share.\n\n    Notes:\n        - This function assumes that dividends grow at a stable rate after the specified number of periods.\n        - The required rate of return (r) is calculated as risk_free_rate + beta * market_risk_premium.\n        - The function assumes dividends are given in chronological order and are scaled to the same currency.\n        - Ensure inputs like the risk-free rate, growth rate, and market risk premium are in decimal form (e.g., 5% as 0.05).\n        - The model does not account for changes in share price due to external factors unrelated to dividends.\n    \"\"\"\n    # Calculate the required rate of return using CAPM\n    required_rate_of_return = risk_free_rate + beta * market_risk_premium\n    \n    # Calculate the present value of dividends for initial periods\n    present_value_of_dividends = sum(dividends[i] / ((1 + required_rate_of_return) ** (i + 1)) for i in range(periods))\n    \n    # Calculate the terminal value at the end of specified periods\n    last_dividend = dividends[-1]\n    dividend_at_steady_growth = last_dividend * (1 + long_term_growth_rate)\n    terminal_value = dividend_at_steady_growth / (required_rate_of_return - long_term_growth_rate)\n    \n    # Calculate the present value of the terminal value\n    present_value_of_terminal_value = terminal_value / ((1 + required_rate_of_return) ** periods)\n    \n    # Sum the present values to get the total inherent worth\n    inherent_worth = present_value_of_dividends + present_value_of_terminal_value\n    \n    return inherent_worth",
            "def calculate_two_stage_dividend_discount(fixed_dividends: list, growth_rate: float, \n                                          discount_rate: float, initial_dividend: float,\n                                          growth_start_year: int) -> float:\n    \"\"\"\n    Calculate the value of common equity using the two-stage dividend discount model.\n\n    This function computes the present value of a stock based on fixed dividends for a few years \n    followed by perpetual growth. It is particularly useful for valuing firms expected to have \n    a period of stable dividends before transitioning to a constant growth rate.\n\n    Args:\n        fixed_dividends (list): List of dividends for the period with fixed payouts.\n        growth_rate (float): The perpetual growth rate of dividends after the fixed period.\n                             Must be between 0 and 1 (exclusive).\n        discount_rate (float): The required rate of return for the equity. Must be greater \n                               than zero and greater than growth_rate.\n        initial_dividend (float): The dividend at the start of the perpetual growth phase.\n        growth_start_year (int): The year when the perpetual growth phase begins, \n                                 corresponding to the first year of the growth rate application.\n\n    Returns:\n        equity_value (float): The present value of the company's common equity.\n\n    Notes:\n        - Applicability: Ideal for valuing firms with an anticipated fixed dividend period \n          followed by a stable growth phase (two-stage model).\n        - Constraints: The growth rate must be positive and smaller than the discount rate \n          to ensure a valid perpetuity calculation.\n        - Considerations: Ensure all rates are expressed in decimal form (e.g., 5% as 0.05).\n    \"\"\"\n    # Calculate the present value of fixed dividends\n    pv_fixed_dividends = sum(dividend / ((1 + discount_rate) ** (i + 1)) \n                             for i, dividend in enumerate(fixed_dividends))\n    \n    # Determine the future value of the perpetuity at the beginning of the growth phase\n    future_value_growth = initial_dividend * (1 + growth_rate) / (discount_rate - growth_rate)\n    \n    # Calculate the present value of the growing perpetuity\n    pv_growth = future_value_growth / ((1 + discount_rate) ** growth_start_year)\n    \n    # Sum the present values to get the total equity value\n    equity_value = pv_fixed_dividends + pv_growth\n    \n    return equity_value",
            "def calculate_terminal_value(initial_dividend: float, short_term_growth: float, \n                             long_term_growth: float, required_return: float, \n                             high_growth_years: int) -> float:\n    \"\"\"\n    Calculate the terminal value of a stock using the two-stage Dividend Discount Model (DDM).\n\n    This function computes the terminal value at the end of the high-growth period\n    for a stock expected to have a period of high growth followed by perpetual growth\n    at a slower rate. The DDM is a popular valuation method for estimating the price\n    of a dividend-paying stock.\n\n    Args:\n        initial_dividend (float): The initial dividend amount at the start of the high-growth period.\n        short_term_growth (float): The growth rate during the high-growth period.\n        long_term_growth (float): The perpetual growth rate following the high-growth period.\n        required_return (float): The required rate of return for the investment.\n        high_growth_years (int): The number of years over which the stock experiences high growth.\n\n    Returns:\n        terminal_value (float): The terminal value of the stock at the end of the high-growth period.\n\n    Notes:\n        - Applicability: Suitable for stocks expected to have distinct high-growth and stable-growth phases.\n        - Constraints: The required return must be greater than the long-term growth rate to avoid division by zero.\n        - Considerations: Ensure growth rates and required return are expressed in decimals (e.g., 0.12 for 12%).\n    \"\"\"\n    if required_return <= long_term_growth:\n        raise ValueError(\"Required return must be greater than the long-term growth rate.\")\n\n    # Calculate the dividend at the end of the high-growth period\n    dividend_at_end_high_growth = initial_dividend * ((1 + short_term_growth) ** high_growth_years)\n    \n    # Calculate the first dividend in the perpetual growth phase\n    first_dividend_in_perpetuity = dividend_at_end_high_growth * (1 + long_term_growth)\n    \n    # Calculate the terminal value using the Gordon Growth Model\n    terminal_value = first_dividend_in_perpetuity / (required_return - long_term_growth)\n    \n    return terminal_value"
        ],
        "usage": {
            "completion_tokens": 1086,
            "prompt_tokens": 2037,
            "total_tokens": 3123,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-1032",
        "article_title": "Heston Model",
        "function": "def calculate_black_scholes_call_price(S: float, K: float, r: float, T: float, volatility: float) -> float:\n    \"\"\"\n    Calculate the European call option price using the Black-Scholes model.\n\n    This function computes the price of a European call option based on the Black-Scholes\n    option pricing model. It considers the option's underlying stock price, strike price,\n    risk-free interest rate, time to maturity, and volatility.\n\n    Args:\n        S (float): Current stock price.\n        K (float): Strike price of the option.\n        r (float): Risk-free interest rate (as a decimal).\n        T (float): Time to maturity in years.\n        volatility (float): Annualized volatility of the stock's returns (as a decimal).\n\n    Returns:\n        call_price (float): The calculated call option price.\n\n    Notes:\n        - This function assumes that the underlying stock does not pay dividends.\n        - European options can only be exercised at the expiration date.\n        - The volatility parameter should be the annualized standard deviation of returns.\n    \"\"\"\n    from math import log, sqrt, exp\n    from scipy.stats import norm\n\n    d1 = (log(S / K) + (r + 0.5 * volatility ** 2) * T) / (volatility * sqrt(T))\n    d2 = d1 - volatility * sqrt(T)\n\n    call_price = S * norm.cdf(d1) - K * exp(-r * T) * norm.cdf(d2)\n    \n    return call_price",
        "statistics": {
            "number_statistics": {
                "args_numbers": 5,
                "question_numbers": 0,
                "context_numbers": 5,
                "total_numbers": 5
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 3,
                    "*": 8,
                    "/": 2,
                    "%": 0,
                    "**": 1
                },
                "total_operators": 16
            },
            "code_statistics": {
                "lines": 6,
                "parentheses": 18
            }
        },
        "difficulty": 5.480638923341991,
        "context": "A financial analyst is assessing the value of a call option on Duratech Inc., a technology company known for high volatility in its stock. The current stock price of Duratech is 120 USD. The analyst considers a call option with a strike price of 130 USD, a maturity of 1 year, and expects an annual risk-free interest rate of 2%. Given Duratech's historical data, the annualized volatility of the stock is estimated to be 35%. The analyst needs to compute the fair value of this European call option using the Black-Scholes model.",
        "question": "What is the calculated price of the European call option on Duratech Inc. using the Black-Scholes model? Answer to two decimal places.",
        "python_solution": "def solution():\n    # Imports for mathematical functions and distributions\n    from math import log, sqrt, exp\n    from scipy.stats import norm\n    \n    # Define variables based on the problem statement\n    S = 120  # Current stock price\n    K = 130  # Strike price\n    r = 0.02  # Risk-free interest rate\n    T = 1  # Time to maturity in years\n    volatility = 0.35  # Volatility of the stock's returns\n    \n    # Calculate d1 and d2 for the Black-Scholes model\n    d1 = (log(S / K) + (r + 0.5 * volatility ** 2) * T) / (volatility * sqrt(T))\n    d2 = d1 - volatility * sqrt(T)\n    \n    # Calculate the call option price using the Black-Scholes formula\n    call_price = S * norm.cdf(d1) - K * exp(-r * T) * norm.cdf(d2)\n    \n    # Return the call price rounded to two decimal places\n    return round(call_price, 2)\n\n# Running the solution function will compute the required result\nsolution()",
        "ground_truth": 13.72,
        "source": "FinanceReasoning-test-55",
        "question_id": "test-2197",
        "level": "hard",
        "output": [
            "### Step-by-Step Reasoning:\n\n1. **Understand the Problem Context and Methodology Used**:\n   - The goal is to calculate the **fair value** of a European call option based on the **Black-Scholes model**.\n   - The function provided in the problem context uses the Black-Scholes formula, which assumes:\n     - No dividends for the underlying stock.\n     - Stock price follows a geometric Brownian motion.\n     - European options can only be exercised at expiration.\n     - The volatility, interest rate, and other parameters are constant.\n\n2. **Identify the Input Variables and Their Values**:\n    - Current stock price (\\(S\\)): 120 USD\n    - Strike price (\\(K\\)): 130 USD\n    - Risk-free interest rate (\\(r\\)): 2% = 0.02 (as a decimal)\n    - Time to maturity (\\(T\\)): 1 year\n    - Volatility (\\(\\sigma\\)): 35% = 0.35 (as a decimal)\n\n3. **Emphasizing Constraints (EC)**:\n    - Inputs such as time to maturity (\\(T\\)), current stock price (\\(S\\)), strike price (\\(K\\)), and volatility (\\(\\sigma\\)) must be strictly positive.\n    - The result should be accurate to **two decimal places**.\n\n4. **Mathematical Formula**:\n   - The Black-Scholes formula calculates the price of a European call option as:\n     \\[\n     C = S \\cdot N(d_1) - K \\cdot e^{-rT} \\cdot N(d_2)\n     \\]\n     where:\n     \\[\n     d_1 = \\frac{\\ln(S / K) + (r + 0.5 \\cdot \\sigma^2) \\cdot T}{\\sigma \\cdot \\sqrt{T}}\n     \\]\n     \\[\n     d_2 = d_1 - \\sigma \\cdot \\sqrt{T}\n     \\]\n     \\(C\\): Call option price, \\(N(d)\\): cumulative standard normal distribution, \\(\\ln\\): natural logarithm, \\(e\\): exponential function.\n\n5. **Execute Solution Safely Using a Provided Formula**:\n   - Use Python to implement the **Black-Scholes model** and solve for the call option price, ensuring accurate implementation.\n\n6. **Generate the Python Program**:\n   - The program will follow the steps:\n     1. Define the known values (e.g., current stock price, strike price, etc.).\n     2. Compute \\(d_1\\) and \\(d_2\\) based on their respective formulas.\n     3. Use these to calculate the final call option price.\n     4. Ensure the result is returned to two decimal points.\n\nHere's the Python solution:\n\n```python\ndef solution():\n    # Import necessary libraries for mathematical calculations\n    from math import log, sqrt, exp\n    from scipy.stats import norm\n\n    # Step 1: Define variables\n    S = 120  # Current stock price (USD)\n    K = 130  # Strike price (USD)\n    r = 0.02  # Annual risk-free interest rate (decimal)\n    T = 1  # Time to maturity (year)\n    sigma = 0.35  # Annualized volatility (decimal)\n\n    # Step 2: Calculate d1 and d2\n    d1 = (log(S / K) + (r + 0.5 * sigma ** 2) * T) / (sigma * sqrt(T))\n    d2 = d1 - sigma * sqrt(T)\n\n    # Step 3: Calculate the call price using the Black-Scholes formula\n    call_price = S * norm.cdf(d1) - K * exp(-r * T) * norm.cdf(d2)\n\n    # Step 4: Return the result rounded to 2 decimal places\n    return round(call_price, 2)\n```"
        ],
        "retrieval_query": "What is the calculated price of the European call option on Duratech Inc. using the Black-Scholes model? Answer to two decimal places.",
        "useful_functions": [
            "def calculate_black_scholes_call_price(S: float, K: float, r: float, T: float, volatility: float) -> float:\n    \"\"\"\n    Calculate the European call option price using the Black-Scholes model.\n\n    This function computes the price of a European call option based on the Black-Scholes\n    option pricing model. It considers the option's underlying stock price, strike price,\n    risk-free interest rate, time to maturity, and volatility.\n\n    Args:\n        S (float): Current stock price.\n        K (float): Strike price of the option.\n        r (float): Risk-free interest rate (as a decimal).\n        T (float): Time to maturity in years.\n        volatility (float): Annualized volatility of the stock's returns (as a decimal).\n\n    Returns:\n        call_price (float): The calculated call option price.\n\n    Notes:\n        - This function assumes that the underlying stock does not pay dividends.\n        - European options can only be exercised at the expiration date.\n        - The volatility parameter should be the annualized standard deviation of returns.\n    \"\"\"\n    from math import log, sqrt, exp\n    from scipy.stats import norm\n\n    d1 = (log(S / K) + (r + 0.5 * volatility ** 2) * T) / (volatility * sqrt(T))\n    d2 = d1 - volatility * sqrt(T)\n\n    call_price = S * norm.cdf(d1) - K * exp(-r * T) * norm.cdf(d2)\n    \n    return call_price",
            "import math\nfrom scipy.stats import norm\n\ndef calculate_black_scholes_call_price(S: float, K: float, t: float, r: float, sigma: float) -> float:\n    \"\"\"\n    Calculate the Black-Scholes price of a European call option.\n\n    This function computes the theoretical price of a European call option using the Black-Scholes \n    model. The model estimates option prices by considering the following variables: the current \n    stock price, the option's strike price, the time to option expiration, the risk-free interest rate, \n    and the volatility of the underlying asset.\n\n    Args:\n        S (float): The current price of the underlying asset.\n        K (float): The strike price of the option.\n        t (float): The time to expiration in years.\n        r (float): The annual risk-free interest rate, expressed as a decimal.\n        sigma (float): The volatility of the underlying asset, expressed as a decimal.\n\n    Returns:\n        C (float): The estimated price of the European call option.\n\n    Notes:\n        - Applicability: This function is used only for pricing European call options which \n          can only be exercised at expiration.\n        - Constraints: The function assumes that the underlying asset pays no dividends, \n          volatility and risk-free rate are constant, and the asset returns are normally distributed.\n        - Considerations: This model may not be accurate for American options or in volatile markets \n          that deviate from its assumptions.\n    \"\"\"\n    if t <= 0 or S <= 0 or K <= 0 or sigma <= 0:\n        raise ValueError(\"Time to expiration, stock price, strike price, and volatility must be positive.\")\n    \n    d1 = (math.log(S / K) + (r + 0.5 * sigma ** 2) * t) / (sigma * math.sqrt(t))\n    d2 = d1 - sigma * math.sqrt(t)\n    \n    C = S * norm.cdf(d1) - K * math.exp(-r * t) * norm.cdf(d2)\n    \n    return C",
            "def black_scholes_option_price(stock_price: float, strike_price: float, time_to_expiration: float, \n                               risk_free_rate: float, volatility: float, option_type: str = 'call') -> float:\n    \"\"\"\n    Calculate the theoretical price of a European option using the Black-Scholes model.\n\n    This function computes the price of European call or put options using the Black-Scholes formula\n    based on input variables such as the underlying stock price, strike price, time to expiration,\n    risk-free rate, and volatility. It assumes a log-normal distribution of stock prices.\n\n    Args:\n        stock_price (float): The current price of the underlying stock.\n        strike_price (float): The strike price of the option.\n        time_to_expiration (float): Time to expiration in years.\n        risk_free_rate (float): The risk-free interest rate as a decimal.\n        volatility (float): The standard deviation of the stock's returns (volatility).\n        option_type (str, optional): The type of option to price ('call' or 'put'). Default is 'call'.\n\n    Returns:\n        option_price (float): The theoretical price of the option.\n\n    Notes:\n        - Applicability: Applies to European options only; not applicable to American options.\n        - Constraints: Assumes constant volatility and risk-free rate, no dividends.\n        - Considerations: Option type must be 'call' or 'put'; otherwise, raises ValueError.\n    \"\"\"\n    from math import log, sqrt, exp\n    from scipy.stats import norm\n\n    if option_type not in ['call', 'put']:\n        raise ValueError(\"Option type must be either 'call' or 'put'.\")\n\n    d1 = (log(stock_price / strike_price) + (risk_free_rate + 0.5 * volatility ** 2) * time_to_expiration) / (volatility * sqrt(time_to_expiration))\n    d2 = d1 - volatility * sqrt(time_to_expiration)\n\n    if option_type == 'call':\n        option_price = (stock_price * norm.cdf(d1)) - (strike_price * exp(-risk_free_rate * time_to_expiration) * norm.cdf(d2))\n    else:  # 'put'\n        option_price = (strike_price * exp(-risk_free_rate * time_to_expiration) * norm.cdf(-d2)) - (stock_price * norm.cdf(-d1))\n\n    return option_price"
        ],
        "usage": {
            "completion_tokens": 826,
            "prompt_tokens": 1736,
            "total_tokens": 2562,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-711",
        "article_title": "Bell Curve",
        "function": "def calculate_empirical_rule_proportions(mean: float, std_dev: float, data_points: list) -> dict:\n    \"\"\"\n    Calculate the percentage of data points within 1, 2, and 3 standard deviations \n    from the mean using the empirical rule for a normal distribution.\n\n    This function utilizes the empirical rule (68-95-99.7 rule) to determine what portion \n    of the data points in a list fall within 1, 2, and 3 standard deviations from the mean \n    in a normally distributed dataset.\n\n    Args:\n        mean (float): The mean (average) of the data distribution.\n        std_dev (float): The standard deviation of the data distribution.\n        data_points (list): A list of numeric data points.\n\n    Returns:\n        proportions (dict): A dictionary containing the proportion of data points within\n                            1, 2, and 3 standard deviations from the mean. Keys are \n                            'within_1_std_dev', 'within_2_std_dev', and 'within_3_std_dev'.\n\n    Notes:\n        - Applicability: Applicable to datasets that are normally distributed.\n        - Constraints: Assumes the data is symmetrically distributed around the mean.\n        - Considerations: Data should be preprocessed to remove anomalies that \n                          do not reflect the characteristics of a normal distribution.\n    \"\"\"\n    within_1_std_dev = sum(mean - std_dev <= x <= mean + std_dev for x in data_points) / len(data_points)\n    within_2_std_dev = sum(mean - 2 * std_dev <= x <= mean + 2 * std_dev for x in data_points) / len(data_points)\n    within_3_std_dev = sum(mean - 3 * std_dev <= x <= mean + 3 * std_dev for x in data_points) / len(data_points)\n\n    proportions = {\n        'within_1_std_dev': within_1_std_dev * 100,\n        'within_2_std_dev': within_2_std_dev * 100,\n        'within_3_std_dev': within_3_std_dev * 100\n    }\n\n    return proportions",
        "statistics": {
            "number_statistics": {
                "args_numbers": 3,
                "question_numbers": 0,
                "context_numbers": 12,
                "total_numbers": 12
            },
            "operator_statistics": {
                "operators": {
                    "+": 3,
                    "-": 3,
                    "*": 7,
                    "/": 3,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 16
            },
            "code_statistics": {
                "lines": 9,
                "parentheses": 12
            }
        },
        "difficulty": 5.480638923341991,
        "context": "You are a financial analyst tasked with evaluating the performance of a group of hedge funds over the past year. The returns of the hedge funds are assumed to be normally distributed. To understand the distribution of these returns, you collect the following data points (in percentage returns): [5, 8, 13, 12, 7, 9, 10, 6, 11, 7]. The average return (mean) of these hedge funds has been calculated to be 9%, and the standard deviation is 2%. \n\nUnderstanding how many funds had returns within certain ranges enables better risk assessments and decision-making to avoid high-risk investments.",
        "question": "In what percentage of cases do the hedge funds' returns fall within one standard deviation of the mean return? Provide your answer as a percentage to two decimal places.",
        "python_solution": "def solution():\n    # Given data\n    mean = 9\n    std_dev = 2\n    data_points = [5, 8, 13, 12, 7, 9, 10, 6, 11, 7]\n    \n    # Calculating the range for within 1 standard deviation\n    lower_bound = mean - std_dev\n    upper_bound = mean + std_dev\n\n    # Counting the number of data points within 1 standard deviation of the mean\n    count_within_1_std_dev = sum(lower_bound <= x <= upper_bound for x in data_points)\n\n    # Calculating the percentage\n    percentage_within_1_std_dev = (count_within_1_std_dev / len(data_points)) * 100\n\n    # Return the answer rounded to two decimal places\n    return round(percentage_within_1_std_dev, 2)\n\n# Running the solution to get the result\n# print(solution())",
        "ground_truth": 60.0,
        "source": "FinanceReasoning-test-79",
        "question_id": "test-2198",
        "level": "hard",
        "output": [
            "To determine the percentage of hedge funds' returns that fall within one standard deviation of the mean, I need to consider the constraints and distributions of the data:\n\n1. **Constraints (EC):**\n   - It is given that the hedge funds' returns are normally distributed.\n   - The mean (average return) is 9%, and the standard deviation is 2%.\n   - For normally distributed data, approximately 68.27% of the data points fall within one standard deviation (mean \u00b1 1 SD).\n   - The answer must be provided in percentage form and rounded to two decimal places.\n\n2. **Approach:**\n   - Using the properties of a normal distribution, calculate the lower and upper boundaries for one standard deviation:\n     - Lower boundary: mean - 1 * standard deviation.\n     - Upper boundary: mean + 1 * standard deviation.\n   - The range is from 7% to 11% (inclusive).\n   - Count how many hedge fund returns in the provided dataset lie within this range.\n   - Divide the count by the total number of data points and multiply by 100 to get the percentage.\n\n3. **Implementation in Python:**\n   - We evaluate how many percentages fall in the range [7%, 11%], as outlined above.\n\nHere is the Python program to solve the problem:\n\n```python\ndef solution():\n    # Define variables: dataset values, mean, standard deviation\n    data = [5, 8, 13, 12, 7, 9, 10, 6, 11, 7]  # hedge fund returns\n    mean = 9  # average return in percentage\n    std_dev = 2  # standard deviation\n    \n    # Calculate the range boundaries for one standard deviation\n    lower_bound = mean - std_dev\n    upper_bound = mean + std_dev\n    \n    # Count how many returns are within the one standard deviation range\n    within_range = sum(lower_bound <= x <= upper_bound for x in data)\n    \n    # Calculate the percentage of returns within the range\n    percentage_within_range = (within_range / len(data)) * 100\n    \n    # Return the percentage rounded to two decimal places\n    return round(percentage_within_range, 2)\n```"
        ],
        "retrieval_query": "In what percentage of cases do the hedge funds' returns fall within one standard deviation of the mean return? Provide your answer as a percentage to two decimal places.",
        "useful_functions": [
            "def calculate_change_in_hedged_percentage(initial_hedge: float, final_hedge: float) -> int:\n    \"\"\"\n    Calculate the change in the percentage of anticipated purchases hedged.\n\n    This function computes the change in percentage points of a hedged position\n    over two periods, representing the degree to which anticipated purchases are\n    covered by hedging instruments.\n\n    Args:\n        initial_hedge (float): The initial percentage of purchases hedged in the first period.\n        final_hedge (float): The final percentage of purchases hedged in the second period.\n\n    Returns:\n        change (int): The change in percentage points between the two hedging percentages.\n                      Result is the absolute value of the percentage point change.\n\n    Notes:\n        - Applicability: Useful for analyzing changes in hedging strategies over time.\n        - Constraints: Percentages must be expressed as numerical values (e.g., 60 for 60%).\n        - Considerations: The function returns the absolute change in percentage points\n                          as an integer, representing the magnitude of change.\n    \"\"\"\n    if initial_hedge < 0 or final_hedge < 0:\n        raise ValueError(\"Hedging percentages must be non-negative values.\")\n    \n    change = abs(final_hedge - initial_hedge)\n    \n    return int(change)"
        ],
        "usage": {
            "completion_tokens": 464,
            "prompt_tokens": 774,
            "total_tokens": 1238,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-2105",
        "article_title": "Least Squares Criterion",
        "function": "def calculate_least_squares_regression_line(x_values: list, y_values: list) -> tuple:\n    \"\"\"\n    Calculate the parameters of the least squares regression line for a given set of data points.\n\n    This function calculates the slope and intercept of the line of best fit using the least squares \n    method for a given set of independent (x) and dependent (y) variable data points. The line can be \n    used to predict the value of the dependent variable for a given independent variable input.\n\n    Args:\n        x_values (list): A list of independent variable data points.\n        y_values (list): A list of dependent variable data points.\n\n    Returns:\n        coefficients (tuple): A tuple containing the slope and intercept of the regression line.\n\n    Notes:\n        - Applicability: Useful in finance, economics, and general statistical analysis for \n          determining the relationship between two variables.\n        - Constraints: x_values and y_values must be of equal length and have more than one data point.\n        - Considerations: Outliers can significantly affect the regression line. It assumes a linear \n          relationship between variables.\n    \"\"\"\n    if len(x_values) != len(y_values):\n        raise ValueError(\"x_values and y_values must be of the same length.\")\n    if len(x_values) < 2:\n        raise ValueError(\"At least two data points are required.\")\n\n    n = len(x_values)\n    sum_x = sum(x_values)\n    sum_y = sum(y_values)\n    sum_x_squared = sum(x**2 for x in x_values)\n    sum_xy = sum(x * y for x, y in zip(x_values, y_values))\n\n    # Calculate the slope (m) and intercept (b)\n    slope = (n * sum_xy - sum_x * sum_y) / (n * sum_x_squared - sum_x**2)\n    intercept = (sum_y - slope * sum_x) / n\n    \n    return slope, intercept",
        "statistics": {
            "number_statistics": {
                "args_numbers": 2,
                "question_numbers": 0,
                "context_numbers": 15,
                "total_numbers": 15
            },
            "operator_statistics": {
                "operators": {
                    "+": 0,
                    "-": 3,
                    "*": 5,
                    "/": 2,
                    "%": 0,
                    "**": 2
                },
                "total_operators": 12
            },
            "code_statistics": {
                "lines": 9,
                "parentheses": 22
            }
        },
        "difficulty": 5.480638923341991,
        "context": "A financial analyst is studying the relationship between advertising expenditure and revenue for a small chain of retail stores. Over the last five months, the analyst has collected the following data:\n\n- Month 1: Advertising Expenditure = $3,000, Revenue = $20,000\n- Month 2: Advertising Expenditure = $4,000, Revenue = $23,000\n- Month 3: Advertising Expenditure = $5,000, Revenue = $25,000\n- Month 4: Advertising Expenditure = $6,000, Revenue = $26,000\n- Month 5: Advertising Expenditure = $7,000, Revenue = $28,000\n\nThe analyst wants to use this data to establish a least squares regression line that predicts revenue based on advertising expenditure.",
        "question": "What is the slope of the least squares regression line that the analyst should use to predict revenue based on advertising expenditure? Answer as a decimal to two decimal places.",
        "python_solution": "def solution():\n    # Define the data points\n    x_values = [3000, 4000, 5000, 6000, 7000]  # Advertising Expenditure\n    y_values = [20000, 23000, 25000, 26000, 28000]  # Revenue\n\n    # Calculate necessary sums\n    n = len(x_values)\n    sum_x = sum(x_values)\n    sum_y = sum(y_values)\n    sum_x_squared = sum(x**2 for x in x_values)\n    sum_xy = sum(x * y for x, y in zip(x_values, y_values))\n\n    # Calculate the slope (m) of the regression line\n    slope = (n * sum_xy - sum_x * sum_y) / (n * sum_x_squared - sum_x**2)\n\n    # Return the slope, rounded to two decimal places\n    return round(slope, 2)",
        "ground_truth": 1.9,
        "source": "FinanceReasoning-test-89",
        "question_id": "test-2199",
        "level": "hard",
        "output": [
            "To solve the problem of finding the slope of the least squares regression line, we proceed as follows:\n\n**Step-by-step Reasoning**:\n\n1. **Understanding the Least Squares Regression**:\n   - The formula to calculate the slope \\( m \\) of the regression line is:\n     \\[\n     m = \\frac{\\Sigma \\left( (x_i - \\bar{x}) \\cdot (y_i - \\bar{y}) \\right)}{\\Sigma (x_i - \\bar{x})^2}\n     \\]\n     where:\n     - \\( x_i \\) = advertising expenditure\n     - \\( y_i \\) = revenue\n     - \\( \\bar{x} \\) = mean of \\( x \\) values\n     - \\( \\bar{y} \\) = mean of \\( y \\) values\n\n2. **Restating Constraints (EC)**:\n   - Compute the slope \\( m \\) of the regression line based on the given data.\n   - Ensure calculations are carried out with sufficient precision, and the final result is rounded to two decimal places.\n\n3. **Calculating Averages**:\n   - Compute \\( \\bar{x} \\), the mean of advertising expenditures (\\( x \\)).\n   - Compute \\( \\bar{y} \\), the mean of revenues (\\( y \\)).\n\n4. **Breaking Down the Formula**:\n   - Compute the numerator:\n     \\[\n     \\Sigma \\left( (x_i - \\bar{x}) \\cdot (y_i - \\bar{y}) \\right)\n     \\]\n   - Compute the denominator:\n     \\[\n     \\Sigma (x_i - \\bar{x})^2\n     \\]\n\n5. **Compute and Return Result**:\n   - Divide the numerator by the denominator to find the slope \\( m \\).\n   - Round to two decimal places.\n\nNow, I will write the Python program to compute the required slope.\n\n```python\ndef solution():\n    # Define variables: data for advertising expenditures and revenues\n    advertising_expenditure = [3000, 4000, 5000, 6000, 7000]\n    revenues = [20000, 23000, 25000, 26000, 28000]\n    \n    # Calculate means of x (advertising expenditures) and y (revenues)\n    x_mean = sum(advertising_expenditure) / len(advertising_expenditure)\n    y_mean = sum(revenues) / len(revenues)\n    \n    # Calculate the numerator and the denominator for the slope formula\n    numerator = sum((x - x_mean) * (y - y_mean) for x, y in zip(advertising_expenditure, revenues))\n    denominator = sum((x - x_mean) ** 2 for x in advertising_expenditure)\n    \n    # Compute the slope\n    slope = numerator / denominator\n    \n    # Return the answer rounded to two decimal places\n    return round(slope, 2)\n```"
        ],
        "retrieval_query": "What is the slope of the least squares regression line that the analyst should use to predict revenue based on advertising expenditure? Answer as a decimal to two decimal places.",
        "useful_functions": [],
        "usage": {
            "completion_tokens": 610,
            "prompt_tokens": 518,
            "total_tokens": 1128,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "A hedge fund with $120 million of initial investment, 2-20 fee structure and a hurdle rate of 5%, earned 35% return at year end. Assuming management fee is based on assets under management at year end and incentive fee is calculated net of management fee and is based on return in excess of the hurdle rate, what is an investor's net return in $ terms? Answer in millions of dollars to two decimal places.",
        "context": "",
        "statistics": {
            "number_statistics": {
                "question_numbers": 5,
                "context_numbers": 0,
                "total_numbers": 5
            },
            "operator_statistics": {
                "operators": {
                    "+": 4,
                    "-": 4,
                    "*": 5,
                    "/": 0,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 13
            },
            "code_statistics": {
                "lines": 14,
                "parentheses": 10
            }
        },
        "difficulty": 5.509388336627977,
        "ground_truth": 32.21,
        "source": "FinCode-test-15",
        "python_solution": "initial_aum = 120\ngrowth_rate = 0.35\nmanagement_fee_rate = 0.02\nincentive_rate = 0.2\nhurdle_rate = 0.05\nend_year_aum = initial_aum * (1 + growth_rate)\nmanagement_fee = end_year_aum * management_fee_rate\nnet_year_end = end_year_aum - management_fee\nif net_year_end < initial_aum * (1 + hurdle_rate):\n    total_fees = management_fee\nelse:\n    total_fees = management_fee + (net_year_end - initial_aum * (1 + hurdle_rate)) * incentive_rate\n\nnet_return = end_year_aum - total_fees - initial_aum\nround(net_return, 2)\n",
        "question_id": "test-2200",
        "level": "hard",
        "output": [
            "### Step-by-Step Reasoning Using Advanced Reasoning Techniques:\n1. **Emphasizing Constraints (EC):**\n   - The hedge fund has a 2% management fee and 20% incentive fee structure.\n   - The hurdle rate is 5% annually\u2014returns below the hurdle rate do not trigger the incentive fee.\n   - Incentive fees are calculated net of the management fee and are based on returns exceeding the hurdle rate.\n   - The net return to the investor has to be computed in dollar terms, rounded to two decimal places, and expressed in millions.\n\n### Step-by-Step Solution:\n1. **Initial Setup:**\n   - Initial investment is $120 million.\n   - The annual growth rate for the investment is 35% (0.35 as a decimal).\n   - Management fee rate is 2% (0.02 as a decimal).\n   - Incentive fee rate is 20% (0.20 as a decimal).\n   - The hurdle rate is 5% (0.05 as a decimal).\n\n2. **Calculate End-of-Year Assets Under Management (AUM):**\n   - AUM at the end of the year is calculated as:\n   \\[\n   \\text{End of Year AUM} = \\text{Initial Investment} \\times (1 + \\text{Growth Rate})\n   \\]\n\n3. **Calculate Management Fee:**\n   - Management fee is calculated as a fixed percentage of the End-of-Year AUM:\n   \\[\n   \\text{Management Fee} = \\text{End of Year AUM} \\times \\text{Management Fee Rate}\n   \\]\n\n4. **Net Year-End AUM After Management Fee:**\n   - Subtract the management fee from the End-of-Year AUM.\n\n5. **Calculate Hurdle Amount:**\n   - Hurdle amount is calculated as:\n   \\[\n   \\text{Hurdle Amount} = \\text{Initial Investment} \\times (1 + \\text{Hurdle Rate})\n   \\]\n\n6. **Calculate Incentive Fee:**\n   - If the net AUM after the management fee exceeds the hurdle amount, calculate the incentive fee as:\n   \\[\n   \\text{Incentive Fee} = (\\text{Net AUM after Management Fee} - \\text{Hurdle Amount}) \\times \\text{Incentive Fee Rate}\n   \\]\n   - Otherwise, the incentive fee is zero.\n\n7. **Total Fees:**\n   - Sum up the management fee and incentive fee to get the total fees.\n\n8. **Net Return to Investor:**\n   - Subtract the total fees and the initial investment from the End-of-Year AUM to calculate the net return to the investor:\n   \\[\n   \\text{Net Return} = \\text{End of Year AUM} - \\text{Total Fees} - \\text{Initial Investment}\n   \\]\n   - Round the result to two decimal places and return the value in millions.\n\n### Python Implementation:\n```python\ndef solution():\n    # Define variables name and value\n    initial_investment = 120  # in millions of dollars\n    growth_rate = 0.35  # 35% annual return\n    management_fee_rate = 0.02  # 2% annual management fee\n    incentive_rate = 0.20  # 20% incentive fee rate\n    hurdle_rate = 0.05  # 5% annual hurdle rate\n\n    # Step 1: Calculate End-of-Year AUM\n    end_year_aum = initial_investment * (1 + growth_rate)\n\n    # Step 2: Calculate Management Fee\n    management_fee = end_year_aum * management_fee_rate\n\n    # Step 3: Net Year-End AUM after Management Fee\n    net_year_end = end_year_aum - management_fee\n\n    # Step 4: Calculate Hurdle Amount\n    hurdle_amount = initial_investment * (1 + hurdle_rate)\n\n    # Step 5: Calculate Incentive Fee\n    if net_year_end > hurdle_amount:\n        incentive_fee = (net_year_end - hurdle_amount) * incentive_rate\n    else:\n        incentive_fee = 0\n\n    # Step 6: Total Fees\n    total_fees = management_fee + incentive_fee\n\n    # Step 7: Calculate Net Return to Investor\n    net_return = end_year_aum - total_fees - initial_investment\n\n    # Step 8: Round to Two Decimal Places and Return Result (in millions)\n    return round(net_return, 2)\n```\n\n### Explanation of Code Behavior:\n- The code systematically follows the logical breakdown of fees and returns.\n- All calculations respect the constraints and requirements of the problem.\n- The result is rounded to two decimal places as requested.\n\nRun the program to get the investor's net return in millions of dollars."
        ],
        "retrieval_query": "A hedge fund with $120 million of initial investment, 2-20 fee structure and a hurdle rate of 5%, earned 35% return at year end. Assuming management fee is based on assets under management at year end and incentive fee is calculated net of management fee and is based on return in excess of the hurdle rate, what is an investor's net return in $ terms? Answer in millions of dollars to two decimal places.",
        "useful_functions": [
            "def calculate_investor_net_return(aum_end_of_year: float, high_water_mark: float, \n                                  management_fee_rate: float, previous_assets_value: float, \n                                  incentive_fee_rate: float, hurdle_rate: float) -> float:\n    \"\"\"\n    Calculate the net return for an investor under a \"2 and 20\" fee arrangement.\n\n    This function determines the net return for an investor, given the end-of-year\n    assets under management (AUM), a high-water mark, management and incentive fee rates, \n    a hurdle rate, and the initial value of assets. It accounts for management fees and \n    calculates incentive fees only if the AUM surpasses the high-water mark adjusted by the hurdle rate.\n\n    Args:\n        aum_end_of_year (float): The assets under management at the end of the year.\n        high_water_mark (float): The benchmark value of assets before fees can be collected.\n        management_fee_rate (float): The rate applied to AUM for management fees.\n        previous_assets_value (float): The value of assets at the start of the year.\n        incentive_fee_rate (float): The rate applied to returns above the high-water mark.\n        hurdle_rate (float): The minimum rate of return required before incentive fees apply.\n\n    Returns:\n        net_return_percentage (float): The net return for the investor, expressed as a percentage.\n\n    Notes:\n        - Applicability: Suitable for investment firms using \"2 and 20\" fee structures.\n        - Constraints: Assumes positive values for all inputs.\n        - Considerations: Always round the final result to three decimal places for percentage representation.\n    \"\"\"\n    management_fee = aum_end_of_year * management_fee_rate\n    \n    if aum_end_of_year < high_water_mark * (1 + hurdle_rate):\n        total_fee = management_fee\n    else:\n        total_fee = management_fee + (aum_end_of_year - high_water_mark * (1 + hurdle_rate)) * incentive_fee_rate\n\n    net_return = (aum_end_of_year - total_fee) / previous_assets_value - 1\n\n    return round(net_return * 100, 3)",
            "def calculate_hedge_fund_net_return(initial_investment: float, growth_rate: float, \n                                    management_fee_rate: float, incentive_rate: float, \n                                    hurdle_rate: float) -> float:\n    \"\"\"\n    Calculate the net return for an investor in a hedge fund given various parameters.\n\n    This function computes the net return for an investor in a hedge fund with specified\n    initial investment, growth rate, fee structure, and hurdle rate. It factors in both\n    the management and incentive fees to determine the investor's net return.\n\n    Args:\n        initial_investment (float): The initial amount invested in the hedge fund.\n        growth_rate (float): The percentage increase in assets by the end of the year.\n        management_fee_rate (float): The management fee rate applied to year-end assets.\n        incentive_rate (float): The incentive fee rate on returns exceeding the hurdle rate.\n        hurdle_rate (float): The minimum acceptable return rate before incentive fees apply.\n\n    Returns:\n        net_return (float): The net return for the investor after fees, in millions.\n\n    Notes:\n        - This calculation assumes that the management fee is based on year-end assets \n          and the incentive fee is based on returns above the hurdle rate after management fees.\n        - All rates should be provided as decimals (e.g., 0.35 for 35%).\n        - Make sure that initial_investment and all rates are realistic and positive values.\n    \"\"\"\n    end_year_aum = initial_investment * (1 + growth_rate)\n    management_fee = end_year_aum * management_fee_rate\n    net_year_end = end_year_aum - management_fee\n    \n    hurdle_amount = initial_investment * (1 + hurdle_rate)\n    if net_year_end > hurdle_amount:\n        incentive_fee = (net_year_end - hurdle_amount) * incentive_rate\n    else:\n        incentive_fee = 0\n    \n    total_fees = management_fee + incentive_fee\n    net_return = end_year_aum - total_fees - initial_investment\n    \n    return round(net_return, 2)"
        ],
        "usage": {
            "completion_tokens": 1006,
            "prompt_tokens": 1283,
            "total_tokens": 2289,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-1295",
        "article_title": "Positive Correlation",
        "function": "def calculate_correlation_coefficient(x_values: list, y_values: list) -> float:\n    \"\"\"\n    Calculate the correlation coefficient between two sets of variables.\n\n    This function computes the correlation coefficient, a statistical measure that\n    describes the strength and direction of a linear relationship between two\n    continuous variables.\n\n    Args:\n        x_values (list): A list of numerical values representing the independent variable.\n        y_values (list): A list of numerical values representing the dependent variable.\n                         Must be of the same length as x_values.\n\n    Returns:\n        correlation_coefficient (float): The correlation coefficient, with a value ranging\n                                         from -1 (perfect negative correlation) to +1\n                                         (perfect positive correlation). A value of 0 indicates\n                                         no correlation.\n\n    Notes:\n        - Applicability: Suitable for evaluating the linear relationship between two\n          datasets in financial analysis, research, and statistics.\n        - Constraints: The lengths of x_values and y_values must be equal.\n        - Considerations: The correlation coefficient only measures linear relationships\n          and may not adequately describe nonlinear relationships. Outliers can also\n          significantly impact the result.\n    \"\"\"\n    if len(x_values) != len(y_values):\n        raise ValueError(\"Both input lists must have the same number of elements.\")\n\n    n = len(x_values)\n    mean_x = sum(x_values) / n\n    mean_y = sum(y_values) / n\n    covariance = sum((x - mean_x) * (y - mean_y) for x, y in zip(x_values, y_values))\n    variance_x = sum((x - mean_x) ** 2 for x in x_values)\n    variance_y = sum((y - mean_y) ** 2 for y in y_values)\n\n    correlation_coefficient = covariance / ((variance_x * variance_y) ** 0.5)\n    \n    return correlation_coefficient",
        "statistics": {
            "number_statistics": {
                "args_numbers": 2,
                "question_numbers": 0,
                "context_numbers": 24,
                "total_numbers": 24
            },
            "operator_statistics": {
                "operators": {
                    "+": 0,
                    "-": 4,
                    "*": 2,
                    "/": 3,
                    "%": 0,
                    "**": 3
                },
                "total_operators": 12
            },
            "code_statistics": {
                "lines": 8,
                "parentheses": 26
            }
        },
        "difficulty": 5.529429087511423,
        "context": "An investment analyst is studying two tech companies, Company A and Company B, to understand the relationship between their stock prices over the past year. The analyst collects monthly closing stock prices for each company. For Company A, the stock prices (in dollars) over twelve months were: [120, 125, 130, 128, 135, 138, 140, 142, 145, 147, 150, 152]. For Company B, the stock prices were: [100, 105, 110, 107, 112, 115, 118, 120, 123, 125, 130, 132]. The analyst wants to calculate the correlation coefficient to understand the strength and direction of the linear relationship between their stock prices.",
        "question": "What is the correlation coefficient between the stock prices of Company A and Company B? Provide your answer rounded to two decimal places.",
        "python_solution": "def solution():\n    # Define the stock prices for Company A and Company B\n    company_a_prices = [120, 125, 130, 128, 135, 138, 140, 142, 145, 147, 150, 152]\n    company_b_prices = [100, 105, 110, 107, 112, 115, 118, 120, 123, 125, 130, 132]\n\n    # Ensure both lists have the same length\n    if len(company_a_prices) != len(company_b_prices):\n        raise ValueError(\"Both input lists must have the same number of elements.\")\n    \n    # Calculate means of both price lists\n    mean_a = sum(company_a_prices) / len(company_a_prices)\n    mean_b = sum(company_b_prices) / len(company_b_prices)\n    \n    # Calculate covariance\n    covariance = sum((a - mean_a) * (b - mean_b) for a, b in zip(company_a_prices, company_b_prices))\n    \n    # Calculate variances\n    variance_a = sum((a - mean_a) ** 2 for a in company_a_prices)\n    variance_b = sum((b - mean_b) ** 2 for b in company_b_prices)\n    \n    # Calculate the correlation coefficient\n    correlation_coefficient = covariance / ((variance_a * variance_b) ** 0.5)\n\n    # Return the result rounded to two decimal places\n    return round(correlation_coefficient, 2)\n\n# To obtain the solution, one would call the solution function:\nsolution()",
        "ground_truth": 0.99,
        "source": "FinanceReasoning-test-86",
        "question_id": "test-2201",
        "level": "hard",
        "output": [
            "To solve the problem, let's consider the following step-by-step reasoning using the \"Emphasizing Constraints (EC)\" technique:\n\n1. **Understand the Problem**:  \n   - The goal is to calculate the correlation coefficient between the stock prices of Company A and Company B.\n   - This involves computing the Pearson correlation coefficient, which measures the linear relationship between two sets of data.\n\n2. **Constraints**:  \n   - Input dataset: Two equal-length lists of monthly closing stock prices for Company A and Company B.\n   - Ensure the computation adheres to requirements:\n     - Use the standard formula for the Pearson correlation coefficient:\n       \\[\n       r = \\frac{\\sum((x - \\bar{x}) \\cdot (y - \\bar{y}))}{\\sqrt{\\sum(x - \\bar{x})^2 \\cdot \\sum(y - \\bar{y})^2}}\n       \\]\n       where \\(x\\) represents values in Company A, \\(y\\) represents values in Company B, and \\(\\bar{x}\\), \\(\\bar{y}\\) are their respective means.\n     - Round the result to two decimal places as required.\n\n3. **Plan Computation**:  \n   - Calculate the mean for both datasets.\n   - Compute the numerator (covariance of the two datasets).\n   - Compute the denominator (product of the standard deviations of both datasets).\n   - Divide the numerator by the denominator to get the correlation coefficient.\n   - Round the result to two decimal places.\n\n4. **Output**:  \n   - Return the rounded correlation coefficient.\n\nHere is the Python program to compute the correlation coefficient:\n\n```python\ndef solution():\n    # Define variables: stock prices of Company A and Company B\n    company_a = [120, 125, 130, 128, 135, 138, 140, 142, 145, 147, 150, 152]\n    company_b = [100, 105, 110, 107, 112, 115, 118, 120, 123, 125, 130, 132]\n    \n    # Compute the means of both datasets\n    mean_a = sum(company_a) / len(company_a)\n    mean_b = sum(company_b) / len(company_b)\n    \n    # Compute the numerator (covariance) and denominator components\n    numerator = sum((a - mean_a) * (b - mean_b) for a, b in zip(company_a, company_b))\n    denominator_a = sum((a - mean_a)**2 for a in company_a)\n    denominator_b = sum((b - mean_b)**2 for b in company_b)\n    \n    # Calculate the correlation coefficient\n    correlation_coefficient = numerator / (denominator_a**0.5 * denominator_b**0.5)\n    \n    # Return the answer rounded to two decimal places\n    return round(correlation_coefficient, 2)\n```"
        ],
        "retrieval_query": "What is the correlation coefficient between the stock prices of Company A and Company B? Provide your answer rounded to two decimal places.",
        "useful_functions": [],
        "usage": {
            "completion_tokens": 605,
            "prompt_tokens": 509,
            "total_tokens": 1114,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "A company debt security provides a coupon rate of 5% and only has 3 years left until it matures. The interest is given yearly. The benchmark spot curve currently lists a series of rates. Right now, the bond is trading at a Z-spread of 234 basis points. The bond has a face value of 100. What's the bond's worth?  Answer to three decimal places.",
        "python_solution": "def solution():\n    PMT = 5\n    FV = 100\n    S1 = 0.0486\n    S2 = 0.0495\n    S3 = 0.0565\n    Z = 0.0234\n\n    PV1 = PMT / ((1 + S1 + Z)**1)\n    PV2 = PMT / ((1 + S2 + Z)**2)\n    PV3 = (PMT + FV) / ((1 + S3 + Z)**3)\n\n    return PV1 + PV2 + PV3",
        "ground_truth": 92.383,
        "topic": "Asset Classes & Derivatives",
        "statistics": {
            "number_statistics": {
                "args_numbers": 5,
                "question_numbers": 4,
                "context_numbers": 6,
                "total_numbers": 10
            },
            "operator_statistics": {
                "operators": {
                    "+": 9,
                    "-": 0,
                    "*": 0,
                    "/": 3,
                    "%": 0,
                    "**": 3
                },
                "total_operators": 15
            },
            "code_statistics": {
                "lines": 10,
                "parentheses": 14
            }
        },
        "difficulty": 5.541263545158426,
        "source": "FinanceMath-validation-100",
        "context": "['| Time-to-Maturity | Spot Rate |\\n|------------------|-----------|\\n| 1 year           | 4.86%     |\\n| 2 years          | 4.95%     |\\n| 3 years          | 5.65%     |']",
        "question_id": "test-2202",
        "level": "hard",
        "output": [
            "To find the worth of the bond, we need to calculate its price. The price of the bond is determined using the specified coupon rate, spot rates, and the Z-spread. Here's the step-by-step solution:\n\n---\n\n### Step-by-Step Solution:\n1. **Understanding Inputs**:\n   - Face Value: \\(100\\)\n   - Coupon Rate: \\(5\\%\\) or \\(0.05\\) (annual coupon payments).\n   - Time to Maturity: \\(3\\) years.\n   - Spot Rates: \\(4.86\\%\\), \\(4.95\\%\\), \\(5.65\\%\\) (given as percentages, must convert to decimals for calculations).\n   - Z-Spread: \\(234\\) basis points, or \\(234/10000 = 0.0234\\).\n\n2. **Constraint (EC)**:\n   - Ensure we discount cash flows by the adjusted discount rate. The adjusted discount rate for each year is calculated by adding the Z-spread to the respective spot rate.\n\n3. **Discount Cash Flows**:\n   - Each coupon payment equals the face value multiplied by the coupon rate (\\(100 \\times 0.05 = 5\\)).\n   - The third-year cash flow includes both the face value (\\(100\\)) and the coupon payment (\\(100 + 5 = 105\\)).\n\n4. **Bond Price Formula (Extended with Z-Spread)**:\n   - Compute the present value of each cash flow using the adjusted discount rate:\n     \\[\n     \\text{bond\\_price} = \\sum_{t=1}^{T} \\frac{\\text{cash\\_flow}_t}{(1 + \\text{spot\\_rate}_t + \\text{z\\_spread})^t}\n     \\]\n\n5. **Discount Rates**:\n   - Adjusted Spot Rates (in decimals) for each year:\n     \\[\n     \\text{Adjusted\\_Rate(t)} = \\text{Spot\\_Rate(t)} + \\text{Z-Spread}\n     \\]\n\n6. **Final Constraint**:\n   - Return the bond price rounded to three decimal places.\n\n---\n\nNow, let's implement the solution in Python:\n\n```python\ndef solution():\n    # Define variables\n    face_value = 100  # Bond face value\n    coupon_rate = 0.05  # 5% coupon rate\n    years_to_maturity = 3  # 3 years\n    spot_rates = [0.0486, 0.0495, 0.0565]  # Spot rates in decimals\n    z_spread = 0.0234  # Z-spread in decimal format\n\n    # Adjust spot rates by adding z-spread\n    adjusted_rates = [spot + z_spread for spot in spot_rates]\n\n    # Calculate bond price\n    bond_price = 0.0\n    for year in range(1, years_to_maturity + 1):\n        if year < years_to_maturity:  # First 2 years, only coupon payments\n            cash_flow = face_value * coupon_rate\n        else:  # Last year includes face value + coupon\n            cash_flow = face_value * coupon_rate + face_value\n        \n        bond_price += cash_flow / ((1 + adjusted_rates[year - 1]) ** year)\n\n    # Round to three decimal places\n    return round(bond_price, 3)\n```"
        ],
        "retrieval_query": "A company debt security provides a coupon rate of 5% and only has 3 years left until it matures. The interest is given yearly. The benchmark spot curve currently lists a series of rates. Right now, the bond is trading at a Z-spread of 234 basis points. The bond has a face value of 100. What's the bond's worth?  Answer to three decimal places.",
        "useful_functions": [
            "def calculate_bond_price(face_value: float, coupon_rate: float, years: int, spot_rates: list) -> float:\n    \"\"\"\n    Calculate the price of a bond using its face value, annual coupon rate, and spot rates for each year.\n\n    This function computes the present value of the bond's future cash flows, \n    which include regular coupon payments and the face value at maturity. Each \n    cash flow is discounted using the specified spot rate for its corresponding year.\n\n    Args:\n        face_value (float): The face value of the bond.\n        coupon_rate (float): The annual coupon rate of the bond as a decimal (e.g., 0.05 for 5%).\n        years (int): The number of years until the bond matures.\n        spot_rates (list): A list of annual spot rates as decimals (one for each year up to maturity).\n\n    Returns:\n        bond_price (float): The calculated price of the bond.\n\n    Notes:\n        - Applicability: This function is used for bonds with annual coupon payments.\n        - Constraints: The length of spot_rates must equal the number of years.\n        - Considerations: Ensure that spot_rates contain realistic values \n          (greater than -1) to prevent calculation errors in the discounting process.\n    \"\"\"\n    if len(spot_rates) != years:\n        raise ValueError(\"The number of spot rates must match the number of years.\")\n\n    bond_price = 0.0\n    coupon_payment = face_value * coupon_rate\n\n    for year in range(1, years + 1):\n        cash_flow = coupon_payment\n        if year == years:\n            cash_flow += face_value  # Add face value at maturity\n        bond_price += cash_flow / ((1 + spot_rates[year - 1]) ** year)\n\n    return round(bond_price, 2)",
            "def calculate_piotroski_score(net_income: float, roas: float, op_cash_flow: float, prev_op_cash_flow: float, \n                              long_term_debt: float, prev_long_term_debt: float, current_ratio: float, \n                              prev_current_ratio: float, new_shares_issued: bool, gross_margin: float, \n                              prev_gross_margin: float, asset_turnover: float, prev_asset_turnover: float) -> int:\n    \"\"\"\n    Calculate the Piotroski score for a company based on its financial statements.\n\n    This function computes the Piotroski score, which is a measure of a company's financial strength,\n    by evaluating profitability, leverage, liquidity, and operating efficiency using 9 predefined criteria.\n    Each criterion awards one point if the condition is met. The maximum possible score is 9.\n\n    Args:\n        net_income (float): The net income of the company for the current period.\n        roas (float): The return on assets for the current year.\n        op_cash_flow (float): The operating cash flow for the current period.\n        prev_op_cash_flow (float): The operating cash flow for the previous period.\n        long_term_debt (float): The amount of long-term debt for the current period.\n        prev_long_term_debt (float): The amount of long-term debt for the previous period.\n        current_ratio (float): The current ratio for the current period.\n        prev_current_ratio (float): The current ratio for the previous period.\n        new_shares_issued (bool): Whether new shares were issued in the current period (True if issued, False otherwise).\n        gross_margin (float): The gross margin for the current year.\n        prev_gross_margin (float): The gross margin for the previous year.\n        asset_turnover (float): The asset turnover ratio for the current year.\n        prev_asset_turnover (float): The asset turnover ratio for the previous year.\n\n    Returns:\n        piotroski_score (int): The Piotroski score, an integer between 0 and 9.\n\n    Notes:\n        - Applicability: Suitable for evaluating the financial strength of value stocks.\n        - Constraints: Assumes availability of the required financial data for both the current and previous periods.\n        - Considerations: This function is a simple method and does not capture all factors affecting financial health.\n    \"\"\"\n    score = 0\n\n    # Profitability criteria\n    if net_income > 0:\n        score += 1\n    if roas > 0:\n        score += 1\n    if op_cash_flow > 0:\n        score += 1\n    if op_cash_flow > net_income:\n        score += 1\n\n    # Leverage, liquidity, and source of funds criteria\n    if long_term_debt < prev_long_term_debt:\n        score += 1\n    if current_ratio > prev_current_ratio:\n        score += 1\n    if not new_shares_issued:\n        score += 1\n\n    # Operating efficiency criteria\n    if gross_margin > prev_gross_margin:\n        score += 1\n    if asset_turnover > prev_asset_turnover:\n        score += 1\n\n    return score"
        ],
        "usage": {
            "completion_tokens": 710,
            "prompt_tokens": 1519,
            "total_tokens": 2229,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-1484",
        "article_title": "Regression",
        "function": "def perform_linear_regression(x_values: list, y_values: list) -> dict:\n    \"\"\"\n    Perform simple linear regression to find the relationship between two variables.\n\n    This function calculates the linear regression parameters: slope (b), y-intercept (a),\n    and residuals (error term) for a given set of x and y values using the least-squares approach.\n\n    Args:\n        x_values (list): A list of independent variable values.\n        y_values (list): A list of dependent variable values.\n\n    Returns:\n        result (dict): A dictionary containing the y-intercept ('a'), the slope ('b'),\n                       and the list of residuals ('residuals').\n\n    Notes:\n        - Applicability: This function is applicable for cases requiring simple linear regression.\n        - Constraints: Lists x_values and y_values must have the same length and contain numeric data.\n        - Considerations: Assumes a linear relationship between x and y. Does not check assumptions\n          of homoskedasticity or normality. Ideal for small datasets.\n    \"\"\"\n    if len(x_values) != len(y_values):\n        raise ValueError(\"x_values and y_values must have the same length.\")\n\n    n = len(x_values)\n    mean_x = sum(x_values) / n\n    mean_y = sum(y_values) / n\n\n    numer = sum((x - mean_x) * (y - mean_y) for x, y in zip(x_values, y_values))\n    denom = sum((x - mean_x) ** 2 for x in x_values)\n\n    if denom == 0:\n        raise ValueError(\"Denominator in slope calculation is zero; check variation in x_values.\")\n\n    b = numer / denom\n    a = mean_y - b * mean_x\n\n    residuals = [y - (a + b * x) for x, y in zip(x_values, y_values)]\n\n    return {'a': a, 'b': b, 'residuals': residuals}",
        "statistics": {
            "number_statistics": {
                "args_numbers": 2,
                "question_numbers": 0,
                "context_numbers": 10,
                "total_numbers": 10
            },
            "operator_statistics": {
                "operators": {
                    "+": 1,
                    "-": 5,
                    "*": 3,
                    "/": 3,
                    "%": 0,
                    "**": 1
                },
                "total_operators": 13
            },
            "code_statistics": {
                "lines": 9,
                "parentheses": 22
            }
        },
        "difficulty": 5.560681631015528,
        "context": "A financial analyst is studying the relationship between advertising expenditure and monthly sales revenue for a retail company. The analyst collects the following data over five months: \n\n- Advertising Expenditure (in thousands): [10, 20, 30, 40, 50]\n- Monthly Sales Revenue (in thousands): [15, 30, 50, 40, 65]\n\nThe analyst wants to establish a linear relationship between the advertising expenditure and the sales revenue to better understand how changes in advertising spending might affect sales.",
        "question": "What is the slope of the linear relationship between advertising expenditure and monthly sales revenue? Express your answer to two decimal places.",
        "python_solution": "def solution():\n    # Provided data\n    x_values = [10, 20, 30, 40, 50]  # Advertising Expenditure in thousands\n    y_values = [15, 30, 50, 40, 65]  # Monthly Sales Revenue in thousands\n\n    # Calculate means\n    n = len(x_values)\n    mean_x = sum(x_values) / n\n    mean_y = sum(y_values) / n\n\n    # Calculate numerator and denominator for the slope (b)\n    numer = sum((x - mean_x) * (y - mean_y) for x, y in zip(x_values, y_values))\n    denom = sum((x - mean_x) ** 2 for x in x_values)\n\n    # Calculate the slope\n    b = numer / denom\n\n    # Return the slope rounded to two decimal places\n    return round(b, 2)\n\nsolution()",
        "ground_truth": 1.1,
        "source": "FinanceReasoning-test-80",
        "question_id": "test-2203",
        "level": "hard",
        "output": [
            "### Step-by-Step Reasoning:\n\n1. **Identify the Problem**: The problem asks us to find the slope of the linear relationship between advertising expenditure and sales revenue. The slope can be mathematically represented as:\n   \\[\n   m = \\frac{{\\text{{Covariance of X and Y}}}}{{\\text{{Variance of X}}}}\n   \\]\n\n2. **Define Constraints** (EC):\n   - Data for advertising expenditure (`X`) and sales revenue (`Y`) is given as a list of numerical values, measured in thousands.\n   - The slope should be expressed to two decimal places.\n   - Ensure correct mathematical computation using appropriate statistical formulas.\n\n3. **Break Down the Formulas**:\n   - The covariance formula:\n     \\[\n     \\text{Cov}(X, Y) = \\frac{\\sum (X_i - \\bar{X})(Y_i - \\bar{Y})}{n}\n     \\]\n   - The variance formula:\n     \\[\n     \\text{Var}(X) = \\frac{\\sum (X_i - \\bar{X})^2}{n}\n     \\]\n   - Here, \\( \\bar{X} \\) and \\( \\bar{Y} \\) are the averages (means) of the datasets `X` and `Y`, and \\( n \\) is the number of data points.\n\n4. **Plan the Calculation**:\n   - First, calculate the means of advertising (`X`) and revenue (`Y`).\n   - Compute covariance of `X` and `Y`, and variance of `X`.\n   - Use these values to determine the slope.\n\n5. **Express as Python Program**:\n   Writing the steps in Python ensures precision and clarity in implementation, using the formulas explicitly.\n\nHere is the Python program:\n\n```python\ndef solution():\n    # Define variables for advertising expenditure (X) and sales revenue (Y)\n    X = [10, 20, 30, 40, 50]\n    Y = [15, 30, 50, 40, 65]\n    n = len(X)  # Number of data points\n    \n    # Calculate mean of X and Y\n    mean_X = sum(X) / n\n    mean_Y = sum(Y) / n\n    \n    # Calculate covariance of X and Y\n    covariance_XY = sum((X[i] - mean_X) * (Y[i] - mean_Y) for i in range(n))\n    \n    # Calculate variance of X\n    variance_X = sum((X[i] - mean_X) ** 2 for i in range(n))\n    \n    # Calculate slope (m)\n    slope = covariance_XY / variance_X\n    \n    # Express slope to two decimal places\n    return round(slope, 2)\n```"
        ],
        "retrieval_query": "What is the slope of the linear relationship between advertising expenditure and monthly sales revenue? Express your answer to two decimal places.",
        "useful_functions": [],
        "usage": {
            "completion_tokens": 572,
            "prompt_tokens": 453,
            "total_tokens": 1025,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-2106",
        "article_title": "Least Squares Method",
        "function": "def calculate_least_squares_line(x_values: list, y_values: list) -> tuple:\n    \"\"\"\n    Calculate the line of best fit using the least squares method.\n\n    This function computes the slope and y-intercept of the line of best fit for \n    a given set of data points using the least squares regression method. It's \n    commonly used to determine the linear relationship between two variables.\n\n    Args:\n        x_values (list): A list of independent variable values.\n        y_values (list): A list of dependent variable values. Must be the same \n                         length as x_values.\n\n    Returns:\n        best_fit_line (tuple): A tuple containing the slope and y-intercept of \n                               the line of best fit (slope, intercept).\n\n    Notes:\n        - Applicability: Used for linear regression analysis to explain the \n          relationship between two variables.\n        - Constraints: x_values and y_values must have the same number of elements.\n        - Considerations: The method is sensitive to outliers, which can skew the \n          resulting line of best fit.\n    \"\"\"\n    if len(x_values) != len(y_values):\n        raise ValueError(\"x_values and y_values must be of the same length.\")\n\n    n = len(x_values)\n    sum_x = sum(x_values)\n    sum_y = sum(y_values)\n    sum_xy = sum(x * y for x, y in zip(x_values, y_values))\n    sum_x_squared = sum(x ** 2 for x in x_values)\n\n    # Calculate the slope (m) and y-intercept (b)\n    slope = (n * sum_xy - sum_x * sum_y) / (n * sum_x_squared - sum_x ** 2)\n    intercept = (sum_y - slope * sum_x) / n\n\n    return slope, intercept",
        "statistics": {
            "number_statistics": {
                "args_numbers": 2,
                "question_numbers": 0,
                "context_numbers": 12,
                "total_numbers": 12
            },
            "operator_statistics": {
                "operators": {
                    "+": 0,
                    "-": 4,
                    "*": 5,
                    "/": 2,
                    "%": 0,
                    "**": 2
                },
                "total_operators": 13
            },
            "code_statistics": {
                "lines": 9,
                "parentheses": 22
            }
        },
        "difficulty": 5.560681631015528,
        "context": "A financial analyst is reviewing historical stock data to identify trends that may inform future investments. The analyst has compiled a list of stock prices from the past five months and wants to determine the trend in the stock prices to understand whether the stock is generally appreciating or depreciating. The months are represented as numbers 1 to 5 for simplicity, and the corresponding stock prices are given. \n\nMonth: 1, 2, 3, 4, 5\nStock Price: $150, $155, $147, $160, $166\n\nUsing these data points, the analyst wants to calculate the line of best fit (trend line) to determine the slope, which indicates the average monthly change in stock price. The analyst will use the least squares method to calculate the slope.",
        "question": "What is the slope of the line of best fit (trend line) indicating the average monthly change in stock price? Answer to two decimal places.",
        "python_solution": "def solution():\n    # Given data\n    x_values = [1, 2, 3, 4, 5]  # months\n    y_values = [150, 155, 147, 160, 166]  # stock prices\n\n    # Number of data points\n    n = len(x_values)\n    \n    # Calculate sums needed for the slope formula\n    sum_x = sum(x_values)\n    sum_y = sum(y_values)\n    sum_xy = sum(x * y for x, y in zip(x_values, y_values))\n    sum_x_squared = sum(x ** 2 for x in x_values)\n\n    # Calculate the slope of the line of best fit\n    slope = (n * sum_xy - sum_x * sum_y) / (n * sum_x_squared - sum_x ** 2)\n    \n    # Return the slope rounded to two decimal places\n    return round(slope, 2)",
        "ground_truth": 3.7,
        "source": "FinanceReasoning-test-81",
        "question_id": "test-2204",
        "level": "hard",
        "output": [
            "Let's solve the problem step by step by using the advanced reasoning technique of **Emphasizing Constraints (EC)**:\n\n### Step-by-step Thought Process:\n\n1. **Understand the Problem**:\n   - We have a series of data points representing the month and the corresponding stock prices.\n   - We need to find the slope of the line of best fit using the **least squares method**, which represents the average monthly change in the stock price.\n\n2. **Constraints**:\n   - The slope must be computed as a floating-point number and returned to two decimal places.\n   - The equation for the slope of the line of best fit is:\n     \n     \\[\n     m = \\frac{n \\cdot \\sum(xy) - \\sum(x) \\cdot \\sum(y)}{n \\cdot \\sum(x^2) - (\\sum(x))^2}\n     \\]\n   \n     Where:\n     - \\( n \\): Number of data points (months).\n     - \\( x \\): Independent variable (month numbers).\n     - \\( y \\): Dependent variable (stock prices).\n     - \\( \\sum(xy) \\): Sum of the product of \\( x \\) and \\( y \\).\n     - \\( \\sum(x) \\): Sum of all \\( x \\)-values.\n     - \\( \\sum(y) \\): Sum of all \\( y \\)-values.\n     - \\( \\sum(x^2) \\): Sum of squares of \\( x \\)-values.\n\n3. **Plan**:\n   - Assign \\( x \\)-values (month numbers) and \\( y \\)-values (stock prices) to corresponding variables.\n   - Calculate all necessary sums for the formula.\n   - Compute the slope \\( m \\) using the least squares formula.\n   - Ensure the result is rounded to two decimal places.\n\n4. **Generate Python Program**:\n   - Use Python to implement the least squares calculation step-by-step and return the slope to two decimal places.\n\nNow, let\u2019s move directly to implementing the solution.\n\n```python\ndef solution():\n    # Define variables name and value\n    months = [1, 2, 3, 4, 5]\n    stock_prices = [150, 155, 147, 160, 166]\n    n = len(months)\n    \n    # Calculate the necessary sums\n    sum_x = sum(months)\n    sum_y = sum(stock_prices)\n    sum_xy = sum(x * y for x, y in zip(months, stock_prices))\n    sum_x_squared = sum(x ** 2 for x in months)\n    \n    # Use least squares formula to calculate slope\n    numerator = n * sum_xy - sum_x * sum_y\n    denominator = n * sum_x_squared - (sum_x ** 2)\n    slope = numerator / denominator\n    \n    # Round to two decimal places and return\n    return round(slope, 2)\n```"
        ],
        "retrieval_query": "What is the slope of the line of best fit (trend line) indicating the average monthly change in stock price? Answer to two decimal places.",
        "useful_functions": [],
        "usage": {
            "completion_tokens": 600,
            "prompt_tokens": 512,
            "total_tokens": 1112,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-462",
        "article_title": "Intraday Momentum Index (IMI)",
        "function": "def calculate_intraday_momentum_index(open_prices: list, close_prices: list, period: int = 14) -> list:\n    \"\"\"\n    Calculate the Intraday Momentum Index (IMI) for a security over a specified period.\n\n    The Intraday Momentum Index combines aspects of candlestick analysis with the\n    relative strength index (RSI) to generate overbought or oversold signals, based on\n    the open and close prices over a series of days.\n\n    Args:\n        open_prices (list): A list of opening prices for the security over a series of days.\n        close_prices (list): A list of closing prices for the security over a series of days.\n        period (int): The number of days over which to calculate the IMI. Default is 14.\n\n    Returns:\n        imi_values (list): A list of IMI values indicating the momentum for each period.\n\n    Notes:\n        - Applicability: Used to estimate buying and selling conditions for stocks or other securities.\n        - Constraints: \n            - The 'open_prices' and 'close_prices' lists must be the same length.\n            - The period must be less than or equal to the length of the price lists.\n        - Considerations:\n            - High IMI values (above 70) indicate overbought conditions; low values (below 30) indicate oversold conditions.\n            - IMI is particularly useful for short-term traders rather than long-term investors.\n    \"\"\"\n    if len(open_prices) != len(close_prices):\n        raise ValueError(\"The length of open_prices and close_prices must be the same.\")\n    if period <= 0 or period > len(open_prices):\n        raise ValueError(\"Period must be positive and less than or equal to the length of price lists.\")\n\n    gains = []\n    losses = []\n    for op, cp in zip(open_prices, close_prices):\n        if cp > op:\n            gains.append(cp - op)\n            losses.append(0)\n        else:\n            gains.append(0)\n            losses.append(op - cp)\n\n    imi_values = []\n    for i in range(period, len(open_prices) + 1):\n        sum_gains = sum(gains[i-period:i])\n        sum_losses = sum(losses[i-period:i])\n        imi = (sum_gains / (sum_gains + sum_losses)) * 100 if (sum_gains + sum_losses) != 0 else 0\n        imi_values.append(imi)\n\n    return imi_values",
        "statistics": {
            "number_statistics": {
                "args_numbers": 3,
                "question_numbers": 1,
                "context_numbers": 32,
                "total_numbers": 33
            },
            "operator_statistics": {
                "operators": {
                    "+": 3,
                    "-": 4,
                    "*": 1,
                    "/": 1,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 9
            },
            "code_statistics": {
                "lines": 16,
                "parentheses": 26
            }
        },
        "difficulty": 5.564520407322694,
        "context": "A day trader is analyzing a stock to determine whether it's in an overbought or oversold condition. The trader decides to use the Intraday Momentum Index (IMI) to guide their decisions. Over the past 15 days, the stock's opening and closing prices have been recorded as follows:\n\n- Opening prices: [150, 152, 153, 151, 152, 150, 149, 151, 150, 148, 147, 146, 148, 149, 147]\n- Closing prices: [152, 150, 152, 153, 151, 152, 150, 149, 151, 150, 149, 148, 146, 147, 148]\n\nThe trader wants to calculate the IMI over a 14-day period to check current momentum conditions.",
        "question": "Calculate the Intraday Momentum Index (IMI) at the end of the 15th day using a 14-day period. What is the IMI value? Answer as a percentage to two decimal places.",
        "python_solution": "def solution():\n    # Define the given opening and closing prices\n    open_prices = [150, 152, 153, 151, 152, 150, 149, 151, 150, 148, 147, 146, 148, 149, 147]\n    close_prices = [152, 150, 152, 153, 151, 152, 150, 149, 151, 150, 149, 148, 146, 147, 148]\n    period = 14\n    \n    # Initialize lists for gains and losses\n    gains = []\n    losses = []\n    \n    # Calculate gains and losses based on daily open and close prices\n    for open_price, close_price in zip(open_prices, close_prices):\n        if close_price > open_price:\n            gains.append(close_price - open_price)\n            losses.append(0)\n        else:\n            gains.append(0)\n            losses.append(open_price - close_price)\n    \n    # Calculate the IMI for the last day of the provided period\n    sum_gains = sum(gains[-period:])\n    sum_losses = sum(losses[-period:])\n    \n    # Compute the IMI value for the period\n    if (sum_gains + sum_losses) != 0:\n        imi = (sum_gains / (sum_gains + sum_losses)) * 100\n    else:\n        imi = 0\n        \n    # Return the IMI value rounded to two decimal places\n    return round(imi, 2)\n\nprint(solution())",
        "ground_truth": 56.52,
        "source": "FinanceReasoning-test-47",
        "question_id": "test-2205",
        "level": "hard",
        "output": [
            "To solve the problem accurately and efficiently, let's proceed step by step by emphasizing the constraints (EC) and then proceed to implement a solution in Python.\n\n### Step-by-step Process:\n\n1. **Understand the Problem Context**:\n   - We are tasked to compute the Intraday Momentum Index (IMI) for a 14-day period.\n   - IMI helps in assessing overbought or oversold conditions using candlestick analysis (difference between opening and closing prices over a given period).\n\n2. **Identify Inputs**:\n   - Opening prices: `[150, 152, 153, 151, 152, 150, 149, 151, 150, 148, 147, 146, 148, 149, 147]`.\n   - Closing prices: `[152, 150, 152, 153, 151, 152, 150, 149, 151, 150, 149, 148, 146, 147, 148]`.\n   - Period: `14`.\n\n3. **Constraints** (EC):\n   - The lengths of `open_prices` and `close_prices` must be equal. This is satisfied as both have a length of 15.\n   - The `period` must be less than or equal to the length of the price lists. This is satisfied as `14 \u2264 15`.\n   - The calculated IMI at the end of the 15th day is requested.\n\n4. **Formula for IMI**:\n   - The IMI formula:\n     \\[\n     IMI = \\left( \\frac{\\text{Sum of gains}}{\\text{Sum of gains} + \\text{Sum of losses}} \\right) \\times 100\n     \\]\n     - A day has a \"gain\" when the closing price is higher than the opening price (`close_price > open_price`). The \"gain\" for that day is the difference `(close_price - open_price)`.\n     - A day has a \"loss\" when the closing price is lower than the opening price (`close_price < open_price`). The \"loss\" for that day is the difference `(open_price - close_price)`.\n     - Use the 14 most recent days to compute the sum of gains and losses at the end of the 15th day.\n\n5. **Plan of Execution**:\n   - Compute the gains and losses for each day.\n   - Sum the gains and losses for the 14-day window ending on the 15th day.\n   - Plug these sums into the IMI formula to compute the value as a percentage with two decimal places.\n\n6. **Implementation**:\n   - Calculate the IMI using the function provided.\n   - Specifically extract and return the IMI at the end of the 15th day, as it corresponds to the last calculated IMI value.\n\nNow, let\u2019s write the Python program.\n\n```python\ndef solution():\n    # Define variables name and value\n    open_prices = [150, 152, 153, 151, 152, 150, 149, 151, 150, 148, 147, 146, 148, 149, 147]\n    close_prices = [152, 150, 152, 153, 151, 152, 150, 149, 151, 150, 149, 148, 146, 147, 148]\n    period = 14\n\n    # Calculate gains and losses\n    gains = []\n    losses = []\n    for op, cp in zip(open_prices, close_prices):\n        if cp > op:\n            gains.append(cp - op)\n            losses.append(0)\n        else:\n            gains.append(0)\n            losses.append(op - cp)\n\n    # Calculate IMI for the specified period\n    imi_values = []\n    for i in range(period, len(open_prices) + 1):  # Calculate IMI starting from the 'period'th day\n        sum_gains = sum(gains[i-period:i])\n        sum_losses = sum(losses[i-period:i])\n        imi = (sum_gains / (sum_gains + sum_losses)) * 100 if (sum_gains + sum_losses) != 0 else 0\n        imi_values.append(imi)\n\n    # The value at the end of the 15th day is the last IMI value\n    answer = round(imi_values[-1], 2)  # Ensure the result is a percentage rounded to 2 decimal places\n    return answer\n```"
        ],
        "retrieval_query": "Calculate the Intraday Momentum Index (IMI) at the end of the 15th day using a 14-day period. What is the IMI value? Answer as a percentage to two decimal places.",
        "useful_functions": [
            "def calculate_intraday_momentum_index(open_prices: list, close_prices: list, period: int = 14) -> list:\n    \"\"\"\n    Calculate the Intraday Momentum Index (IMI) for a security over a specified period.\n\n    The Intraday Momentum Index combines aspects of candlestick analysis with the\n    relative strength index (RSI) to generate overbought or oversold signals, based on\n    the open and close prices over a series of days.\n\n    Args:\n        open_prices (list): A list of opening prices for the security over a series of days.\n        close_prices (list): A list of closing prices for the security over a series of days.\n        period (int): The number of days over which to calculate the IMI. Default is 14.\n\n    Returns:\n        imi_values (list): A list of IMI values indicating the momentum for each period.\n\n    Notes:\n        - Applicability: Used to estimate buying and selling conditions for stocks or other securities.\n        - Constraints: \n            - The 'open_prices' and 'close_prices' lists must be the same length.\n            - The period must be less than or equal to the length of the price lists.\n        - Considerations:\n            - High IMI values (above 70) indicate overbought conditions; low values (below 30) indicate oversold conditions.\n            - IMI is particularly useful for short-term traders rather than long-term investors.\n    \"\"\"\n    if len(open_prices) != len(close_prices):\n        raise ValueError(\"The length of open_prices and close_prices must be the same.\")\n    if period <= 0 or period > len(open_prices):\n        raise ValueError(\"Period must be positive and less than or equal to the length of price lists.\")\n\n    gains = []\n    losses = []\n    for op, cp in zip(open_prices, close_prices):\n        if cp > op:\n            gains.append(cp - op)\n            losses.append(0)\n        else:\n            gains.append(0)\n            losses.append(op - cp)\n\n    imi_values = []\n    for i in range(period, len(open_prices) + 1):\n        sum_gains = sum(gains[i-period:i])\n        sum_losses = sum(losses[i-period:i])\n        imi = (sum_gains / (sum_gains + sum_losses)) * 100 if (sum_gains + sum_losses) != 0 else 0\n        imi_values.append(imi)\n\n    return imi_values"
        ],
        "usage": {
            "completion_tokens": 938,
            "prompt_tokens": 1063,
            "total_tokens": 2001,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-1797",
        "article_title": "T-Test",
        "function": "def calculate_equal_variance_t_test(mean_1: float, mean_2: float, var_1: float, var_2: float, n1: int, n2: int) -> (float, int):\n    \"\"\"\n    Calculate the t-value and degrees of freedom for an equal variance t-test.\n\n    This function computes the t-value and degrees of freedom for an independent\n    t-test assuming equal variances, often used with the same number of samples or\n    similar variances in each group.\n\n    Args:\n        mean_1 (float): The average value of the first sample set.\n        mean_2 (float): The average value of the second sample set.\n        var_1 (float): The variance of the first sample set.\n        var_2 (float): The variance of the second sample set.\n        n1 (int): The number of records in the first sample set.\n        n2 (int): The number of records in the second sample set.\n\n    Returns:\n        t_value (float): The computed t-value for the equal variance t-test.\n        degrees_of_freedom (int): The degrees of freedom used in the test.\n\n    Notes:\n        - Applicability: Use when samples have equal sizes or variances.\n        - Constraints: Sample size must be greater than 1 for each group.\n        - Considerations: Assumes sampled populations are normally distributed.\n    \"\"\"\n    if n1 <= 1 or n2 <= 1:\n        raise ValueError(\"Sample size must be greater than 1 for each group.\")\n\n    pooled_variance = (((n1 - 1) * var_1 ** 2) + ((n2 - 1) * var_2 ** 2)) / (n1 + n2 - 2)\n    t_value = (mean_1 - mean_2) / ((pooled_variance * (1/n1 + 1/n2)) ** 0.5)\n    degrees_of_freedom = n1 + n2 - 2\n    \n    return t_value, degrees_of_freedom",
        "statistics": {
            "number_statistics": {
                "args_numbers": 6,
                "question_numbers": 0,
                "context_numbers": 6,
                "total_numbers": 6
            },
            "operator_statistics": {
                "operators": {
                    "+": 4,
                    "-": 5,
                    "*": 3,
                    "/": 4,
                    "%": 0,
                    "**": 3
                },
                "total_operators": 19
            },
            "code_statistics": {
                "lines": 4,
                "parentheses": 20
            }
        },
        "difficulty": 5.583496308781699,
        "context": "A financial analyst is comparing the performance of two mutual funds. The first fund, Fund A, has an average annual return of 8% with a variance of 4, over the past 5 years. The second fund, Fund B, has an average annual return of 6% with a variance of 3, also over the past 5 years. The analyst wants to determine if there is a statistically significant difference in the performance of these two funds using an equal variance t-test.",
        "question": "What is the t-value of the equal variance t-test for these two mutual funds? Answer to two decimal places.",
        "python_solution": "def solution():\n    # Define variables with given values\n    mean_1 = 8.0  # Average return for Fund A\n    mean_2 = 6.0  # Average return for Fund B\n    var_1 = 4.0   # Variance for Fund A\n    var_2 = 3.0   # Variance for Fund B\n    n1 = 5        # Number of years for Fund A\n    n2 = 5        # Number of years for Fund B\n\n    # Compute the pooled variance\n    pooled_variance = (((n1 - 1) * var_1) + ((n2 - 1) * var_2)) / (n1 + n2 - 2)\n\n    # Compute the t-value\n    t_value = (mean_1 - mean_2) / ((pooled_variance * (1/n1 + 1/n2)) ** 0.5)\n\n    # Return the t-value rounded to two decimal places\n    return round(t_value, 2)\n\n# Example execution\n# print(solution())  # This will output the t-value rounded to two decimal places.",
        "ground_truth": 1.69,
        "source": "FinanceReasoning-test-53",
        "question_id": "test-2206",
        "level": "hard",
        "output": [
            "To solve this problem step by step using the reasoning technique:\n\n### Step-by-Step Process:\n1. Understand the requirements:\n   - The goal is to calculate the t-value using the given data.\n   - The data involves average annual returns, variances, and number of years (n = 5 for both funds).\n   - A two-sample equal variance t-test is required.\n\n2. Emphasize Constraints (EC):\n   - Calculate the t-value precisely and answer to two decimal places.\n   - Use appropriate formulas for the two-sample t-test assuming equal variances.\n\n3. Formula for the t-value:\n   \\[\n   t = \\frac{\\overline{X_1} - \\overline{X_2}}{\\sqrt{s_p^2 (\\frac{1}{n_1} + \\frac{1}{n_2})}}\n   \\]\n   Where:\n   - \\(\\overline{X_1}, \\overline{X_2}\\) are the average annual returns (mean) of Fund A and Fund B respectively.\n   - \\(n_1, n_2\\) are the sample sizes for Fund A and Fund B respectively (both are 5 in this case).\n   - \\(s_p^2\\) is the pooled variance, calculated as:\n     \\[\n     s_p^2 = \\frac{(n_1 - 1)s_1^2 + (n_2 - 1)s_2^2}{n_1 + n_2 - 2}\n     \\]\n     Where \\(s_1^2\\) and \\(s_2^2\\) are the variances of Fund A and Fund B respectively.\n\n4. Assign given values:\n   - \\(\\overline{X_1} = 8\\%\\), \\(\\overline{X_2} = 6\\%\\)\n   - \\(s_1^2 = 4\\), \\(s_2^2 = 3\\)\n   - \\(n_1 = n_2 = 5\\)\n\n5. Compute step-by-step:\n   - Calculate \\(s_p^2\\) (pooled variance).\n   - Substitute all values into the t-value formula.\n   - Ensure calculation accuracy and round the final answer to two decimal places.\n\n### Python Program:\n```python\ndef solution():\n    # Define variables for means, variances, and sample sizes\n    mean_fund_a = 8  # Average annual return for Fund A (%)\n    mean_fund_b = 6  # Average annual return for Fund B (%)\n    variance_fund_a = 4  # Variance of Fund A\n    variance_fund_b = 3  # Variance of Fund B\n    n1 = 5  # Sample size for Fund A\n    n2 = 5  # Sample size for Fund B\n\n    # Calculate the pooled variance (s_p^2)\n    pooled_variance = ((n1 - 1) * variance_fund_a + (n2 - 1) * variance_fund_b) / (n1 + n2 - 2)\n    \n    # Calculate t-value\n    t_value = (mean_fund_a - mean_fund_b) / ((pooled_variance * (1 / n1 + 1 / n2)) ** 0.5)\n    \n    # Round the result to two decimal places\n    t_value = round(t_value, 2)\n    \n    return t_value\n```"
        ],
        "retrieval_query": "What is the t-value of the equal variance t-test for these two mutual funds? Answer to two decimal places.",
        "useful_functions": [],
        "usage": {
            "completion_tokens": 726,
            "prompt_tokens": 447,
            "total_tokens": 1173,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "A portfolio consisting of two shares has the following properties: What is the standard deviation of the returns from this portfolio (expressed as a percentage)? Answer to two decimal places.",
        "python_solution": "def solution():\n    # weights \n    w1 = 0.3\n    w2 = 0.7\n\n    # standard deviations \n    sigma1 = 12\n    sigma2 = 25\n\n    # correlation coefficient \n    rho = 0.2\n\n    # covariance \n    Cov = rho * sigma1 * sigma2\n    \n    # portfolio variance \n    variance = (w1**2 * sigma1**2) + (w2**2 * sigma2**2) + (2*w1*w2*Cov)\n    \n    # portfolio standard deviation \n    std_dev = variance**0.5\n\n    return round(std_dev, 2)",
        "ground_truth": 18.56,
        "topic": "Quantitative Analysis & Valuation",
        "statistics": {
            "number_statistics": {
                "args_numbers": 5,
                "question_numbers": 0,
                "context_numbers": 10,
                "total_numbers": 10
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 0,
                    "*": 7,
                    "/": 0,
                    "%": 0,
                    "**": 5
                },
                "total_operators": 14
            },
            "code_statistics": {
                "lines": 15,
                "parentheses": 8
            }
        },
        "difficulty": 5.583496308781699,
        "source": "FinanceMath-validation-70",
        "context": "['|                   | Stock 1 | Stock 2 |\\n|-------------------|---------|---------|\\n| Expected return   | 7%      | 10%     |\\n| Standard deviation| 12%     | 25%     |\\n| Portfolio weights | 0.30    | 0.70    |\\n| Correlation       | 0.20    | 0.20    |']",
        "question_id": "test-2207",
        "level": "hard",
        "output": [
            "To calculate the standard deviation of the portfolio, let\u2019s analyze the problem with the **constraints** in place:\n\n### Step-by-Step Plan:\n1. **Understand Inputs and Constraints**:  \n   The weights of the two stocks (`0.30` for Stock 1 and `0.70` for Stock 2) should sum up to `1`. The standard deviations are to be expressed in percentages (`12%` for Stock 1 and `25%` for Stock 2). The correlation coefficient (`0.20`) is between the two stocks.\n   \n2. **Check Covariance Matrix Formation**:  \n   - The covariance between Stock i and Stock j is given by:\n     \\[\n     \\text{Cov}(i, j) = \\text{correlation}(i, j) \\times \\sigma_i \\times \\sigma_j\n     \\]\n     Using this formula:\n     - Cov(Stock1, Stock2) = \\( 0.20 \\times 12\\% \\times 25\\% \\)\n\n3. **Define and Use Portfolio Standard Deviation Formula**:  \n   The portfolio variance, and subsequently standard deviation, for two assets is calculated as:\n   \\[\n   \\text{portfolio variance} = (w_1 \\cdot \\sigma_1)^2 + (w_2 \\cdot \\sigma_2)^2 + 2 \\cdot w_1 \\cdot w_2 \\cdot \\text{Cov}(1, 2)\n   \\]\n   Where:\n   - \\( w_1, w_2 \\) are weights\n   - \\( \\sigma_1, \\sigma_2 \\) are standard deviations\n   - Cov(1, 2) is the covariance between the two stocks.\n\n4. **Perform Final Standard Deviation Calculation**:  \n   - The standard deviation of the portfolio is simply:\n     \\[\n     \\text{portfolio standard deviation} = \\sqrt{\\text{portfolio variance}}\n     \\]\n\n5. **Output Constraints**:  \n   - Return the final value in percentage terms, up to **two decimal places**.\n\nNow, let\u2019s implement the solution in Python:\n\n```python\ndef solution():\n    # Define variables\n    weights = [0.30, 0.70]  # Portfolio weights\n    std_devs = [12 / 100, 25 / 100]  # Standard deviations as decimals\n    correlation = 0.20  # Correlation coefficient between the stocks\n\n    # Calculate covariance between the stocks\n    covariance = correlation * std_devs[0] * std_devs[1]\n\n    # Define covariance matrix (diagonal contains variances, off-diagonal the covariance)\n    cov_matrix = [\n        [std_devs[0]**2, covariance],  # Stock 1 variance and covariance\n        [covariance, std_devs[1]**2]   # Covariance and Stock 2 variance\n    ]\n\n    # Portfolio variance calculation\n    portfolio_variance = 0\n    for i in range(len(weights)):\n        for j in range(len(weights)):\n            portfolio_variance += weights[i] * weights[j] * cov_matrix[i][j]\n\n    # Portfolio standard deviation\n    portfolio_std_dev = portfolio_variance ** 0.5\n\n    # Return answer in percentage and rounded to two decimal places\n    return round(portfolio_std_dev * 100, 2)\n\n```\n\nThis program calculates the standard deviation of the portfolio returns, accounting for asset weights, individual asset standard deviations, and their correlation."
        ],
        "retrieval_query": "A portfolio consisting of two shares has the following properties: What is the standard deviation of the returns from this portfolio (expressed as a percentage)? Answer to two decimal places.",
        "useful_functions": [
            "def calculate_portfolio_standard_deviation(weights: list, std_deviations: list, cov_matrix: list) -> float:\n    \"\"\"\n    Calculate the standard deviation of a portfolio's returns.\n\n    This function computes the overall standard deviation (volatility) of a portfolio,\n    which is a measure of risk. It takes into account both the individual asset \n    standard deviations and the covariances between different assets.\n\n    Args:\n        weights (list): A list of the weights of the assets in the portfolio. \n                        The sum of weights should equal 1.\n        std_deviations (list): A list of standard deviations of the individual assets.\n        cov_matrix (list): A matrix (2D list) of covariances between the assets. \n                           The matrix must be square and symmetric.\n\n    Returns:\n        portfolio_std_dev (float): The standard deviation of the portfolio, \n                                   representing its risk.\n\n    Notes:\n        - Applicability: This function is used in financial analysis to assess the \n          risk of an investment portfolio.\n        - Constraints: The length of weights and std_deviations lists should be \n          equal to the number of assets. The covariance matrix should be of the same size.\n        - Considerations: Ensure that all inputs are properly scaled and in matching \n          units (e.g., all in percentage terms).\n    \"\"\"\n    if not (len(weights) == len(std_deviations) == len(cov_matrix)):\n        raise ValueError(\"Input lists must have the same length.\")\n\n    if sum(weights) != 1:\n        raise ValueError(\"Sum of weights must be equal to 1.\")\n\n    n = len(weights)\n    portfolio_variance = 0.0\n\n    for i in range(n):\n        for j in range(n):\n            portfolio_variance += weights[i] * weights[j] * (\n                (std_deviations[i] * std_deviations[j]) if i == j else cov_matrix[i][j]\n            )\n    \n    portfolio_std_dev = portfolio_variance ** 0.5\n    return portfolio_std_dev"
        ],
        "usage": {
            "completion_tokens": 737,
            "prompt_tokens": 886,
            "total_tokens": 1623,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-1033",
        "article_title": "Heston Model",
        "function": "def calculate_black_scholes_put_price(S: float, K: float, r: float, T: float, volatility: float) -> float:\n    \"\"\"\n    Calculate the European put option price using the Black-Scholes model.\n\n    This function computes the price of a European put option based on the Black-Scholes\n    option pricing model. It considers the option's underlying stock price, strike price,\n    risk-free interest rate, time to maturity, and volatility.\n\n    Args:\n        S (float): Current stock price.\n        K (float): Strike price of the option.\n        r (float): Risk-free interest rate (as a decimal).\n        T (float): Time to maturity in years.\n        volatility (float): Annualized volatility of the stock's returns (as a decimal).\n\n    Returns:\n        put_price (float): The calculated put option price.\n\n    Notes:\n        - This function assumes that the underlying stock does not pay dividends.\n        - European options can only be exercised at the expiration date.\n        - The volatility parameter should be the annualized standard deviation of returns.\n    \"\"\"\n    from math import log, sqrt, exp\n    from scipy.stats import norm\n\n    d1 = (log(S / K) + (r + 0.5 * volatility ** 2) * T) / (volatility * sqrt(T))\n    d2 = d1 - volatility * sqrt(T)\n\n    put_price = K * exp(-r * T) * norm.cdf(-d2) - S * norm.cdf(-d1)\n    \n    return put_price",
        "statistics": {
            "number_statistics": {
                "args_numbers": 5,
                "question_numbers": 0,
                "context_numbers": 5,
                "total_numbers": 5
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 5,
                    "*": 8,
                    "/": 2,
                    "%": 0,
                    "**": 1
                },
                "total_operators": 18
            },
            "code_statistics": {
                "lines": 6,
                "parentheses": 18
            }
        },
        "difficulty": 5.598421958998374,
        "context": "A professional investor is considering purchasing a European put option for a technology stock currently trading at 150 USD. The put option has a strike price of 140 USD, a time to maturity of 0.5 years, and the risk-free interest rate is 2% per annum. The annualized volatility of the stock's returns is estimated to be 25%. The investor wants to determine the fair price of the put option to make an informed investment decision.",
        "question": "What is the fair price of the European put option? Answer in USD, rounded to two decimal places.",
        "python_solution": "def solution():\n    from math import log, sqrt, exp\n    from scipy.stats import norm\n\n    # Define variables\n    S = 150  # Current stock price in USD\n    K = 140  # Strike price in USD\n    r = 0.02  # Risk-free interest rate (as a decimal)\n    T = 0.5  # Time to maturity in years\n    volatility = 0.25  # Volatility as a decimal\n\n    # Calculate d1 and d2 using the Black-Scholes formula\n    d1 = (log(S / K) + (r + 0.5 * volatility ** 2) * T) / (volatility * sqrt(T))\n    d2 = d1 - volatility * sqrt(T)\n\n    # Calculate the put option price\n    put_price = K * exp(-r * T) * norm.cdf(-d2) - S * norm.cdf(-d1)\n\n    # Return the put price rounded to two decimal places\n    return round(put_price, 2)\n\n# Execute the solution function and print the result\nsolution()",
        "ground_truth": 5.46,
        "source": "FinanceReasoning-test-51",
        "question_id": "test-2208",
        "level": "hard",
        "output": [
            "To determine the fair price of the European put option, I'll approach the solution step-by-step, strictly adhering to the Emphasizing Constraints (EC) technique to ensure all details and constraints are met:\n\n### Step-by-Step Solution:\n1. **Constraints Identification (EC)**:\n   - We are dealing with a European put option, which can only be exercised at expiration.\n   - The Black-Scholes model assumes the following:\n     - Constant volatility and risk-free rate.\n     - Annualized volatility and interest rate inputs.\n     - The underlying stock pays no dividends.\n   - The result should be rounded to two decimal places and returned in USD.\n\n2. **Variable Definitions**:\n   - Input variables from the question:\n     - Stock price (`S`): \\$150.00\n     - Strike price (`K`): \\$140.00\n     - Time to maturity (`T`): 0.5 years\n     - Risk-free interest rate (`r`): 2% = 0.02 (in decimal)\n     - Volatility (`\ud835\udf0e`): 25% = 0.25 (in decimal)\n\n3. **Mathematical Implementation**:\n   - Using the Black-Scholes formula for a put option:\n     \\[\n     P = K \\cdot e^{-rT} \\cdot N(-d_2) - S \\cdot N(-d_1)\n     \\]\n     Where:\n     \\[\n     d_1 = \\frac{\\ln(S / K) + (r + 0.5 \\cdot \\sigma^2) \\cdot T}{\\sigma \\cdot \\sqrt{T}}\n     \\]\n     \\[\n     d_2 = d_1 - \\sigma \\cdot \\sqrt{T}\n     \\]\n   - \\(N(x)\\) represents the cumulative distribution function (CDF) of the standard normal distribution.\n\n4. **Ensure Accuracy with Reliable Libraries**:\n   - Use `math` for logarithmic, exponential, and square root operations.\n   - Use `scipy.stats.norm` for the standard normal cumulative distribution function \\(N(x)\\).\n\n5. **Output Format**:\n   - Final result (put option price) rounded to two decimal places.\n\nWith this understanding, here is the Python program:\n\n```python\ndef solution():\n    # Import necessary libraries\n    from math import log, sqrt, exp\n    from scipy.stats import norm\n\n    # Define variables for the Black-Scholes calculation\n    S = 150.0  # Current stock price (USD)\n    K = 140.0  # Strike price (USD)\n    T = 0.5    # Time to maturity (years)\n    r = 0.02   # Risk-free annual interest rate (decimal)\n    sigma = 0.25  # Annualized volatility (decimal)\n\n    # Calculate d1 and d2\n    d1 = (log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * sqrt(T))\n    d2 = d1 - sigma * sqrt(T)\n\n    # Calculate the European put option price using the Black-Scholes formula\n    put_price = K * exp(-r * T) * norm.cdf(-d2) - S * norm.cdf(-d1)\n\n    # Return the result rounded to two decimal places\n    return round(put_price, 2)\n``` \n\nThis implementation will compute the fair price of the European put option based on the given data."
        ],
        "retrieval_query": "What is the fair price of the European put option? Answer in USD, rounded to two decimal places.",
        "useful_functions": [
            "def calculate_bsm_put_option_price(stock_price: float, strike_price: float, time_to_maturity: float, \n                                   risk_free_rate: float, nd1: float, nd2: float) -> float:\n    \"\"\"\n    Calculate the value of a European put option using the Black-Scholes-Merton (BSM) model.\n\n    This function computes the price of a European put option based on the current stock \n    price, strike price, time to expiration, risk-free interest rate, and cumulative standard \n    normal distribution values for d1 and d2.\n\n    Args:\n        stock_price (float): The current price of the underlying stock (S).\n        strike_price (float): The strike price of the option (X).\n        time_to_maturity (float): The time to expiration of the option in years (T).\n        risk_free_rate (float): The continuously compounded risk-free interest rate (r).\n        nd1 (float): The cumulative standard normal distribution value for d1 (N(d1)).\n        nd2 (float): The cumulative standard normal distribution value for d2 (N(d2)).\n\n    Returns:\n        put_option_price (float): The calculated price of the European put option.\n\n    Notes:\n        - Applicability: This function applies to the valuation of European put options under \n          the assumption of constant volatility and risk-free rate, as per the BSM model.\n        - Constraints: This function does not account for dividend payouts. It assumes European \n          style options (exercisable only at expiration).\n        - Considerations: Ensure nd1 and nd2 are derived appropriately using an additional model\n          or calculation for d1 and d2 based on stock volatility and other factors.\n    \"\"\"\n    from math import exp\n\n    nd1_neg = 1 - nd1\n    nd2_neg = 1 - nd2\n\n    present_value_factor = exp(-risk_free_rate * time_to_maturity)\n    put_option_price = present_value_factor * strike_price * nd2_neg - stock_price * nd1_neg\n\n    return round(put_option_price, 3)",
            "def calculate_black_scholes_put_price(S: float, K: float, r: float, T: float, volatility: float) -> float:\n    \"\"\"\n    Calculate the European put option price using the Black-Scholes model.\n\n    This function computes the price of a European put option based on the Black-Scholes\n    option pricing model. It considers the option's underlying stock price, strike price,\n    risk-free interest rate, time to maturity, and volatility.\n\n    Args:\n        S (float): Current stock price.\n        K (float): Strike price of the option.\n        r (float): Risk-free interest rate (as a decimal).\n        T (float): Time to maturity in years.\n        volatility (float): Annualized volatility of the stock's returns (as a decimal).\n\n    Returns:\n        put_price (float): The calculated put option price.\n\n    Notes:\n        - This function assumes that the underlying stock does not pay dividends.\n        - European options can only be exercised at the expiration date.\n        - The volatility parameter should be the annualized standard deviation of returns.\n    \"\"\"\n    from math import log, sqrt, exp\n    from scipy.stats import norm\n\n    d1 = (log(S / K) + (r + 0.5 * volatility ** 2) * T) / (volatility * sqrt(T))\n    d2 = d1 - volatility * sqrt(T)\n\n    put_price = K * exp(-r * T) * norm.cdf(-d2) - S * norm.cdf(-d1)\n    \n    return put_price",
            "def black_scholes_option_price(stock_price: float, strike_price: float, time_to_expiration: float, \n                               risk_free_rate: float, volatility: float, option_type: str = 'call') -> float:\n    \"\"\"\n    Calculate the theoretical price of a European option using the Black-Scholes model.\n\n    This function computes the price of European call or put options using the Black-Scholes formula\n    based on input variables such as the underlying stock price, strike price, time to expiration,\n    risk-free rate, and volatility. It assumes a log-normal distribution of stock prices.\n\n    Args:\n        stock_price (float): The current price of the underlying stock.\n        strike_price (float): The strike price of the option.\n        time_to_expiration (float): Time to expiration in years.\n        risk_free_rate (float): The risk-free interest rate as a decimal.\n        volatility (float): The standard deviation of the stock's returns (volatility).\n        option_type (str, optional): The type of option to price ('call' or 'put'). Default is 'call'.\n\n    Returns:\n        option_price (float): The theoretical price of the option.\n\n    Notes:\n        - Applicability: Applies to European options only; not applicable to American options.\n        - Constraints: Assumes constant volatility and risk-free rate, no dividends.\n        - Considerations: Option type must be 'call' or 'put'; otherwise, raises ValueError.\n    \"\"\"\n    from math import log, sqrt, exp\n    from scipy.stats import norm\n\n    if option_type not in ['call', 'put']:\n        raise ValueError(\"Option type must be either 'call' or 'put'.\")\n\n    d1 = (log(stock_price / strike_price) + (risk_free_rate + 0.5 * volatility ** 2) * time_to_expiration) / (volatility * sqrt(time_to_expiration))\n    d2 = d1 - volatility * sqrt(time_to_expiration)\n\n    if option_type == 'call':\n        option_price = (stock_price * norm.cdf(d1)) - (strike_price * exp(-risk_free_rate * time_to_expiration) * norm.cdf(d2))\n    else:  # 'put'\n        option_price = (strike_price * exp(-risk_free_rate * time_to_expiration) * norm.cdf(-d2)) - (stock_price * norm.cdf(-d1))\n\n    return option_price"
        ],
        "usage": {
            "completion_tokens": 725,
            "prompt_tokens": 1704,
            "total_tokens": 2429,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-2314",
        "article_title": "Amortized Loan",
        "function": "def calculate_amortization_schedule(principal: float, annual_interest_rate: float, number_of_payments: int) -> list:\n    \"\"\"\n    Calculate the amortization schedule for a loan.\n\n    This function generates an amortization schedule for a fixed-rate loan.\n    It returns a list with each entry representing details of each period's payment,\n    including the principal payment, interest payment, total interest paid to date,\n    and the ending outstanding balance.\n\n    Args:\n        principal (float): The initial amount of the loan.\n        annual_interest_rate (float): The annual interest rate of the loan as a decimal (e.g., 0.045 for 4.5%).\n        number_of_payments (int): The total number of payments to be made over the life of the loan.\n\n    Returns:\n        amortization_schedule (list): A list of dictionaries, each containing:\n            - 'payment_number' (int): The payment period number.\n            - 'principal_payment' (float): The amount of the payment that goes toward the principal.\n            - 'interest_payment' (float): The amount of the payment that goes toward interest.\n            - 'total_interest_to_date' (float): The cumulative interest paid up to this payment.\n            - 'ending_balance' (float): The remaining balance of the loan after the payment.\n\n    Notes:\n        - Applicability: This function applies to fixed-rate amortizing loans.\n        - Constraints: The interest rate must be non-negative and the number of payments must be positive.\n        - Considerations: Ensure that the annual interest rate is provided as a decimal for accurate calculations.\n    \"\"\"\n    monthly_interest_rate = annual_interest_rate / 12\n    monthly_payment = (principal * monthly_interest_rate) / (1 - (1 + monthly_interest_rate) ** -number_of_payments)\n    \n    amortization_schedule = []\n    total_interest_to_date = 0\n    current_balance = principal\n\n    for payment_number in range(1, number_of_payments + 1):\n        interest_payment = current_balance * monthly_interest_rate\n        principal_payment = monthly_payment - interest_payment\n        total_interest_to_date += interest_payment\n        current_balance -= principal_payment\n        \n        amortization_schedule.append({\n            'payment_number': payment_number,\n            'principal_payment': principal_payment,\n            'interest_payment': interest_payment,\n            'total_interest_to_date': total_interest_to_date,\n            'ending_balance': current_balance\n        })\n    \n    return amortization_schedule",
        "statistics": {
            "number_statistics": {
                "args_numbers": 3,
                "question_numbers": 0,
                "context_numbers": 3,
                "total_numbers": 3
            },
            "operator_statistics": {
                "operators": {
                    "+": 3,
                    "-": 4,
                    "*": 2,
                    "/": 2,
                    "%": 0,
                    "**": 1
                },
                "total_operators": 12
            },
            "code_statistics": {
                "lines": 18,
                "parentheses": 10
            }
        },
        "difficulty": 5.62040086571715,
        "context": "John has just taken a personal loan of $20,000 from his bank. The loan comes with an annual fixed interest rate of 5.5%, and it is to be repaid in monthly installments over a 5-year period. John wants to know the details of his first monthly payment, particularly how much of it will go toward paying down the principal. This understanding will help John in managing his finances better.",
        "question": "How much of John's first monthly payment will go towards paying down the principal of the loan? Answer to the nearest cent.",
        "python_solution": "def solution():\n    # Define the loan parameters\n    principal = 20000  # Loan principal amount\n    annual_interest_rate = 0.055  # Annual interest rate in decimal\n    number_of_payments = 5 * 12  # Total number of payments over 5 years\n\n    # Calculate monthly interest rate\n    monthly_interest_rate = annual_interest_rate / 12\n    \n    # Calculate monthly payment using the formula for an amortizing loan\n    monthly_payment = (principal * monthly_interest_rate) / (1 - (1 + monthly_interest_rate) ** -number_of_payments)\n    \n    # Calculate interest payment for the first payment\n    first_interest_payment = principal * monthly_interest_rate\n    \n    # Calculate principal payment for the first payment\n    first_principal_payment = monthly_payment - first_interest_payment\n    \n    # Return the principal payment rounded to the nearest cent\n    return round(first_principal_payment, 2)\n\n# Output the result of the solution function\nprint(solution())",
        "ground_truth": 290.36,
        "source": "FinanceReasoning-test-68",
        "question_id": "test-2209",
        "level": "hard",
        "output": [
            "### Step-by-Step Solution Using \"Emphasizing Constraints (EC)\"\n1. **Understanding the Problem**:\n   - John takes a loan of **$20,000** for a term of **5 years**.\n   - The annual interest rate is **5.5%** (or 0.055 in decimal).\n   - Payments are made **monthly**, so there will be \\(5 \\times 12 = 60\\) payments in total.\n   - His payment is fixed for each month. To calculate how much of the first payment goes toward the principal, we need to:\n     - First calculate the fixed monthly payment using the loan's annuity formula.\n     - Then determine the interest portion of the first payment. This can be done by multiplying the original loan balance by the monthly interest rate.\n     - Finally, subtract the interest portion from the fixed monthly payment to find the principal portion.\n\n2. **Constraints**:\n   - The annual interest rate is given as a percentage but needs to be converted to a decimal for calculations.\n   - The monthly interest rate is derived by dividing the annual interest rate by 12.\n   - Monthly payments involve standard time-value-of-money formulas.\n   - The unit of the final answer is required in **dollars and cents** (rounded to the nearest cent).\n\n3. **Key Formulas**:\n   - Monthly Payment:\n     \\[\n     P_{\\text{monthly}} = \\frac{r \\cdot L}{1 - (1 + r)^{-n}}\n     \\]\n     where:\n     - \\(r\\): monthly interest rate (\\(\\frac{\\text{annual\\_interest\\_rate}}{12}\\)),\n     - \\(L\\): loan amount (principal),\n     - \\(n\\): total number of monthly payments (loan term in months).\n   - First Interest Payment:\n     \\[\n     \\text{Interest}_{\\text{month 1}} = r \\cdot L\n     \\]\n   - First Principal Payment:\n     \\[\n     \\text{Principal}_{\\text{month 1}} = P_{\\text{monthly}} - \\text{Interest}_{\\text{month 1}}\n     \\]\n\n4. **Implementation**:\n   - We'll reuse the annuity formula to calculate the monthly payment.\n   - Using John's first month's interest, we will subtract it from the fixed payment to determine how much goes to principal.\n\nNow we implement the solution:\n\n```python\ndef solution():\n    # Define variables name and value\n    principal = 20000  # Loan amount in dollars\n    annual_interest_rate = 0.055  # Annual interest rate as a decimal\n    loan_term_years = 5  # Loan repayment period in years\n    \n    # Calculate monthly interest rate\n    monthly_interest_rate = annual_interest_rate / 12  # Convert annual rate to monthly\n    \n    # Calculate the number of monthly payments\n    number_of_payments = loan_term_years * 12  # Total number of months\n    \n    # Calculate monthly payment using the annuity formula\n    monthly_payment = (principal * monthly_interest_rate) / (1 - (1 + monthly_interest_rate) ** -number_of_payments)\n    \n    # Calculate the interest portion of the first month's payment\n    first_interest_payment = monthly_interest_rate * principal\n    \n    # Calculate the principal portion of the first month's payment\n    first_principal_payment = monthly_payment - first_interest_payment\n    \n    # Round to the nearest cent and return\n    return round(first_principal_payment, 2)\n```"
        ],
        "retrieval_query": "How much of John's first monthly payment will go towards paying down the principal of the loan? Answer to the nearest cent.",
        "useful_functions": [
            "def calculate_fixed_rate_payment(principal: float, annual_interest_rate: float, years: int) -> float:\n    \"\"\"\n    Calculate the monthly payment for a fixed-rate loan.\n\n    This function computes the fixed monthly payment required to fully amortize\n    a loan over a specified number of years, given the loan principal and an\n    annual interest rate.\n\n    Args:\n        principal (float): The initial amount of the loan.\n        annual_interest_rate (float): The annual interest rate as a decimal (e.g., 0.045 for 4.5%).\n        years (int): The term of the loan in years.\n\n    Returns:\n        monthly_payment (float): The monthly payment required to fully amortize\n                                 the loan over the specified term.\n\n    Notes:\n        - The monthly interest rate is calculated from the annual interest rate.\n        - The function uses the annuity formula for calculating the payment.\n        - Applicability: This function is applicable for fixed-rate loans.\n        - Constraints: The annual interest rate must be non-negative.\n        - Considerations: Ensure the principal and years are positive values.\n    \"\"\"\n    if annual_interest_rate < 0:\n        raise ValueError(\"Annual interest rate must be non-negative.\")\n    \n    monthly_interest_rate = annual_interest_rate / 12\n    number_of_payments = years * 12\n    \n    if monthly_interest_rate == 0:  # Special case for zero interest\n        return principal / number_of_payments\n    \n    monthly_payment = (principal * monthly_interest_rate) / (1 - (1 + monthly_interest_rate) ** -number_of_payments)\n    \n    return monthly_payment",
            "def calculate_monthly_mortgage_payment(principal: float, annual_interest_rate: float, loan_term_years: int) -> float:\n    \"\"\"\n    Calculate the monthly mortgage payment for a fixed-rate mortgage.\n\n    This function computes the monthly payment amount for a fixed-rate mortgage \n    given the principal loan amount, annual interest rate, and loan term in years.\n\n    Args:\n        principal (float): The principal loan amount (the amount that you borrow).\n        annual_interest_rate (float): The annual interest rate as a decimal \n                                      (e.g., 0.05 for 5%).\n        loan_term_years (int): The number of years required to repay the loan.\n\n    Returns:\n        monthly_payment (float): The calculated monthly payment amount.\n\n    Notes:\n        - The calculation assumes consistent monthly payments for the entire loan term.\n        - The function assumes that interest compounds monthly.\n        - Payments can still include additional expenses like taxes and insurance, \n          which aren't considered here.\n        - Ensure the annual interest rate is converted into a monthly rate \n          (i.e., divide by 12) for calculations.\n    \"\"\"\n    monthly_interest_rate = annual_interest_rate / 12\n    number_of_payments = loan_term_years * 12\n    monthly_payment = (principal * monthly_interest_rate * (1 + monthly_interest_rate) ** number_of_payments) / ((1 + monthly_interest_rate) ** number_of_payments - 1)\n\n    return monthly_payment"
        ],
        "usage": {
            "completion_tokens": 724,
            "prompt_tokens": 1083,
            "total_tokens": 1807,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-2166",
        "article_title": "Loan",
        "function": "def calculate_total_loan_cost(principal: float, annual_interest_rate: float, loan_term_years: int, extra_monthly_payment: float = 0) -> float:\n    \"\"\"\n    Calculate the total cost of a loan including potential extra monthly payments.\n\n    This function calculates the total amount paid over the period of a loan, factoring in optional additional monthly\n    payments. This helps borrowers understand the impact of extra payments on the total cost and loan duration.\n\n    Args:\n        principal (float): The original sum of money borrowed in the loan.\n        annual_interest_rate (float): The annual interest rate of the loan expressed as a decimal (e.g., 0.05 for 5%).\n        loan_term_years (int): The duration of the loan in years.\n        extra_monthly_payment (float): The optional extra amount paid monthly in addition to the regular payment.\n\n    Returns:\n        total_cost (float): The total cost of the loan including all scheduled and extra payments.\n\n    Notes:\n        - This calculation assumes a fixed interest rate and payments until the loan is paid off.\n        - Extra payments must be non-negative and can reduce the total interest paid and the loan term.\n        - The accuracy of the calculation diminishes with very high extra payments due to reduced loan duration.\n    \"\"\"\n    if annual_interest_rate <= 0:\n        raise ValueError(\"Annual interest rate must be greater than 0.\")\n    \n    monthly_interest_rate = annual_interest_rate / 12\n    number_of_payments = loan_term_years * 12\n    regular_monthly_payment = (principal * monthly_interest_rate) / (1 - (1 + monthly_interest_rate) ** -number_of_payments)\n    payout_schedule = []\n\n    remaining_principal = principal\n    extra_monthly_payment = max(extra_monthly_payment, 0)\n\n    while remaining_principal > 0:\n        interest_payment = remaining_principal * monthly_interest_rate\n        principal_payment = regular_monthly_payment - interest_payment + extra_monthly_payment\n        remaining_principal -= principal_payment\n        payout_schedule.append((regular_monthly_payment + extra_monthly_payment, interest_payment, principal_payment))\n        \n        if principal_payment <= 0:\n            break\n\n    total_cost = sum(payment[0] for payment in payout_schedule)\n    \n    return total_cost",
        "statistics": {
            "number_statistics": {
                "args_numbers": 4,
                "question_numbers": 1,
                "context_numbers": 4,
                "total_numbers": 5
            },
            "operator_statistics": {
                "operators": {
                    "+": 3,
                    "-": 4,
                    "*": 3,
                    "/": 2,
                    "%": 0,
                    "**": 1
                },
                "total_operators": 13
            },
            "code_statistics": {
                "lines": 15,
                "parentheses": 14
            }
        },
        "difficulty": 5.655991810819852,
        "context": "John intends to finance a new car by taking out a loan of 30,000 dollars. The loan has an annual interest rate of 6%, and it is set to be repaid over a period of 5 years. John is considering making an additional monthly payment of 100 dollars to reduce the total cost of borrowing. He would like to know how much this will affect the total cost he will pay over the duration of the loan.",
        "question": "What will be the total cost of the loan if John makes an additional monthly payment of 100 dollars? Answer to the nearest dollar.",
        "python_solution": "def solution():\n    # Define loan parameters\n    principal = 30000\n    annual_interest_rate = 0.06\n    loan_term_years = 5\n    extra_monthly_payment = 100\n\n    # Calculate monthly interest rate and total number of payments\n    monthly_interest_rate = annual_interest_rate / 12\n    number_of_payments = loan_term_years * 12\n\n    # Calculate regular monthly payment using the amortization formula\n    monthly_payment = (principal * monthly_interest_rate) / (1 - (1 + monthly_interest_rate) ** -number_of_payments)\n\n    # Initialize variables for calculation\n    remaining_principal = principal\n    total_payment_made = 0\n\n    # Iterate until the loan is paid off\n    while remaining_principal > 0:\n        # Calculate interest for the current month\n        interest_payment = remaining_principal * monthly_interest_rate\n        \n        # Calculate principal payment\n        principal_payment = monthly_payment - interest_payment + extra_monthly_payment\n        \n        # Update remaining principal\n        remaining_principal -= principal_payment\n        \n        # Update total payment made\n        total_payment_made += monthly_payment + extra_monthly_payment\n        \n        # Prevent potential infinite loop by checking if principal payment stops reducing the balance\n        if principal_payment <= 0:\n            break\n\n    # Return the total cost of the loan rounded to the nearest dollar\n    return round(total_payment_made)",
        "ground_truth": 33999,
        "source": "FinanceReasoning-test-48",
        "question_id": "test-2210",
        "level": "hard",
        "output": [
            "### Step-by-step solution:\n\n#### **Emphasizing Constraints (EC)**:\n1. **Loan details**:\n   - Principal: $30,000\n   - Annual Interest Rate: 6% (converted to decimal: 0.06)\n   - Loan Term: 5 years\n   - Extra Monthly Payment: $100\n2. **Precision**:\n   - We need the total cost of the loan in whole dollars. So, the result must be rounded to the nearest dollar.\n3. **Payment structure**:\n   - Regular payments + extra monthly payments will reduce the loan term by paying down the principal faster. This also reduces the total interest cost.\n4. **Function constraints**:\n   - Use the given `calculate_total_loan_cost()` function to calculate the total cost, as it accurately accounts for regular and extra payments.\n\nBy following the constraints and leveraging the provided function, we are able to calculate the total cost of the loan efficiently.\n\n---\n\n### Python Program:\n```python\ndef solution():\n    # Define the input variables\n    principal = 30000  # Loan amount in dollars\n    annual_interest_rate = 0.06  # Annual interest rate (6%)\n    loan_term_years = 5  # Loan term in years\n    extra_monthly_payment = 100  # Extra payment in dollars\n    \n    # Function to calculate the total loan cost\n    def calculate_total_loan_cost(principal, annual_interest_rate, loan_term_years, extra_monthly_payment=0):\n        # Calculate monthly interest rate\n        monthly_interest_rate = annual_interest_rate / 12\n        # Total number of monthly payments without extra payment\n        number_of_payments = loan_term_years * 12\n        # Regular monthly payment (using mortgage formula)\n        regular_monthly_payment = (principal * monthly_interest_rate) / (1 - (1 + monthly_interest_rate) ** -number_of_payments)\n        \n        # Initialize variables for the payment schedule\n        remaining_principal = principal\n        payout_schedule = []\n        \n        # Ensure extra monthly payment is non-negative\n        extra_monthly_payment = max(extra_monthly_payment, 0)\n        \n        # Loop until the loan principal is paid off\n        while remaining_principal > 0:\n            # Interest portion of the payment\n            interest_payment = remaining_principal * monthly_interest_rate\n            # Principal portion is whatever is left after covering interest\n            principal_payment = regular_monthly_payment - interest_payment + extra_monthly_payment\n            # Reduce the remaining principal\n            remaining_principal -= principal_payment\n            # Track the total payment, interest, and principal components\n            payout_schedule.append((regular_monthly_payment + extra_monthly_payment, interest_payment, principal_payment))\n            \n            # Prevent infinite loop in case principal payment becomes zero or negative\n            if principal_payment <= 0:\n                break\n        \n        # Sum up all payments to get the total cost\n        total_cost = sum(payment[0] for payment in payout_schedule)\n        return total_cost\n\n    # Calculate total loan cost with additional monthly payment\n    total_cost = calculate_total_loan_cost(principal, annual_interest_rate, loan_term_years, extra_monthly_payment)\n    \n    # Return the total cost rounded to the nearest dollar\n    return round(total_cost)\n```"
        ],
        "retrieval_query": "What will be the total cost of the loan if John makes an additional monthly payment of 100 dollars? Answer to the nearest dollar.",
        "useful_functions": [
            "def calculate_total_loan_cost(principal: float, annual_interest_rate: float, loan_term_years: int, extra_monthly_payment: float = 0) -> float:\n    \"\"\"\n    Calculate the total cost of a loan including potential extra monthly payments.\n\n    This function calculates the total amount paid over the period of a loan, factoring in optional additional monthly\n    payments. This helps borrowers understand the impact of extra payments on the total cost and loan duration.\n\n    Args:\n        principal (float): The original sum of money borrowed in the loan.\n        annual_interest_rate (float): The annual interest rate of the loan expressed as a decimal (e.g., 0.05 for 5%).\n        loan_term_years (int): The duration of the loan in years.\n        extra_monthly_payment (float): The optional extra amount paid monthly in addition to the regular payment.\n\n    Returns:\n        total_cost (float): The total cost of the loan including all scheduled and extra payments.\n\n    Notes:\n        - This calculation assumes a fixed interest rate and payments until the loan is paid off.\n        - Extra payments must be non-negative and can reduce the total interest paid and the loan term.\n        - The accuracy of the calculation diminishes with very high extra payments due to reduced loan duration.\n    \"\"\"\n    if annual_interest_rate <= 0:\n        raise ValueError(\"Annual interest rate must be greater than 0.\")\n    \n    monthly_interest_rate = annual_interest_rate / 12\n    number_of_payments = loan_term_years * 12\n    regular_monthly_payment = (principal * monthly_interest_rate) / (1 - (1 + monthly_interest_rate) ** -number_of_payments)\n    payout_schedule = []\n\n    remaining_principal = principal\n    extra_monthly_payment = max(extra_monthly_payment, 0)\n\n    while remaining_principal > 0:\n        interest_payment = remaining_principal * monthly_interest_rate\n        principal_payment = regular_monthly_payment - interest_payment + extra_monthly_payment\n        remaining_principal -= principal_payment\n        payout_schedule.append((regular_monthly_payment + extra_monthly_payment, interest_payment, principal_payment))\n        \n        if principal_payment <= 0:\n            break\n\n    total_cost = sum(payment[0] for payment in payout_schedule)\n    \n    return total_cost"
        ],
        "usage": {
            "completion_tokens": 677,
            "prompt_tokens": 926,
            "total_tokens": 1603,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-872",
        "article_title": "Market Risk",
        "function": "def calculate_beta(asset_returns: list, market_returns: list) -> float:\n    \"\"\"\n    Calculate the beta of an asset, which measures its volatility in relation to the market.\n\n    Beta is used in finance to gauge the risk of an asset relative to the overall market. It indicates \n    whether the asset tends to move with the market (beta > 1), is less volatile (beta < 1), or is inversely \n    correlated (beta < 0).\n\n    Args:\n        asset_returns (list): A list of historical returns for the asset.\n        market_returns (list): A list of historical returns for the market, typically represented by an index.\n\n    Returns:\n        beta (float): The calculated beta value of the asset.\n\n    Notes:\n        - Applicability: Suitable for portfolios or individual securities with return data.\n        - Constraints: Requires consistent timeframes and return intervals for asset and market data.\n        - Considerations: May not account for duplication or regime change in highly volatile periods.\n    \"\"\"\n    if len(asset_returns) != len(market_returns):\n        raise ValueError(\"Asset and market return lists must have the same length.\")\n    \n    # Calculate covariance between asset and market, and variance of the market\n    covariance = sum((a - sum(asset_returns) / len(asset_returns)) * (m - sum(market_returns) / len(market_returns))\n                     for a, m in zip(asset_returns, market_returns)) / (len(asset_returns) - 1)\n    market_variance = sum((m - sum(market_returns) / len(market_returns)) ** 2 for m in market_returns) / (len(market_returns) - 1)\n    \n    beta = covariance / market_variance\n    \n    return beta",
        "statistics": {
            "number_statistics": {
                "args_numbers": 2,
                "question_numbers": 0,
                "context_numbers": 10,
                "total_numbers": 10
            },
            "operator_statistics": {
                "operators": {
                    "+": 0,
                    "-": 5,
                    "*": 1,
                    "/": 6,
                    "%": 0,
                    "**": 1
                },
                "total_operators": 13
            },
            "code_statistics": {
                "lines": 6,
                "parentheses": 32
            }
        },
        "difficulty": 5.655991810819852,
        "context": "XYZ Corp is a publicly traded company, and a financial analyst is interested in determining the company's beta to understand its volatility relative to the market. The analyst has collected the following historical monthly returns data: \n\nFor XYZ Corp:\n- January: 2.5%\n- February: -1.2%\n- March: 3.8%\n- April: 1.7%\n- May: 4.0%\n\nFor the benchmark market index:\n- January: 1.8%\n- February: -0.5%\n- March: 2.1%\n- April: 1.3%\n- May: 3.5%\n\nUnderstanding XYZ Corp's beta helps the analyst gauge its relative risk compared to the market.",
        "question": "What is the beta of XYZ Corp relative to the market, based on the given historical returns data? Answer to two decimal places.",
        "python_solution": "def solution():\n    # Historical returns for XYZ Corp and the market index\n    asset_returns = [2.5, -1.2, 3.8, 1.7, 4.0]  # in percentage\n    market_returns = [1.8, -0.5, 2.1, 1.3, 3.5]  # in percentage\n\n    # Convert percentages to decimal for calculations\n    asset_returns = [x / 100 for x in asset_returns]\n    market_returns = [x / 100 for x in market_returns]\n\n    # Calculate the mean of asset and market returns\n    mean_asset = sum(asset_returns) / len(asset_returns)\n    mean_market = sum(market_returns) / len(market_returns)\n\n    # Calculate covariance between asset and market returns\n    covariance = sum((a - mean_asset) * (m - mean_market) for a, m in zip(asset_returns, market_returns)) / (len(asset_returns) - 1)\n\n    # Calculate market variance\n    market_variance = sum((m - mean_market) ** 2 for m in market_returns) / (len(market_returns) - 1)\n\n    # Calculate beta\n    beta = covariance / market_variance\n\n    # Return the beta rounded to two decimal places\n    return round(beta, 2)\n\n# Execute the solution function to get the result\nsolution()",
        "ground_truth": 1.38,
        "source": "FinanceReasoning-test-85",
        "question_id": "test-2211",
        "level": "hard",
        "output": [
            "### Step-by-step reasoning:\n\n#### 1. Understand the Problem\nWe aim to compute the beta of XYZ Corp relative to the market using historical monthly returns data. Beta is a measure of a stock's volatility compared to the overall market. It is calculated using:\n\\[\n\\text{Beta} = \\frac{\\text{Covariance between stock and market returns}}{\\text{Variance of market returns}}\n\\]\n\nThe historical monthly returns are provided:\n- **XYZ Corp's returns (Stock returns)**: [2.5%, -1.2%, 3.8%, 1.7%, 4.0%]\n- **Market returns**: [1.8%, -0.5%, 2.1%, 1.3%, 3.5%]\n\n#### 2. Emphasizing Constraints (EC)\n- **Constraint 1**: Both input lists of returns must have the same length and represent corresponding time periods; this constraint will hold since the data provided for XYZ Corp and the market includes exactly 5 returns for 5 matching months.\n- **Constraint 2**: Compute beta to **two decimal places.** We will incorporate this rounding into our solution.\n- **Constraint 3**: Ensure no division by zero. If the market variance is zero, beta cannot be computed.\n\n#### 3. Approach\n- Convert the percentages to decimals (e.g., 2.5% \u2192 0.025).\n- Calculate:\n  - Market mean return.\n  - Stock mean return.\n  - Variance of market returns.\n  - Covariance of stock and market returns.\n- Plug into the formula for beta and round to two decimal places.\n\n#### 4. Python Implementation\nThe next step is to implement this logic in Python. Below is the solution to calculate the beta.\n\n```python\ndef solution():\n    # Define variables - Historical monthly returns (in percentages)\n    xyz_returns_percentage = [2.5, -1.2, 3.8, 1.7, 4.0]\n    market_returns_percentage = [1.8, -0.5, 2.1, 1.3, 3.5]\n    \n    # Convert percentages to decimals\n    xyz_returns = [r / 100 for r in xyz_returns_percentage]\n    market_returns = [r / 100 for r in market_returns_percentage]\n    \n    # Calculate mean returns\n    avg_xyz_return = sum(xyz_returns) / len(xyz_returns)\n    avg_market_return = sum(market_returns) / len(market_returns)\n    \n    # Calculate market variance\n    market_variance = sum((r - avg_market_return) ** 2 for r in market_returns)\n    \n    # Calculate covariance between stock and market returns\n    covariance = sum((s - avg_xyz_return) * (m - avg_market_return) for s, m in zip(xyz_returns, market_returns))\n    \n    # Ensure no division by zero\n    if market_variance == 0:\n        raise ValueError(\"Market variance is zero, cannot calculate beta.\")\n    \n    # Calculate beta\n    beta = covariance / market_variance\n    \n    # Round to two decimal places\n    return round(beta, 2)\n```"
        ],
        "retrieval_query": "What is the beta of XYZ Corp relative to the market, based on the given historical returns data? Answer to two decimal places.",
        "useful_functions": [
            "def calculate_beta(stock_returns: list, market_returns: list) -> float:\n    \"\"\"\n    Calculate the beta of a stock, indicating its volatility relative to the market.\n\n    Beta is a measure of a stock's volatility in relation to the overall market.\n    A beta of 1 indicates that the stock's price tends to move with the market.\n    A beta greater than 1 indicates greater volatility than the market, while a beta less\n    than 1 indicates less volatility.\n\n    Args:\n        stock_returns (list): A list of periodic return rates for the stock.\n        market_returns (list): A list of periodic return rates for the market benchmark,\n                               such as the S&P 500. Must be of the same length as stock_returns.\n\n    Returns:\n        beta (float): The beta of the stock relative to the market.\n\n    Notes:\n        - Applicability: Used in assessing the risk and expected return of a stock or portfolio.\n        - Constraints: The input lists must represent returns for the same periods and must have\n          the same length.\n        - Considerations: Beta reflects past volatility and may not predict future volatility.\n          Values could be affected by outliers in the historical data.\n    \"\"\"\n    if len(stock_returns) != len(market_returns):\n        raise ValueError(\"Both input lists must have the same number of elements.\")\n\n    market_variance = sum((r - (sum(market_returns) / len(market_returns))) ** 2 for r in market_returns)\n    covariance = sum((s - (sum(stock_returns) / len(stock_returns))) * \n                     (m - (sum(market_returns) / len(market_returns))) for s, m in zip(stock_returns, market_returns))\n\n    if market_variance == 0:\n        raise ValueError(\"Market variance is zero, cannot calculate beta.\")\n    \n    beta = covariance / market_variance\n    \n    return beta",
            "def calculate_intrinsic_value_of_perpetual_preferred_share(par_value: float, coupon_rate: float, required_return: float) -> float:\n    \"\"\"\n    Calculate the intrinsic value of a perpetual preferred share.\n\n    This function computes the intrinsic value of perpetual preferred shares given\n    the par value, coupon rate, and required rate of return. It applies the\n    perpetuity formula V = D / r, where D is the annual dividend and r is the\n    required rate of return.\n\n    Args:\n        par_value (float): The par value of the preferred share.\n        coupon_rate (float): The annual coupon rate as a decimal (e.g., 0.032 for 3.2%).\n        required_return (float): The required return rate as a decimal (e.g., 0.058 for 5.8%).\n\n    Returns:\n        intrinsic_value (float): The calculated intrinsic value of the preferred share,\n                                 rounded to the nearest cent.\n\n    Notes:\n        - This function assumes the preferred shares are noncallable and non-convertible.\n        - The coupon rate and required return must be provided as decimals between 0 and 1.\n        - The par value, coupon rate, and required return should be agreed upon and known values.\n    \"\"\"\n    annual_dividend = par_value * coupon_rate\n    intrinsic_value = annual_dividend / required_return\n    return round(intrinsic_value, 2)",
            "def calculate_worden_stochastic(closing_prices: list, lookback_period: int) -> list:\n    \"\"\"\n    Calculate the Worden Stochastic indicator for a series of closing prices.\n\n    This function computes the Worden Stochastic, which indicates the percentile\n    rank of the most recent closing price compared to the other closing values\n    over a specified lookback period. It helps traders determine overbought or\n    oversold conditions in a security.\n\n    Args:\n        closing_prices (list): A list of closing prices for the security.\n        lookback_period (int): The number of periods to consider for the calculation.\n\n    Returns:\n        worden_stochastics (list): A list of Worden Stochastic values for each\n                                   price in the series.\n\n    Notes:\n        - Applicability: Useful for technical analysis to identify price extremes.\n        - Constraints: The lookback period must be less than or equal to the length\n                       of the closing_prices list and greater than 0.\n        - Considerations: This function does not account for any additional trading\n                          signals or filters; it computes only the raw stochastic\n                          values.\n    \"\"\"\n    if lookback_period <= 0 or lookback_period > len(closing_prices):\n        raise ValueError(\"Invalid lookback period: must be > 0 and <= number of closing prices.\")\n\n    worden_stochastics = []\n    \n    for i in range(len(closing_prices)):\n        if i >= lookback_period - 1:\n            # Slice the current lookback window of closing prices\n            window = closing_prices[i-lookback_period+1:i+1]\n            # Calculate rank of the most recent closing price in the sorted window\n            rank = sorted(window).index(closing_prices[i]) + 1\n            # Calculate the Worden Stochastic\n            worden_stochastic = (100 / (lookback_period - 1)) * (rank - 1)\n            worden_stochastics.append(worden_stochastic)\n\n    return worden_stochastics"
        ],
        "usage": {
            "completion_tokens": 664,
            "prompt_tokens": 1607,
            "total_tokens": 2271,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-984",
        "article_title": "2-1 Buydown",
        "function": "def calculate_mortgage_payments(principal: float, term_years: int, initial_rate: float, rate_changes: list) -> list:\n    \"\"\"\n    Calculate the monthly mortgage payments over time with changing interest rates.\n\n    This function computes the monthly payment amounts for a mortgage given\n    an initial rate and a series of rate changes at specified intervals. It\n    is particularly applicable to mortgages with structured rate adjustments \n    such as 2-1 buydowns.\n\n    Args:\n        principal (float): The initial loan amount.\n        term_years (int): The total number of years for the mortgage term.\n        initial_rate (float): The interest rate for the first year.\n        rate_changes (list): A list of tuples where each tuple consists of the \n                             year the rate changes and the new rate for that year.\n\n    Returns:\n        payments (list): A list of tuples where each tuple contains the year\n                         and the corresponding monthly payment amount starting\n                         from year 1 to the end of the mortgage term.\n\n    Notes:\n        - The function assumes monthly payments and interest rate is in annual percentage form.\n        - Rate changes are expected to be input as absolute values and should reflect\n          the transition to a new rate rather than relative changes.\n        - This function does not account for taxes, insurance, or potential refinance actions.\n    \"\"\"\n    from math import pow\n\n    def monthly_payment(principal, annual_rate, term_months):\n        monthly_rate = annual_rate / 12 / 100\n        return (principal * monthly_rate) / (1 - pow(1 + monthly_rate, -term_months))\n\n    total_months = term_years * 12\n    current_rate = initial_rate\n    payments = []\n\n    for year in range(1, term_years + 1):\n        if any(change[0] == year for change in rate_changes):\n            current_rate = next(change[1] for change in rate_changes if change[0] == year)\n        \n        monthly_payment_amount = monthly_payment(principal, current_rate, total_months - ((year - 1) * 12))\n        payments.append((year, monthly_payment_amount))\n\n    return payments",
        "statistics": {
            "number_statistics": {
                "args_numbers": 4,
                "question_numbers": 0,
                "context_numbers": 5,
                "total_numbers": 5
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 4,
                    "*": 3,
                    "/": 3,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 12
            },
            "code_statistics": {
                "lines": 13,
                "parentheses": 24
            }
        },
        "difficulty": 5.703782474656201,
        "context": "A homeowner is planning to take a mortgage to purchase a house with a principal amount of $300,000. The mortgage term is set for 30 years with an initial interest rate of 3.5% for the first year. The lender offers a structured rate change such that in the second year, the interest rate will be 4.0%, and from the third year onwards, it will stabilize at 4.5% until the term ends. The borrower wants to understand the monthly payment for the first year of this mortgage plan.",
        "question": "What will be the monthly mortgage payment for the first year of the mortgage? Answer to the nearest dollar.",
        "python_solution": "def solution():\n    # Define the principal amount, term, and initial interest rate\n    principal = 300000.0\n    initial_rate = 3.5\n    term_years = 30\n    \n    # Convert term in years to months\n    total_months = term_years * 12\n    \n    # Calculate the monthly interest rate\n    monthly_rate = initial_rate / 12 / 100\n    \n    # Calculate the monthly payment using the formula for annuities\n    monthly_payment = (principal * monthly_rate) / (1 - (1 + monthly_rate) ** -total_months)\n    \n    # Return the monthly payment rounded to the nearest dollar\n    return round(monthly_payment)\n\n# Running the solution function:\nsolution()",
        "ground_truth": 1347,
        "source": "FinanceReasoning-test-37",
        "question_id": "test-2212",
        "level": "hard",
        "output": [
            "### Thinking Through the Problem\n\n1. **Understanding the Question**: \n    - We need to calculate the **monthly mortgage payment** for the **first year** given a mortgage of $300,000 with the following conditions:\n      - Loan term: 30 years\n      - Interest rate for the **first year**: 3.5%\n    \n2. **Identifying Constraints (EC)**:\n    - The interest rate must be annual (percentage form, not decimal).\n    - The resulting value for the monthly payment must be rounded to the nearest dollar.\n    - We are interested only in the monthly payment for **Year 1** and not for subsequent years.\n\n3. **Approach**:\n    - Use an amortization formula for calculating a **fixed monthly mortgage payment**.\n    - Formulate the monthly payment using the standard mortgage payment calculation formula:\n      \\[\n      M = P \\cdot \\frac{r(1 + r)^n}{(1 + r)^n - 1}\n      \\]\n      - **P** = Loan Principal ($300,000)\n      - **r** = Monthly Interest Rate (Annual Rate \u00f7 12 \u00f7 100)\n      - **n** = Total Number of Months (30 years \u00d7 12 months)\n\n4. **Plan**:\n    - Define the loan principal, annual interest rate, and loan term.\n    - Convert the parameters into monthly interest rate and total months.\n    - Apply the formula to compute the monthly payment.\n    - Round the answer to the nearest dollar.\n\n### Python Program\nBelow is the Python implementation to compute the desired monthly mortgage payment for the given problem:\n\n```python\ndef solution():\n    # Define variables name and value\n    loan_amount = 300000  # Principal in dollars\n    annual_interest_rate = 3.5  # First year's interest rate in percentage\n    loan_term_years = 30  # Loan period (years)\n    \n    # Convert annual interest rate into monthly interest rate in decimal form\n    monthly_interest_rate = annual_interest_rate / 12 / 100\n    total_months = loan_term_years * 12  # Total loan term in months\n    \n    # Calculate the monthly payment using the amortization formula\n    monthly_payment = (loan_amount * monthly_interest_rate * (1 + monthly_interest_rate) ** total_months) / \\\n                      ((1 + monthly_interest_rate) ** total_months - 1)\n    \n    # Round the monthly payment to the nearest dollar\n    monthly_payment_rounded = round(monthly_payment)\n    \n    # Return the answer\n    return monthly_payment_rounded\n```\n\n### Explanation of the Code:\n1. **Input Values**:\n    - Principal: $300,000\n    - Annual Interest Rate: 3.5%\n    - Loan Term: 30 years\n\n2. **Intermediate Calculations**:\n    - Convert the annual interest rate to a monthly interest rate.\n    - Compute the total number of payments over the loan term.\n\n3. **Formula Application**:\n    - Use the amortization formula to calculate the monthly payment.\n\n4. **Output**:\n    - The computed payment is rounded to the nearest dollar.\n\n### Constraints Validated\n- The interest rate is converted correctly.\n- The final result is within the constraint (nearest dollar output)."
        ],
        "retrieval_query": "What will be the monthly mortgage payment for the first year of the mortgage? Answer to the nearest dollar.",
        "useful_functions": [
            "def calculate_mortgage_payments(principal: float, term_years: int, initial_rate: float, rate_changes: list) -> list:\n    \"\"\"\n    Calculate the monthly mortgage payments over time with changing interest rates.\n\n    This function computes the monthly payment amounts for a mortgage given\n    an initial rate and a series of rate changes at specified intervals. It\n    is particularly applicable to mortgages with structured rate adjustments \n    such as 2-1 buydowns.\n\n    Args:\n        principal (float): The initial loan amount.\n        term_years (int): The total number of years for the mortgage term.\n        initial_rate (float): The interest rate for the first year.\n        rate_changes (list): A list of tuples where each tuple consists of the \n                             year the rate changes and the new rate for that year.\n\n    Returns:\n        payments (list): A list of tuples where each tuple contains the year\n                         and the corresponding monthly payment amount starting\n                         from year 1 to the end of the mortgage term.\n\n    Notes:\n        - The function assumes monthly payments and interest rate is in annual percentage form.\n        - Rate changes are expected to be input as absolute values and should reflect\n          the transition to a new rate rather than relative changes.\n        - This function does not account for taxes, insurance, or potential refinance actions.\n    \"\"\"\n    from math import pow\n\n    def monthly_payment(principal, annual_rate, term_months):\n        monthly_rate = annual_rate / 12 / 100\n        return (principal * monthly_rate) / (1 - pow(1 + monthly_rate, -term_months))\n\n    total_months = term_years * 12\n    current_rate = initial_rate\n    payments = []\n\n    for year in range(1, term_years + 1):\n        if any(change[0] == year for change in rate_changes):\n            current_rate = next(change[1] for change in rate_changes if change[0] == year)\n        \n        monthly_payment_amount = monthly_payment(principal, current_rate, total_months - ((year - 1) * 12))\n        payments.append((year, monthly_payment_amount))\n\n    return payments",
            "def calculate_monthly_mortgage_payment(loan_amount: float, annual_interest_rate: float, loan_term_years: int) -> float:\n    \"\"\"\n    Calculate the monthly mortgage payment for an amortizing loan.\n\n    This function computes the monthly payment amount for a fixed-rate mortgage,\n    given the loan amount, annual interest rate, and the term of the loan in years.\n    It uses the formula for calculating payments on an amortizing loan.\n\n    Args:\n        loan_amount (float): The total amount of the loan.\n        annual_interest_rate (float): The annual interest rate as a percentage (e.g., 5.8 for 5.8%).\n        loan_term_years (int): The loan term in years.\n\n    Returns:\n        monthly_payment (float): The calculated monthly payment amount.\n\n    Notes:\n        - Applicability: Suitable for fixed-rate mortgages where payments are made monthly.\n        - Constraints: The annual interest rate should be positive and expressed as a percentage.\n        - Considerations: This calculation assumes a fully amortizing loan with no additional fees or insurance.\n    \"\"\"\n    monthly_interest_rate = annual_interest_rate / 12 / 100\n    number_of_payments = loan_term_years * 12\n    \n    # Calculate the monthly payment using the formula for an amortizing loan\n    monthly_payment = loan_amount * (monthly_interest_rate * (1 + monthly_interest_rate) ** number_of_payments) / \\\n                      ((1 + monthly_interest_rate) ** number_of_payments - 1)\n\n    return monthly_payment",
            "def calculate_monthly_payment(principal: float, annual_interest_rate: float, years: int) -> float:\n    \"\"\"\n    Calculate the monthly mortgage payment for a fixed-rate period.\n\n    This function computes the monthly payment for a mortgage based on the loan\n    principal, annual fixed interest rate, and duration of the loan in years.\n\n    Args:\n        principal (float): The loan amount (principal) in dollars.\n        annual_interest_rate (float): The annual fixed interest rate as a percentage (e.g., 3.5 for 3.5%).\n        years (int): The number of years for the fixed-rate period.\n\n    Returns:\n        monthly_payment (float): The monthly mortgage payment in dollars.\n\n    Notes:\n        - This function assumes a fixed interest rate for the specified period.\n        - The interest rate should be provided as a percentage, not a decimal.\n        - The result will be a positive float representing the payment amount.\n        - This calculation does not include taxes, insurance, or other fees.\n    \"\"\"\n    monthly_interest_rate = annual_interest_rate / 100 / 12\n    number_of_payments = years * 12\n    if annual_interest_rate == 0:\n        return principal / number_of_payments\n    monthly_payment = (principal * monthly_interest_rate) / \\\n                      (1 - (1 + monthly_interest_rate) ** -number_of_payments)\n    return monthly_payment\n\ndef calculate_adjusted_monthly_payment(principal: float, years: int, index_rate: float, margin: float) -> float:\n    \"\"\"\n    Calculate the adjusted monthly mortgage payment after the fixed-rate period.\n\n    This function computes the monthly payment for a mortgage based on the loan\n    principal, remaining years, indexed rate, and bank margin, after the initial\n    fixed rate period has ended.\n\n    Args:\n        principal (float): The remaining loan amount (principal) in dollars.\n        years (int): The remaining number of years on the loan.\n        index_rate (float): The current index rate as a percentage (e.g., 3 for 3%).\n        margin (float): The bank's margin as a percentage.\n\n    Returns:\n        adjusted_monthly_payment (float): The adjusted monthly payment in dollars.\n\n    Notes:\n        - The function assumes the interest rate is adjusted based on an index rate plus a margin.\n        - The rates should be provided as percentages, not decimals.\n        - This calculation does not account for potential rate caps.\n        - The function is meant for transition from fixed to adjustable rates.\n    \"\"\"\n    adjusted_annual_rate = index_rate + margin\n    monthly_interest_rate = adjusted_annual_rate / 100 / 12\n    number_of_payments = years * 12\n    if adjusted_annual_rate == 0:\n        return principal / number_of_payments\n    adjusted_monthly_payment = (principal * monthly_interest_rate) / \\\n                               (1 - (1 + monthly_interest_rate) ** -number_of_payments)\n    return adjusted_monthly_payment"
        ],
        "usage": {
            "completion_tokens": 681,
            "prompt_tokens": 1852,
            "total_tokens": 2533,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-176",
        "article_title": "Correlation",
        "function": "def calculate_pearson_correlation(x_values: list, y_values: list) -> float:\n    \"\"\"\n    Calculate the Pearson product-moment correlation coefficient between two sets of values.\n\n    This function computes the Pearson correlation coefficient which measures the linear relationship \n    between two datasets. The return value will be between -1 and 1, indicating the strength \n    and direction of the linear relationship.\n\n    Args:\n        x_values (list): A list of numerical values representing the x-variable data points.\n        y_values (list): A list of numerical values representing the y-variable data points.\n\n    Returns:\n        correlation_coefficient (float): The Pearson correlation coefficient, ranging from -1 to 1.\n\n    Notes:\n        - Applicability: This function applies to datasets where a linear relation is assumed.\n        - Constraints: The two lists must be of equal length and contain more than two values \n          to produce a meaningful correlation coefficient. Both lists must be numerically quantifiable.\n        - Considerations: The function assumes a linear relationship. Nonlinear relationships may not be \n          accurately represented using this method. Data with outliers may inflate or deflate the coefficient.\n    \"\"\"\n    if len(x_values) != len(y_values):\n        raise ValueError(\"Input lists must have the same length.\")\n    \n    n = len(x_values)\n    if n < 3:\n        raise ValueError(\"Insufficient data. At least three observations are required.\")\n        \n    sum_x = sum(x_values)\n    sum_y = sum(y_values)\n    sum_xy = sum(x * y for x, y in zip(x_values, y_values))\n    sum_x_squared = sum(x ** 2 for x in x_values)\n    sum_y_squared = sum(y ** 2 for y in y_values)\n    \n    numerator = n * sum_xy - sum_x * sum_y\n    denominator = ((n * sum_x_squared - sum_x ** 2) * (n * sum_y_squared - sum_y ** 2)) ** 0.5\n\n    if denominator == 0:\n        raise ValueError(\"Denominator in correlation calculation is zero, which may indicate zero variance.\")\n\n    correlation_coefficient = numerator / denominator\n    \n    return correlation_coefficient",
        "statistics": {
            "number_statistics": {
                "args_numbers": 2,
                "question_numbers": 0,
                "context_numbers": 12,
                "total_numbers": 12
            },
            "operator_statistics": {
                "operators": {
                    "+": 0,
                    "-": 3,
                    "*": 6,
                    "/": 1,
                    "%": 0,
                    "**": 5
                },
                "total_operators": 15
            },
            "code_statistics": {
                "lines": 10,
                "parentheses": 20
            }
        },
        "difficulty": 5.703782474656201,
        "context": "A financial analyst at an investment firm is studying the relationship between the monthly returns of a tech sector stock and a market index to understand how closely the stock's returns are correlated to the broader market. The analyst has collected the following data over the past six months:\n\n- Tech Stock Returns (%): `[5.2, 3.8, 4.9, 2.7, 6.5, 3.3]`\n- Market Index Returns (%): `[4.1, 3.9, 5.0, 2.5, 6.0, 3.7]`\n\nThe analyst wants to compute the Pearson correlation coefficient to determine the correlation between the returns of the tech stock and the market index.",
        "question": "What is the Pearson correlation coefficient between the monthly returns of the tech stock and the market index? Answer to four decimal places.",
        "python_solution": "def solution():\n    # Define the tech stock and market index returns\n    tech_stock_returns = [5.2, 3.8, 4.9, 2.7, 6.5, 3.3]\n    market_index_returns = [4.1, 3.9, 5.0, 2.5, 6.0, 3.7]\n\n    # Calculate necessary sums for the Pearson correlation formula\n    n = len(tech_stock_returns)\n    sum_x = sum(tech_stock_returns)\n    sum_y = sum(market_index_returns)\n    sum_xy = sum(x * y for x, y in zip(tech_stock_returns, market_index_returns))\n    sum_x_squared = sum(x ** 2 for x in tech_stock_returns)\n    sum_y_squared = sum(y ** 2 for y in market_index_returns)\n    \n    # Calculate the numerator and denominator for the Pearson correlation coefficient\n    numerator = n * sum_xy - sum_x * sum_y\n    denominator = ((n * sum_x_squared - sum_x ** 2) * (n * sum_y_squared - sum_y ** 2)) ** 0.5\n    \n    # Handle potential division by zero\n    if denominator == 0:\n        raise ValueError(\"Denominator in correlation calculation is zero, which may indicate zero variance.\")\n\n    # Calculate the Pearson correlation coefficient\n    correlation_coefficient = numerator / denominator\n    \n    # Return the correlation coefficient rounded to four decimal places\n    return round(correlation_coefficient, 4)",
        "ground_truth": 0.9261,
        "source": "FinanceReasoning-test-72",
        "question_id": "test-2213",
        "level": "hard",
        "output": [
            "To solve the problem step by step and ensure accuracy, I will use the **Emphasizing Constraints (EC)** approach:\n\n### Step-by-Step Analysis\n1. **Input Constraints**:\n   - Two lists representing returns must be equal in length.\n   - Both lists must contain numeric data points and should have at least 3 values.\n   \n   In this problem:\n   - The tech stock returns are `[5.2, 3.8, 4.9, 2.7, 6.5, 3.3]`.\n   - The market index returns are `[4.1, 3.9, 5.0, 2.5, 6.0, 3.7]`.\n   - Both lists have 6 data points, satisfying the constraint.\n\n2. **Computation Constraints**:\n   - Numerator and denominator need to be computed without division by zero.\n   - The formula for the Pearson correlation coefficient is:\n     \\[\n     r = \\frac{n (\\sum xy) - (\\sum x)(\\sum y)}{\\sqrt{[n (\\sum x^2) - (\\sum x)^2][n (\\sum y^2) - (\\sum y)^2]}}\n     \\]\n   - The denominator must not equal 0, otherwise, a division by zero error occurs.\n\n3. **Rounding Constraints**:\n   - The final output must be rounded to **four decimal places** as stated in the problem.\n\n4. **Functional Implementation**:\n   - Compute numerator and denominator separately.\n   - Carefully handle summations and square calculations.\n   - Use the Pearson correlation formula to determine the coefficient.\n\n5. **Verification**:\n   - Cross-check all data points and verify that they produce a valid, meaningful Pearson correlation coefficient between -1 and 1.\n\nNow, let's implement the Python program to compute the Pearson correlation coefficient.\n\n### Python Program\n```python\ndef solution():\n    # Define variables for the tech stock and market index returns\n    tech_stock_returns = [5.2, 3.8, 4.9, 2.7, 6.5, 3.3]\n    market_index_returns = [4.1, 3.9, 5.0, 2.5, 6.0, 3.7]\n    \n    # Validate that the lengths of the input lists are equal\n    if len(tech_stock_returns) != len(market_index_returns):\n        raise ValueError(\"Input lists must have the same length.\")\n    \n    # Number of data points\n    n = len(tech_stock_returns)\n    \n    # Summation calculations\n    sum_x = sum(tech_stock_returns)\n    sum_y = sum(market_index_returns)\n    sum_xy = sum(x * y for x, y in zip(tech_stock_returns, market_index_returns))\n    sum_x_squared = sum(x ** 2 for x in tech_stock_returns)\n    sum_y_squared = sum(y ** 2 for y in market_index_returns)\n    \n    # Numerator and denominator for Pearson correlation coefficient\n    numerator = n * sum_xy - sum_x * sum_y\n    denominator = ((n * sum_x_squared - sum_x ** 2) * (n * sum_y_squared - sum_y ** 2)) ** 0.5\n    \n    # Handle edge case where denominator is zero\n    if denominator == 0:\n        raise ValueError(\"Denominator in correlation calculation is zero, which may indicate zero variance.\")\n    \n    # Calculate and round the Pearson correlation coefficient to 4 decimal places\n    correlation_coefficient = numerator / denominator\n    answer = round(correlation_coefficient, 4)\n    \n    return answer\n```"
        ],
        "retrieval_query": "What is the Pearson correlation coefficient between the monthly returns of the tech stock and the market index? Answer to four decimal places.",
        "useful_functions": [
            "def calculate_pearson_correlation(x_values: list, y_values: list) -> float:\n    \"\"\"\n    Calculate the Pearson product-moment correlation coefficient between two sets of values.\n\n    This function computes the Pearson correlation coefficient which measures the linear relationship \n    between two datasets. The return value will be between -1 and 1, indicating the strength \n    and direction of the linear relationship.\n\n    Args:\n        x_values (list): A list of numerical values representing the x-variable data points.\n        y_values (list): A list of numerical values representing the y-variable data points.\n\n    Returns:\n        correlation_coefficient (float): The Pearson correlation coefficient, ranging from -1 to 1.\n\n    Notes:\n        - Applicability: This function applies to datasets where a linear relation is assumed.\n        - Constraints: The two lists must be of equal length and contain more than two values \n          to produce a meaningful correlation coefficient. Both lists must be numerically quantifiable.\n        - Considerations: The function assumes a linear relationship. Nonlinear relationships may not be \n          accurately represented using this method. Data with outliers may inflate or deflate the coefficient.\n    \"\"\"\n    if len(x_values) != len(y_values):\n        raise ValueError(\"Input lists must have the same length.\")\n    \n    n = len(x_values)\n    if n < 3:\n        raise ValueError(\"Insufficient data. At least three observations are required.\")\n        \n    sum_x = sum(x_values)\n    sum_y = sum(y_values)\n    sum_xy = sum(x * y for x, y in zip(x_values, y_values))\n    sum_x_squared = sum(x ** 2 for x in x_values)\n    sum_y_squared = sum(y ** 2 for y in y_values)\n    \n    numerator = n * sum_xy - sum_x * sum_y\n    denominator = ((n * sum_x_squared - sum_x ** 2) * (n * sum_y_squared - sum_y ** 2)) ** 0.5\n\n    if denominator == 0:\n        raise ValueError(\"Denominator in correlation calculation is zero, which may indicate zero variance.\")\n\n    correlation_coefficient = numerator / denominator\n    \n    return correlation_coefficient"
        ],
        "usage": {
            "completion_tokens": 765,
            "prompt_tokens": 965,
            "total_tokens": 1730,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-177",
        "article_title": "Correlation Coefficient",
        "function": "def calculate_pearson_correlation(x_values: list, y_values: list) -> float:\n    \"\"\"\n    Calculate the Pearson correlation coefficient between two data sets.\n\n    This function computes the Pearson product-moment correlation coefficient,\n    which measures the linear relationship between two variables. The result ranges \n    from -1 to 1, indicating the strength and direction of the correlation.\n\n    Args:\n        x_values (list): A list of numerical values representing the first data set.\n        y_values (list): A list of numerical values representing the second data set. \n                         Must be the same length as x_values.\n\n    Returns:\n        correlation_coefficient (float): The Pearson correlation coefficient.\n\n    Notes:\n        - Applicability: Useful for determining the linear relationship between two\n          variables in fields such as finance, science, and social sciences.\n        - Constraints: The lists x_values and y_values must be of equal length and\n          contain numerical data. The correlation assumes the data follows a \n          normal distribution.\n        - Considerations: The Pearson correlation does not capture nonlinear \n          relationships and is sensitive to outliers. Ensure data is cleaned and \n          reviewed before analysis.\n    \"\"\"\n    if len(x_values) != len(y_values):\n        raise ValueError(\"The input lists must have the same number of elements.\")\n    \n    n = len(x_values)\n    sum_x = sum(x_values)\n    sum_y = sum(y_values)\n    sum_x_squared = sum(x ** 2 for x in x_values)\n    sum_y_squared = sum(y ** 2 for y in y_values)\n    sum_xy = sum(x * y for x, y in zip(x_values, y_values))\n    \n    numerator = n * sum_xy - sum_x * sum_y\n    denominator = ((n * sum_x_squared - sum_x ** 2) * (n * sum_y_squared - sum_y ** 2)) ** 0.5\n    \n    if denominator == 0:\n        raise ValueError(\"The calculation resulted in a division by zero.\")\n    \n    correlation_coefficient = numerator / denominator\n    return correlation_coefficient",
        "statistics": {
            "number_statistics": {
                "args_numbers": 2,
                "question_numbers": 0,
                "context_numbers": 11,
                "total_numbers": 11
            },
            "operator_statistics": {
                "operators": {
                    "+": 0,
                    "-": 3,
                    "*": 6,
                    "/": 1,
                    "%": 0,
                    "**": 5
                },
                "total_operators": 15
            },
            "code_statistics": {
                "lines": 10,
                "parentheses": 20
            }
        },
        "difficulty": 5.703782474656201,
        "context": "A financial analyst is reviewing the relationship between the daily closing prices of two stocks, Stock A and Stock B, to assess their correlation over a recent week. The closing prices for Stock A over 5 consecutive trading days are as follows: [150, 152, 149, 153, 151]. For Stock B, the corresponding closing prices are [45, 47, 44, 48, 46]. The analyst wants to determine the strength and direction of the linear relationship between these two stocks to guide investment strategies.",
        "question": "What is the Pearson correlation coefficient between the daily closing prices of Stock A and Stock B over the five days? Answer as a decimal rounded to four decimal places.",
        "python_solution": "def solution():\n    # Define the closing prices for Stock A and Stock B\n    x_values = [150, 152, 149, 153, 151]\n    y_values = [45, 47, 44, 48, 46]\n\n    # Ensure both lists have the same number of elements\n    if len(x_values) != len(y_values):\n        raise ValueError(\"The input lists must have the same number of elements.\")\n\n    # Number of observations\n    n = len(x_values)\n    \n    # Calculate needed sums\n    sum_x = sum(x_values)\n    sum_y = sum(y_values)\n    sum_x_squared = sum(x ** 2 for x in x_values)\n    sum_y_squared = sum(y ** 2 for y in y_values)\n    sum_xy = sum(x * y for x, y in zip(x_values, y_values))\n    \n    # Calculate the numerator and denominator of the Pearson correlation coefficient\n    numerator = n * sum_xy - sum_x * sum_y\n    denominator = ((n * sum_x_squared - sum_x ** 2) * (n * sum_y_squared - sum_y ** 2)) ** 0.5\n    \n    # Check for division by zero\n    if denominator == 0:\n        raise ValueError(\"The calculation resulted in a division by zero.\")\n    \n    # Calculate the Pearson correlation coefficient\n    correlation_coefficient = numerator / denominator\n    \n    # Return the result rounded to four decimal places\n    return round(correlation_coefficient, 4)\n\nsolution()",
        "ground_truth": 1.0,
        "source": "FinanceReasoning-test-73",
        "question_id": "test-2214",
        "level": "hard",
        "output": [
            "### Step-by-Step Analysis Using Emphasizing Constraints (EC):\n\n1. **Problem Objective**:\n    - The goal is to compute the **Pearson correlation coefficient (r)** between the closing prices of Stock A and Stock B over five consecutive trading days. \n    - This quantifies the strength and direction of the linear relationship between the two stocks.\n\n2. **Pearson Correlation Coefficient Formula**:\n    - The formula for correlation is:\n      \\[\n      r = \\frac{\\sum((X_i - \\bar{X})(Y_i - \\bar{Y}))}{\\sqrt{\\sum(X_i - \\bar{X})^2 \\cdot \\sum(Y_i - \\bar{Y})^2}}\n      \\]\n      Where:\n      - \\(X_i\\) = Individual values in dataset X (Stock A closing prices).\n      - \\(Y_i\\) = Individual values in dataset Y (Stock B closing prices).\n      - \\(\\bar{X}\\) = Mean of \\(X\\).\n      - \\(\\bar{Y}\\) = Mean of \\(Y\\).\n      - \\(r\\) is the Pearson correlation coefficient.\n\n3. **Constraints**:\n    - The daily closing prices for Stock A are given as: [150, 152, 149, 153, 151].\n    - The daily closing prices for Stock B are given as: [45, 47, 44, 48, 46].\n    - The answer must be returned as a decimal rounded to four decimal places.\n\n4. **Key Steps**:\n    - Calculate the mean (\\(\\bar{X}\\) and \\(\\bar{Y}\\)) of the prices for Stock A and Stock B.\n    - Compute the deviations of each data point from the mean (\\(X_i - \\bar{X}\\) and \\(Y_i - \\bar{Y}\\)).\n    - Find the numerator: Sum of the product of deviations [\\(\\sum((X_i - \\bar{X})(Y_i - \\bar{Y}))\\)].\n    - Compute the denominator: Product of square root of the sum of squared deviations of each stock separately.\n    - Divide the numerator by the denominator to calculate \\(r\\).\n\n5. **Decimal Precision**:\n    - The result must be rounded to **four decimal places** as specified in the constraints.\n\n### Python Program to Solve:\n```python\ndef solution():\n    # Define variables name and value\n    stock_a_prices = [150, 152, 149, 153, 151]\n    stock_b_prices = [45, 47, 44, 48, 46]\n    \n    # Step 1: Calculate means\n    mean_a = sum(stock_a_prices) / len(stock_a_prices)\n    mean_b = sum(stock_b_prices) / len(stock_b_prices)\n    \n    # Step 2: Calculate deviations and components for correlation formula\n    numerator = sum((a - mean_a) * (b - mean_b) for a, b in zip(stock_a_prices, stock_b_prices))\n    denominator_a = sum((a - mean_a) ** 2 for a in stock_a_prices)\n    denominator_b = sum((b - mean_b) ** 2 for b in stock_b_prices)\n    denominator = (denominator_a * denominator_b) ** 0.5\n    \n    # Step 3: Pearson correlation coefficient\n    correlation = numerator / denominator\n    \n    # Return result rounded to four decimal places\n    return round(correlation, 4)\n```"
        ],
        "retrieval_query": "What is the Pearson correlation coefficient between the daily closing prices of Stock A and Stock B over the five days? Answer as a decimal rounded to four decimal places.",
        "useful_functions": [],
        "usage": {
            "completion_tokens": 726,
            "prompt_tokens": 465,
            "total_tokens": 1191,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-1960",
        "article_title": "Trend Analysis",
        "function": "def calculate_correlation(x_values: list, y_values: list) -> float:\n    \"\"\"\n    Calculate the Pearson correlation coefficient between two variables.\n\n    This function calculates the correlation coefficient which measures the strength\n    and direction of a linear relationship between two variables.\n\n    Args:\n        x_values (list): A list of independent variable data points.\n        y_values (list): A list of dependent variable data points. Must have the same length as x_values.\n\n    Returns:\n        correlation_coefficient (float): The Pearson correlation coefficient, ranging from -1 to 1.\n\n    Notes:\n        - The input lists must have at least two points and must be of equal length.\n        - A correlation coefficient of 1 indicates a perfect positive relationship,\n          -1 indicates a perfect negative relationship, and 0 indicates no linear relationship.\n    \"\"\"\n    if len(x_values) != len(y_values):\n        raise ValueError(\"Input lists must be of the same length.\")\n    \n    if len(x_values) < 2:\n        raise ValueError(\"At least two data points are required for correlation calculation.\")\n        \n    n = len(x_values)\n    sum_x = sum(x_values)\n    sum_y = sum(y_values)\n    sum_x_squared = sum(x ** 2 for x in x_values)\n    sum_y_squared = sum(y ** 2 for y in y_values)\n    sum_xy = sum(x * y for x, y in zip(x_values, y_values))\n\n    numerator = n * sum_xy - sum_x * sum_y\n    denominator = ((n * sum_x_squared - sum_x ** 2) * (n * sum_y_squared - sum_y ** 2)) ** 0.5\n    \n    if denominator == 0:\n        raise ValueError(\"Denominator in correlation calculation is zero, check for constant inputs.\")\n\n    correlation_coefficient = numerator / denominator\n    \n    return correlation_coefficient",
        "statistics": {
            "number_statistics": {
                "args_numbers": 2,
                "question_numbers": 0,
                "context_numbers": 12,
                "total_numbers": 12
            },
            "operator_statistics": {
                "operators": {
                    "+": 0,
                    "-": 3,
                    "*": 6,
                    "/": 1,
                    "%": 0,
                    "**": 5
                },
                "total_operators": 15
            },
            "code_statistics": {
                "lines": 10,
                "parentheses": 20
            }
        },
        "difficulty": 5.703782474656201,
        "context": "An investment analyst is examining the relationship between the quarterly percentage changes in sales (independent variable) and the quarterly percentage changes in stock prices (dependent variable) for XYZ Corporation over the last six quarters. The analyst wants to determine if there is a significant correlation between these two financial metrics, which might indicate that sales performance influences stock price movements.\n\nThe observed data are as follows:\n\n- Quarterly percentage change in sales: [3.5, 4.2, -1.0, 5.5, 2.1, 3.8]\n- Quarterly percentage change in stock prices: [2.8, 5.0, -0.5, 6.0, 1.9, 4.4]",
        "question": "What is the Pearson correlation coefficient between the quarterly percentage changes in sales and stock prices for XYZ Corporation? Provide the answer as a decimal rounded to two decimal places.",
        "python_solution": "def solution():\n    # Define the data points for the changes in sales and stock prices\n    sales_changes = [3.5, 4.2, -1.0, 5.5, 2.1, 3.8]\n    stock_price_changes = [2.8, 5.0, -0.5, 6.0, 1.9, 4.4]\n\n    # Validate that the both lists have the same number of elements\n    n = len(sales_changes)\n    \n    # Calculate sums and intermediate sums needed for the formula\n    sum_sales = sum(sales_changes)\n    sum_prices = sum(stock_price_changes)\n    sum_sales_squared = sum(x ** 2 for x in sales_changes)\n    sum_prices_squared = sum(y ** 2 for y in stock_price_changes)\n    sum_sales_prices = sum(x * y for x, y in zip(sales_changes, stock_price_changes))\n\n    # Calculate the numerator of the Pearson correlation coefficient\n    numerator = n * sum_sales_prices - sum_sales * sum_prices\n\n    # Calculate the denominator of the Pearson correlation coefficient\n    denominator = ((n * sum_sales_squared - sum_sales ** 2) *\n                   (n * sum_prices_squared - sum_prices ** 2)) ** 0.5\n\n    # Handle the potential zero denominator situation\n    if denominator == 0:\n        raise ValueError(\"Denominator in correlation calculation is zero, check for constant inputs.\")\n\n    # Calculate the correlation coefficient\n    correlation_coefficient = numerator / denominator\n\n    # Return the correlation coefficient rounded to two decimal places\n    return round(correlation_coefficient, 2)",
        "ground_truth": 0.97,
        "source": "FinanceReasoning-test-74",
        "question_id": "test-2215",
        "level": "hard",
        "output": [
            "To calculate the Pearson correlation coefficient between the quarterly percentage changes in sales and the quarterly percentage changes in stock prices, let us proceed step-by-step:\n\n### Step-by-Step Analysis\n\n1. **Understand the Pearson correlation coefficient**:\n   - It measures the linear relationship between two datasets.\n   - The coefficient ranges from -1 to 1.\n   - A value of 1 indicates a perfect positive correlation, -1 indicates a perfect negative correlation, and 0 indicates no correlation.\n\n2. **Identify constraints (EC)**:\n   - Use a precise calculation method to compute the Pearson correlation coefficient.\n   - Ensure the result is rounded to **two decimal places** as per the problem constraints.\n\n3. **Find the formula for Pearson correlation coefficient**:\n   The formula is:\n   \\[\n   r = \\frac{\\text{Cov}(X, Y)}{\\sigma_X \\cdot \\sigma_Y}\n   \\]\n   - where:\n     - \\(\\text{Cov}(X, Y)\\): Covariance of `X` and `Y`\n     - \\(\\sigma_X\\): Standard deviation of `X`\n     - \\(\\sigma_Y\\): Standard deviation of `Y`\n\n4. **Input the data**:\n   - Sales percentage changes: `X = [3.5, 4.2, -1.0, 5.5, 2.1, 3.8]`\n   - Stock prices percentage changes: `Y = [2.8, 5.0, -0.5, 6.0, 1.9, 4.4]`\n\n5. **Perform the calculation**:\n   - First, calculate the means of \\(X\\) and \\(Y\\).\n   - Then compute \\(\\text{Cov}(X, Y)\\).\n   - Finally, compute \\(\\sigma_X\\) and \\(\\sigma_Y\\) to calculate \\(r\\).\n\nBelow is the Python program that implements the above process:\n\n```python\ndef solution():\n    # Importing the required module\n    from math import sqrt\n\n    # Data input: Quarterly percentage changes\n    sales_changes = [3.5, 4.2, -1.0, 5.5, 2.1, 3.8]\n    stock_price_changes = [2.8, 5.0, -0.5, 6.0, 1.9, 4.4]\n    \n    # Step 1: Calculate means\n    mean_sales = sum(sales_changes) / len(sales_changes)\n    mean_stock_prices = sum(stock_price_changes) / len(stock_price_changes)\n    \n    # Step 2: Calculate covariance\n    covariance = sum((x - mean_sales) * (y - mean_stock_prices) for x, y in zip(sales_changes, stock_price_changes)) / len(sales_changes)\n    \n    # Step 3: Calculate standard deviations\n    std_sales = sqrt(sum((x - mean_sales) ** 2 for x in sales_changes) / len(sales_changes))\n    std_stock_prices = sqrt(sum((y - mean_stock_prices) ** 2 for y in stock_price_changes) / len(stock_price_changes))\n    \n    # Step 4: Calculate Pearson correlation coefficient\n    pearson_correlation = covariance / (std_sales * std_stock_prices)\n    \n    # Step 5: Round the result to two decimal places\n    answer = round(pearson_correlation, 2)\n    \n    return answer\n```"
        ],
        "retrieval_query": "What is the Pearson correlation coefficient between the quarterly percentage changes in sales and stock prices for XYZ Corporation? Provide the answer as a decimal rounded to two decimal places.",
        "useful_functions": [],
        "usage": {
            "completion_tokens": 722,
            "prompt_tokens": 507,
            "total_tokens": 1229,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-1975",
        "article_title": "True Strength Index (TSI)",
        "function": "def calculate_tsi(current_prices: list, prior_prices: list, period1: int = 25, period2: int = 13) -> float:\n    \"\"\"\n    Calculate the True Strength Index (TSI) for a given series of prices.\n\n    The True Strength Index is a technical indicator used to identify trends,\n    reversals, and potential overbought/oversold conditions in a market.\n\n    Args:\n        current_prices (list): A list of current closing prices.\n        prior_prices (list): A list of prior closing prices corresponding to each current price.\n        period1 (int): The period for the first exponential moving average (default is 25).\n        period2 (int): The period for the second exponential moving average (default is 13).\n\n    Returns:\n        tsi (float): The calculated True Strength Index value.\n\n    Notes:\n        - Applicable for technical analysis to identify market trends.\n        - The lists current_prices and prior_prices must be of equal length.\n        - The function assumes that prices are ordered chronologically.\n        - The EMA is calculated using a simple exponential smoothing method.\n    \"\"\"\n    def calculate_ema(values, period):\n        ema = [values[0]]\n        multiplier = 2 / (period + 1)\n        for price in values[1:]:\n            ema.append((price - ema[-1]) * multiplier + ema[-1])\n        return ema\n\n    price_changes = [(ccp - pcp) for ccp, pcp in zip(current_prices, prior_prices)]\n    absolute_price_changes = [abs(pc) for pc in price_changes]\n\n    pcs_ema = calculate_ema(price_changes, period1)\n    apc_ema = calculate_ema(absolute_price_changes, period1)\n    \n    pcds_ema = calculate_ema(pcs_ema, period2)\n    apcds_ema = calculate_ema(apc_ema, period2)\n\n    tsi = (pcds_ema[-1] / apcds_ema[-1]) * 100\n\n    return tsi",
        "statistics": {
            "number_statistics": {
                "args_numbers": 4,
                "question_numbers": 0,
                "context_numbers": 13,
                "total_numbers": 13
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 6,
                    "*": 2,
                    "/": 2,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 12
            },
            "code_statistics": {
                "lines": 14,
                "parentheses": 24
            }
        },
        "difficulty": 5.7430031878094825,
        "context": "An analyst is evaluating the performance of a stock for potential investment. They decide to use the True Strength Index (TSI) to identify trends and assess whether the stock is overbought or oversold. Over the past month, the closing prices of the stock were recorded daily, with the current closing prices for the last 5 days documented as [150, 152, 151, 153, 155]. The corresponding prior closing prices are [148, 149, 150, 151, 152]. The analyst uses a period of 25 days for the first exponential moving average and 13 days for the second exponential moving average to calculate the TSI.",
        "question": "What is the True Strength Index (TSI) for the stock based on the given closing prices? Answer as a percentage to two decimal places.",
        "python_solution": "def solution():\n    # Define the current and prior closing prices\n    current_prices = [150, 152, 151, 153, 155]\n    prior_prices = [148, 149, 150, 151, 152]\n    \n    # Define the periods for EMA\n    period1 = 25\n    period2 = 13\n\n    # Function to calculate EMA\n    def calculate_ema(values, period):\n        ema = [values[0]]\n        multiplier = 2 / (period + 1)\n        for price in values[1:]:\n            ema.append((price - ema[-1]) * multiplier + ema[-1])\n        return ema\n\n    # Calculate price changes\n    price_changes = [(ccp - pcp) for ccp, pcp in zip(current_prices, prior_prices)]\n    absolute_price_changes = [abs(pc) for pc in price_changes]\n\n    # Calculate EMAs needed for TSI\n    pcs_ema = calculate_ema(price_changes, period1)\n    apc_ema = calculate_ema(absolute_price_changes, period1)\n    \n    pcds_ema = calculate_ema(pcs_ema, period2)\n    apcds_ema = calculate_ema(apc_ema, period2)\n\n    # Calculate TSI\n    tsi = (pcds_ema[-1] / apcds_ema[-1]) * 100\n    \n    # Return the TSI rounded to two decimal places\n    return round(tsi, 2)\n\n# Run the solution function and get the result",
        "ground_truth": 100.0,
        "source": "FinanceReasoning-test-36",
        "question_id": "test-2216",
        "level": "hard",
        "output": [
            "To solve the problem, we need to calculate the True Strength Index (TSI) based on the given closing prices and corresponding prior closing prices using the provided reference function. As outlined, the end result should be expressed in percentage format accurate to two decimal places. Let's proceed step by step using the advanced \"Emphasizing Constraints\" reasoning:\n\n### Step-by-Step Reasoning:\n\n1. **Understand the Problem Constraints**:\n   - We are given a list of current prices and prior prices. These lists are of equal length and ordered chronologically.\n   - We are tasked with calculating the TSI using the periods for the first and second Exponential Moving Averages (EMA). Specifically:\n     - The first EMA has a period of 25 days.\n     - The second EMA has a period of 13 days.\n   - The TSI formula involves calculating:\n     - Price changes and their absolute values over the timeframe.\n     - Exponential moving averages of both (1) the price changes (pcs) and (2) the absolute price changes (apc).\n     - A second smoothing (EMA) is applied to each result.\n   - The TSI is calculated as:\n     \\[\n     TSI = \\left(\\frac{{EMA(\\text{pcs})}}{{EMA(\\text{apcs})}}\\right) \\times 100\n     \\]\n   - The final result is to be output as a percentage rounded to two decimal places.\n\n2. **Align the Method with Constraints**:\n   - We use the provided `calculate_tsi` function as a reference for implementing the calculation. The function already encapsulates the steps necessary to compute the TSI.\n   - Ensure all intermediate calculations respect the constraints (like EMA calculations).\n   - The final output should be formatted as a percentage to two decimal places.\n\n3. **Proceed to Implement the Solution**:\n   - The data provided is limited to the last 5 days, and we'll use it directly as inputs to the function.\n   - Calculate the TSI using the reference method for the provided input while ensuring adherence to all constraints.\n\nHere is the Python program to calculate and return the TSI:\n\n```python\ndef solution():\n    # Define variables\n    current_prices = [150, 152, 151, 153, 155]  # Given current closing prices\n    prior_prices = [148, 149, 150, 151, 152]    # Corresponding prior closing prices\n    period1 = 25  # Period for the first EMA\n    period2 = 13  # Period for the second EMA\n    \n    # Define the calculate_tsi function to handle the TSI calculation\n    def calculate_tsi(current_prices, prior_prices, period1=25, period2=13):\n        # Internal helper function to calculate EMA\n        def calculate_ema(values, period):\n            ema = [values[0]]  # Start the EMA calculation with the first value\n            multiplier = 2 / (period + 1)  # Multiplier for smoothing\n            for price in values[1:]:  # Calculate remaining EMA values\n                ema.append((price - ema[-1]) * multiplier + ema[-1])\n            return ema\n\n        # Step 1: Calculate price changes and their absolute values\n        price_changes = [(ccp - pcp) for ccp, pcp in zip(current_prices, prior_prices)]\n        absolute_price_changes = [abs(pc) for pc in price_changes]\n\n        # Step 2: Calculate EMA for price changes (pcs) and abs price changes (apc)\n        pcs_ema = calculate_ema(price_changes, period1)\n        apc_ema = calculate_ema(absolute_price_changes, period1)\n\n        # Step 3: Calculate second-level EMA for the smoothed values\n        pcds_ema = calculate_ema(pcs_ema, period2)\n        apcds_ema = calculate_ema(apc_ema, period2)\n\n        # Step 4: Calculate the TSI as the ratio of smoothed components\n        tsi = (pcds_ema[-1] / apcds_ema[-1]) * 100  # TSI as a percentage\n        return tsi\n\n    # Perform the TSI calculation with the given data\n    tsi_value = calculate_tsi(current_prices, prior_prices, period1, period2)\n\n    # Return the TSI value rounded to two decimal places\n    return round(tsi_value, 2)\n```\n\nThis program calculates the TSI based on the provided current and prior closing prices using the specified periods for the EMA computations, and adheres strictly to the formatting constraints."
        ],
        "retrieval_query": "What is the True Strength Index (TSI) for the stock based on the given closing prices? Answer as a percentage to two decimal places.",
        "useful_functions": [
            "def calculate_tsi(current_prices: list, prior_prices: list, period1: int = 25, period2: int = 13) -> float:\n    \"\"\"\n    Calculate the True Strength Index (TSI) for a given series of prices.\n\n    The True Strength Index is a technical indicator used to identify trends,\n    reversals, and potential overbought/oversold conditions in a market.\n\n    Args:\n        current_prices (list): A list of current closing prices.\n        prior_prices (list): A list of prior closing prices corresponding to each current price.\n        period1 (int): The period for the first exponential moving average (default is 25).\n        period2 (int): The period for the second exponential moving average (default is 13).\n\n    Returns:\n        tsi (float): The calculated True Strength Index value.\n\n    Notes:\n        - Applicable for technical analysis to identify market trends.\n        - The lists current_prices and prior_prices must be of equal length.\n        - The function assumes that prices are ordered chronologically.\n        - The EMA is calculated using a simple exponential smoothing method.\n    \"\"\"\n    def calculate_ema(values, period):\n        ema = [values[0]]\n        multiplier = 2 / (period + 1)\n        for price in values[1:]:\n            ema.append((price - ema[-1]) * multiplier + ema[-1])\n        return ema\n\n    price_changes = [(ccp - pcp) for ccp, pcp in zip(current_prices, prior_prices)]\n    absolute_price_changes = [abs(pc) for pc in price_changes]\n\n    pcs_ema = calculate_ema(price_changes, period1)\n    apc_ema = calculate_ema(absolute_price_changes, period1)\n    \n    pcds_ema = calculate_ema(pcs_ema, period2)\n    apcds_ema = calculate_ema(apc_ema, period2)\n\n    tsi = (pcds_ema[-1] / apcds_ema[-1]) * 100\n\n    return tsi"
        ],
        "usage": {
            "completion_tokens": 957,
            "prompt_tokens": 923,
            "total_tokens": 1880,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "John oversees a fund, with the returns for the first three years displayed below: What will be the holding period return (expressed as a percentage)? Answer to three decimal places.",
        "python_solution": "def solution():\n    # Define variables name and value\n    investment_year_1 = 500\n    return_year_1 = 0.12\n    \n    investment_year_2 = 600\n    return_year_2 = 0.05\n    \n    investment_year_3 = 1000\n    return_year_3 = 0.01\n    \n    # Calculate future value for each year\n    future_value_year_1 = investment_year_1 * (1 + return_year_1)\n    future_value_year_2 = investment_year_2 * (1 + return_year_2)\n    future_value_year_3 = investment_year_3 * (1 + return_year_3)\n    \n    # Calculate total future value\n    total_future_value = future_value_year_1 + future_value_year_2 + future_value_year_3\n    \n    # Calculate total initial investment\n    total_initial_investment = investment_year_1 + investment_year_2 + investment_year_3\n    \n    # Calculate holding period return\n    holding_period_return = ((total_future_value / total_initial_investment) - 1) * 100\n    \n    # return answer\n    return holding_period_return\n",
        "ground_truth": 4.762,
        "topic": "Portfolio Management & Strategy",
        "statistics": {
            "number_statistics": {
                "args_numbers": 4,
                "question_numbers": 0,
                "context_numbers": 8,
                "total_numbers": 8
            },
            "operator_statistics": {
                "operators": {
                    "+": 7,
                    "-": 1,
                    "*": 4,
                    "/": 1,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 13
            },
            "code_statistics": {
                "lines": 19,
                "parentheses": 10
            }
        },
        "difficulty": 5.7430031878094825,
        "source": "FinanceMath-validation-144",
        "context": "['| Year | Investment | Return |\\n|------|------------|--------|\\n| 1    | $500       | 12%    |\\n| 2    | $600       | 5%     |\\n| 3    | $1000      | 1%     |']",
        "question_id": "test-2217",
        "level": "hard",
        "output": [
            "To compute the Holding Period Return (HPR), which measures the total return earned on an investment over a holding period expressed as a percentage, we can use the formula:\n\n\\[\n\\text{HPR} = \\frac{\\text{Ending value of the investment} - \\text{Beginning value of the investment} + \\text{Total returns}}{\\text{Beginning value of the investment}} \\times 100\n\\]\n\n### Step-by-step computation:\n1. **Constraints**:\n   - Compute the HPR as a percentage.\n   - Answer must be accurate to three decimal places.\n\n2. **Gathering Key Values**:\n   - **Year 1 investment**: $500 with a return of 12%.\n   - **Year 2 investment**: $600 with a return of 5%.\n   - **Year 3 investment**: $1000 with a return of 1%.\n\n3. **Aggregate Outcome**:\n   - For compounded returns, multiply individual year returns sequentially to establish the total return factor:\n     \\[\n     \\text{Total Return Factor} = (1 + \\text{Year1 Return}) \\times (1 + \\text{Year2 Return}) \\times (1 + \\text{Year3 Return})\n     \\]\n     Subtract 1 from the calculated final factor, and then multiply by the total initial investment.\n\nGiven these steps, let's set up the Python code to compute the Holding Period Return (HPR). \n\n### Python Code:\n```python\ndef solution():\n    # Define variables for investments and returns\n    investment_year1 = 500\n    return_year1 = 12 / 100  # 12% as a decimal\n    \n    investment_year2 = 600\n    return_year2 = 5 / 100  # 5% as a decimal\n    \n    investment_year3 = 1000\n    return_year3 = 1 / 100  # 1% as a decimal\n    \n    # Total investment amount\n    total_investment = investment_year1 + investment_year2 + investment_year3\n    \n    # Calculate total return factor by compounding the returns for each year\n    total_return_factor = (1 + return_year1) * (1 + return_year2) * (1 + return_year3)\n    \n    # Holding Period Return (HPR)\n    hpr_percentage = (total_return_factor - 1) * 100  # Convert to percentage\n    \n    # Return result rounded to three decimal places\n    return round(hpr_percentage, 3)\n```"
        ],
        "retrieval_query": "John oversees a fund, with the returns for the first three years displayed below: What will be the holding period return (expressed as a percentage)? Answer to three decimal places.",
        "useful_functions": [
            "def calculate_net_revenue_change(net_revenue_previous_year: float, net_revenue_current_year: float) -> float:\n    \"\"\"\n    Calculate the net change in net revenue between two consecutive years.\n\n    This function computes the change in net revenue from one year to the next\n    by subtracting the net revenue of the previous year from the net revenue of\n    the current year. It is useful for analyzing financial performance over time.\n\n    Args:\n        net_revenue_previous_year (float): The net revenue of the previous year.\n        net_revenue_current_year (float): The net revenue of the current year.\n\n    Returns:\n        net_change (float): The net change in net revenue from the previous year\n                            to the current year, rounded to three decimal places.\n\n    Notes:\n        - Applicability: This function is applicable to any scenario where net\n          revenue comparison across two consecutive years is needed.\n        - Constraints: Ensure that the net revenue values are expressed in the\n          same unit (e.g., millions of dollars).\n        - Considerations: Negative results indicate a decrease in net revenue,\n          while positive results indicate an increase.\n    \"\"\"\n    net_change = round(net_revenue_current_year - net_revenue_previous_year, 3)\n    \n    return net_change",
            "def calculate_net_gain_or_loss(ordinary_income: float, ordinary_expenses: float, short_term_gain: float, short_term_loss: float, long_term_gain: float, long_term_loss: float) -> dict:\n    \"\"\"\n    Calculate the net gain or loss from ordinary income and capital transactions.\n\n    This function computes the net ordinary gain or loss from business operations\n    as well as the net capital gain or loss from short-term and long-term investments.\n    The net values allow a taxpayer to understand their financial standing and tax liability.\n\n    Args:\n        ordinary_income (float): Total ordinary income earned from business operations.\n        ordinary_expenses (float): Total expenses incurred in business operations.\n        short_term_gain (float): Total short-term capital gains from asset sales.\n        short_term_loss (float): Total short-term capital losses from asset sales.\n        long_term_gain (float): Total long-term capital gains from asset sales.\n        long_term_loss (float): Total long-term capital losses from asset sales.\n\n    Returns:\n        result (dict): A dictionary containing:\n            'net_ordinary_gain' (float): The net ordinary gain or loss.\n            'net_short_term_capital' (float): The net short-term capital gain or loss.\n            'net_long_term_capital' (float): The net long-term capital gain or loss.\n            'net_overall_gain' (float): The overall net gain or loss considering allowable deductions.\n\n    Notes:\n        - Ordinary losses can be fully deducted to offset ordinary income.\n        - Capital losses exceeding capital gains can only offset $3,000 of ordinary income.\n        - Remaining capital losses can be carried over to subsequent years.\n        - This function does not handle carryover processes; it only returns current year\u2019s computations.\n    \"\"\"\n    net_ordinary_gain = ordinary_income - ordinary_expenses\n    net_short_term_capital = short_term_gain - short_term_loss\n    net_long_term_capital = long_term_gain - long_term_loss\n\n    net_capital = net_short_term_capital + net_long_term_capital\n\n    # Apply the $3,000 deduction limit for capital losses against ordinary income\n    if net_capital < 0:\n        capital_deduction = max(net_capital, -3000)\n    else:\n        capital_deduction = net_capital\n\n    net_overall_gain = net_ordinary_gain + capital_deduction\n\n    return {\n        'net_ordinary_gain': net_ordinary_gain,\n        'net_short_term_capital': net_short_term_capital,\n        'net_long_term_capital': net_long_term_capital,\n        'net_overall_gain': net_overall_gain\n    }"
        ],
        "usage": {
            "completion_tokens": 522,
            "prompt_tokens": 1244,
            "total_tokens": 1766,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-2311",
        "article_title": "What Is an Amortized Bond? How They Work, and Example",
        "function": "def calculate_amortization_schedule(principal: float, annual_interest_rate: float, years: int) -> list:\n    \"\"\"\n    Calculate the amortization schedule for a loan or bond.\n\n    This function computes the amortization schedule for a loan or bond\n    given the principal amount, annual interest rate, and the term in years.\n    It returns a list of dictionaries, each representing a period with details\n    about principal paid, interest paid, and remaining balance.\n\n    Args:\n        principal (float): The initial principal or face value of the bond/loan.\n        annual_interest_rate (float): The annual interest rate expressed as a decimal.\n        years (int): The total number of years to amortize the loan/bond.\n\n    Returns:\n        schedule (list): A list of dictionaries containing 'period', 'principal_paid',\n                         'interest_paid', and 'remaining_balance' for each period.\n\n    Notes:\n        - This function assumes fixed monthly payments over the term.\n        - It calculates based on equal monthly payments and monthly compounding.\n        - The annual_interest_rate must be greater than 0.\n        - The principal should be positive and greater than zero.\n        - The function does not account for taxes or fees.\n\n    \"\"\"\n    if annual_interest_rate <= 0 or principal <= 0 or years <= 0:\n        raise ValueError(\"Principal, interest rate, and years must be greater than zero.\")\n\n    monthly_interest_rate = annual_interest_rate / 12\n    num_payments = years * 12\n    payment = principal * (monthly_interest_rate * (1 + monthly_interest_rate) ** num_payments) / \\\n              ((1 + monthly_interest_rate) ** num_payments - 1)\n    \n    schedule = []\n    remaining_balance = principal\n\n    for period in range(1, num_payments + 1):\n        interest_paid = remaining_balance * monthly_interest_rate\n        principal_paid = payment - interest_paid\n        remaining_balance -= principal_paid\n        \n        schedule.append({\n            'period': period,\n            'principal_paid': principal_paid,\n            'interest_paid': interest_paid,\n            'remaining_balance': remaining_balance\n        })\n\n    return schedule",
        "statistics": {
            "number_statistics": {
                "args_numbers": 3,
                "question_numbers": 0,
                "context_numbers": 3,
                "total_numbers": 3
            },
            "operator_statistics": {
                "operators": {
                    "+": 3,
                    "-": 3,
                    "*": 4,
                    "/": 2,
                    "%": 0,
                    "**": 2
                },
                "total_operators": 14
            },
            "code_statistics": {
                "lines": 17,
                "parentheses": 12
            }
        },
        "difficulty": 5.7745515455444085,
        "context": "A couple is planning to finance their first home purchase by taking out a mortgage loan. They have been approved for a loan amount of $200,000 with an annual interest rate of 3.75%, and plan to pay it off over 30 years. They are interested in understanding how much of their first month's mortgage payment will be allocated to interest.",
        "question": "What is the amount of interest paid during the first month of the mortgage? Provide your answer in dollars to two decimal places.",
        "python_solution": "def solution():\n    # Initialize the variables with the given values\n    principal = 200000  # Loan amount\n    annual_interest_rate = 0.0375  # Annual interest rate as a decimal\n    years = 30  # Loan term in years\n\n    # Derive the monthly interest rate\n    monthly_interest_rate = annual_interest_rate / 12\n    \n    # Calculate the number of payments (months)\n    num_payments = years * 12\n\n    # Calculate the monthly payment using the amortization formula\n    monthly_payment = principal * (monthly_interest_rate * (1 + monthly_interest_rate) ** num_payments) / \\\n                      ((1 + monthly_interest_rate) ** num_payments - 1)\n\n    # Calculate the interest paid in the first month\n    first_month_interest_paid = principal * monthly_interest_rate\n\n    # Return the first month's interest paid, rounded to two decimal places\n    return round(first_month_interest_paid, 2)\n\n# The solution to the problem\nresult = solution()\nprint(result)",
        "ground_truth": 625.0,
        "source": "FinanceReasoning-test-56",
        "question_id": "test-2218",
        "level": "hard",
        "output": [
            "### Step-by-Step Thought Process:\nI will first break down the problem into smaller components to develop a step-by-step plan to find the answer.\n\n#### 1. Define the Problem:\nWe are tasked with calculating **the interest paid during the first month** of a mortgage loan. The key elements provided in the problem are:\n- Loan amount: $200,000\n- Annual interest rate: 3.75% (0.0375 in decimal form)\n- Loan period: 30 years (360 months)\n- Fixed monthly mortgage payments (assumption since it's a standard mortgage).\n\n#### 2. Key Formula to Calculate Interest Paid in Month 1:\nFor the first month of a loan, the interest portion of the payment is calculated as:\n\\[\n\\text{Monthly Interest Payment} = \\text{Principal Balance} \\times \\frac{\\text{Annual Interest Rate}}{12}\n\\]\n\nSince the principal balance for the first month is the full loan amount, the monthly interest is calculated on $200,000 for an annual interest rate of 3.75%.\n\n#### 3. Intermediate Calculation:\n- Convert the annual interest rate to a monthly interest rate:\n  \\[\n  \\text{Monthly Interest Rate} = \\frac{\\text{Annual Interest Rate}}{12} = \\frac{0.0375}{12}\n  \\]\n\n- Compute the interest paid for the first month:\n  \\[\n  \\text{First Month Interest} = \\text{Loan Amount} \\times \\text{Monthly Interest Rate}\n  \\]\n\n#### 4. Constraints and Rounding:\n- Adhere to the constraint of providing the **amount in dollars to two decimal places**. \n- Use fixed rates for the calculation; assume there is no compounding other than monthly.\n- Follow step-by-step arithmetic and formatting requirements.\n\n---\n\n### Python Program:\n```python\ndef solution():\n    # Define variables name and value\n    loan_amount = 200000  # Loan amount in dollars\n    annual_interest_rate = 0.0375  # Annual interest rate as decimal\n    \n    # Do math calculation to get the answer\n    monthly_interest_rate = annual_interest_rate / 12  # Convert annual interest to monthly interest rate\n    first_month_interest = loan_amount * monthly_interest_rate  # Interest paid in the first month\n    \n    # Round the answer to two decimal places\n    answer = round(first_month_interest, 2)\n    \n    # Return the answer\n    return answer\n```\n\n### Explanation of the Code:\n1. We calculate the **monthly interest rate** from the given annual rate by dividing it by 12.\n2. The monthly interest is then computed by multiplying the **principal balance** ($200,000) by the **monthly interest rate**.\n3. The result is rounded to two decimal places to ensure the result aligns with the constraints.\n\nThis program efficiently calculates the amount of interest paid during the first month of the mortgage."
        ],
        "retrieval_query": "What is the amount of interest paid during the first month of the mortgage? Provide your answer in dollars to two decimal places.",
        "useful_functions": [
            "def calculate_accrued_interest(start_date: str, end_date: str, nominal_rate: float, principal: float, convention: str) -> float:\n    \"\"\"\n    Calculate the accrued interest for a financial instrument using specified day-count conventions.\n\n    This function computes the accrued interest between two dates based on the nominal interest rate,\n    principal amount, and the selected day-count convention. It supports multiple conventions such as\n    30/360, 30/365, actual/360, actual/365, and actual/actual.\n\n    Args:\n        start_date (str): The start date in 'YYYY-MM-DD' format.\n        end_date (str): The end date in 'YYYY-MM-DD' format.\n        nominal_rate (float): The annual nominal interest rate (as a decimal, e.g., 0.05 for 5%).\n        principal (float): The principal amount on which interest is calculated.\n        convention (str): The day-count convention to use ('30/360', '30/365', 'actual/360', 'actual/365', 'actual/actual').\n\n    Returns:\n        accrued_interest (float): The calculated accrued interest over the period defined by the start and end dates.\n\n    Notes:\n        - Applicability: This function is applicable for bonds, swaps, and similar financial instruments.\n        - Constraints: The date inputs must be in 'YYYY-MM-DD' format, and the convention must be a recognized value.\n        - Considerations: Ensure that start_date precedes end_date for correct calculation.\n    \"\"\"\n    from datetime import datetime\n\n    date_format = \"%Y-%m-%d\"\n    start = datetime.strptime(start_date, date_format)\n    end = datetime.strptime(end_date, date_format)\n    \n    day_count = (end - start).days\n    year_days = 0\n    \n    if convention == '30/360':\n        year_days = 360\n        month_diff = (end.year - start.year) * 12 + (end.month - start.month)\n        day_count = 30 * month_diff + (min(30, end.day) - min(30, start.day))\n    elif convention == '30/365':\n        year_days = 365\n        month_diff = (end.year - start.year) * 12 + (end.month - start.month)\n        day_count = 30 * month_diff + (min(30, end.day) - min(30, start.day))\n    elif convention == 'actual/360':\n        year_days = 360\n    elif convention == 'actual/365':\n        year_days = 365\n    elif convention == 'actual/actual':\n        year_days = 365 if (end.year % 4 == 0 and (end.year % 100 != 0 or end.year % 400 == 0)) else 366\n\n    accrued_interest = (nominal_rate * principal * day_count) / year_days\n    return accrued_interest",
            "def calculate_receivables_percentage(partial_receivables: float, total_receivables: float) -> float:\n    \"\"\"\n    Calculate the percentage of a specific age category of receivables in total receivables.\n\n    This function computes the percentage of receivables for a specified age category\n    within the total trade receivables. It is useful for financial analysis to understand\n    the composition of aging receivables.\n\n    Args:\n        partial_receivables (float): The amount of receivables for a specific age category.\n        total_receivables (float): The total amount of trade receivables.\n\n    Returns:\n        percentage (float): The percentage of the specific age category within the total trade receivables,\n                            rounded to two decimal places.\n\n    Notes:\n        - Applicability: The function is applicable to any breakdown of trade receivables by age category.\n        - Constraints: The total_receivables value must be greater than zero to avoid division by zero.\n        - Considerations: Ensure the values provided are for the same period and currency to maintain consistency.\n    \"\"\"\n    if total_receivables <= 0:\n        raise ValueError(\"Total receivables must be greater than zero.\")\n\n    percentage = (partial_receivables / total_receivables) * 100\n    return round(percentage, 2)",
            "def calculate_change_in_unrecognized_tax_benefits(start_balance: float, end_balance: float) -> int:\n    \"\"\"\n    Calculate the total change in unrecognized tax benefits over a period.\n\n    This function computes the change in unrecognized tax benefits between two \n    specified dates and returns the result rounded to the nearest integer. \n    It is typically used in financial analysis to assess changes in tax \n    liabilities or benefits.\n\n    Args:\n        start_balance (float): The balance of unrecognized tax benefits at the \n                               beginning of the period.\n        end_balance (float): The balance of unrecognized tax benefits at the \n                             end of the period.\n\n    Returns:\n        change_in_benefits (int): The total change in unrecognized tax benefits, \n                                  rounded to the nearest integer.\n\n    Notes:\n        - Applicability: This function is applicable for calculating changes in \n          unrecognized tax benefits over specified periods.\n        - Constraints: The start_balance and end_balance should be in the same units \n          (typically millions).\n        - Considerations: Ensure that the input values account for any interim \n          adjustments that could affect the calculation.\n    \"\"\"\n    change_in_benefits = round(end_balance - start_balance)\n    return change_in_benefits"
        ],
        "usage": {
            "completion_tokens": 601,
            "prompt_tokens": 1570,
            "total_tokens": 2171,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "Currently, Serene Vacation Corp has 1.2 million common shares of stock outstanding with a beta of 2.2. They also have $10 million face value of bonds with five years left to maturity and an 8% coupon with semiannual payments, priced to yield 13.65%. If Serene issues up to $2.5 million of new bonds, they will be priced at par and will have a yield of 13.65%; but if they issue bonds beyond $2.5 million, the entire issuance is expected to yield 16%. Serene has found out it can issue new common stock at $10 a share. The current risk-free interest rate is 3%, and the expected market return is 10%. Serene's marginal tax rate is 30%. If Serene secures $7.5 million of new funding while keeping the same debt-to-equity ratio, what will its weighted average cost of capital be (expressed as a percentage)? Answer to two decimal places.",
        "python_solution": "def solution():\n    FV = 10000000\n    PMT = 400000\n    N = 10\n    I_YR = 6.825/100\n    PV = FV / ((1 + I_YR)**N)\n    Equity = 1.2 * 1000000 * 10\n    to_be_raised = 7.5 * 1000000\n    bonds = to_be_raised * 0.4\n    rd = 0.16\n    t = 0.3\n    re = 0.03 + 2.2 * (0.10 - 0.03)\n    rdnt = rd * (1 - t)\n    WACC = 0.4 * rdnt + 0.6 * re\n    return round(WACC * 100, 2)",
        "ground_truth": 15.52,
        "topic": "Corporate & Securities Issuance",
        "statistics": {
            "number_statistics": {
                "args_numbers": 10,
                "question_numbers": 14,
                "context_numbers": 0,
                "total_numbers": 14
            },
            "operator_statistics": {
                "operators": {
                    "+": 3,
                    "-": 2,
                    "*": 9,
                    "/": 2,
                    "%": 0,
                    "**": 1
                },
                "total_operators": 17
            },
            "code_statistics": {
                "lines": 14,
                "parentheses": 10
            }
        },
        "difficulty": 5.777652323222656,
        "source": "FinanceMath-validation-103",
        "context": "[]",
        "question_id": "test-2219",
        "level": "hard",
        "output": [
            "To solve this question and calculate the Weighted Average Cost of Capital (WACC) for Serene Vacation Corp, we will begin by reasoning step-by-step with \"Emphasizing Constraints (EC)\":\n\n### Step-by-Step Analysis:\n1. **Understand Existing Debt-to-Equity Ratio Constraint**:\n   - Serene is maintaining the same **Debt-to-Equity Ratio (D/E Ratio)**. This is important since it directly impacts the amount of debt and equity in the new funding.\n\n2. **Determine the Debt and Equity Components of the $7.5 Million New Funding**:\n   - If we know the D/E ratio is to remain unchanged, we'll calculate the split between debt and equity from the initial capital structure.\n\n3. **Cost of New Debt**:\n   - Issuing new bonds comes with distinct cost structures:\n      - If new bonds up to $2.5 million are issued, these have a yield (cost of debt) of 13.65%.\n      - Beyond $2.5 million, the additional bonds are issued at a higher, risk-adjusted yield of 16%.\n   - In our calculations, we will account for this progressive increase in the cost of debt.\n\n4. **Cost of Equity**:\n   - Using the Capital Asset Pricing Model (CAPM), we calculate:\n     \\[\n     \\text{Cost of Equity} = \\text{Risk-Free Rate} + \\beta \\times (\\text{Market Return} - \\text{Risk-Free Rate})\n     \\]\n     Substituting the given data:\n     - Risk-free rate = 3%.\n     - Beta = 2.2.\n     - Expected market return = 10%.\n\n5. **Tax Impact on Debt**:\n   - The cost of debt is **reduced** by the tax shield since interest expenses are tax-deductible. Marginal tax rate is 30%.\n\n6. **Market Values for Debt and Equity**:\n   - The number of shares = 1.2 million.\n   - Price per share = $10.\n   - Total equity value is the product of shares and price.\n   - Debt value is given as $10 million initially and will grow with new funding.\n\n7. **Recalculate WACC**:\n   - Finally, compute WACC using the formula:\n     \\[\n     \\text{WACC} = \\frac{E}{V} \\times \\text{Re} + \\frac{D}{V} \\times \\text{Rd} \\times (1 - \\text{Tax Rate})\n     \\]\n     Where:\n     - \\( E \\) = equity value.\n     - \\( D \\) = debt value.\n     - \\( V \\) = total value (equity + debt).\n     - \\( \\text{Re} \\) = cost of equity.\n     - \\( \\text{Rd} \\) = cost of debt.\n\n### Python Program:\nNow, we will implement the above calculations in a Python function:\n\n```python\ndef solution():\n    # Given data\n    shares_outstanding = 1_200_000  # Number of shares\n    share_price = 10  # Price per share\n    initial_debt = 10_000_000  # Initial debt in dollars\n    rf_rate = 0.03  # Risk-free rate\n    market_return = 0.10  # Market return\n    beta = 2.2  # Company beta\n    marginal_tax_rate = 0.30  # Tax rate\n    bond_yield_low = 0.1365  # Yield on bonds up to $2.5M\n    bond_yield_high = 0.16  # Yield on bonds above $2.5M\n    new_funding = 7_500_000  # Total new funding\n    \n    # Step 1: Calculate initial Debt-to-Equity (D/E) Ratio\n    equity_value = shares_outstanding * share_price  # Market value of equity\n    d_e_ratio = initial_debt / equity_value  # Debt-to-Equity ratio\n    \n    # Step 2: Distribute new funding into debt and equity based on D/E ratio\n    # Total funding = debt_value + equity_value.\n    funding_debt = (d_e_ratio / (1 + d_e_ratio)) * new_funding\n    funding_equity = new_funding - funding_debt  # Remaining goes to equity\n    \n    # Step 3: Adjust new debt cost (progressive yield)\n    if funding_debt <= 2_500_000:  # Case where all debt is at 13.65%\n        cost_new_debt = bond_yield_low\n    else:\n        # Split into two components: $2.5M at 13.65% and the rest at 16%\n        cost_new_debt = ((2_500_000 * bond_yield_low) + \n                         ((funding_debt - 2_500_000) * bond_yield_high)) / funding_debt\n    \n    # Step 4: Calculate the new total debt and equity market values\n    total_debt = initial_debt + funding_debt\n    total_equity = equity_value + funding_equity\n    total_value = total_debt + total_equity  # Total market value\n    \n    # Step 5: Cost of Equity using CAPM\n    cost_of_equity = rf_rate + beta * (market_return - rf_rate)\n    \n    # Step 6: Post-tax cost of debt\n    after_tax_cost_of_debt = cost_new_debt * (1 - marginal_tax_rate)\n    \n    # Step 7: Calculate WACC\n    wacc = ((total_equity / total_value) * cost_of_equity) + \\\n           ((total_debt / total_value) * after_tax_cost_of_debt)\n    \n    # Return the WACC as a percentage, rounded to two decimal places\n    return round(wacc * 100, 2)\n\n```"
        ],
        "retrieval_query": "Currently, Serene Vacation Corp has 1.2 million common shares of stock outstanding with a beta of 2.2. They also have $10 million face value of bonds with five years left to maturity and an 8% coupon with semiannual payments, priced to yield 13.65%. If Serene issues up to $2.5 million of new bonds, they will be priced at par and will have a yield of 13.65%; but if they issue bonds beyond $2.5 million, the entire issuance is expected to yield 16%. Serene has found out it can issue new common stock at $10 a share. The current risk-free interest rate is 3%, and the expected market return is 10%. Serene's marginal tax rate is 30%. If Serene secures $7.5 million of new funding while keeping the same debt-to-equity ratio, what will its weighted average cost of capital be (expressed as a percentage)? Answer to two decimal places.",
        "useful_functions": [
            "def calculate_wacc(equity_value: float, equity_cost: float, debt_value: float, debt_cost: float, preferred_value: float = 0.0, preferred_cost: float = 0.0) -> float:\n    \"\"\"\n    Calculate the Weighted Average Cost of Capital (WACC).\n\n    This function calculates the WACC, which is the average rate of return a company must earn on its\n    investments to satisfy its stakeholders (equity, debt, and optionally preferred stock).\n\n    Args:\n        equity_value (float): The market value of the company's equity.\n        equity_cost (float): The cost of equity (expected return).\n        debt_value (float): The market value of the company's debt.\n        debt_cost (float): The cost of debt (interest rate).\n        preferred_value (float, optional): The market value of preferred stock. Defaults to 0.0.\n        preferred_cost (float, optional): The cost of preferred stock (dividend rate). Defaults to 0.0.\n\n    Returns:\n        wacc (float): The weighted average cost of capital.\n\n    Notes:\n        - Applicability: This function is applicable for companies looking to calculate their WACC as a benchmark\n          for investment evaluation.\n        - Constraints: Assumes all values provided are non-negative and that the sum of equity_value, debt_value,\n          and preferred_value is greater than zero.\n        - Considerations: The costs used should reflect market conditions and expectations; tax shields are not\n          considered in this basic version.\n    \"\"\"\n    total_value = equity_value + debt_value + preferred_value\n    if total_value == 0:\n        raise ValueError(\"The sum of equity, debt, and preferred stock values must be greater than zero.\")\n\n    weight_equity = equity_value / total_value\n    weight_debt = debt_value / total_value\n    weight_preferred = preferred_value / total_value\n\n    wacc = (weight_equity * equity_cost) + (weight_debt * debt_cost) + (weight_preferred * preferred_cost)\n    \n    return wacc"
        ],
        "usage": {
            "completion_tokens": 1234,
            "prompt_tokens": 969,
            "total_tokens": 2203,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-1233",
        "article_title": "Par Yield Curve",
        "function": "def calculate_zero_coupon_rate(par_value: float, coupon: float, market_price: float, periods: int) -> float:\n    \"\"\"\n    Calculate the zero-coupon rate for a bond.\n\n    This function computes the zero-coupon rate required to discount the bond's\n    future cash flows to match its current market price.\n\n    Args:\n        par_value (float): The face value (par value) of the bond.\n        coupon (float): The coupon payment amount.\n        market_price (float): The current market price of the bond.\n        periods (int): The number of periods until the bond matures.\n\n    Returns:\n        zero_coupon_rate (float): The zero-coupon rate.\n\n    Notes:\n        - Assumes bonds have semi-annual coupon payments; adjust calculations for other frequencies.\n        - This function is essential for constructing yield curves and evaluating the cost of financing.\n    \"\"\"\n    # Implementing the formula to match present value with market price\n    iteration_limit = 1000\n    tolerance = 1e-6\n    rate_low = 0.0\n    rate_high = 1.0\n\n    while iteration_limit > 0:\n        iteration_limit -= 1\n        guess_rate = (rate_low + rate_high) / 2\n        discount_factor = (1 + guess_rate / 2) ** periods\n        pv = coupon * (1 - 1 / discount_factor) / (guess_rate / 2) + par_value / discount_factor\n        if abs(pv - market_price) < tolerance:\n            return guess_rate\n        elif pv < market_price:\n            rate_high = guess_rate\n        else:\n            rate_low = guess_rate\n\n    # If no convergence, return the last calculated rate\n    return guess_rate",
        "statistics": {
            "number_statistics": {
                "args_numbers": 4,
                "question_numbers": 0,
                "context_numbers": 3,
                "total_numbers": 3
            },
            "operator_statistics": {
                "operators": {
                    "+": 3,
                    "-": 4,
                    "*": 1,
                    "/": 6,
                    "%": 0,
                    "**": 1
                },
                "total_operators": 15
            },
            "code_statistics": {
                "lines": 18,
                "parentheses": 10
            }
        },
        "difficulty": 5.84354441703136,
        "context": "An investment firm is evaluating a zero-coupon bond that matures in 5 years. The bond has a par value of $1,000 and is currently priced in the market at $850. The bond does not have any coupon payments, as it is a zero-coupon bond. The firm wants to determine the annual yield for this investment to ascertain its return rate.",
        "question": "What is the zero-coupon rate for this bond expressed as an annual percentage? Answer as a percentage to two decimal places.",
        "python_solution": "def solution():\n    # Given bond parameters\n    par_value = 1000.0\n    market_price = 850.0\n    periods = 5  # since it's a 5-year bond\n\n    # Define tolerance and iteration parameters for numerical methods\n    tolerance = 1e-6\n    rate_low = 0.0\n    rate_high = 1.0\n    iteration_limit = 1000\n    \n    # Use a binary search method similar to bisection to find the zero-coupon rate\n    while iteration_limit > 0:\n        iteration_limit -= 1\n        guess_rate = (rate_low + rate_high) / 2\n        discount_factor = (1 + guess_rate) ** periods\n        pv = par_value / discount_factor\n        if abs(pv - market_price) < tolerance:\n            return round(guess_rate * 100, 2)\n        elif pv < market_price:\n            rate_high = guess_rate\n        else:\n            rate_low = guess_rate\n\n    # If no convergence, return the last guess rounded\n    return round(guess_rate * 100, 2)\n\n# To execute and see the result of the function call:\n# print(solution())",
        "ground_truth": 3.3,
        "source": "FinanceReasoning-test-49",
        "question_id": "test-2220",
        "level": "hard",
        "output": [
            "### Step-by-Step Reasoning Using EC (Emphasizing Constraints)\n\n1. **Understand the Problem**:  \n   - This is a zero-coupon bond, so it does not pay periodic coupon payments. The return is determined solely by the price appreciation of the bond.\n   - The bond matures in 5 years, its par value is $1,000, and the current price is $850.\n   - We need to calculate the annual yield (zero-coupon rate), expressed as a percentage, rounded to two decimal places.\n\n2. **Key Formula and Variables**:  \n   - The zero-coupon rate (Yield to Maturity, YTM) is given by the formula:  \n     \\[\n     (1 + r)^N = \\frac{\\text{Par Value}}{\\text{Price}}\n     \\]  \n     Where \\(r\\) is the annual zero-coupon rate, \\(N\\) is the number of years until maturity, \\(\\text{Par Value}\\) is the bond's maturity value, and \\(\\text{Price}\\) is the current market price.\n\n   - Rearrange the formula to solve for \\(r\\):  \n     \\[\n     r = \\left(\\frac{\\text{Par Value}}{\\text{Price}}\\right)^{\\frac{1}{N}} - 1\n     \\]\n\n3. **Apply Given Data**:\n   - Par Value = $1,000  \n   - Price = $850  \n   - \\(N = 5\\) years  \n\n4. **Constraints**:\n   - The result should be expressed as a percentage (not in decimal form).\n   - The percentage should be rounded to two decimal places.\n\n5. **Execution Steps**:\n   - Compute \\(\\frac{\\text{Par Value}}{\\text{Price}}\\).\n   - Take the 5th root (\\(N\\)) of this ratio.\n   - Subtract 1 from the result to find the annual rate in decimal form.\n   - Multiply the decimal form by 100 to express as a percentage.\n   - Round the final answer to two decimal places.\n\nNow, let's implement this in Python.\n\n```python\ndef solution():\n    # Define variables name and value\n    par_value = 1000\n    price = 850\n    years_to_maturity = 5\n    \n    # Calculate the annual zero-coupon rate\n    zero_coupon_rate = ((par_value / price) ** (1 / years_to_maturity)) - 1\n    \n    # Convert to a percentage and round to two decimal places\n    annual_rate_percentage = round(zero_coupon_rate * 100, 2)\n    \n    # Return the result\n    return annual_rate_percentage\n```"
        ],
        "retrieval_query": "What is the zero-coupon rate for this bond expressed as an annual percentage? Answer as a percentage to two decimal places.",
        "useful_functions": [],
        "usage": {
            "completion_tokens": 557,
            "prompt_tokens": 425,
            "total_tokens": 982,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "Analyst Johnson is determining the RAROC of a commercial loan portfolio for Company P. He has gathered the following details: The primary borrowing is $1.3 billion. The predicted pre-tax profit from the loan portfolio is 7%. The estimated direct annual operation cost is around $6 million. The loan portfolio is backed by $1.3 billion of consumer deposits and the interest rate is at 5%. Johnson is also predicting that the expected yearly loss on the portfolio is 0.3% of the principal. On top of this, Johnson estimates the unexpected loss on the principal amount could be as high as 8%. Further, Johnson takes into consideration that the risk-free rate is 1.5% and the effective tax rate is 25%. Finally, Johnson presumes there will not be any transfer pricing issues. Based off the definition of RAROC, what would Johnson's prediction about RAROC be (expressed as a percentage)? Answer to three decimal places.",
        "python_solution": "def solution():\n    principal = 1300000000\n    predicted_pre_tax_profit_rate = 7/100\n    operation_cost = 6000000\n    interest_rate = 5/100\n    expected_loss_rate = 0.3/100\n    unexpected_loss_rate = 8/100\n    risk_free_rate = 1.5/100\n    tax_rate = 25/100\n    \n    unexpected_loss = principal * unexpected_loss_rate\n    economic_capital = unexpected_loss\n    return_on_economic_capital = economic_capital * risk_free_rate\n    \n    expected_revenue = principal * predicted_pre_tax_profit_rate\n    interest_expense = principal * interest_rate\n    expected_loss = principal * expected_loss_rate\n    \n    RAROC = ((expected_revenue - operation_cost - expected_loss - interest_expense + return_on_economic_capital ) * (1-tax_rate)) / economic_capital\n    \n    return RAROC * 100",
        "ground_truth": 12.736,
        "topic": "Risk Management",
        "statistics": {
            "number_statistics": {
                "args_numbers": 3,
                "question_numbers": 9,
                "context_numbers": 0,
                "total_numbers": 9
            },
            "operator_statistics": {
                "operators": {
                    "+": 1,
                    "-": 4,
                    "*": 7,
                    "/": 7,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 19
            },
            "code_statistics": {
                "lines": 16,
                "parentheses": 6
            }
        },
        "difficulty": 5.8888779583328805,
        "source": "FinanceMath-validation-132",
        "context": "[]",
        "question_id": "test-2221",
        "level": "hard",
        "output": [
            "To calculate the RAROC (Risk-Adjusted Return On Capital), we need to follow a few steps based on its formula:\n\n### Steps:\n1. **Definition of RAROC**:  \n   RAROC is defined as the risk-adjusted return divided by the economic capital. It is a measure to determine how efficiently an investment can generate risk-adjusted returns.\n\n   \\[\n   \\text{RAROC} = \\frac{\\text{Risk-Adjusted Return}}{\\text{Economic Capital}}\n   \\]\n\n2. **Risk-Adjusted Return computation**:  \n   - Start with the predicted pre-tax profit, which is obtained using the formula:\n     \\[\n     \\text{Pre-tax Profit} = (Principal \\times \\text{Pre-tax Profit Percentage}) - \\text{Direct Operating Costs} - \\text{Consumer Deposits Expense}\n     \\]\n   - Compute the Net Profit after tax using:\n     \\[\n     \\text{Net Profit After Tax} = \\text{Pre-tax Profit} \\times (1 - \\text{Tax Rate})\n     \\]\n\n3. **Economic Capital computation**:  \n   Use the Unexpected Loss (UL) amount for the economic capital:\n   \\[\n   \\text{Economic Capital} = Principal \\times \\text{Unexpected Loss Percentage}\n   \\]\n\n4. **Constraints**:  \n   Based on the question:\n   - Inputs: Principal = $1.3 \\, \\text{billion}$, Pre-tax profit = 7%, Operating costs = $6 \\, \\text{million}$, Deposits Interest Rate = 5%, Expected Loss = 0.3%, Unexpected Loss = 8%, Risk-free rate = 1.5%, Tax Rate = 25%.\n   - Outputs: RAROC as a percentage, rounded to three decimal places.\n\n5. **Formula Application**:  \n   Combine the steps and constraints to compute the RAROC.\n\nThe final computation involves applying these formulas systematically.\n\n---\n\n### Python program:\nHere is the Python program that implements the above steps:\n\n```python\ndef solution():\n    # Define variables\n    principal = 1.3e9  # $1.3 billion\n    pre_tax_profit_percentage = 0.07  # Predicted pre-tax profit (7%)\n    direct_operating_cost = 6e6  # $6 million\n    deposit_interest_rate = 0.05  # 5% interest rate on deposits\n    tax_rate = 0.25  # Effective tax rate (25%)\n    unexpected_loss_percentage = 0.08  # Unexpected loss (8%)\n    \n    # Step 1: Compute the pre-tax profit\n    consumer_deposit_expense = principal * deposit_interest_rate\n    pre_tax_profit = (principal * pre_tax_profit_percentage) - direct_operating_cost - consumer_deposit_expense\n    \n    # Step 2: Compute the net profit after tax\n    net_profit_after_tax = pre_tax_profit * (1 - tax_rate)\n    \n    # Step 3: Calculate economic capital\n    economic_capital = principal * unexpected_loss_percentage\n    \n    # Step 4: Calculate RAROC\n    raroc = (net_profit_after_tax / economic_capital) * 100  # Convert to percentage\n    \n    # Step 5: Return result rounded to three decimal places\n    return round(raroc, 3)\n```\n\nThis program adheres explicitly to the constraints and calculates RAROC based on the given information. The result is rounded to three decimal places as required by the problem."
        ],
        "retrieval_query": "Analyst Johnson is determining the RAROC of a commercial loan portfolio for Company P. He has gathered the following details: The primary borrowing is $1.3 billion. The predicted pre-tax profit from the loan portfolio is 7%. The estimated direct annual operation cost is around $6 million. The loan portfolio is backed by $1.3 billion of consumer deposits and the interest rate is at 5%. Johnson is also predicting that the expected yearly loss on the portfolio is 0.3% of the principal. On top of this, Johnson estimates the unexpected loss on the principal amount could be as high as 8%. Further, Johnson takes into consideration that the risk-free rate is 1.5% and the effective tax rate is 25%. Finally, Johnson presumes there will not be any transfer pricing issues. Based off the definition of RAROC, what would Johnson's prediction about RAROC be (expressed as a percentage)? Answer to three decimal places.",
        "useful_functions": [],
        "usage": {
            "completion_tokens": 731,
            "prompt_tokens": 525,
            "total_tokens": 1256,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-952",
        "article_title": "Money-Weighted Rate of Return",
        "function": "def calculate_money_weighted_rate_of_return(cash_flows: list, initial_investment: float, guess_rate: float = 0.1, tolerance: float = 1e-6, max_iterations: int = 1000) -> float:\n    \"\"\"\n    Calculate the money-weighted rate of return (MWRR) for a series of cash flows.\n\n    This function computes the MWRR, equivalent to the internal rate of return (IRR),\n    for a series of cash flows using a numerical method. The MWRR accounts for the\n    size and timing of deposits or withdrawals during the investment period.\n\n    Args:\n        cash_flows (list): A list of cash flows (positive for inflow, negative for outflow).\n                           The order represents the time sequence of cash flows.\n        initial_investment (float): The initial cash outlay or investment amount (negative value).\n        guess_rate (float): An initial guess for the rate of return, default is 0.1 (10%).\n        tolerance (float): The precision tolerance for the calculation, default is 1e-6.\n        max_iterations (int): The maximum number of iterations for convergence, default is 1000.\n\n    Returns:\n        mwrr (float): The money-weighted rate of return as a decimal (e.g., 0.1173 for 11.73%).\n\n    Notes:\n        - This function uses the Newton-Raphson method to solve for the MWRR.\n        - The cash_flows list should include all cash movements related to the investment,\n          starting from the initial investment.\n        - Ensure all cash flows are ordered chronologically.\n        - The initial investment should not be included in the cash_flows list; it is a separate parameter.\n        - Convergence depends on the initial guess and provided tolerance.\n        - If the function does not converge within the specified iterations, it throws a ValueError.\n    \"\"\"\n    def npv(rate):\n        return initial_investment + sum(cf / ((1 + rate) ** (i + 1)) for i, cf in enumerate(cash_flows))\n    \n    def npv_derivative(rate):\n        return sum(-i * cf / ((1 + rate) ** (i + 1)) for i, cf in enumerate(cash_flows, start=1))\n    \n    rate = guess_rate\n    for _ in range(max_iterations):\n        current_npv = npv(rate)\n        derivative = npv_derivative(rate)\n        if abs(current_npv) < tolerance:\n            return rate\n        rate -= current_npv / derivative\n\n    raise ValueError(\"The calculation did not converge; try different parameters or increase max_iterations.\")",
        "statistics": {
            "number_statistics": {
                "args_numbers": 5,
                "question_numbers": 0,
                "context_numbers": 10,
                "total_numbers": 10
            },
            "operator_statistics": {
                "operators": {
                    "+": 5,
                    "-": 2,
                    "*": 1,
                    "/": 3,
                    "%": 0,
                    "**": 2
                },
                "total_operators": 13
            },
            "code_statistics": {
                "lines": 12,
                "parentheses": 32
            }
        },
        "difficulty": 5.8971538676367405,
        "context": "A small business invested an initial amount of $100,000 in a project. Over the next four years, the project generated cash flows as follows: Year 1: $20,000, Year 2: $30,000, Year 3: $50,000, Year 4: $60,000. The business owner wants to determine the money-weighted rate of return (MWRR) for their investment over this period to evaluate its performance. They are using an initial guess rate of 10% for the calculation.",
        "question": "What is the money-weighted rate of return (MWRR) for the project's cash flows? Provide the answer as a percentage to two decimal places.",
        "python_solution": "def solution():\n    # Define the initial investment and the series of cash flows\n    initial_investment = -100000  # Outflow, hence negative\n    cash_flows = [20000, 30000, 50000, 60000]\n    \n    # Initialize parameters for the Newton-Raphson method\n    guess_rate = 0.1  # Initial guess rate (10%)\n    tolerance = 1e-6\n    max_iterations = 1000\n    \n    # Define functions for NPV and its derivative\n    def npv(rate):\n        return initial_investment + sum(cf / ((1 + rate) ** (i + 1)) for i, cf in enumerate(cash_flows))\n    \n    def npv_derivative(rate):\n        return sum(-i * cf / ((1 + rate) ** (i + 1)) for i, cf in enumerate(cash_flows, start=1))\n    \n    # Implement the Newton-Raphson method\n    rate = guess_rate\n    for _ in range(max_iterations):\n        current_npv = npv(rate)\n        derivative = npv_derivative(rate)\n        if abs(current_npv) < tolerance:\n            return round(rate * 100, 2)  # Convert rate to percentage\n        \n        rate -= current_npv / derivative\n    \n    raise ValueError(\"The calculation did not converge; try different parameters or increase max_iterations.\")\n\n# Call the solution function to find the MWRR\nsolution()",
        "ground_truth": 17.95,
        "source": "FinanceReasoning-test-24",
        "question_id": "test-2222",
        "level": "hard",
        "output": [
            "To determine the Money-Weighted Rate of Return (MWRR), we will be using the provided function `calculate_money_weighted_rate_of_return`. Let's break this problem step by step:\n\n### Step 1: Understand Constraints\n- We are tasked with calculating the MWRR, which involves evaluating the return considering the size and timing of cash flows.\n- The cash flows are given: Year 1: $20,000, Year 2: $30,000, Year 3: $50,000, Year 4: $60,000.\n- The initial investment is $100,000 (negative outlay).\n- The solution needs to be returned as a percentage with precision up to two decimal places.\n- We must ensure the constraint of tolerances (`1e-6`) and maximum iterations (`1000`) for numerical accuracy during the calculation.\n\n### Step 2: Cash Flow Preparation\n- The cash flows for the project\u2014including outflows and inflows\u2014need to be considered chronologically.\n- The initial cash outflow is treated separately and input explicitly via `initial_investment`.\n- The subsequent inflows are provided as `cash_flows`.\n\n### Step 3: MWRR Calculation with Newton-Raphson Method\nThe function works by iterating to minimize the Net Present Value (NPV) at a given rate (`rate`). It updates the rate using:\n\\[ \\text{rate}_\\text{new} = \\text{rate}_\\text{old} - \\frac{\\text{NPV(rate)}}{\\text{NPV Derivative(rate)}} \\]\n- The Newton-Raphson iterations continue until the calculated NPV is within the `tolerance` (1e-6).\n\n### Step 4: Formatting the Output\n- Once the MWRR is calculated in decimal form, it must be converted to a percentage and rounded to two decimal places.\n\nHere's the Python program:\n\n```python\ndef solution():\n    def calculate_money_weighted_rate_of_return(cash_flows, initial_investment, guess_rate=0.1, tolerance=1e-6, max_iterations=1000):\n        # Define the Net Present Value function\n        def npv(rate):\n            return initial_investment + sum(cf / ((1 + rate) ** (i + 1)) for i, cf in enumerate(cash_flows))\n        \n        # Define the derivative of the NPV function\n        def npv_derivative(rate):\n            return sum(-i * cf / ((1 + rate) ** (i + 1)) for i, cf in enumerate(cash_flows, start=1))\n        \n        # Iterative approach using Newton-Raphson Method\n        rate = guess_rate\n        for _ in range(max_iterations):\n            current_npv = npv(rate)\n            derivative = npv_derivative(rate)\n            if abs(current_npv) < tolerance:\n                return rate\n            rate -= current_npv / derivative\n        \n        # If convergence fails\n        raise ValueError(\"The calculation did not converge; try different parameters or increase max_iterations.\")\n\n    # Define variables\n    initial_investment = -100000  # Initial investment outflow as negative\n    cash_flows = [20000, 30000, 50000, 60000]  # Chronological cash inflows\n    \n    # Calculate MWRR using the provided function\n    mwrr_decimal = calculate_money_weighted_rate_of_return(cash_flows, initial_investment)\n    \n    # Convert MWRR to percentage and round to two decimal places\n    answer = round(mwrr_decimal * 100, 2)\n    \n    # Return the answer\n    return answer\n``` \n\nThis function will evaluate the MWRR based on the provided project cash flows and initial investment, and return the MWRR as a percentage rounded to two decimal places."
        ],
        "retrieval_query": "What is the money-weighted rate of return (MWRR) for the project's cash flows? Provide the answer as a percentage to two decimal places.",
        "useful_functions": [
            "def calculate_money_weighted_rate_of_return(cash_flows: list, initial_investment: float, guess_rate: float = 0.1, tolerance: float = 1e-6, max_iterations: int = 1000) -> float:\n    \"\"\"\n    Calculate the money-weighted rate of return (MWRR) for a series of cash flows.\n\n    This function computes the MWRR, equivalent to the internal rate of return (IRR),\n    for a series of cash flows using a numerical method. The MWRR accounts for the\n    size and timing of deposits or withdrawals during the investment period.\n\n    Args:\n        cash_flows (list): A list of cash flows (positive for inflow, negative for outflow).\n                           The order represents the time sequence of cash flows.\n        initial_investment (float): The initial cash outlay or investment amount (negative value).\n        guess_rate (float): An initial guess for the rate of return, default is 0.1 (10%).\n        tolerance (float): The precision tolerance for the calculation, default is 1e-6.\n        max_iterations (int): The maximum number of iterations for convergence, default is 1000.\n\n    Returns:\n        mwrr (float): The money-weighted rate of return as a decimal (e.g., 0.1173 for 11.73%).\n\n    Notes:\n        - This function uses the Newton-Raphson method to solve for the MWRR.\n        - The cash_flows list should include all cash movements related to the investment,\n          starting from the initial investment.\n        - Ensure all cash flows are ordered chronologically.\n        - The initial investment should not be included in the cash_flows list; it is a separate parameter.\n        - Convergence depends on the initial guess and provided tolerance.\n        - If the function does not converge within the specified iterations, it throws a ValueError.\n    \"\"\"\n    def npv(rate):\n        return initial_investment + sum(cf / ((1 + rate) ** (i + 1)) for i, cf in enumerate(cash_flows))\n    \n    def npv_derivative(rate):\n        return sum(-i * cf / ((1 + rate) ** (i + 1)) for i, cf in enumerate(cash_flows, start=1))\n    \n    rate = guess_rate\n    for _ in range(max_iterations):\n        current_npv = npv(rate)\n        derivative = npv_derivative(rate)\n        if abs(current_npv) < tolerance:\n            return rate\n        rate -= current_npv / derivative\n\n    raise ValueError(\"The calculation did not converge; try different parameters or increase max_iterations.\")"
        ],
        "usage": {
            "completion_tokens": 795,
            "prompt_tokens": 1030,
            "total_tokens": 1825,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-957",
        "article_title": "Mortgage Rate Lock Float Down",
        "function": "def calculate_savings_from_float_down(original_rate: float, new_rate: float, loan_amount: float, loan_term_years: int, float_down_fee_percent: float) -> float:\n    \"\"\"\n    Calculate the potential savings from exercising a mortgage rate lock float down option.\n\n    This function computes the savings a borrower could realize by opting for the \n    float down in the mortgage rate during the underwriting process, considering \n    the fee paid for the option.\n\n    Args:\n        original_rate (float): The initially locked interest rate (e.g., 4.25% as 0.0425).\n        new_rate (float): The new, lower interest rate available during float down (e.g., 3.80% as 0.0380).\n        loan_amount (float): The total loan amount in currency units.\n        loan_term_years (int): The term of the loan in years (e.g., 30 for a 30-year mortgage).\n        float_down_fee_percent (float): The cost of the float down option as a percentage (e.g., 0.5 for 0.5%).\n\n    Returns:\n        savings (float): The total savings from the reduced mortgage rate over the loan term, \n                         minus the cost of the float down option.\n\n    Notes:\n        - Applicability: This function is applicable for fixed-rate mortgages with a float down \n          option during the lock-in period.\n        - Constraints: Assumes constant principal and interest payment throughout the loan term.\n        - Considerations: Ensure that savings exceed the float down fee to make the float down \n          financially worthwhile.\n    \"\"\"\n    import math\n\n    # Calculate monthly payments for original and new rates\n    def monthly_payment(rate, n_periods, principal):\n        return principal * rate / (1 - (1 + rate) ** -n_periods)\n\n    # Convert annual rates to monthly rates\n    original_monthly_rate = original_rate / 12\n    new_monthly_rate = new_rate / 12\n\n    # Total number of payments\n    total_payments = loan_term_years * 12\n\n    # Calculate monthly payments\n    original_payment = monthly_payment(original_monthly_rate, total_payments, loan_amount)\n    new_payment = monthly_payment(new_monthly_rate, total_payments, loan_amount)\n\n    # Calculate savings in monthly payments over the loan term\n    total_payment_savings = (original_payment - new_payment) * total_payments\n\n    # Calculate the cost of the float down option as a flat fee\n    float_down_cost = loan_amount * (float_down_fee_percent / 100)\n\n    # Calculate net savings\n    savings = total_payment_savings - float_down_cost\n\n    return savings",
        "statistics": {
            "number_statistics": {
                "args_numbers": 5,
                "question_numbers": 0,
                "context_numbers": 5,
                "total_numbers": 5
            },
            "operator_statistics": {
                "operators": {
                    "+": 1,
                    "-": 4,
                    "*": 4,
                    "/": 4,
                    "%": 0,
                    "**": 1
                },
                "total_operators": 14
            },
            "code_statistics": {
                "lines": 19,
                "parentheses": 14
            }
        },
        "difficulty": 5.8971538676367405,
        "context": "John is considering a mortgage of $300,000 for a 30-year term and secured an interest rate lock at 4.5%. A new opportunity allows him to exercise a float down option to capitalize on a lower interest rate of 4.0%. This option incurs a flat fee of 0.4% of the loan amount. John is keen to determine if the float down will result in significant savings over the life of the loan after considering the cost of the fee.",
        "question": "What is the total potential savings for John if he exercises the float down option and reduces his mortgage interest rate? Answer to the nearest dollar.",
        "python_solution": "def solution():\n    import math\n    \n    # Define the given values\n    original_rate = 0.045\n    new_rate = 0.040\n    loan_amount = 300000\n    loan_term_years = 30\n    float_down_fee_percent = 0.4\n\n    # Function to calculate monthly payment\n    def monthly_payment(rate, n_periods, principal):\n        return principal * rate / (1 - (1 + rate) ** -n_periods)\n\n    # Convert annual rates to monthly rates\n    original_monthly_rate = original_rate / 12\n    new_monthly_rate = new_rate / 12\n\n    # Total number of payments\n    total_payments = loan_term_years * 12\n\n    # Calculate monthly payments for original and new rates\n    original_payment = monthly_payment(original_monthly_rate, total_payments, loan_amount)\n    new_payment = monthly_payment(new_monthly_rate, total_payments, loan_amount)\n\n    # Calculate savings from reduced monthly payments over the loan term\n    total_payment_savings = (original_payment - new_payment) * total_payments\n\n    # Calculate the float down cost\n    float_down_cost = loan_amount * (float_down_fee_percent / 100)\n\n    # Calculate net savings\n    savings = total_payment_savings - float_down_cost\n\n    # Return the total potential savings, rounded to the nearest dollar\n    return round(savings)",
        "ground_truth": 30412,
        "source": "FinanceReasoning-test-32",
        "question_id": "test-2223",
        "level": "hard",
        "output": [
            "### Step-by-Step Solution with Emphasizing Constraints (EC):\n\n1. **Constraints**:\n   - Loan amount is $300,000.\n   - Loan term is 30 years (360 months).\n   - Original interest rate is 4.5% (0.045 in decimal form).\n   - New interest rate with float down is 4.0% (0.04 in decimal form).\n   - Fee for float down option is 0.4% of the loan amount (0.004 in decimal form).\n   - Answer must be calculated to the nearest dollar.\n\n2. **Function objective**:\n   - Calculate the monthly payment using the formula for fixed-rate mortgages:\n     \\[\n     M = \\frac{P \\cdot r}{1 - (1 + r)^{-n}}\n     \\]\n     where:\n     - \\( M \\) is the monthly payment,\n     - \\( P \\) is the loan amount (principal),\n     - \\( r \\) is the monthly interest rate (\\(\\text{annual rate} \\div 12\\)),\n     - \\( n \\) is the total number of payments (\\(\\text{loan term (years)} \\times 12\\)).\n\n   - Calculate the savings in monthly payment over the term of the loan by finding the difference between the old and new payments and multiplying by the total payments.\n   - Deduct the float down fee (\\(0.4\\%\\) of loan amount) from the total payment savings to determine the net savings.\n\n3. **Numerical Simplifications**:\n   - Convert all annual rates to monthly rates by dividing by 12.\n   - Calculate the total savings to the nearest dollar.\n\n4. **Final Output**:\n   - Return the total net savings after applying the float down option.\n\nNow, here's the Python program implementing the solution:\n\n```python\ndef solution():\n    # Define variables name and value\n    loan_amount = 300000\n    loan_term_years = 30\n    original_rate = 0.045  # 4.5% annual rate as a decimal\n    new_rate = 0.04       # 4.0% annual rate as a decimal\n    float_down_fee_percent = 0.4  # 0.4% of loan amount as a percentage\n    \n    # Helper function to calculate monthly payment\n    def monthly_payment(rate, n_periods, principal):\n        return principal * rate / (1 - (1 + rate) ** -n_periods)\n    \n    # Convert annual rates to monthly rates\n    original_monthly_rate = original_rate / 12\n    new_monthly_rate = new_rate / 12\n    \n    # Calculate the total number of payments (months)\n    total_payments = loan_term_years * 12\n    \n    # Calculate monthly payments for original and new rates\n    original_payment = monthly_payment(original_monthly_rate, total_payments, loan_amount)\n    new_payment = monthly_payment(new_monthly_rate, total_payments, loan_amount)\n    \n    # Calculate savings from reduced monthly payments over the loan term\n    total_payment_savings = (original_payment - new_payment) * total_payments\n    \n    # Calculate the cost of the float down option\n    float_down_cost = loan_amount * (float_down_fee_percent / 100)\n    \n    # Calculate total net savings\n    net_savings = total_payment_savings - float_down_cost\n    \n    # Return the result rounded to the nearest dollar\n    return round(net_savings)\n```"
        ],
        "retrieval_query": "What is the total potential savings for John if he exercises the float down option and reduces his mortgage interest rate? Answer to the nearest dollar.",
        "useful_functions": [
            "def calculate_savings_from_float_down(original_rate: float, new_rate: float, loan_amount: float, loan_term_years: int, float_down_fee_percent: float) -> float:\n    \"\"\"\n    Calculate the potential savings from exercising a mortgage rate lock float down option.\n\n    This function computes the savings a borrower could realize by opting for the \n    float down in the mortgage rate during the underwriting process, considering \n    the fee paid for the option.\n\n    Args:\n        original_rate (float): The initially locked interest rate (e.g., 4.25% as 0.0425).\n        new_rate (float): The new, lower interest rate available during float down (e.g., 3.80% as 0.0380).\n        loan_amount (float): The total loan amount in currency units.\n        loan_term_years (int): The term of the loan in years (e.g., 30 for a 30-year mortgage).\n        float_down_fee_percent (float): The cost of the float down option as a percentage (e.g., 0.5 for 0.5%).\n\n    Returns:\n        savings (float): The total savings from the reduced mortgage rate over the loan term, \n                         minus the cost of the float down option.\n\n    Notes:\n        - Applicability: This function is applicable for fixed-rate mortgages with a float down \n          option during the lock-in period.\n        - Constraints: Assumes constant principal and interest payment throughout the loan term.\n        - Considerations: Ensure that savings exceed the float down fee to make the float down \n          financially worthwhile.\n    \"\"\"\n    import math\n\n    # Calculate monthly payments for original and new rates\n    def monthly_payment(rate, n_periods, principal):\n        return principal * rate / (1 - (1 + rate) ** -n_periods)\n\n    # Convert annual rates to monthly rates\n    original_monthly_rate = original_rate / 12\n    new_monthly_rate = new_rate / 12\n\n    # Total number of payments\n    total_payments = loan_term_years * 12\n\n    # Calculate monthly payments\n    original_payment = monthly_payment(original_monthly_rate, total_payments, loan_amount)\n    new_payment = monthly_payment(new_monthly_rate, total_payments, loan_amount)\n\n    # Calculate savings in monthly payments over the loan term\n    total_payment_savings = (original_payment - new_payment) * total_payments\n\n    # Calculate the cost of the float down option as a flat fee\n    float_down_cost = loan_amount * (float_down_fee_percent / 100)\n\n    # Calculate net savings\n    savings = total_payment_savings - float_down_cost\n\n    return savings"
        ],
        "usage": {
            "completion_tokens": 719,
            "prompt_tokens": 1018,
            "total_tokens": 1737,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-641",
        "article_title": "Fully Amortizing Payment",
        "function": "def calculate_amortization_schedule(principal: float, annual_interest_rate: float, years: int) -> list:\n    \"\"\"\n    Calculate the amortization schedule for a fully amortizing loan.\n\n    This function generates the amortization schedule for a given loan amount,\n    interest rate, and term in years. It provides the monthly payment amount,\n    breakdown of principal and interest for each payment, and remaining balance.\n\n    Args:\n        principal (float): The initial loan amount.\n        annual_interest_rate (float): The annual interest rate as a percentage (e.g., 4.5 for 4.5%).\n        years (int): The term of the loan in years.\n\n    Returns:\n        schedule (list): A list of dictionaries, each representing a monthly payment with keys:\n            - 'month': Month number (int).\n            - 'payment': Total payment for the month (float).\n            - 'principal': Part of the payment applied to the principal (float).\n            - 'interest': Part of the payment applied to interest (float).\n            - 'remaining_balance': Remaining balance of the loan after the payment (float).\n\n    Notes:\n        - Applicability: This function is suitable for fixed-rate loans with fully amortizing payments.\n        - Constraints: The interest rate should be non-negative, and the term should be a positive integer.\n        - Considerations: Monthly payments are rounded to two decimal places for precision in financial calculations.\n    \"\"\"\n    monthly_interest_rate = annual_interest_rate / 100 / 12\n    num_payments = years * 12\n\n    # Calculate monthly payment\n    monthly_payment = (principal * monthly_interest_rate) / (1 - (1 + monthly_interest_rate) ** -num_payments)\n    schedule = []\n    remaining_balance = principal\n\n    for month in range(1, num_payments + 1):\n        interest_payment = remaining_balance * monthly_interest_rate\n        principal_payment = monthly_payment - interest_payment\n        remaining_balance -= principal_payment\n\n        schedule.append({\n            'month': month,\n            'payment': round(monthly_payment, 2),\n            'principal': round(principal_payment, 2),\n            'interest': round(interest_payment, 2),\n            'remaining_balance': round(remaining_balance, 2)\n        })\n\n        if remaining_balance < 0:\n            remaining_balance = 0\n\n    return schedule",
        "statistics": {
            "number_statistics": {
                "args_numbers": 3,
                "question_numbers": 1,
                "context_numbers": 4,
                "total_numbers": 5
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 4,
                    "*": 3,
                    "/": 3,
                    "%": 0,
                    "**": 1
                },
                "total_operators": 13
            },
            "code_statistics": {
                "lines": 20,
                "parentheses": 18
            }
        },
        "difficulty": 5.932245187448011,
        "context": "John is planning to buy a house and has secured a fixed-rate mortgage of $250,000. The loan has an annual interest rate of 3.75% and a term of 30 years. John wants to fully understand how much of each monthly payment will go towards the principal and how much will go towards interest in the first year. He is particularly interested in knowing the total amount applied to the principal over the first 12 months.",
        "question": "What is the total amount of money that John will pay towards the principal in the first 12 months of his mortgage? Answer to the nearest dollar.",
        "python_solution": "def solution():\n    # Define the loan parameters\n    principal = 250000\n    annual_interest_rate = 3.75\n    years = 30\n\n    # Convert annual interest rate to monthly and calculate number of payments\n    monthly_interest_rate = annual_interest_rate / 100 / 12\n    num_payments = years * 12\n\n    # Calculate monthly payment using the amortization formula\n    monthly_payment = (principal * monthly_interest_rate) / (1 - (1 + monthly_interest_rate) ** -num_payments)\n\n    # Initialize remaining balance and total principal paid in the first year\n    remaining_balance = principal\n    total_principal_first_year = 0\n\n    # Calculate the amortization schedule for the first 12 months\n    for month in range(1, 13):\n        interest_payment = remaining_balance * monthly_interest_rate\n        principal_payment = monthly_payment - interest_payment\n        remaining_balance -= principal_payment\n\n        # Accumulate the principal payments for the first year\n        total_principal_first_year += principal_payment\n\n    # Return the total principal paid in the first year, rounded to the nearest dollar\n    return round(total_principal_first_year)",
        "ground_truth": 4597,
        "source": "FinanceReasoning-test-41",
        "question_id": "test-2224",
        "level": "hard",
        "output": [
            "To calculate the total amount of money John will pay towards the principal in the first 12 months, let's break this problem into smaller steps:\n\n### Steps and Reasoning:\n1. **Understand the Fixed Rate and Monthly Payment**:\n   - John's mortgage has an annual interest rate of 3.75% and a loan term of 30 years. \n   - To compute the monthly payment, we use the formula for mortgage payment:\n     \\[\n     M = P \\cdot \\frac{r \\cdot (1 + r)^n}{(1 + r)^n - 1}\n     \\]\n     where:\n     - \\(M\\) = monthly payment.\n     - \\(P = 250,000\\) (loan amount).\n     - Annual interest rate is 3.75%, so monthly interest rate \\(r = \\frac{3.75}{100} \\div 12 = 0.003125\\).\n     - \\(n = 30 \\cdot 12 = 360\\) (number of monthly payments).\n     \n2. **Break Down Each Payment into Interest and Principal**:\n   - For each month, calculate the interest owed based on the remaining principal:\n     \\[\n     \\text{Interest} = \\text{Remaining Principal} \\cdot r\n     \\]\n   - The portion of the payment applied to the principal is then:\n     \\[\n     \\text{Principal Payment} = M - \\text{Interest}\n     \\]\n   - Then, update the remaining principal:\n     \\[\n     \\text{Remaining Principal (next month)} = \\text{Remaining Principal (current month)} - \\text{Principal Payment}\n     \\]\n\n3. **Calculate the Total Principal Paid in the First Year**:\n   - Iterate through the first 12 months:\n     - Compute the interest and principal payments.\n     - Keep a running total of the principal payments over the 12 months.\n\n4. **Constraints (EC)**:\n   - Ensure computations respect decimal precision and round monetary values to nearest dollar when summing up total values.\n   - Return the total principal paid as an integer.\n\nNow, let's implement the solution programmatically:\n\n```python\ndef solution():\n    # Define variables\n    loan_amount = 250000  # principal\n    annual_interest_rate = 3.75  # in percentage\n    loan_term_years = 30  # duration in years\n    monthly_interest_rate = (annual_interest_rate / 100) / 12\n    total_months = loan_term_years * 12\n    \n    # Calculate monthly payment using the formula\n    M = loan_amount * (monthly_interest_rate * (1 + monthly_interest_rate) ** total_months) / \\\n        ((1 + monthly_interest_rate) ** total_months - 1)\n    \n    # Initialize variables for the calculation of total principal in the first year\n    remaining_principal = loan_amount\n    total_principal_paid = 0\n    \n    # Iterate over the first 12 months\n    for _ in range(12):\n        interest_payment = remaining_principal * monthly_interest_rate\n        principal_payment = M - interest_payment\n        total_principal_paid += principal_payment\n        remaining_principal -= principal_payment\n    \n    # Round to the nearest dollar\n    return round(total_principal_paid)\n```"
        ],
        "retrieval_query": "What is the total amount of money that John will pay towards the principal in the first 12 months of his mortgage? Answer to the nearest dollar.",
        "useful_functions": [
            "def calculate_investor_net_return(aum_end_of_year: float, high_water_mark: float, \n                                  management_fee_rate: float, previous_assets_value: float, \n                                  incentive_fee_rate: float, hurdle_rate: float) -> float:\n    \"\"\"\n    Calculate the net return for an investor under a \"2 and 20\" fee arrangement.\n\n    This function determines the net return for an investor, given the end-of-year\n    assets under management (AUM), a high-water mark, management and incentive fee rates, \n    a hurdle rate, and the initial value of assets. It accounts for management fees and \n    calculates incentive fees only if the AUM surpasses the high-water mark adjusted by the hurdle rate.\n\n    Args:\n        aum_end_of_year (float): The assets under management at the end of the year.\n        high_water_mark (float): The benchmark value of assets before fees can be collected.\n        management_fee_rate (float): The rate applied to AUM for management fees.\n        previous_assets_value (float): The value of assets at the start of the year.\n        incentive_fee_rate (float): The rate applied to returns above the high-water mark.\n        hurdle_rate (float): The minimum rate of return required before incentive fees apply.\n\n    Returns:\n        net_return_percentage (float): The net return for the investor, expressed as a percentage.\n\n    Notes:\n        - Applicability: Suitable for investment firms using \"2 and 20\" fee structures.\n        - Constraints: Assumes positive values for all inputs.\n        - Considerations: Always round the final result to three decimal places for percentage representation.\n    \"\"\"\n    management_fee = aum_end_of_year * management_fee_rate\n    \n    if aum_end_of_year < high_water_mark * (1 + hurdle_rate):\n        total_fee = management_fee\n    else:\n        total_fee = management_fee + (aum_end_of_year - high_water_mark * (1 + hurdle_rate)) * incentive_fee_rate\n\n    net_return = (aum_end_of_year - total_fee) / previous_assets_value - 1\n\n    return round(net_return * 100, 3)"
        ],
        "usage": {
            "completion_tokens": 680,
            "prompt_tokens": 894,
            "total_tokens": 1574,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-1994",
        "article_title": "Ultimate Oscillator",
        "function": "def calculate_ultimate_oscillator(close_prices: list, low_prices: list, high_prices: list, prior_close_prices: list) -> float:\n    \"\"\"\n    Calculate the Ultimate Oscillator for a series of price data.\n\n    The Ultimate Oscillator is a technical indicator that measures the price momentum of\n    an asset over three different timeframes (7, 14, and 28 periods).\n\n    Args:\n        close_prices (list): A list of closing prices for the periods considered.\n        low_prices (list): A list of low prices for the periods considered.\n        high_prices (list): A list of high prices for the periods considered.\n        prior_close_prices (list): A list of prior closing prices for the periods.\n\n    Returns:\n        ultimate_oscillator (float): The value of the Ultimate Oscillator, scaled between 0 and 100.\n\n    Notes:\n        - The function assumes that the input lists are of the same length.\n        - It's important that the lengths of these lists are at least 28 periods to calculate\n          the longest average.\n        - The indicator provides insight into potential buy or sell signals through divergences\n          with price.\n          \n    \"\"\"\n    def calculate_bp_and_tr(close, low, high, prior_close):\n        bp = close - min(low, prior_close)\n        tr = max(high, prior_close) - min(low, prior_close)\n        return bp, tr\n\n    bp_values, tr_values = zip(*[calculate_bp_and_tr(c, l, h, pc) for c, l, h, pc in zip(close_prices, low_prices, high_prices, prior_close_prices)])\n\n    def calculate_average(bp_values, tr_values, period):\n        bp_sum = sum(bp_values[-period:])\n        tr_sum = sum(tr_values[-period:])\n        return bp_sum / tr_sum if tr_sum != 0 else 0\n\n    average_7 = calculate_average(bp_values, tr_values, 7)\n    average_14 = calculate_average(bp_values, tr_values, 14)\n    average_28 = calculate_average(bp_values, tr_values, 28)\n\n    ultimate_oscillator = ((average_7 * 4 + average_14 * 2 + average_28) / (4 + 2 + 1)) * 100\n\n    return ultimate_oscillator",
        "statistics": {
            "number_statistics": {
                "args_numbers": 4,
                "question_numbers": 0,
                "context_numbers": 116,
                "total_numbers": 116
            },
            "operator_statistics": {
                "operators": {
                    "+": 4,
                    "-": 4,
                    "*": 4,
                    "/": 2,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 14
            },
            "code_statistics": {
                "lines": 14,
                "parentheses": 32
            }
        },
        "difficulty": 6.040254711277414,
        "context": "An asset manager is analyzing the price momentum of a stock using the Ultimate Oscillator over three timeframes of 7, 14, and 28 periods. The closing prices for the last 28 trading days are as follows: [145, 148, 150, 149, 151, 153, 154, 155, 156, 158, 159, 160, 162, 161, 163, 165, 166, 167, 168, 170, 171, 172, 173, 175, 176, 177, 178, 180]. The low prices are [140, 145, 148, 147, 149, 150, 152, 153, 154, 155, 156, 157, 159, 158, 160, 162, 163, 164, 165, 167, 168, 169, 170, 172, 173, 174, 175, 177] and the high prices are [150, 151, 153, 155, 156, 158, 159, 160, 161, 162, 163, 164, 165, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 179, 180, 181, 182, 183]. The closing prices of the previous day (used as prior close prices) are [144, 145, 148, 150, 149, 151, 153, 154, 155, 156, 158, 159, 160, 162, 161, 163, 165, 166, 167, 168, 170, 171, 172, 173, 175, 176, 177, 178].\n\nThe asset manager wants to calculate the Ultimate Oscillator for the stock to gauge the momentum over these specified periods.",
        "question": "What is the Ultimate Oscillator value for the stock's price data, rounded to two decimal places?",
        "python_solution": "def solution():\n    # Sample data as specified in the problem\n    close_prices = [145, 148, 150, 149, 151, 153, 154, 155, 156, 158, 159, 160, 162, 161, 163, 165, 166, 167, 168, 170, 171, 172, 173, 175, 176, 177, 178, 180]\n    low_prices = [140, 145, 148, 147, 149, 150, 152, 153, 154, 155, 156, 157, 159, 158, 160, 162, 163, 164, 165, 167, 168, 169, 170, 172, 173, 174, 175, 177]\n    high_prices = [150, 151, 153, 155, 156, 158, 159, 160, 161, 162, 163, 164, 165, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 179, 180, 181, 182, 183]\n    prior_close_prices = [144, 145, 148, 150, 149, 151, 153, 154, 155, 156, 158, 159, 160, 162, 161, 163, 165, 166, 167, 168, 170, 171, 172, 173, 175, 176, 177, 178]\n\n    # Function to calculate buying pressure (BP) and true range (TR) for each period\n    def calculate_bp_and_tr(close, low, high, prior_close):\n        bp = close - min(low, prior_close)\n        tr = max(high, prior_close) - min(low, prior_close)\n        return bp, tr\n\n    # Calculate BP and TR arrays\n    bp_values, tr_values = zip(*[calculate_bp_and_tr(c, l, h, pc) \n                                 for c, l, h, pc in zip(close_prices, low_prices, high_prices, prior_close_prices)])\n\n    # Function to calculate weighted average for specified period\n    def calculate_average(bp_values, tr_values, period):\n        bp_sum = sum(bp_values[-period:])\n        tr_sum = sum(tr_values[-period:])\n        return bp_sum / tr_sum if tr_sum != 0 else 0\n\n    # Calculate averages for 7, 14, and 28 periods\n    average_7 = calculate_average(bp_values, tr_values, 7)\n    average_14 = calculate_average(bp_values, tr_values, 14)\n    average_28 = calculate_average(bp_values, tr_values, 28)\n\n    # Calculate the Ultimate Oscillator value\n    ultimate_oscillator = ((average_7 * 4 + average_14 * 2 + average_28) / (4 + 2 + 1)) * 100\n\n    # Round the Ultimate Oscillator value to two decimal places and return\n    return round(ultimate_oscillator, 2)",
        "ground_truth": 42.99,
        "source": "FinanceReasoning-test-23",
        "question_id": "test-2225",
        "level": "hard",
        "output": [
            "To solve this problem, I will follow the below steps:\n\n1. **Understand the Constraints**:\n   - The input lengths for `close_prices`, `low_prices`, `high_prices`, and `prior_close_prices` must be equal and at least 28 periods.\n   - The Ultimate Oscillator is calculated using three designated timeframes, specifically 7, 14, and 28 periods.\n   - These parameters must align with the specified formulas for calculating the oscillator.\n   - The result should be rounded to **two decimal places**.\n\n2. **Formulate the Calculation**:\n   - The formulas for the Ultimate Oscillator involve calculating `BP (Buying Pressure)` and `TR (True Range)` individually for each day:\n      ```\n      BP = close_price - min(low_price, prior_close_price)\n      TR = max(high_price, prior_close_price) - min(low_price, prior_close_price)\n      ```\n   - For each timeframe (7, 14, and 28), we calculate averages:\n      ```\n      Average_BP_TR = sum(BP of timeframe) / sum(TR of timeframe)\n      ```\n   - Using weightage of the three timeframes (4 for 7-period, 2 for 14-period, and 1 for 28-period), we calculate the Ultimate Oscillator:\n      ```\n      Ultimate Oscillator = ((average_7 * 4) + (average_14 * 2) + (average_28 * 1)) / (4 + 2 + 1) * 100\n      ```\n\n3. **Derive Solution Logic**:\n   - Take the input `close_prices`, `low_prices`, `high_prices`, and `prior_close_prices`.\n   - Compute `BP` and `TR` values for each trading day.\n   - Calculate the averaged `BP / TR` values for the three different timeframes.\n   - Derive and return the Ultimate Oscillator value, rounded to two decimal places.\n\nHere is the Python program:\n\n```python\ndef solution():\n    # Define variables for closing prices, low prices, high prices, and prior close prices\n    close_prices = [145, 148, 150, 149, 151, 153, 154, 155, 156, 158, 159, 160, 162, 161, 163, 165, 166, 167, 168, 170, 171, 172, 173, 175, 176, 177, 178, 180]\n    low_prices = [140, 145, 148, 147, 149, 150, 152, 153, 154, 155, 156, 157, 159, 158, 160, 162, 163, 164, 165, 167, 168, 169, 170, 172, 173, 174, 175, 177]\n    high_prices = [150, 151, 153, 155, 156, 158, 159, 160, 161, 162, 163, 164, 165, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 179, 180, 181, 182, 183]\n    prior_close_prices = [144, 145, 148, 150, 149, 151, 153, 154, 155, 156, 158, 159, 160, 162, 161, 163, 165, 166, 167, 168, 170, 171, 172, 173, 175, 176, 177, 178]\n    \n    # Step 1: Calculate BP (Buying Pressure) and TR (True Range) for each period\n    def calculate_bp_and_tr(close, low, high, prior_close):\n        bp = close - min(low, prior_close)\n        tr = max(high, prior_close) - min(low, prior_close)\n        return bp, tr\n\n    bp_values, tr_values = zip(*[calculate_bp_and_tr(c, l, h, pc) for c, l, h, pc in zip(close_prices, low_prices, high_prices, prior_close_prices)])\n    \n    # Step 2: Define function to calculate the average BP/TR for the specified period\n    def calculate_average(bp_values, tr_values, period):\n        bp_sum = sum(bp_values[-period:])\n        tr_sum = sum(tr_values[-period:])\n        return bp_sum / tr_sum if tr_sum != 0 else 0\n\n    # Step 3: Calculate averages for 7, 14, and 28 periods\n    average_7 = calculate_average(bp_values, tr_values, 7)\n    average_14 = calculate_average(bp_values, tr_values, 14)\n    average_28 = calculate_average(bp_values, tr_values, 28)\n\n    # Step 4: Compute the Ultimate Oscillator value\n    ultimate_oscillator = ((average_7 * 4 + average_14 * 2 + average_28 * 1) / (4 + 2 + 1)) * 100\n\n    # Step 5: Return the value rounded to two decimal places\n    return round(ultimate_oscillator, 2)\n```"
        ],
        "retrieval_query": "What is the Ultimate Oscillator value for the stock's price data, rounded to two decimal places?",
        "useful_functions": [
            "def calculate_ultimate_oscillator(close_prices: list, low_prices: list, high_prices: list, prior_close_prices: list) -> float:\n    \"\"\"\n    Calculate the Ultimate Oscillator for a series of price data.\n\n    The Ultimate Oscillator is a technical indicator that measures the price momentum of\n    an asset over three different timeframes (7, 14, and 28 periods).\n\n    Args:\n        close_prices (list): A list of closing prices for the periods considered.\n        low_prices (list): A list of low prices for the periods considered.\n        high_prices (list): A list of high prices for the periods considered.\n        prior_close_prices (list): A list of prior closing prices for the periods.\n\n    Returns:\n        ultimate_oscillator (float): The value of the Ultimate Oscillator, scaled between 0 and 100.\n\n    Notes:\n        - The function assumes that the input lists are of the same length.\n        - It's important that the lengths of these lists are at least 28 periods to calculate\n          the longest average.\n        - The indicator provides insight into potential buy or sell signals through divergences\n          with price.\n          \n    \"\"\"\n    def calculate_bp_and_tr(close, low, high, prior_close):\n        bp = close - min(low, prior_close)\n        tr = max(high, prior_close) - min(low, prior_close)\n        return bp, tr\n\n    bp_values, tr_values = zip(*[calculate_bp_and_tr(c, l, h, pc) for c, l, h, pc in zip(close_prices, low_prices, high_prices, prior_close_prices)])\n\n    def calculate_average(bp_values, tr_values, period):\n        bp_sum = sum(bp_values[-period:])\n        tr_sum = sum(tr_values[-period:])\n        return bp_sum / tr_sum if tr_sum != 0 else 0\n\n    average_7 = calculate_average(bp_values, tr_values, 7)\n    average_14 = calculate_average(bp_values, tr_values, 14)\n    average_28 = calculate_average(bp_values, tr_values, 28)\n\n    ultimate_oscillator = ((average_7 * 4 + average_14 * 2 + average_28) / (4 + 2 + 1)) * 100\n\n    return ultimate_oscillator"
        ],
        "usage": {
            "completion_tokens": 1119,
            "prompt_tokens": 1260,
            "total_tokens": 2379,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-1798",
        "article_title": "T-Test",
        "function": "def calculate_unequal_variance_t_test(mean_1: float, mean_2: float, var_1: float, var_2: float, n1: int, n2: int) -> (float, float):\n    \"\"\"\n    Calculate the t-value and degrees of freedom for an unequal variance t-test (Welch's t-test).\n\n    This function computes the t-value and degrees of freedom for an independent\n    t-test assuming unequal variances and sample sizes in the comparison groups.\n\n    Args:\n        mean_1 (float): The average value of the first sample set.\n        mean_2 (float): The average value of the second sample set.\n        var_1 (float): The variance of the first sample set.\n        var_2 (float): The variance of the second sample set.\n        n1 (int): The number of records in the first sample set.\n        n2 (int): The number of records in the second sample set.\n\n    Returns:\n        t_value (float): The computed t-value for the unequal variance t-test.\n        degrees_of_freedom (float): The computed degrees of freedom for the test.\n\n    Notes:\n        - Applicability: Use when samples have different sizes or variances.\n        - Constraints: Sample size must be greater than 1 for each group.\n        - Considerations: Assumes sampled populations are normally distributed.\n    \"\"\"\n    if n1 <= 1 or n2 <= 1:\n        raise ValueError(\"Sample size must be greater than 1 for each group.\")\n\n    t_value = (mean_1 - mean_2) / (((var_1/n1) + (var_2/n2)) ** 0.5)\n    numerator = ((var_1/n1) + (var_2/n2)) ** 2\n    denominator = (((var_1/n1) ** 2) / (n1 - 1)) + (((var_2/n2) ** 2) / (n2 - 1))\n    degrees_of_freedom = numerator / denominator\n\n    return t_value, degrees_of_freedom",
        "statistics": {
            "number_statistics": {
                "args_numbers": 6,
                "question_numbers": 0,
                "context_numbers": 6,
                "total_numbers": 6
            },
            "operator_statistics": {
                "operators": {
                    "+": 3,
                    "-": 3,
                    "*": 0,
                    "/": 10,
                    "%": 0,
                    "**": 4
                },
                "total_operators": 20
            },
            "code_statistics": {
                "lines": 5,
                "parentheses": 32
            }
        },
        "difficulty": 6.040254711277414,
        "context": "A financial analyst is comparing the average return rates of two different investment portfolios over the past year. The first portfolio has an average return rate of 8% with a variance of 1.5% squared, derived from a sample of 18 investment products. The second portfolio has an average return rate of 6% with a variance of 2.0% squared, derived from a sample of 22 investment products. The analyst wants to determine if there is a statistically significant difference between the average return rates of the two portfolios by performing a Welch's t-test, assuming unequal variances and sample sizes.",
        "question": "What is the t-value calculated for the unequal variance t-test between the two portfolios? Answer to two decimal places.",
        "python_solution": "def solution():\n    # Define variables from the problem\n    mean_1 = 0.08  # Average return rate for the first portfolio\n    mean_2 = 0.06  # Average return rate for the second portfolio\n    var_1 = 0.015  # Variance for the first portfolio\n    var_2 = 0.02  # Variance for the second portfolio\n    n1 = 18       # Sample size for the first portfolio\n    n2 = 22       # Sample size for the second portfolio\n\n    # Calculate the t-value for the unequal variance t-test\n    t_value = (mean_1 - mean_2) / (((var_1/n1) + (var_2/n2)) ** 0.5)\n\n    # Return the final answer rounded to two decimal places\n    return round(t_value, 2)\n\n# The solution provides the t-value used to assess statistical significance",
        "ground_truth": 0.48,
        "source": "FinanceReasoning-test-31",
        "question_id": "test-2226",
        "level": "hard",
        "output": [
            "### Step-by-step Analysis Using EC (Emphasizing Constraints):\n\n1. **Understand the Formula for Welch's t-test**:\n   The t-value for the test between two populations with unequal variances is given by:\n   \\[\n   t = \\frac{\\bar{X}_1 - \\bar{X}_2}{\\sqrt{\\frac{s_1^2}{n_1} + \\frac{s_2^2}{n_2}}}\n   \\]\n   where:\n   - \\(\\bar{X}_1, \\bar{X}_2\\) = sample means of the two groups.\n   - \\(s_1^2, s_2^2\\) = sample variances of the two groups.\n   - \\(n_1, n_2\\) = sample sizes of the two groups.\n\n2. **Clarify the Given Values**:\n   - Portfolio 1 mean (\\(\\bar{X}_1\\)) = 8% = \\(0.08\\) (convert percentage to decimal).\n   - Portfolio 2 mean (\\(\\bar{X}_2\\)) = 6% = \\(0.06\\).\n   - Portfolio 1 variance (\\(s_1^2\\)) = 1.5% squared = 0.0015.\n   - Portfolio 2 variance (\\(s_2^2\\)) = 2.0% squared = 0.0020.\n   - Sample size of portfolio 1 (\\(n_1\\)) = 18.\n   - Sample size of portfolio 2 (\\(n_2\\)) = 22.\n\n3. **Translate Constraints**:\n   - Constraint 1: Adhere to the formula for Welch's t-test with the given inputs.\n   - Constraint 2: The output must be rounded to two decimal places.\n   - Constraint 3: Handle percentages accurately by converting them to decimals before calculations.\n\n4. **Solve for the Denominator**:\n   \\[\n   \\text{denominator} = \\sqrt{\\frac{s_1^2}{n_1} + \\frac{s_2^2}{n_2}}\n   \\]\n\n5. **Calculate the t-value**:\n   Substitute the values into the formula for \\(t\\):\n   \\[\n   t = \\frac{\\bar{X}_1 - \\bar{X}_2}{\\text{denominator}}\n   \\]\n\n6. **Python Implementation**:\n   Implement the above calculations step-by-step and ensure rounding to two decimal places.\n\nHere's the Python implementation:\n\n```python\ndef solution():\n    # Define variables\n    mean1 = 0.08  # Portfolio 1 mean\n    mean2 = 0.06  # Portfolio 2 mean\n    var1 = 0.0015  # Portfolio 1 variance\n    var2 = 0.0020  # Portfolio 2 variance\n    n1 = 18  # Sample size for portfolio 1\n    n2 = 22  # Sample size for portfolio 2\n\n    # Calculate the denominator of the t-value\n    denominator = ((var1 / n1) + (var2 / n2))**0.5\n\n    # Calculate the t-value\n    t_value = (mean1 - mean2) / denominator\n\n    # Round the result to two decimal places\n    return round(t_value, 2)\n```\n\nThis program calculates the t-value by applying the Welch's t-test formula and respects all stated constraints."
        ],
        "retrieval_query": "What is the t-value calculated for the unequal variance t-test between the two portfolios? Answer to two decimal places.",
        "useful_functions": [],
        "usage": {
            "completion_tokens": 726,
            "prompt_tokens": 470,
            "total_tokens": 1196,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-451",
        "article_title": "Interest Rate Risk",
        "function": "def calculate_bond_price_change(face_value: float, coupon_rate: float, current_market_rate: float, years_to_maturity: int) -> float:\n    \"\"\"\n    Calculate the change in a bond's market price due to a change in market interest rates.\n\n    This function estimates how the market price of a bond fluctuates when the current market interest rate differs from the bond's coupon rate.\n    It assumes that bond payments occur annually.\n\n    Args:\n        face_value (float): The bond's face value or the principal amount to be paid at maturity.\n        coupon_rate (float): The annual coupon rate of the bond.\n        current_market_rate (float): The current market interest rate.\n        years_to_maturity (int): The number of years until the bond matures.\n\n    Returns:\n        price_change (float): The percentage change in the bond's market price due to interest rate variation.\n\n    Notes:\n        - This function assumes the bond pays annual coupons.\n        - It uses simplified calculations and does not account for accrued interest or taxes.\n        - The bond's cash flows are assumed to be fixed and known in advance.\n    \"\"\"\n    annual_coupon_payment = face_value * coupon_rate\n    total_coupon_payment = annual_coupon_payment * years_to_maturity\n    original_price = sum(annual_coupon_payment / ((1 + coupon_rate) ** t) for t in range(1, years_to_maturity + 1)) + face_value / ((1 + coupon_rate) ** years_to_maturity)\n    new_price = sum(annual_coupon_payment / ((1 + current_market_rate) ** t) for t in range(1, years_to_maturity + 1)) + face_value / ((1 + current_market_rate) ** years_to_maturity)\n    price_change = ((new_price - original_price) / original_price) * 100\n\n    return price_change",
        "statistics": {
            "number_statistics": {
                "args_numbers": 4,
                "question_numbers": 0,
                "context_numbers": 4,
                "total_numbers": 4
            },
            "operator_statistics": {
                "operators": {
                    "+": 8,
                    "-": 1,
                    "*": 3,
                    "/": 5,
                    "%": 0,
                    "**": 4
                },
                "total_operators": 21
            },
            "code_statistics": {
                "lines": 6,
                "parentheses": 28
            }
        },
        "difficulty": 6.040254711277414,
        "context": "A corporate treasurer is evaluating the impact of interest rate changes on their bond portfolio. They hold bonds with a face value of $100,000, an annual coupon rate of 5%, and 10 years remaining to maturity. Recently, market interest rates have increased, and the current market rate now stands at 6%. The treasurer wants to know how much the market price of these bonds has changed due to this increase in interest rates.",
        "question": "What is the percentage change in the bond's market price due to the increase in the market interest rate? Answer as a percentage to two decimal places.",
        "python_solution": "def solution():\n    # Define variables and their values\n    face_value = 100000\n    coupon_rate = 0.05\n    current_market_rate = 0.06\n    years_to_maturity = 10\n\n    # Calculate the annual coupon payment\n    annual_coupon_payment = face_value * coupon_rate\n    \n    # Calculate the original bond price using the coupon rate\n    original_price = sum(\n        annual_coupon_payment / ((1 + coupon_rate) ** t) for t in range(1, years_to_maturity + 1)\n    ) + face_value / ((1 + coupon_rate) ** years_to_maturity)\n    \n    # Calculate the new bond price using the current market rate\n    new_price = sum(\n        annual_coupon_payment / ((1 + current_market_rate) ** t) for t in range(1, years_to_maturity + 1)\n    ) + face_value / ((1 + current_market_rate) ** years_to_maturity)\n    \n    # Calculate the percentage change in the bond's price\n    price_change = ((new_price - original_price) / original_price) * 100\n    \n    # Return the result rounded to two decimal places\n    return round(price_change, 2)",
        "ground_truth": -7.36,
        "source": "FinanceReasoning-test-40",
        "question_id": "test-2227",
        "level": "hard",
        "output": [
            "### Step-by-Step Explanation for the Problem\n\n#### **1. Problem Context**\n- We are determining the percentage change in the **market price** of a bond due to an increase in **market interest rates** from 5% (coupon rate) to 6%.\n- Bonds are priced using their **present value**, which depends on:\n  - **Face value** (future lump sum paid at maturity): $100,000.\n  - **Coupon rate** (annual payments as a percentage of the face value): 5% of $100,000.\n  - **Market interest rate** (used to discount cash flows): Increased from 5% (previous rate) to 6% (current rate).\n  - **Time to maturity:** 10 years.\n\n#### **2. Approach**\n- Use the **present value pricing formula for bonds**:\n  \\[\n  \\text{Price of Bond} = \\sum_{t=1}^{T} \\frac{\\text{Coupon Payment}}{(1 + r)^t} + \\frac{\\text{Face Value}}{(1 + r)^T},\n  \\]\n  where:\n  - \\( T = \\text{time to maturity (10 years)} \\),\n  - \\( r = \\text{market interest rate} \\),\n  - \\(\\text{Coupon Payment} = \\text{Coupon Rate} \\times \\text{Face Value}\\).\n\n#### **3. Required Calculation**\n- Compute the bond price **before** the interest rate change (\\(r = 5\\%\\)).\n- Compute the bond price **after** the interest rate change (\\(r = 6\\%\\)).\n- Use the provided **percentage change formula**:\n  \\[\n  \\text{Percentage Change} = \\frac{\\text{New Price} - \\text{Old Price}}{\\text{Old Price}} \\times 100\n  \\]\n  Round the result to **2 decimal places**, as specified.\n\n#### **4. Constraints**\n- **Decimal precision:** Ensure intermediate bond price calculations use high precision (to avoid rounding errors).\n- **Units:** Work consistently with percentages (convert to decimals where needed, e.g., 5% \u2192 0.05).\n- **Output:** Final percentage result is rounded to **two decimal places**.\n\nLet's now write the Python program.\n\n```python\ndef solution():\n    # Bond Parameters\n    face_value = 100000  # Bond face value\n    annual_coupon_rate = 0.05  # Annual coupon rate (5% \u2192 0.05)\n    coupon_payment = face_value * annual_coupon_rate  # Annual coupon amount\n    years_to_maturity = 10  # Time to maturity\n    old_market_rate = 0.05  # Market rate before the increase (5% \u2192 0.05)\n    new_market_rate = 0.06  # Market rate after the increase (6% \u2192 0.06)\n    \n    # Function to calculate bond price based on market rate\n    def calculate_bond_price(face_value, coupon_payment, years_to_maturity, market_rate):\n        price = 0\n        # Present value of annual coupon payments\n        for t in range(1, years_to_maturity + 1):\n            price += coupon_payment / ((1 + market_rate) ** t)\n        # Present value of the face value at maturity\n        price += face_value / ((1 + market_rate) ** years_to_maturity)\n        return price\n    \n    # Calculate bond price before and after interest rate change\n    old_price = calculate_bond_price(face_value, coupon_payment, years_to_maturity, old_market_rate)\n    new_price = calculate_bond_price(face_value, coupon_payment, years_to_maturity, new_market_rate)\n    \n    # Calculate the percentage change\n    percentage_change = ((new_price - old_price) / old_price) * 100\n    \n    # Return the percentage change rounded to 2 decimal places\n    return round(percentage_change, 2)\n```"
        ],
        "retrieval_query": "What is the percentage change in the bond's market price due to the increase in the market interest rate? Answer as a percentage to two decimal places.",
        "useful_functions": [
            "def calculate_percentage_change(initial_value: float, final_value: float, decimal_places: int = 2) -> float:\n    \"\"\"\n    Calculate the percentage change between two values, rounded to a specified number of decimal places.\n\n    This function computes the percentage change from an initial value to a final value using the formula:\n    Percentage Change = ((final_value - initial_value) / initial_value) * 100. The result is rounded to\n    a specified number of decimal places.\n\n    Args:\n        initial_value (float): The initial value from which the change is measured.\n        final_value (float): The final value after the change.\n        decimal_places (int): The number of decimal places to round the result to. Defaults to 2.\n\n    Returns:\n        percentage_change (float): The percentage change from the initial value to the final value,\n                                   rounded to the specified number of decimal places.\n\n    Notes:\n        - Applicability: Useful for financial analysis, sales trend analysis, and any scenario where\n          percentage change needs to be calculated.\n        - Constraints: The initial_value must not be zero to avoid division by zero errors.\n        - Considerations: Negative values in initial_value or final_value can lead to misleading\n          results if not appropriately interpreted in the context of usage.\n    \"\"\"\n    if initial_value == 0:\n        raise ValueError(\"Initial value must not be zero.\")\n\n    change = final_value - initial_value\n    percentage_change = (change / initial_value) * 100\n    return round(percentage_change, decimal_places)"
        ],
        "usage": {
            "completion_tokens": 825,
            "prompt_tokens": 769,
            "total_tokens": 1594,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "Ethan Hawk is analyzing the return to his leveraged stock position that he invested in last year. The stock's price at the time of purchase was $50/share. Hawk purchased 100 shares paying a commission of $0.05/share. The leverage ratio was 2.0 and the call money rate was 6.0%. At the end of the year, the stock paid a dividend of $0.50/share and the share price rose to $70/share. What is the total return on Hawk's investment? Answer as a percentage to two decimal places.",
        "context": "",
        "statistics": {
            "number_statistics": {
                "question_numbers": 7,
                "context_numbers": 0,
                "total_numbers": 7
            },
            "operator_statistics": {
                "operators": {
                    "+": 3,
                    "-": 3,
                    "*": 8,
                    "/": 3,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 17
            },
            "code_statistics": {
                "lines": 19,
                "parentheses": 12
            }
        },
        "difficulty": 6.052089168924416,
        "ground_truth": 75.65,
        "source": "FinCode-test-16",
        "python_solution": "purchase_price = 50.0\nshares = 100.0\ncommisson_per_share = 0.05\nleverage_ratio = 2.0\ncall_money_rate = 0.06\ndividend_per_share = 0.50\nfinal_price = 70.0\ntotal_purchase = shares * purchase_price\namount_spent = (1.0 - (1.0 / leverage_ratio)) * total_purchase\nsales_commisson = commisson_per_share * shares\ninitial_investment = amount_spent + sales_commisson\nloan_amount = (1.0 / leverage_ratio) * total_purchase\nmargin_interest = loan_amount * call_money_rate\ntotal_dividends = dividend_per_share * shares\nproceeds_from_sale = final_price * shares\nholding_costs = loan_amount + margin_interest\nremaining_equity = (proceeds_from_sale + total_dividends) - holding_costs\nreturn_on_investment = 100.0 * (remaining_equity - initial_investment) / initial_investment\nround(return_on_investment, 2)\n",
        "question_id": "test-2228",
        "level": "hard",
        "output": [
            "To determine the total return on Ethan Hawk's investment, we will calculate it step-by-step, considering all constraints and financial information provided.\n\n**Step-by-Step Reasoning Using EC:**\n1. **Initial Investment Calculation:**\n   - Hawk bought 100 shares at $50/share. Since there is a commission cost of $0.05/share, the total initial investment will include this additional cost. The formula is:\n     \\( \\text{Initial Investment} = \\text{Number of Shares} \\times (\\text{Stock Price} + \\text{Commission}) \\).\n   - Initial investment = \\(100 \\times (50 + 0.05) = 100 \\times 50.05\\).\n\n2. **Leverage Ratio Effect:**\n   - Hawk utilized a leverage ratio of 2.0, meaning half of the initial investment was financed through his own funds, and half was borrowed. His personal equity contribution was:\n     \\( \\text{Equity Contribution} = \\text{Initial Investment} / \\text{Leverage Ratio} \\).\n\n3. **Annual Interest Paid:**\n   - Since Hawk financed half of the investment (leverage) via borrowing, he paid an annual interest rate (call money rate) of 6% on the borrowed amount. The interest is calculated as:\n     \\( \\text{Interest Payment} = \\text{Borrowed Amount} \\times \\text{Call Money Rate} \\).\n\n4. **Final Value of Investment:**\n   - By the end of the year, the stock price rose to $70/share. The total value of the shares at the end of the year is:\n     \\( \\text{Final Value of Investment} = \\text{Number of Shares} \\times \\text{End-of-Year Stock Price} \\).\n\n5. **Dividend Income:**\n   - The stock paid a dividend of $0.50/share; thus, the total dividend received is:\n     \\( \\text{Total Dividend} = \\text{Number of Shares} \\times \\text{Dividend per Share} \\).\n\n6. **Net Value After Repaying Borrowed Amount and Deducting Interest:**\n   - To calculate the net proceeds, Hawk sells all shares at the end of the year and repays the borrowed amount and the incurred annual interest. The net proceeds are:\n     \\( \\text{Net Proceeds} = (\\text{Final Value of Investment} + \\text{Total Dividend}) - (\\text{Borrowed Amount} + \\text{Interest Payment}) \\).\n\n7. **Calculate Total Return:**\n   - The return is calculated as the percentage increase or decrease in the equity contribution:\n     \\( \\text{Total Return} (\\%) = \\left(\\frac{\\text{Net Proceeds}}{\\text{Equity Contribution}} - 1\\right) \\times 100 \\).\n\n**Constraints Used:**\n- The commission rate is $0.05/share.\n- Call money rate is 6.0%.\n- The total return is expressed as a percentage to two decimal places.\n\nNow, let's translate this into the Python program:\n\n```python\ndef solution():\n    # Step 1: Define variables\n    stock_price_at_purchase = 50  # in dollars\n    commission = 0.05  # in dollars per share\n    number_of_shares = 100\n    leverage_ratio = 2.0\n    call_money_rate = 0.06  # 6% as a decimal\n    end_year_stock_price = 70  # in dollars\n    dividend_per_share = 0.50  # in dollars per share\n    \n    # Step 2: Calculate initial investment\n    initial_investment = number_of_shares * (stock_price_at_purchase + commission)\n    \n    # Step 3: Calculate equity contribution and borrowed amount\n    equity_contribution = initial_investment / leverage_ratio  # amount Hawk invested\n    borrowed_amount = initial_investment - equity_contribution  # amount borrowed\n    \n    # Step 4: Calculate annual interest payment\n    interest_payment = borrowed_amount * call_money_rate  # interest on borrowed amount\n    \n    # Step 5: Calculate final value of the investment\n    final_value = number_of_shares * end_year_stock_price\n    \n    # Step 6: Calculate total dividend\n    total_dividend = number_of_shares * dividend_per_share\n    \n    # Step 7: Calculate net proceeds\n    net_proceeds = (final_value + total_dividend) - (borrowed_amount + interest_payment)\n    \n    # Step 8: Calculate total return as a percentage\n    total_return = ((net_proceeds / equity_contribution) - 1) * 100\n    \n    # Step 9: Return formatted result\n    return round(total_return, 2)\n\n# Example Usage:\n# print(solution())\n```\n\nThis will correctly compute the total return on Hawk's investment as a percentage to two decimal places, respecting all specified constraints."
        ],
        "retrieval_query": "Ethan Hawk is analyzing the return to his leveraged stock position that he invested in last year. The stock's price at the time of purchase was $50/share. Hawk purchased 100 shares paying a commission of $0.05/share. The leverage ratio was 2.0 and the call money rate was 6.0%. At the end of the year, the stock paid a dividend of $0.50/share and the share price rose to $70/share. What is the total return on Hawk's investment? Answer as a percentage to two decimal places.",
        "useful_functions": [
            "def calculate_investor_net_return(aum_end_of_year: float, high_water_mark: float, \n                                  management_fee_rate: float, previous_assets_value: float, \n                                  incentive_fee_rate: float, hurdle_rate: float) -> float:\n    \"\"\"\n    Calculate the net return for an investor under a \"2 and 20\" fee arrangement.\n\n    This function determines the net return for an investor, given the end-of-year\n    assets under management (AUM), a high-water mark, management and incentive fee rates, \n    a hurdle rate, and the initial value of assets. It accounts for management fees and \n    calculates incentive fees only if the AUM surpasses the high-water mark adjusted by the hurdle rate.\n\n    Args:\n        aum_end_of_year (float): The assets under management at the end of the year.\n        high_water_mark (float): The benchmark value of assets before fees can be collected.\n        management_fee_rate (float): The rate applied to AUM for management fees.\n        previous_assets_value (float): The value of assets at the start of the year.\n        incentive_fee_rate (float): The rate applied to returns above the high-water mark.\n        hurdle_rate (float): The minimum rate of return required before incentive fees apply.\n\n    Returns:\n        net_return_percentage (float): The net return for the investor, expressed as a percentage.\n\n    Notes:\n        - Applicability: Suitable for investment firms using \"2 and 20\" fee structures.\n        - Constraints: Assumes positive values for all inputs.\n        - Considerations: Always round the final result to three decimal places for percentage representation.\n    \"\"\"\n    management_fee = aum_end_of_year * management_fee_rate\n    \n    if aum_end_of_year < high_water_mark * (1 + hurdle_rate):\n        total_fee = management_fee\n    else:\n        total_fee = management_fee + (aum_end_of_year - high_water_mark * (1 + hurdle_rate)) * incentive_fee_rate\n\n    net_return = (aum_end_of_year - total_fee) / previous_assets_value - 1\n\n    return round(net_return * 100, 3)"
        ],
        "usage": {
            "completion_tokens": 1017,
            "prompt_tokens": 878,
            "total_tokens": 1895,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "An investor purchases a five-year, 6% annual-coupon payment bond at 89.4535 and sells it in four years. Following the purchase of the bond and prior to the receipt of the first coupon, interest rates go down to 8.5%. What is the realized yield on the bond investment? Answer as a percentage with two decimal places.",
        "context": "",
        "statistics": {
            "number_statistics": {
                "question_numbers": 3,
                "context_numbers": 0,
                "total_numbers": 3
            },
            "operator_statistics": {
                "operators": {
                    "+": 9,
                    "-": 2,
                    "*": 5,
                    "/": 3,
                    "%": 0,
                    "**": 4
                },
                "total_operators": 23
            },
            "code_statistics": {
                "lines": 12,
                "parentheses": 22
            }
        },
        "difficulty": 6.270988431858299,
        "ground_truth": 8.71,
        "source": "FinCode-test-8",
        "python_solution": "face_value = 100\ncoupon_rate = 0.06\ninitial_price = 89.4535\nyears_til_maturity = 5\ninterest_rate = 0.085\nholding_period = 4\ncoupon = coupon_rate * face_value\nsell_price = (face_value + coupon) / ((1 + interest_rate) ** (years_til_maturity - holding_period))\ncoupon_received = coupon + coupon * (1 + interest_rate) + coupon * (1 + interest_rate) ** 2 + coupon * (1 + interest_rate) ** 3\nrealized_yield = ((sell_price + coupon_received) / initial_price) ** (1 / holding_period) - 1\nrealized_yield_per = 100.0 * realized_yield\nround(realized_yield_per, 2)",
        "question_id": "test-2229",
        "level": "hard",
        "output": [
            "To solve this problem, let's follow a step-by-step approach using advanced reasoning techniques, specifically emphasizing constraints (EC). Here's the breakdown:\n\n### Problem Analysis and Steps:\n1. **Bond Description and Purchase Details**:\n   - The bond has an annual coupon rate of 6% and a face value of 100 (assuming a standard bond face value of 100 units).\n   - The investor purchases the bond at a price of 89.4535.\n\n2. **Realized Holding Period**:\n   - Investor sells the bond after four years.\n   - During this period, the investor receives four annual coupon payments.\n\n3. **Interest Rate Change**:\n   - After the bond purchase and before receiving the first coupon, interest rates drop to 8.5%.\n   - This means we must calculate the bond's **new price at the end of the fourth year** (based on the prevailing rate of 8.5%).\n\n4. **Realized Yield Calculation**:\n   - The realized yield (or IRR) of the investment is computed based on:\n     - The purchase price (89.4535).\n     - The periodic coupon payments of 6% based on the face value.\n     - The sale price of the bond at the prevailing rate of 8.5%.\n   - Use the internal rate of return (IRR) formula for cash flows to determine the realized yield.\n\n### Constraints\n1. **Output as Percentage**: Realized yield should be calculated and returned as a percentage, rounded to two decimal places.\n2. **Face Value**: The bond is assumed to have a face value of 100.\n3. **Time Periods**: The analysis considers exactly four years.\n\n### Strategy for the Solution:\n1. Calculate the new sale price of the bond after four years using the future value of the remaining cash flows (1 year of coupon and face value) discounted at 8.5%.\n2. Compute the investment's realized yield using the IRR formula by iteratively solving for the discount rate that equates the purchased price and cash flows (four coupon payments and the sale price).\n\n### Python Implementation:\nWith these steps in mind, we'll create the solution:\n\n```python\ndef solution():\n    import numpy as np\n\n    # Define variables\n    purchase_price = 89.4535\n    face_value = 100\n    annual_coupon_rate = 6  # As a percentage\n    new_interest_rate = 8.5  # As a percentage\n    holding_period = 4  # In years\n    \n    # Step 1: Calculate annual coupon payment\n    coupon_payment = face_value * annual_coupon_rate / 100\n    \n    # Step 2: Calculate bond's price at the end of four years\n    # Since only 1 year remains after 4 years, future cash flows are:\n    # - One final coupon payment\n    # - Return of face value\n    # These are discounted at the new interest rate (8.5%)\n    remaining_cash_flows = [coupon_payment + face_value]\n    sale_price = np.sum([cf / ((1 + new_interest_rate / 100) ** t) for t, cf in enumerate(remaining_cash_flows, start=1)])\n    \n    # Step 3: Define cash flows for realized yield calculation\n    # Initial cash outflow (negative) is the purchase price\n    # Subsequent inflows are the annual coupon payments, followed by the sale price in Year 4\n    cash_flows = [-purchase_price] + [coupon_payment] * holding_period\n    cash_flows[-1] += sale_price  # Adding the sale price to the final year's cash flow\n    \n    # Step 4: Calculate realized yield using IRR\n    realized_yield = np.irr(cash_flows)  # IRR returns the periodic rate in decimal form\n    \n    # Convert to percentage and round to two decimal places\n    answer = round(realized_yield * 100, 2)\n    \n    return answer\n```"
        ],
        "retrieval_query": "An investor purchases a five-year, 6% annual-coupon payment bond at 89.4535 and sells it in four years. Following the purchase of the bond and prior to the receipt of the first coupon, interest rates go down to 8.5%. What is the realized yield on the bond investment? Answer as a percentage with two decimal places.",
        "useful_functions": [
            "def amortize_bond_discount(purchase_price: float, face_value: float, num_periods: int, coupon_rate: float, market_rate: float) -> list:\n    \"\"\"\n    Amortize the bond discount using the effective interest rate method.\n\n    This function computes the amortization schedule of a bond discount over\n    its life using the effective interest rate method. The bond discount is\n    gradually expensed to interest, with each period's interest expense based\n    on the bond's book value at the start of the period.\n\n    Args:\n        purchase_price (float): The price at which the bond was originally purchased.\n        face_value (float): The face value or par value of the bond.\n        num_periods (int): The total number of periods (e.g., years) until maturity.\n        coupon_rate (float): The annual coupon rate of the bond as a percentage.\n        market_rate (float): The annual market interest rate during issuance as a percentage.\n\n    Returns:\n        amortization_schedule (list): A list of tuples representing each period's\n        interest payment, interest expense, and amortization amount.\n\n    Notes:\n        - Applicability: Useful for calculating interest expenses for bonds issued at a discount.\n        - Constraints: Assumes the bond has periodic, fixed coupon payments.\n        - Considerations: Ensure that coupon and market rates are expressed as percentages.\n    \"\"\"\n    amortization_schedule = []\n    book_value = purchase_price\n\n    for period in range(1, num_periods + 1):\n        coupon_payment = face_value * coupon_rate / 100\n        interest_expense = book_value * market_rate / 100\n        amortization = interest_expense - coupon_payment\n        book_value += amortization\n\n        amortization_schedule.append((coupon_payment, interest_expense, amortization))\n\n    return amortization_schedule",
            "def calculate_holding_period_cost(annual_management_fee: float, \n                                  round_trip_trading_fees: float, \n                                  bid_offer_spread: float, \n                                  holding_period_months: int) -> float:\n    \"\"\"\n    Calculate the anticipated overall holding period cost of an investment in an ETF.\n\n    This function computes the total expected holding period cost of an ETF \n    over a specified number of months. The calculation considers annual \n    management fees, round-trip trading fees, and bid-offer spread costs.\n\n    Args:\n        annual_management_fee (float): The annual management fee percentage (e.g., 0.32 for 0.32%).\n        round_trip_trading_fees (float): The round-trip trading fees percentage (e.g., 0.20 for 0.20%).\n        bid_offer_spread (float): The bid-offer spread percentage for buy and sell transactions\n                                  (e.g., 0.10 for 0.10%).\n        holding_period_months (int): The number of months the ETF is held.\n\n    Returns:\n        total_cost (float): The total expected holding period cost, expressed as a percentage.\n\n    Notes:\n        - This function assumes the effects of compounding are excluded.\n        - The holding period should be provided in months.\n        - Inputs must represent percentages and should be expressed as decimal fractions,\n          for example, 0.32 for 0.32%.\n    \"\"\"\n    holding_period_years = holding_period_months / 12\n    total_expected_holding_period_cost = (holding_period_years * annual_management_fee) + \\\n                                         round_trip_trading_fees + bid_offer_spread\n    return total_expected_holding_period_cost",
            "def calculate_zero_coupon_bond_valuation(face_value: float, initial_rate: float, risk_premium: float,\n                                         up_rate: float, down_rate: float, probability_up: float, \n                                         probability_down: float) -> float:\n    \"\"\"\n    Calculate the valuation of a zero-coupon bond with potential interest rate changes.\n\n    This function computes the present value of a zero-coupon bond given a current interest rate,\n    possible future interest rate changes with associated probabilities, and a risk premium.\n    \n    Args:\n        face_value (float): The face value of the bond.\n        initial_rate (float): The initial 1-year risk-free interest rate.\n        risk_premium (float): The yearly risk premium for duration risk.\n        up_rate (float): The potential interest rate if rates go up after one year.\n        down_rate (float): The potential interest rate if rates go down after one year.\n        probability_up (float): The probability of the up_rate scenario occurring.\n        probability_down (float): The probability of the down_rate scenario occurring.\n\n    Returns:\n        zero_coupon_bond_price (float): The present value of the zero-coupon bond.\n\n    Notes:\n        - Applicability: This function is applicable for the evaluation of a zero-coupon \n          bond's present value in a two-period model with uncertain future interest rates.\n        - Constraints: The sum of `probability_up` and `probability_down` should equal 1.\n        - Considerations: The interest rates and risk premium should be in decimal form.\n    \"\"\"\n    up_price_date1 = face_value / (1 + up_rate + risk_premium)\n    down_price_date1 = face_value / (1 + down_rate + risk_premium)\n\n    expected_price_date1 = probability_up * up_price_date1 + probability_down * down_price_date1\n    zero_coupon_bond_price = expected_price_date1 / (1 + initial_rate)\n\n    return zero_coupon_bond_price"
        ],
        "usage": {
            "completion_tokens": 823,
            "prompt_tokens": 1534,
            "total_tokens": 2357,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "question": "What is the projected price value of a basis point for a bond that provides a 3% coupon rate with yearly coupons, has nine years until maturity, a yield-to-maturity of 5%, and is valued at 85.784357 per 100 of par value? Answer to three decimal places.",
        "python_solution": "def solution():\n    coupon_rate = 3\n    maturity_years = 9\n    yield_to_maturity = 5\n    bond_value = 85.784357\n\n    PV_minus = sum([coupon_rate/(1 + (yield_to_maturity - 0.01)/100)**i for i in range(1, maturity_years+1)])\n    PV_minus += 100/(1 + (yield_to_maturity - 0.01)/100)**maturity_years\n\n    PV_plus = sum([coupon_rate/(1 + (yield_to_maturity + 0.01)/100)**i for i in range(1, maturity_years+1)])\n    PV_plus += 100/(1 + (yield_to_maturity + 0.01)/100)**maturity_years\n\n    PVBP = (PV_minus - PV_plus) / 2\n\n    return PVBP",
        "ground_truth": 0.065,
        "topic": "Asset Classes & Derivatives",
        "statistics": {
            "number_statistics": {
                "args_numbers": 3,
                "question_numbers": 4,
                "context_numbers": 0,
                "total_numbers": 4
            },
            "operator_statistics": {
                "operators": {
                    "+": 10,
                    "-": 3,
                    "*": 0,
                    "/": 9,
                    "%": 0,
                    "**": 4
                },
                "total_operators": 26
            },
            "code_statistics": {
                "lines": 10,
                "parentheses": 26
            }
        },
        "difficulty": 6.393590753950631,
        "source": "FinanceMath-validation-159",
        "context": "[]",
        "question_id": "test-2230",
        "level": "hard",
        "output": [
            "To solve the problem, let's think through step-by-step:\n\n---\n### Step 1: Understand the Problem\nWe need to compute the **projected price value of a basis point**, which is a measurement to assess the change in bond prices based on a change in yield. A **basis point** is 0.01% (or 0.0001 in decimal). A decrease of one basis point in yield raises the bond price slightly, and the change in bond price due to this decrease is what we aim to compute.\n\nThe bond has the following details:\n- **Coupon Rate**: 3% annually.\n- **Time to Maturity**: 9 years.\n- **Yield-to-Maturity (YTM)**: 5% expressed as a decimal `0.05`.\n- **Current Price**: `85.784357` per `100` units of par value.\n\n---\n### Step 2: Constraints\nUsing the **Emphasizing Constraints (EC)** technique:\n1. The bond calculations will involve:\n   - Yield-to-Maturity (YTM) as a decimal.\n   - Effective bond price with high precision.\n2. Return value must be to **three decimal places**.\n3. The calculations will apply **time value of money concepts**.\n\n**Given the provided data**, the steps to calculate the price value of a basis point (PVBP) include:\n1. Calculate the original bond price (`P_y`) using the given yield (`YTM` = 5%).\n2. Compute the bond price (`P_(y-0.0001)`) after reducing the yield by one basis point (YTM decreases to 4.99%).\n3. PVBP = `P_(y-0.0001)` - `P_y`.\n\n**Formula for bond price:**\n\\[\nP = \\sum_{t=1}^{T} \\frac{C}{(1 + Y)^t} + \\frac{\\text{Face Value}}{(1 + Y)^T}\n\\]\nWhere:\n- \\(C\\): Coupon payment = Face Value \u00d7 Coupon Rate.\n- \\(T\\): Years until maturity.\n- \\(Y\\): Yield-to-maturity (YTM) as a decimal.\n\nWe'll calculate **bond prices under the original YTM and decreased YTM using the above formula** and subtract them to find PVBP.\n\n---\n### Step 3: Plan the Python Program\n1. Define constants (coupon rate, yield-to-maturity, years to maturity, current price, etc.).\n2. Use the bond price formula to calculate price at both `YTM = 5%` and `YTM = 4.99%` for high precision.\n3. Subtract the two calculated prices to determine PVBP.\n4. Return the result rounded to three decimal places.\n\n---\n### Implementation\nBelow is the Python program implementing the solution:\n\n```python\ndef solution():\n    # Define variables\n    face_value = 100  # Par value of the bond\n    coupon_rate = 0.03  # Coupon rate as a decimal (3%)\n    years_to_maturity = 9  # Time until maturity\n    original_ytm = 0.05  # Original yield-to-maturity as a decimal (5%)\n    reduced_ytm = original_ytm - 0.0001  # Yield reduced by 1 basis point (4.99%)\n\n    # Calculate annual coupon payment\n    coupon_payment = face_value * coupon_rate\n\n    # Function to calculate bond price given a YTM\n    def calculate_bond_price(ytm, face_value, coupon_payment, years_to_maturity):\n        bond_price = 0\n        for t in range(1, years_to_maturity + 1):\n            bond_price += coupon_payment / ((1 + ytm) ** t)  # Discount coupon payments\n        bond_price += face_value / ((1 + ytm) ** years_to_maturity)  # Discount face value\n        return bond_price\n\n    # Calculate bond prices\n    original_price = calculate_bond_price(original_ytm, face_value, coupon_payment, years_to_maturity)\n    reduced_price = calculate_bond_price(reduced_ytm, face_value, coupon_payment, years_to_maturity)\n\n    # Calculate projected price value of a basis point (PVBP)\n    pvbp = reduced_price - original_price\n\n    # Return the answer rounded to 3 decimal places\n    return round(pvbp, 3)\n```"
        ],
        "retrieval_query": "What is the projected price value of a basis point for a bond that provides a 3% coupon rate with yearly coupons, has nine years until maturity, a yield-to-maturity of 5%, and is valued at 85.784357 per 100 of par value? Answer to three decimal places.",
        "useful_functions": [
            "def calculate_discount_margin(present_value: float, index_rate: float, quoted_margin: float, face_value: float, semiannual_periods: int, annual_yield: float) -> float:\n    \"\"\"\n    Calculate the discount margin for a bond in basis points (bps).\n\n    This function computes the discount margin for a two-year floating-rate bond \n    based on its present value, current index rate (e.g., LPR), added quoted margin, \n    face value, number of semiannual periods, and annual yield. The result is expressed \n    in basis points (bps).\n\n    Args:\n        present_value (float): The current price of the bond for every unit of face value.\n        index_rate (float): The current 6-month lending prime rate (e.g., LPR) expressed as a decimal.\n        quoted_margin (float): The quoted margin above the index rate, expressed as a decimal.\n        face_value (float): The face value of the bond.\n        semiannual_periods (int): Number of semiannual periods (e.g., 2 for a two-year bond).\n        annual_yield (float): The current annual yield expressed as a decimal.\n\n    Returns:\n        discount_margin (float): The discount margin in basis points (bps).\n\n    Notes:\n        - Applicability: This function is applicable for bonds with floating rates based on an index rate.\n        - Constraints: The annual yield, index rate, and quoted margin should be provided as decimals.\n        - Considerations: Ensure that the calculated yield is correct and in the desired format (bps).\n    \"\"\"\n    discount_margin_decimal = (annual_yield - index_rate) / semiannual_periods\n    discount_margin_bps = discount_margin_decimal * 10000\n    \n    return discount_margin_bps"
        ],
        "usage": {
            "completion_tokens": 925,
            "prompt_tokens": 763,
            "total_tokens": 1688,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-3060",
        "article_title": "Option Pricing Theory",
        "function": "def black_scholes_option_price(stock_price: float, strike_price: float, time_to_expiration: float, \n                               risk_free_rate: float, volatility: float, option_type: str = 'call') -> float:\n    \"\"\"\n    Calculate the theoretical price of a European option using the Black-Scholes model.\n\n    This function computes the price of European call or put options using the Black-Scholes formula\n    based on input variables such as the underlying stock price, strike price, time to expiration,\n    risk-free rate, and volatility. It assumes a log-normal distribution of stock prices.\n\n    Args:\n        stock_price (float): The current price of the underlying stock.\n        strike_price (float): The strike price of the option.\n        time_to_expiration (float): Time to expiration in years.\n        risk_free_rate (float): The risk-free interest rate as a decimal.\n        volatility (float): The standard deviation of the stock's returns (volatility).\n        option_type (str, optional): The type of option to price ('call' or 'put'). Default is 'call'.\n\n    Returns:\n        option_price (float): The theoretical price of the option.\n\n    Notes:\n        - Applicability: Applies to European options only; not applicable to American options.\n        - Constraints: Assumes constant volatility and risk-free rate, no dividends.\n        - Considerations: Option type must be 'call' or 'put'; otherwise, raises ValueError.\n    \"\"\"\n    from math import log, sqrt, exp\n    from scipy.stats import norm\n\n    if option_type not in ['call', 'put']:\n        raise ValueError(\"Option type must be either 'call' or 'put'.\")\n\n    d1 = (log(stock_price / strike_price) + (risk_free_rate + 0.5 * volatility ** 2) * time_to_expiration) / (volatility * sqrt(time_to_expiration))\n    d2 = d1 - volatility * sqrt(time_to_expiration)\n\n    if option_type == 'call':\n        option_price = (stock_price * norm.cdf(d1)) - (strike_price * exp(-risk_free_rate * time_to_expiration) * norm.cdf(d2))\n    else:  # 'put'\n        option_price = (strike_price * exp(-risk_free_rate * time_to_expiration) * norm.cdf(-d2)) - (stock_price * norm.cdf(-d1))\n\n    return option_price",
        "statistics": {
            "number_statistics": {
                "args_numbers": 6,
                "question_numbers": 0,
                "context_numbers": 5,
                "total_numbers": 5
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 7,
                    "*": 12,
                    "/": 2,
                    "%": 0,
                    "**": 1
                },
                "total_operators": 24
            },
            "code_statistics": {
                "lines": 9,
                "parentheses": 32
            }
        },
        "difficulty": 6.396929655216146,
        "context": "An investor is considering purchasing a European call option on a popular tech company's stock. The current stock price is $150. The option has a strike price of $160 and is set to expire in 6 months. The annual risk-free interest rate is 5%, and the volatility of the stock is estimated to be 20%. The investor wants to know the theoretical price of the call option to make an informed decision.",
        "question": "What is the theoretical price of the European call option on the company's stock? Answer the price to two decimal places.",
        "python_solution": "def solution():\n    from math import log, sqrt, exp\n    from scipy.stats import norm\n\n    # Given values\n    stock_price = 150.0  # Current stock price in dollars\n    strike_price = 160.0  # Strike price in dollars\n    time_to_expiration = 0.5  # Time to expiration in years (6 months)\n    risk_free_rate = 0.05  # Annual risk-free interest rate (5%)\n    volatility = 0.20  # Volatility in decimal (20%)\n\n    # Calculate d1 and d2 using the Black-Scholes formula\n    d1 = (log(stock_price / strike_price) + (risk_free_rate + 0.5 * volatility ** 2) * time_to_expiration) / (volatility * sqrt(time_to_expiration))\n    d2 = d1 - volatility * sqrt(time_to_expiration)\n\n    # Calculate call option price\n    call_option_price = (stock_price * norm.cdf(d1)) - (strike_price * exp(-risk_free_rate * time_to_expiration) * norm.cdf(d2))\n\n    # Return the calculated price rounded to two decimal places\n    return round(call_option_price, 2)\n\n# Example of running the solution function\nprint(solution())  # Should print the theoretical price of the call option",
        "ground_truth": 5.94,
        "source": "FinanceReasoning-test-16",
        "question_id": "test-2231",
        "level": "hard",
        "output": [
            "To solve the problem, I will use the Black-Scholes model to calculate the theoretical price of the European call option. I will consider the following input values:\n\n1. **Stock Price (S)**: $150\n2. **Strike Price (K)**: $160\n3. **Time to Expiration (T)**: 6 months = 0.5 years\n4. **Risk-Free Rate (r)**: 5% = 0.05\n5. **Volatility (\u03c3)**: 20% = 0.2\n6. **Constraints**: The result should be rounded to two decimal places.\n\n### Step-by-Step Approach:\n1. Use the given formula to calculate `d1` and `d2`:\n   \\[\n   d1 = \\frac{\\ln(S/K) + (r + 0.5 \\cdot \\sigma^2)T}{\\sigma \\cdot \\sqrt{T}}\n   \\]\n   \\[\n   d2 = d1 - \\sigma \\cdot \\sqrt{T}\n   \\]\n\n2. Calculate the call option price using the Black-Scholes formula for a European call option:\n   \\[\n   C = (S \\cdot N(d1)) - \\left(K \\cdot e^{-rT} \\cdot N(d2)\\right)\n   \\]\n   Where \\(N(x)\\) is the cumulative distribution function (CDF) of the standard normal distribution.\n\n3. Import required libraries (`math` for calculations and `scipy.stats.norm` for the normal CDF).\n\n4. Ensure values are expressed as decimals (e.g., 5% = 0.05).\n\n5. Round the result to two decimal places as per the requirements.\n\nNow, let's create the Python program to compute the theoretical price of the European call option.\n\n```python\ndef solution():\n    import math\n    from scipy.stats import norm\n\n    # Define variables\n    S = 150  # Current stock price\n    K = 160  # Strike price\n    T = 0.5  # Time to maturity in years (6 months)\n    r = 0.05  # Annual risk-free rate (5%)\n    sigma = 0.2  # Volatility (20%)\n\n    # Calculate d1 and d2\n    d1 = (math.log(S / K) + (r + 0.5 * sigma ** 2) * T) / (sigma * math.sqrt(T))\n    d2 = d1 - sigma * math.sqrt(T)\n\n    # Calculate the call option price using Black-Scholes formula\n    call_price = S * norm.cdf(d1) - K * math.exp(-r * T) * norm.cdf(d2)\n\n    # Round the call price to two decimal places\n    answer = round(call_price, 2)\n\n    return answer\n```"
        ],
        "retrieval_query": "What is the theoretical price of the European call option on the company's stock? Answer the price to two decimal places.",
        "useful_functions": [
            "import math\nfrom scipy.stats import norm\n\ndef calculate_black_scholes_call_price(S: float, K: float, t: float, r: float, sigma: float) -> float:\n    \"\"\"\n    Calculate the Black-Scholes price of a European call option.\n\n    This function computes the theoretical price of a European call option using the Black-Scholes \n    model. The model estimates option prices by considering the following variables: the current \n    stock price, the option's strike price, the time to option expiration, the risk-free interest rate, \n    and the volatility of the underlying asset.\n\n    Args:\n        S (float): The current price of the underlying asset.\n        K (float): The strike price of the option.\n        t (float): The time to expiration in years.\n        r (float): The annual risk-free interest rate, expressed as a decimal.\n        sigma (float): The volatility of the underlying asset, expressed as a decimal.\n\n    Returns:\n        C (float): The estimated price of the European call option.\n\n    Notes:\n        - Applicability: This function is used only for pricing European call options which \n          can only be exercised at expiration.\n        - Constraints: The function assumes that the underlying asset pays no dividends, \n          volatility and risk-free rate are constant, and the asset returns are normally distributed.\n        - Considerations: This model may not be accurate for American options or in volatile markets \n          that deviate from its assumptions.\n    \"\"\"\n    if t <= 0 or S <= 0 or K <= 0 or sigma <= 0:\n        raise ValueError(\"Time to expiration, stock price, strike price, and volatility must be positive.\")\n    \n    d1 = (math.log(S / K) + (r + 0.5 * sigma ** 2) * t) / (sigma * math.sqrt(t))\n    d2 = d1 - sigma * math.sqrt(t)\n    \n    C = S * norm.cdf(d1) - K * math.exp(-r * t) * norm.cdf(d2)\n    \n    return C",
            "def black_scholes_option_price(stock_price: float, strike_price: float, time_to_expiration: float, \n                               risk_free_rate: float, volatility: float, option_type: str = 'call') -> float:\n    \"\"\"\n    Calculate the theoretical price of a European option using the Black-Scholes model.\n\n    This function computes the price of European call or put options using the Black-Scholes formula\n    based on input variables such as the underlying stock price, strike price, time to expiration,\n    risk-free rate, and volatility. It assumes a log-normal distribution of stock prices.\n\n    Args:\n        stock_price (float): The current price of the underlying stock.\n        strike_price (float): The strike price of the option.\n        time_to_expiration (float): Time to expiration in years.\n        risk_free_rate (float): The risk-free interest rate as a decimal.\n        volatility (float): The standard deviation of the stock's returns (volatility).\n        option_type (str, optional): The type of option to price ('call' or 'put'). Default is 'call'.\n\n    Returns:\n        option_price (float): The theoretical price of the option.\n\n    Notes:\n        - Applicability: Applies to European options only; not applicable to American options.\n        - Constraints: Assumes constant volatility and risk-free rate, no dividends.\n        - Considerations: Option type must be 'call' or 'put'; otherwise, raises ValueError.\n    \"\"\"\n    from math import log, sqrt, exp\n    from scipy.stats import norm\n\n    if option_type not in ['call', 'put']:\n        raise ValueError(\"Option type must be either 'call' or 'put'.\")\n\n    d1 = (log(stock_price / strike_price) + (risk_free_rate + 0.5 * volatility ** 2) * time_to_expiration) / (volatility * sqrt(time_to_expiration))\n    d2 = d1 - volatility * sqrt(time_to_expiration)\n\n    if option_type == 'call':\n        option_price = (stock_price * norm.cdf(d1)) - (strike_price * exp(-risk_free_rate * time_to_expiration) * norm.cdf(d2))\n    else:  # 'put'\n        option_price = (strike_price * exp(-risk_free_rate * time_to_expiration) * norm.cdf(-d2)) - (stock_price * norm.cdf(-d1))\n\n    return option_price",
            "def calculate_black_scholes_call_price(S: float, K: float, r: float, T: float, volatility: float) -> float:\n    \"\"\"\n    Calculate the European call option price using the Black-Scholes model.\n\n    This function computes the price of a European call option based on the Black-Scholes\n    option pricing model. It considers the option's underlying stock price, strike price,\n    risk-free interest rate, time to maturity, and volatility.\n\n    Args:\n        S (float): Current stock price.\n        K (float): Strike price of the option.\n        r (float): Risk-free interest rate (as a decimal).\n        T (float): Time to maturity in years.\n        volatility (float): Annualized volatility of the stock's returns (as a decimal).\n\n    Returns:\n        call_price (float): The calculated call option price.\n\n    Notes:\n        - This function assumes that the underlying stock does not pay dividends.\n        - European options can only be exercised at the expiration date.\n        - The volatility parameter should be the annualized standard deviation of returns.\n    \"\"\"\n    from math import log, sqrt, exp\n    from scipy.stats import norm\n\n    d1 = (log(S / K) + (r + 0.5 * volatility ** 2) * T) / (volatility * sqrt(T))\n    d2 = d1 - volatility * sqrt(T)\n\n    call_price = S * norm.cdf(d1) - K * exp(-r * T) * norm.cdf(d2)\n    \n    return call_price"
        ],
        "usage": {
            "completion_tokens": 595,
            "prompt_tokens": 1697,
            "total_tokens": 2292,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-339",
        "article_title": "Vortex Indicator (VI)",
        "function": "def calculate_vortex_indicator(highs: list, lows: list, closes: list, parameter_length: int) -> tuple:\n    \"\"\"\n    Calculate the Vortex Indicator (VI) lines: VI+ and VI-.\n\n    This function computes the Vortex Indicator lines used to identify\n    trend reversals in financial markets. The indicator is comprised of\n    VI+ and VI-, which are derived from price data over a specified\n    parameter length.\n\n    Args:\n        highs (list): A list of high prices for each period.\n        lows (list): A list of low prices for each period.\n        closes (list): A list of closing prices for each period.\n        parameter_length (int): The number of periods to use for the calculation,\n                                typically between 14 and 30.\n\n    Returns:\n        vi_plus (list): The VI+ line values for each period, truncated by the parameter length.\n        vi_minus (list): The VI- line values for each period, truncated by the parameter length.\n\n    Notes:\n        - Applicability: This function can be used in technical analysis\n          for identifying potential trend reversals.\n        - Constraints: Ensure the length of highs, lows, and closes match\n          and are greater than the parameter_length.\n        - Considerations: To reduce false signals, a longer parameter length\n          may be used, especially in choppy market conditions.\n\n    Raises:\n        ValueError: If the parameter_length is less than 1 or greater than the\n        number of data points provided in highs, lows, or closes.\n    \"\"\"\n    if parameter_length < 1 or parameter_length > len(highs):\n        raise ValueError(\"Invalid parameter length for the given data.\")\n\n    true_ranges = []\n    vm_plus = []\n    vm_minus = []\n    for i in range(1, len(highs)):\n        true_range = max(highs[i] - lows[i], abs(highs[i] - closes[i - 1]), abs(lows[i] - closes[i - 1]))\n        true_ranges.append(true_range)\n\n        vm_plus.append(abs(highs[i] - lows[i - 1]))\n        vm_minus.append(abs(lows[i] - highs[i - 1]))\n\n    vi_plus = []\n    vi_minus = []\n    for i in range(parameter_length - 1, len(true_ranges)):\n        sum_tr = sum(true_ranges[i - parameter_length + 1:i + 1])\n        sum_vm_plus = sum(vm_plus[i - parameter_length + 1:i + 1])\n        sum_vm_minus = sum(vm_minus[i - parameter_length + 1:i + 1])\n\n        vi_plus.append(sum_vm_plus / sum_tr)\n        vi_minus.append(sum_vm_minus / sum_tr)\n\n    return vi_plus, vi_minus",
        "statistics": {
            "number_statistics": {
                "args_numbers": 4,
                "question_numbers": 0,
                "context_numbers": 56,
                "total_numbers": 56
            },
            "operator_statistics": {
                "operators": {
                    "+": 6,
                    "-": 13,
                    "*": 0,
                    "/": 2,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 21
            },
            "code_statistics": {
                "lines": 17,
                "parentheses": 34
            }
        },
        "difficulty": 6.570882962339585,
        "context": "An analyst is reviewing the stock price movement of a company for potential trend reversals using the Vortex Indicator (VI). The data for the past 18 days includes the highest price (highs), the lowest price (lows), and the closing price (closes) each day. The analyst decides to use a parameter length of 14 days to calculate the VI+ and VI- lines. The high prices recorded are [120, 122, 125, 123, 126, 124, 127, 129, 130, 128, 131, 133, 134, 135, 136, 137, 138, 139], the low prices are [118, 120, 121, 119, 123, 122, 124, 126, 127, 126, 128, 130, 131, 132, 133, 134, 135, 136], and the closing prices are [119, 121, 123, 120, 125, 123, 126, 128, 129, 127, 130, 132, 133, 134, 135, 136, 137, 138].",
        "question": "Using the given data, what is the last value of the VI+ line computed for the given parameter length? Provide your answer to four decimal places.",
        "python_solution": "def solution():\n    # Define the input data\n    highs = [120, 122, 125, 123, 126, 124, 127, 129, 130, 128, 131, 133, 134, 135, 136, 137, 138, 139]\n    lows = [118, 120, 121, 119, 123, 122, 124, 126, 127, 126, 128, 130, 131, 132, 133, 134, 135, 136]\n    closes = [119, 121, 123, 120, 125, 123, 126, 128, 129, 127, 130, 132, 133, 134, 135, 136, 137, 138]\n    parameter_length = 14\n    \n    # Calculate the true ranges and the Vortex Movement components\n    true_ranges = []\n    vm_plus = []\n    vm_minus = []\n    \n    for i in range(1, len(highs)):\n        true_range = max(highs[i] - lows[i], abs(highs[i] - closes[i - 1]), abs(lows[i] - closes[i - 1]))\n        true_ranges.append(true_range)\n        \n        vm_plus.append(abs(highs[i] - lows[i - 1]))\n        vm_minus.append(abs(lows[i] - highs[i - 1]))\n    \n    # Calculate the VI+ line\n    vi_plus = []\n    for i in range(parameter_length - 1, len(true_ranges)):\n        sum_tr = sum(true_ranges[i - parameter_length + 1:i + 1])\n        sum_vm_plus = sum(vm_plus[i - parameter_length + 1:i + 1])\n        \n        vi_plus_value = sum_vm_plus / sum_tr\n        vi_plus.append(vi_plus_value)\n    \n    # Return the last value of the VI+ line\n    return round(vi_plus[-1], 4)",
        "ground_truth": 1.2128,
        "source": "FinanceReasoning-test-12",
        "question_id": "test-2232",
        "level": "hard",
        "output": [
            "To solve the given problem, I will calculate the last value of the VI+ line using the provided `calculate_vortex_indicator` function. I'll utilize the steps below:\n\n### Step-by-step approach using Emphasizing Constraints (EC):\n\n**1. Constraints in the Problem:**\n   - The lengths of `highs`, `lows`, and `closes` must be equal and greater than the parameter length of 14 days.\n   - The VI+ value must be calculated and returned to four decimal places.\n\n**2. Analyze the function `calculate_vortex_indicator`:**\n   - The function takes the `highs`, `lows`, `closes`, and the `parameter_length` as inputs.\n   - It computes the True Range (TR), VM+ (Vortex Movement Plus), and VM- (Vortex Movement Minus) from price data for each period.\n   - It then calculates the VI+ and VI- for the range defined by the `parameter_length`.\n\n**3. Focus on the `VI+` Calculation:**\n   - The formula involves summing the `VM+` and `True Range` over the parameter length and dividing them:\n     \\[\n     VI^+ = \\frac{\\text{Sum of VM+ over parameter\\_length}}{\\text{Sum of TR over parameter\\_length}}\n     \\]\n   - We need to calculate the final (or last) value of the `VI+` series computed.\n\n**4. Inputs Validation:**\n   - The problem provides 18 days of `highs`, `lows`, and `closes` (greater than the parameter length of 14 days). Thus, the function can be safely used.\n\n**5. Program Implementation:**\n   - Pass the inputs `highs`, `lows`, `closes`, and `parameter_length = 14` to the `calculate_vortex_indicator` function.\n   - Extract the last value of the `VI+` list.\n   - Return the value truncated to four decimal places.\n\n### Python Implementation:\n```python\ndef solution():\n    # Define input data\n    highs = [120, 122, 125, 123, 126, 124, 127, 129, 130, 128, 131, 133, 134, 135, 136, 137, 138, 139]\n    lows = [118, 120, 121, 119, 123, 122, 124, 126, 127, 126, 128, 130, 131, 132, 133, 134, 135, 136]\n    closes = [119, 121, 123, 120, 125, 123, 126, 128, 129, 127, 130, 132, 133, 134, 135, 136, 137, 138]\n    parameter_length = 14\n    \n    # Utility function to calculate the Vortex Indicator\n    def calculate_vortex_indicator(highs, lows, closes, parameter_length):\n        if parameter_length < 1 or parameter_length > len(highs):\n            raise ValueError(\"Invalid parameter length for the given data.\")\n\n        true_ranges = []\n        vm_plus = []\n        vm_minus = []\n        for i in range(1, len(highs)):\n            true_range = max(highs[i] - lows[i], \n                             abs(highs[i] - closes[i - 1]), \n                             abs(lows[i] - closes[i - 1]))\n            true_ranges.append(true_range)\n\n            vm_plus.append(abs(highs[i] - lows[i - 1]))\n            vm_minus.append(abs(lows[i] - highs[i - 1]))\n\n        vi_plus = []\n        vi_minus = []\n        for i in range(parameter_length - 1, len(true_ranges)):\n            sum_tr = sum(true_ranges[i - parameter_length + 1:i + 1])\n            sum_vm_plus = sum(vm_plus[i - parameter_length + 1:i + 1])\n            sum_vm_minus = sum(vm_minus[i - parameter_length + 1:i + 1])\n\n            vi_plus.append(sum_vm_plus / sum_tr)\n            vi_minus.append(sum_vm_minus / sum_tr)\n\n        return vi_plus, vi_minus\n\n    # Perform calculations to get VI+ and VI- lines\n    vi_plus, vi_minus = calculate_vortex_indicator(highs, lows, closes, parameter_length)\n    \n    # Retrieve the last value of the VI+ line and round to four decimal places\n    answer = round(vi_plus[-1], 4)\n    \n    # Return the result\n    return answer\n```"
        ],
        "retrieval_query": "Using the given data, what is the last value of the VI+ line computed for the given parameter length? Provide your answer to four decimal places.",
        "useful_functions": [
            "def calculate_vortex_indicator(highs: list, lows: list, closes: list, parameter_length: int) -> tuple:\n    \"\"\"\n    Calculate the Vortex Indicator (VI) lines: VI+ and VI-.\n\n    This function computes the Vortex Indicator lines used to identify\n    trend reversals in financial markets. The indicator is comprised of\n    VI+ and VI-, which are derived from price data over a specified\n    parameter length.\n\n    Args:\n        highs (list): A list of high prices for each period.\n        lows (list): A list of low prices for each period.\n        closes (list): A list of closing prices for each period.\n        parameter_length (int): The number of periods to use for the calculation,\n                                typically between 14 and 30.\n\n    Returns:\n        vi_plus (list): The VI+ line values for each period, truncated by the parameter length.\n        vi_minus (list): The VI- line values for each period, truncated by the parameter length.\n\n    Notes:\n        - Applicability: This function can be used in technical analysis\n          for identifying potential trend reversals.\n        - Constraints: Ensure the length of highs, lows, and closes match\n          and are greater than the parameter_length.\n        - Considerations: To reduce false signals, a longer parameter length\n          may be used, especially in choppy market conditions.\n\n    Raises:\n        ValueError: If the parameter_length is less than 1 or greater than the\n        number of data points provided in highs, lows, or closes.\n    \"\"\"\n    if parameter_length < 1 or parameter_length > len(highs):\n        raise ValueError(\"Invalid parameter length for the given data.\")\n\n    true_ranges = []\n    vm_plus = []\n    vm_minus = []\n    for i in range(1, len(highs)):\n        true_range = max(highs[i] - lows[i], abs(highs[i] - closes[i - 1]), abs(lows[i] - closes[i - 1]))\n        true_ranges.append(true_range)\n\n        vm_plus.append(abs(highs[i] - lows[i - 1]))\n        vm_minus.append(abs(lows[i] - highs[i - 1]))\n\n    vi_plus = []\n    vi_minus = []\n    for i in range(parameter_length - 1, len(true_ranges)):\n        sum_tr = sum(true_ranges[i - parameter_length + 1:i + 1])\n        sum_vm_plus = sum(vm_plus[i - parameter_length + 1:i + 1])\n        sum_vm_minus = sum(vm_minus[i - parameter_length + 1:i + 1])\n\n        vi_plus.append(sum_vm_plus / sum_tr)\n        vi_minus.append(sum_vm_minus / sum_tr)\n\n    return vi_plus, vi_minus"
        ],
        "usage": {
            "completion_tokens": 962,
            "prompt_tokens": 1187,
            "total_tokens": 2149,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-1073",
        "article_title": "Home Mortgage Interest Deduction",
        "function": "def calculate_mortgage_interest_deduction(mortgage_amount: float, is_secured: bool, loan_date: str, filing_status: str) -> float:\n    \"\"\"\n    Calculate the deductible mortgage interest based on loan details and filing status.\n\n    This function calculates the deductible amount of mortgage interest for tax purposes, considering the limits\n    imposed by the Tax Cuts and Jobs Act of 2017 and other IRS rules for different mortgage issuance dates and filing statuses.\n\n    Args:\n        mortgage_amount (float): The total mortgage amount remaining.\n        is_secured (bool): Whether the mortgage is a secured debt.\n        loan_date (str): The date the mortgage was issued, formatted as 'YYYY-MM-DD'.\n        filing_status (str): The filing status of the taxpayer ('single', 'married_jointly', or 'married_separately').\n\n    Returns:\n        deductible_interest (float): The portion of mortgage interest payments that is deductible.\n\n    Notes:\n        - Applicability: For homeowners itemizing deductions and claiming mortgage interest.\n        - Constraints: Mortgage must be secured by the home. Loan date affects deduction limits.\n        - Considerations: Future changes in tax law can alter deduction limits.\n    \"\"\"\n    # Define deduction limits based on filing status and loan date\n    dates_limits = {\n        ('single', 'before_1987-10-13'): float('inf'),  # Unlimited before 1987\n        ('single', '1987-10-13_to_2017-12-15'): 1_000_000,\n        ('single', 'after_2017-12-15'): 750_000,\n        ('married_jointly', 'before_1987-10-13'): float('inf'),\n        ('married_jointly', '1987-10-13_to_2017-12-15'): 1_000_000,\n        ('married_jointly', 'after_2017-12-15'): 750_000,\n        ('married_separately', 'before_1987-10-13'): float('inf'),\n        ('married_separately', '1987-10-13_to_2017-12-15'): 500_000,\n        ('married_separately', 'after_2017-12-15'): 375_000,\n    }\n    \n    # Determine date range for the loan\n    if loan_date < '1987-10-13':\n        date_range = 'before_1987-10-13'\n    elif '1987-10-13' <= loan_date <= '2017-12-15':\n        date_range = '1987-10-13_to_2017-12-15'\n    else:\n        date_range = 'after_2017-12-15'\n\n    # Calculate deductible interest based on secured status and limits\n    if not is_secured:\n        raise ValueError(\"Mortgage must be secured to qualify for interest deduction.\")\n    \n    limit = dates_limits.get((filing_status, date_range))\n    \n    deductible_interest = min(mortgage_amount, limit)\n\n    return deductible_interest",
        "statistics": {
            "number_statistics": {
                "args_numbers": 4,
                "question_numbers": 0,
                "context_numbers": 2,
                "total_numbers": 2
            },
            "operator_statistics": {
                "operators": {
                    "+": 0,
                    "-": 24,
                    "*": 0,
                    "/": 0,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 24
            },
            "code_statistics": {
                "lines": 16,
                "parentheses": 30
            }
        },
        "difficulty": 6.6120410348330925,
        "context": "Emily purchased a home with a secured mortgage of $850,000 on January 10, 2018. She is filing her taxes as 'married_jointly' this year. Emily is curious about the deductible amount of mortgage interest for her loan under the current IRS rules and limits established by the Tax Cuts and Jobs Act of 2017.",
        "question": "What is the maximum deductible mortgage interest amount that Emily can claim on her taxes? Answer in dollars to the nearest integer.",
        "python_solution": "def solution():\n    # Define the problem variables\n    mortgage_amount = 850000\n    is_secured = True\n    loan_date = \"2018-01-10\"\n    filing_status = \"married_jointly\"\n    \n    # Determine deduction limits based on filing status and loan date\n    dates_limits = {\n        ('married_jointly', 'before_1987-10-13'): float('inf'),\n        ('married_jointly', '1987-10-13_to_2017-12-15'): 1_000_000,\n        ('married_jointly', 'after_2017-12-15'): 750_000,\n    }\n    \n    # Determine date range for the loan\n    if loan_date < '1987-10-13':\n        date_range = 'before_1987-10-13'\n    elif '1987-10-13' <= loan_date <= '2017-12-15':\n        date_range = '1987-10-13_to_2017-12-15'\n    else:\n        date_range = 'after_2017-12-15'\n    \n    # Check if the mortgage is secured\n    if not is_secured:\n        raise ValueError(\"Mortgage must be secured to qualify for interest deduction.\")\n    \n    # Obtain the relevant limit\n    limit = dates_limits.get((filing_status, date_range), 0)\n    \n    # Calculate the deductible interest\n    deductible_interest = min(mortgage_amount, limit)\n    \n    # Return the deductible interest rounded to the nearest integer\n    return round(deductible_interest)\n\n# The solution function would compute the result based on the given problem specifics",
        "ground_truth": 750000,
        "source": "FinanceReasoning-test-14",
        "question_id": "test-2233",
        "level": "hard",
        "output": [
            "### Step-by-step Reasoning:\n\n1. **Understand IRS Rules and Limits**:\n   - Under the Tax Cuts and Jobs Act (TCJA) of 2017, the IRS establishes rules for deduction of mortgage interest for those filing jointly. \n   - The TCJA limits the mortgage interest deduction for new loans taken out after December 15, 2017, to **interest on up to $750,000 of mortgage debt**.\n   - Loans taken out before December 15, 2017, maintain the previous limit of **interest on up to $1,000,000 of mortgage debt**.\n   \n2. **Emphasize Constraints (EC)**:\n   - Emily filed her taxes as 'married_jointly'.\n   - Emily's mortgage is from January 10, 2018 (post TCJA cut-off date).\n   - Therefore, the maximum debt amount qualifying for interest deduction is **$750,000**.\n   - Emily's actual mortgage loan amount is $850,000, which exceeds the $750,000 limit. Hence, only interest on $750,000 of debt is deductible.\n\n3. **Objective**:\n   - Determine the deductible mortgage interest amount in dollars under IRS rules, adhering to the above constraints.\n\n4. **Key Takeaways**:\n   - Only the interest on the first $750,000 of Emily's $850,000 mortgage is deductible.\n   - The IRS does not provide limits on actual interest rates or amounts explicitly; the deduction is capped based on the qualifying debt amount.\n\n### Python Program:\nThe problem does not specify the actual interest Emily paid, but under the constraints, we only determine the deductible amount **with respect to the debt limit of $750,000**.\n\nHere\u2019s how we write a Python function for this fixed input condition:\n\n```python\ndef solution():\n    # Define variables name and value\n    max_qualifying_debt = 750000  # IRS limit for post-TCJA mortgages (in USD)\n    \n    # The maximum deductible mortgage interest is determined by the qualifying debt limit\n    deductible_interest = max_qualifying_debt\n    \n    # Return the answer, rounded to nearest integer\n    return round(deductible_interest)\n```\n\nThis program simply defines the maximum deductible limit based on the qualifying conditions in the problem and returns the dollar value."
        ],
        "retrieval_query": "What is the maximum deductible mortgage interest amount that Emily can claim on her taxes? Answer in dollars to the nearest integer.",
        "useful_functions": [
            "def calculate_revenue_ton_miles_without_increase(initial_rate: float, adjusted_rate: float) -> int:\n    \"\"\"\n    Calculate the hypothetical revenue ton-miles without changes in carloads and mix, given two rates.\n\n    This function determines what the revenue ton-miles would have been without the impact of increased carloads \n    and mix changes by calculating the difference between two known rates and adjusting accordingly.\n\n    Args:\n        initial_rate (float): The known revenue ton-miles growth rate for the initial period.\n        adjusted_rate (float): The adjusted revenue ton-miles growth rate affected by carloads and mix changes.\n\n    Returns:\n        hypothetical_revenue_ton_miles (int): The calculated hypothetical revenue ton-miles, rounded to the nearest integer.\n\n    Notes:\n        - Applicability: Useful in scenarios where you need to isolate the effect of specific variables on ton-mile calculations.\n        - Constraints: The rates should represent proportional changes expressed as decimal (e.g., 0.05 for a 5% increase).\n        - Considerations: Ensure that rates accurately reflect the desired temporal comparison and adjustments.\n    \"\"\"\n    revenue_ton_miles_change = initial_rate - adjusted_rate\n    hypothetical_revenue_ton_miles = revenue_ton_miles_change * 100\n    \n    return round(hypothetical_revenue_ton_miles)"
        ],
        "usage": {
            "completion_tokens": 476,
            "prompt_tokens": 705,
            "total_tokens": 1181,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-999",
        "article_title": "80-10-10 Mortgage",
        "function": "def calculate_80_10_10_mortgage(home_value: float, first_mortgage_rate: float, \n                               second_mortgage_rate: float, first_term_years: int, \n                               second_term_years: int) -> dict:\n    \"\"\"\n    Calculate the details of an 80-10-10 mortgage, including monthly payments and \n    total cost for the first and second mortgages.\n\n    This function computes the initial and second mortgage amounts based on the \n    80-10-10 mortgage rule, along with their respective monthly payments and \n    total payment over the loan term.\n\n    Args:\n        home_value (float): The total purchase price of the home.\n        first_mortgage_rate (float): Annual interest rate for the first mortgage.\n        second_mortgage_rate (float): Annual interest rate for the second mortgage.\n        first_term_years (int): The term of the first mortgage in years.\n        second_term_years (int): The term of the second mortgage in years.\n\n    Returns:\n        mortgage_details (dict): A dictionary containing the mortgage amounts, \n        monthly payments, and total payments for both the first and second loans.\n        {\n            'first_mortgage_amount': float,\n            'second_mortgage_amount': float,\n            'first_mortgage_monthly_payment': float,\n            'second_mortgage_monthly_payment': float,\n            'first_mortgage_total_payment': float,\n            'second_mortgage_total_payment': float\n        }\n\n    Notes:\n        - This function does not factor in taxes, PMI, or insurance costs.\n        - Monthly payments are calculated using a standard amortizing loan formula.\n        - Ensure interest rates are expressed as decimals (e.g., 5% as 0.05).\n    \"\"\"\n    # Constants for the 80-10-10 rule\n    down_payment_ratio = 0.10\n    first_mortgage_ratio = 0.80\n    second_mortgage_ratio = 0.10\n\n    # Calculate mortgage amounts\n    first_mortgage_amount = home_value * first_mortgage_ratio\n    second_mortgage_amount = home_value * second_mortgage_ratio\n\n    # Convert annual rates to monthly\n    first_monthly_rate = first_mortgage_rate / 12\n    second_monthly_rate = second_mortgage_rate / 12\n\n    # Convert terms in years to total payments\n    first_total_payments = first_term_years * 12\n    second_total_payments = second_term_years * 12\n\n    # Calculate monthly payments using the formula for an amortizing loan\n    first_mortgage_monthly_payment = (first_mortgage_amount * first_monthly_rate) / \\\n        (1 - (1 + first_monthly_rate) ** -first_total_payments)\n    \n    second_mortgage_monthly_payment = (second_mortgage_amount * second_monthly_rate) / \\\n        (1 - (1 + second_monthly_rate) ** -second_total_payments)\n\n    # Calculate total payments\n    first_mortgage_total_payment = first_mortgage_monthly_payment * first_total_payments\n    second_mortgage_total_payment = second_mortgage_monthly_payment * second_total_payments\n\n    return {\n        'first_mortgage_amount': first_mortgage_amount,\n        'second_mortgage_amount': second_mortgage_amount,\n        'first_mortgage_monthly_payment': first_mortgage_monthly_payment,\n        'second_mortgage_monthly_payment': second_mortgage_monthly_payment,\n        'first_mortgage_total_payment': first_mortgage_total_payment,\n        'second_mortgage_total_payment': second_mortgage_total_payment\n    }",
        "statistics": {
            "number_statistics": {
                "args_numbers": 5,
                "question_numbers": 0,
                "context_numbers": 11,
                "total_numbers": 11
            },
            "operator_statistics": {
                "operators": {
                    "+": 2,
                    "-": 6,
                    "*": 8,
                    "/": 4,
                    "%": 0,
                    "**": 2
                },
                "total_operators": 22
            },
            "code_statistics": {
                "lines": 29,
                "parentheses": 12
            }
        },
        "difficulty": 6.646390514847729,
        "context": "You are considering purchasing a home priced at $500,000 using an 80-10-10 mortgage structure. This means you'll have an 80% first mortgage, a 10% second mortgage, and a 10% down payment. The first mortgage has an annual interest rate of 3.5% with a term of 30 years, and the second mortgage has an annual interest rate of 6.0% with a term of 15 years. You are evaluating the monthly costs associated with this financing structure to determine if it fits within your budget.",
        "question": "What will be the total monthly payment for both the first and second mortgages combined? Answer to the nearest dollar.",
        "python_solution": "def solution():\n    # Home purchase price and mortgage details\n    home_value = 500000  # Home price in dollars\n    first_mortgage_rate = 0.035  # Annual interest rate for the first mortgage\n    second_mortgage_rate = 0.060  # Annual interest rate for the second mortgage\n    first_term_years = 30  # Term for the first mortgage in years\n    second_term_years = 15  # Term for the second mortgage in years\n\n    # 80% loan (first mortgage), 10% equity (second mortgage), 10% down payment\n    first_mortgage_amount = home_value * 0.80\n    second_mortgage_amount = home_value * 0.10\n\n    # Convert annual rates to monthly rates\n    first_monthly_rate = first_mortgage_rate / 12\n    second_monthly_rate = second_mortgage_rate / 12\n\n    # Convert years to number of monthly payments\n    first_total_payments = first_term_years * 12\n    second_total_payments = second_term_years * 12\n\n    # Calculate monthly payments for each mortgage\n    first_mortgage_monthly_payment = (first_mortgage_amount * first_monthly_rate) / \\\n        (1 - (1 + first_monthly_rate) ** -first_total_payments)\n    \n    second_mortgage_monthly_payment = (second_mortgage_amount * second_monthly_rate) / \\\n        (1 - (1 + second_monthly_rate) ** -second_total_payments)\n\n    # Calculate total monthly payment\n    total_monthly_payment = first_mortgage_monthly_payment + second_mortgage_monthly_payment\n\n    # Return the total monthly payment rounded to the nearest dollar\n    return round(total_monthly_payment)",
        "ground_truth": 2218,
        "source": "FinanceReasoning-test-18",
        "question_id": "test-2234",
        "level": "hard",
        "output": [
            "### Step-by-Step Reasoning with Emphasizing Constraints (EC)\n\n1. **Understand the Problem and Key Constraints**:\n   - The home price is $500,000.\n   - The financing uses an 80-10-10 structure:\n     - 80% of the price: first mortgage.\n     - 10% of the price: second mortgage.\n     - 10% down payment (irrelevant to monthly payments, but subtracting this ensures accuracy).\n   - First mortgage details: 3.5% annual interest rate, 30 years.\n   - Second mortgage details: 6.0% annual interest rate, 15 years.\n   - Monthly payments for both mortgages are calculated separately and then combined.\n   - Use a standard amortization formula for monthly payments.\n\n2. **Key Constraints to Adhere To**:\n   - Interest rates are annual but must be converted to monthly rates for computation.\n   - Amortization formula must ensure all terms are consistent (e.g., monthly rates, monthly periods).\n   - Answer must be rounded to the nearest dollar for the final solution.\n\n3. **Amortization Formula**:\n   For a loan:\n   \\[\n   M = \\frac{P \\cdot r}{1 - (1 + r)^{-n}}\n   \\]\n   Where:\n   - \\(M\\) = Monthly payment.\n   - \\(P\\) = Loan principal.\n   - \\(r\\) = Monthly interest rate (annual rate divided by 12).\n   - \\(n\\) = Total number of payments (term in years multiplied by 12).\n\n4. **Derive Calculations**:\n   - First mortgage:\n     \\[\n     P_1 = \\text{home\\_value} \\times 0.80,\\, r_1 = \\frac{\\text{first\\_mortgage\\_rate}}{12},\\, n_1 = \\text{first\\_term\\_years} \\times 12\n     \\]\n     Use the amortization formula to find \\(M_1\\).\n   - Second mortgage:\n     \\[\n     P_2 = \\text{home\\_value} \\times 0.10,\\, r_2 = \\frac{\\text{second\\_mortgage\\_rate}}{12},\\, n_2 = \\text{second\\_term\\_years} \\times 12\n     \\]\n     Use the amortization formula to find \\(M_2\\).\n\n5. **Combine Results**:\n   - Add the monthly payments for both mortgages (\\(M = M_1 + M_2\\)) and round to the nearest dollar.\n\n### Python Solution:\n```python\ndef solution():\n    # Define variables\n    home_value = 500000  # Home price\n    first_mortgage_rate = 0.035  # 3.5% annual interest rate\n    second_mortgage_rate = 0.06  # 6.0% annual interest rate\n    first_term_years = 30  # First mortgage duration in years\n    second_term_years = 15  # Second mortgage duration in years\n\n    # Mortgage ratios\n    first_mortgage_ratio = 0.80\n    second_mortgage_ratio = 0.10\n\n    # Loan amounts\n    first_mortgage_amount = home_value * first_mortgage_ratio  # First mortgage amount\n    second_mortgage_amount = home_value * second_mortgage_ratio  # Second mortgage amount\n\n    # Convert interest rates to monthly rates\n    first_monthly_rate = first_mortgage_rate / 12\n    second_monthly_rate = second_mortgage_rate / 12\n\n    # Convert loan terms to total number of payments\n    first_total_payments = first_term_years * 12\n    second_total_payments = second_term_years * 12\n\n    # Calculate monthly payment for first mortgage using amortization formula\n    first_mortgage_monthly_payment = (first_mortgage_amount * first_monthly_rate) / \\\n        (1 - (1 + first_monthly_rate) ** -first_total_payments)\n    \n    # Calculate monthly payment for second mortgage using amortization formula\n    second_mortgage_monthly_payment = (second_mortgage_amount * second_monthly_rate) / \\\n        (1 - (1 + second_monthly_rate) ** -second_total_payments)\n\n    # Total monthly payment\n    total_monthly_payment = first_mortgage_monthly_payment + second_mortgage_monthly_payment\n\n    # Round to the nearest dollar and return\n    return round(total_monthly_payment)\n```"
        ],
        "retrieval_query": "What will be the total monthly payment for both the first and second mortgages combined? Answer to the nearest dollar.",
        "useful_functions": [
            "def calculate_80_10_10_mortgage(home_value: float, first_mortgage_rate: float, \n                               second_mortgage_rate: float, first_term_years: int, \n                               second_term_years: int) -> dict:\n    \"\"\"\n    Calculate the details of an 80-10-10 mortgage, including monthly payments and \n    total cost for the first and second mortgages.\n\n    This function computes the initial and second mortgage amounts based on the \n    80-10-10 mortgage rule, along with their respective monthly payments and \n    total payment over the loan term.\n\n    Args:\n        home_value (float): The total purchase price of the home.\n        first_mortgage_rate (float): Annual interest rate for the first mortgage.\n        second_mortgage_rate (float): Annual interest rate for the second mortgage.\n        first_term_years (int): The term of the first mortgage in years.\n        second_term_years (int): The term of the second mortgage in years.\n\n    Returns:\n        mortgage_details (dict): A dictionary containing the mortgage amounts, \n        monthly payments, and total payments for both the first and second loans.\n        {\n            'first_mortgage_amount': float,\n            'second_mortgage_amount': float,\n            'first_mortgage_monthly_payment': float,\n            'second_mortgage_monthly_payment': float,\n            'first_mortgage_total_payment': float,\n            'second_mortgage_total_payment': float\n        }\n\n    Notes:\n        - This function does not factor in taxes, PMI, or insurance costs.\n        - Monthly payments are calculated using a standard amortizing loan formula.\n        - Ensure interest rates are expressed as decimals (e.g., 5% as 0.05).\n    \"\"\"\n    # Constants for the 80-10-10 rule\n    down_payment_ratio = 0.10\n    first_mortgage_ratio = 0.80\n    second_mortgage_ratio = 0.10\n\n    # Calculate mortgage amounts\n    first_mortgage_amount = home_value * first_mortgage_ratio\n    second_mortgage_amount = home_value * second_mortgage_ratio\n\n    # Convert annual rates to monthly\n    first_monthly_rate = first_mortgage_rate / 12\n    second_monthly_rate = second_mortgage_rate / 12\n\n    # Convert terms in years to total payments\n    first_total_payments = first_term_years * 12\n    second_total_payments = second_term_years * 12\n\n    # Calculate monthly payments using the formula for an amortizing loan\n    first_mortgage_monthly_payment = (first_mortgage_amount * first_monthly_rate) / \\\n        (1 - (1 + first_monthly_rate) ** -first_total_payments)\n    \n    second_mortgage_monthly_payment = (second_mortgage_amount * second_monthly_rate) / \\\n        (1 - (1 + second_monthly_rate) ** -second_total_payments)\n\n    # Calculate total payments\n    first_mortgage_total_payment = first_mortgage_monthly_payment * first_total_payments\n    second_mortgage_total_payment = second_mortgage_monthly_payment * second_total_payments\n\n    return {\n        'first_mortgage_amount': first_mortgage_amount,\n        'second_mortgage_amount': second_mortgage_amount,\n        'first_mortgage_monthly_payment': first_mortgage_monthly_payment,\n        'second_mortgage_monthly_payment': second_mortgage_monthly_payment,\n        'first_mortgage_total_payment': first_mortgage_total_payment,\n        'second_mortgage_total_payment': second_mortgage_total_payment\n    }"
        ],
        "usage": {
            "completion_tokens": 963,
            "prompt_tokens": 1248,
            "total_tokens": 2211,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-1623",
        "article_title": "Day-Count Convention",
        "function": "def calculate_accrued_interest(start_date: str, end_date: str, nominal_rate: float, principal: float, convention: str) -> float:\n    \"\"\"\n    Calculate the accrued interest for a financial instrument using specified day-count conventions.\n\n    This function computes the accrued interest between two dates based on the nominal interest rate,\n    principal amount, and the selected day-count convention. It supports multiple conventions such as\n    30/360, 30/365, actual/360, actual/365, and actual/actual.\n\n    Args:\n        start_date (str): The start date in 'YYYY-MM-DD' format.\n        end_date (str): The end date in 'YYYY-MM-DD' format.\n        nominal_rate (float): The annual nominal interest rate (as a decimal, e.g., 0.05 for 5%).\n        principal (float): The principal amount on which interest is calculated.\n        convention (str): The day-count convention to use ('30/360', '30/365', 'actual/360', 'actual/365', 'actual/actual').\n\n    Returns:\n        accrued_interest (float): The calculated accrued interest over the period defined by the start and end dates.\n\n    Notes:\n        - Applicability: This function is applicable for bonds, swaps, and similar financial instruments.\n        - Constraints: The date inputs must be in 'YYYY-MM-DD' format, and the convention must be a recognized value.\n        - Considerations: Ensure that start_date precedes end_date for correct calculation.\n    \"\"\"\n    from datetime import datetime\n\n    date_format = \"%Y-%m-%d\"\n    start = datetime.strptime(start_date, date_format)\n    end = datetime.strptime(end_date, date_format)\n    \n    day_count = (end - start).days\n    year_days = 0\n    \n    if convention == '30/360':\n        year_days = 360\n        month_diff = (end.year - start.year) * 12 + (end.month - start.month)\n        day_count = 30 * month_diff + (min(30, end.day) - min(30, start.day))\n    elif convention == '30/365':\n        year_days = 365\n        month_diff = (end.year - start.year) * 12 + (end.month - start.month)\n        day_count = 30 * month_diff + (min(30, end.day) - min(30, start.day))\n    elif convention == 'actual/360':\n        year_days = 360\n    elif convention == 'actual/365':\n        year_days = 365\n    elif convention == 'actual/actual':\n        year_days = 365 if (end.year % 4 == 0 and (end.year % 100 != 0 or end.year % 400 == 0)) else 366\n\n    accrued_interest = (nominal_rate * principal * day_count) / year_days\n    return accrued_interest",
        "statistics": {
            "number_statistics": {
                "args_numbers": 5,
                "question_numbers": 2,
                "context_numbers": 5,
                "total_numbers": 7
            },
            "operator_statistics": {
                "operators": {
                    "+": 4,
                    "-": 9,
                    "*": 6,
                    "/": 6,
                    "%": 6,
                    "**": 0
                },
                "total_operators": 31
            },
            "code_statistics": {
                "lines": 22,
                "parentheses": 32
            }
        },
        "difficulty": 7.071573364211532,
        "context": "A bondholder has invested in a corporate bond with a nominal annual interest rate of 7% and a principal amount of $200,000. The bond follows the 'actual/365' day-count convention to calculate interest accrual. The bondholder wants to calculate the accrued interest between March 1, 2023, and September 1, 2023. This information is crucial for the bondholder to understand the interest accrued over six months of ownership to assess their investment performance.",
        "question": "What is the amount of accrued interest from March 1, 2023, to September 1, 2023, on the bond? Answer to the nearest cent.",
        "python_solution": "def solution():\n    from datetime import datetime\n\n    # Define variables and their values\n    start_date = \"2023-03-01\"\n    end_date = \"2023-09-01\"\n    nominal_rate = 0.07\n    principal = 200000\n    convention = \"actual/365\"\n\n    # Convert date strings to date objects\n    date_format = \"%Y-%m-%d\"\n    start = datetime.strptime(start_date, date_format)\n    end = datetime.strptime(end_date, date_format)\n\n    # Calculate the number of days between the dates\n    day_count = (end - start).days\n    year_days = 365\n\n    # Calculate the accrued interest based on the 'actual/365' convention\n    accrued_interest = (nominal_rate * principal * day_count) / year_days\n\n    # Return the accrued interest, rounded to the nearest cent\n    return round(accrued_interest, 2)",
        "ground_truth": 7057.53,
        "source": "FinanceReasoning-test-7",
        "question_id": "test-2235",
        "level": "hard",
        "output": [
            "### Step-by-Step Reasoning\n\n1. **Understand the given problem and requirements**:\n   - A corporate bond accrues interest between **March 1, 2023** and **September 1, 2023**.\n   - The bond has a **nominal annual interest rate** of 7% (0.07 in decimal form), a **principal amount** of $200,000, and follows the \"Actual/365\" **day-count convention**.\n\n2. **Constraints (Emphasizing Constraints - EC)**:\n   - The day-count convention is **Actual/365**, so I will compute the number of actual days (not assuming uniform months or years), and divide by 365 for the year length.\n   - Input-Output format precision: Compute the **accrued interest to the nearest cent**, which means using floating-point arithmetic rounded to two decimal places.\n   - Correct date format compliance: The provided dates are in `YYYY-MM-DD` format.\n\n3. **Steps to calculate accrued interest**:\n   - **Step 1**: Compute the actual number of days between **March 1, 2023** and **September 1, 2023**.\n   - **Step 2**: Use the \"actual/365\" formula:  \n     \\[\n     \\text{Accrued Interest} = \\frac{\\text{Nominal Rate} \\times \\text{Principal} \\times \\text{Number of Days}}{365}\n     \\]\n   - **Step 3**: Round the final accrued interest to two decimal places.\n\n4. **Implementation Plan**:\n   - Import the `datetime` library to calculate the number of days between two dates.\n   - Define constants for principal, nominal rate, and dates.\n   - Implement the \"Actual/365\" interest calculation formula.\n\n### Python Program\n```python\ndef solution():\n    from datetime import datetime  # Import datetime for date calculations\n\n    # Define variables\n    start_date = \"2023-03-01\"\n    end_date = \"2023-09-01\"\n    nominal_rate = 0.07  # Annual interest rate as a decimal\n    principal = 200000.0  # Principal amount in dollars\n    convention = \"actual/365\"  # Day-count convention\n\n    # Step 1: Calculate the day count (actual days between start_date and end_date)\n    date_format = \"%Y-%m-%d\"  # Define the date format\n    start = datetime.strptime(start_date, date_format)\n    end = datetime.strptime(end_date, date_format)\n    day_count = (end - start).days  # Actual number of days\n\n    # Step 2: Calculate accrued interest using the \"actual/365\" formula\n    year_days = 365  # Number of days in the year for \"actual/365\"\n    accrued_interest = (nominal_rate * principal * day_count) / year_days\n\n    # Step 3: Return the accrued interest rounded to the nearest cent\n    return round(accrued_interest, 2)\n```\n\n### Explanation of Code\n1. **Calculate the day count**: Use `datetime` to find the difference in days (`end - start`) between the two dates.\n2. **Use the Actual/365 formula**: Plug in the values for nominal rate, principal, day count, and `365`, then compute the interest.\n3. **Round to 2 decimal places**: Ensure the result is returned to the nearest cent to comply with financial precision standards.\n\n### Output\nThe function will return the accrued interest between **March 1, 2023**, and **September 1, 2023**, in dollars rounded to two decimal places."
        ],
        "retrieval_query": "What is the amount of accrued interest from March 1, 2023, to September 1, 2023, on the bond? Answer to the nearest cent.",
        "useful_functions": [
            "def calculate_accrued_interest(start_date: str, end_date: str, nominal_rate: float, principal: float, convention: str) -> float:\n    \"\"\"\n    Calculate the accrued interest for a financial instrument using specified day-count conventions.\n\n    This function computes the accrued interest between two dates based on the nominal interest rate,\n    principal amount, and the selected day-count convention. It supports multiple conventions such as\n    30/360, 30/365, actual/360, actual/365, and actual/actual.\n\n    Args:\n        start_date (str): The start date in 'YYYY-MM-DD' format.\n        end_date (str): The end date in 'YYYY-MM-DD' format.\n        nominal_rate (float): The annual nominal interest rate (as a decimal, e.g., 0.05 for 5%).\n        principal (float): The principal amount on which interest is calculated.\n        convention (str): The day-count convention to use ('30/360', '30/365', 'actual/360', 'actual/365', 'actual/actual').\n\n    Returns:\n        accrued_interest (float): The calculated accrued interest over the period defined by the start and end dates.\n\n    Notes:\n        - Applicability: This function is applicable for bonds, swaps, and similar financial instruments.\n        - Constraints: The date inputs must be in 'YYYY-MM-DD' format, and the convention must be a recognized value.\n        - Considerations: Ensure that start_date precedes end_date for correct calculation.\n    \"\"\"\n    from datetime import datetime\n\n    date_format = \"%Y-%m-%d\"\n    start = datetime.strptime(start_date, date_format)\n    end = datetime.strptime(end_date, date_format)\n    \n    day_count = (end - start).days\n    year_days = 0\n    \n    if convention == '30/360':\n        year_days = 360\n        month_diff = (end.year - start.year) * 12 + (end.month - start.month)\n        day_count = 30 * month_diff + (min(30, end.day) - min(30, start.day))\n    elif convention == '30/365':\n        year_days = 365\n        month_diff = (end.year - start.year) * 12 + (end.month - start.month)\n        day_count = 30 * month_diff + (min(30, end.day) - min(30, start.day))\n    elif convention == 'actual/360':\n        year_days = 360\n    elif convention == 'actual/365':\n        year_days = 365\n    elif convention == 'actual/actual':\n        year_days = 365 if (end.year % 4 == 0 and (end.year % 100 != 0 or end.year % 400 == 0)) else 366\n\n    accrued_interest = (nominal_rate * principal * day_count) / year_days\n    return accrued_interest"
        ],
        "usage": {
            "completion_tokens": 769,
            "prompt_tokens": 1073,
            "total_tokens": 1842,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-501",
        "article_title": "Keltner Channel",
        "function": "def calculate_keltner_channel(prices: list, period_ema: int = 20, period_atr: int = 20, multiplier: float = 2.0) -> dict:\n    \"\"\"\n    Calculate the Keltner Channel for a given list of prices.\n\n    This function computes the Keltner Channel lines, including the middle line (EMA),\n    upper band, and lower band, based on the exponential moving average (EMA)\n    and average true range (ATR) of the provided prices. Keltner Channels are used \n    in technical analysis to determine trend directions and potential trade signals.\n\n    Args:\n        prices (list): A list of asset prices used to calculate the Keltner Channel.\n        period_ema (int): The number of periods for computing the EMA (default is 20).\n        period_atr (int): The number of periods for computing the ATR (default is 20).\n        multiplier (float): The multiplier for the ATR to determine band distance (default is 2.0).\n\n    Returns:\n        keltner_channel (dict): A dictionary containing the middle line, upper band, and lower band\n                               of the Keltner Channel, keys being 'middle_line', 'upper_band', and 'lower_band'.\n\n    Notes:\n        - Applicability: Suitable for analyzing volatility and trend directions in asset prices.\n        - Constraints: The length of `prices` must be greater than `period_ema` and `period_atr`.\n        - Considerations: Ensure inputs are accurate and consistent for meaningful results.\n    \"\"\"\n    def exponential_moving_average(prices, periods):\n        ema = [sum(prices[:periods]) / periods]\n        multiplier = 2 / (periods + 1)\n        for price in prices[periods:]:\n            ema.append((price - ema[-1]) * multiplier + ema[-1])\n        return ema\n\n    def average_true_range(prices, periods):\n        if len(prices) < periods + 1:\n            return []\n        high_lows = [high - low for high, low in zip(prices[1:], prices[:-1])]\n        atr = [sum(high_lows[:periods]) / periods]\n        for i in range(periods, len(high_lows)):\n            atr.append((atr[-1] * (periods - 1) + high_lows[i]) / periods)\n        return atr\n\n    ema = exponential_moving_average(prices, period_ema)\n    atr = average_true_range(prices, period_atr)\n\n    if len(ema) < len(atr):\n        ema = ema[len(ema) - len(atr):]\n    elif len(ema) > len(atr):\n        atr = atr[len(atr) - len(ema):]\n\n    middle_line = ema\n    upper_band = [m + (multiplier * a) for m, a in zip(middle_line, atr)]\n    lower_band = [m - (multiplier * a) for m, a in zip(middle_line, atr)]\n\n    keltner_channel = {\n        'middle_line': middle_line,\n        'upper_band': upper_band,\n        'lower_band': lower_band\n    }\n\n    return keltner_channel",
        "statistics": {
            "number_statistics": {
                "args_numbers": 4,
                "question_numbers": 3,
                "context_numbers": 29,
                "total_numbers": 32
            },
            "operator_statistics": {
                "operators": {
                    "+": 5,
                    "-": 10,
                    "*": 4,
                    "/": 4,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 23
            },
            "code_statistics": {
                "lines": 29,
                "parentheses": 56
            }
        },
        "difficulty": 7.1785454837637,
        "context": "An investor is analyzing the price movements of stock ABC over the past month to determine potential trends and volatility. The stock prices over the last 25 days are recorded as follows (in USD): \n\n[120, 122, 121, 124, 125, 127, 126, 129, 130, 128, 131, 132, 134, 135, 137, 136, 138, 139, 140, 142, 141, 143, 144, 146, 145]. \n\nThe investor wants to calculate the Keltner Channel using a 10-day EMA period and a 10-day ATR period, with a multiplier of 1.5, to identify potential breakout opportunities. The goal is to use these channels for better decision-making in market entry and exit strategies.",
        "question": "What is the value of the last upper band in the Keltner Channel, calculated using the given prices, a 10-day EMA period, a 10-day ATR period, and a multiplier of 1.5? Answer to two decimal places.",
        "python_solution": "def solution():\n    prices = [\n        120, 122, 121, 124, 125, 127, 126, 129, 130, 128,\n        131, 132, 134, 135, 137, 136, 138, 139, 140, 142,\n        141, 143, 144, 146, 145\n    ]\n    period_ema = 10\n    period_atr = 10\n    multiplier = 1.5\n\n    def exponential_moving_average(prices, periods):\n        ema = [sum(prices[:periods]) / periods]\n        multiplier_ema = 2 / (periods + 1)\n        for price in prices[periods:]:\n            ema.append((price - ema[-1]) * multiplier_ema + ema[-1])\n        return ema\n\n    def average_true_range(prices, periods):\n        if len(prices) < periods + 1:\n            return []\n        true_ranges = [abs(prices[i] - prices[i - 1]) for i in range(1, len(prices))]\n        atr = [sum(true_ranges[:periods]) / periods]\n        for i in range(periods, len(true_ranges)):\n            atr.append(((atr[-1] * (periods - 1)) + true_ranges[i]) / periods)\n        return atr\n\n    ema = exponential_moving_average(prices, period_ema)\n    atr = average_true_range(prices, period_atr)\n\n    # Align EMA and ATR lengths\n    if len(ema) < len(atr):\n        atr = atr[len(atr) - len(ema):]\n    else:\n        ema = ema[len(ema) - len(atr):]\n\n    middle_line = ema\n    upper_band = [m + (multiplier * a) for m, a in zip(middle_line, atr)]\n    \n    # Return the last upper band value\n    return round(upper_band[-1], 2)\n\nsolution()",
        "ground_truth": 143.66,
        "source": "FinanceReasoning-test-5",
        "question_id": "test-2236",
        "level": "hard",
        "output": [
            "### Step-by-step solution using **Emphasizing Constraints (EC):**\n\n1. **Understand the Problem and Define Input:**\n   - We are tasked with computing the last `upper_band` of the Keltner Channel using the stock prices provided for 25 days (`prices = [120, 122, 121, ..., 145]`).\n   - The following constraints and parameters will apply:\n     - A 10-day EMA period (used to calculate the `middle_line`).\n     - A 10-day ATR period (used to determine the range).\n     - Multiplier of 1.5 (used to adjust the size of the band distances).\n\n2. **Constraints from the Problem:**\n   - The defined prices list must have a length greater than both the EMA and ATR periods. As the list has 25 elements, this constraint is satisfied as both periods are 10.\n   - All intermediate calculations \u2014 such as EMA and ATR \u2014 must utilize their respective formulas accurately.\n\n3. **Plan for Implementation:**\n   - Use the provided stock prices to calculate the Keltner Channel.\n   - **EMA (Exponential Moving Average) Calculation:** Smooth the averages over the past 10 days.\n   - **ATR (Average True Range) Calculation:** Use high and low differences of prices over 10 days.\n   - Compute the `middle_line` (from EMA), then compute the `upper_band` using the multiplier applied on ATR added to EMA. Finally, fetch the last value of the `upper_band`.\n\n4. **Output:**\n   - Round off the `upper_band`'s last value to **two decimal points** as per constraint.\n\n### Implementation Plan:\nThe solution will follow these steps:\n1. Define the `prices` list and parameters (period_ema = 10, period_atr = 10, multiplier = 1.5).\n2. Define helper functions for EMA and ATR calculation.\n3. Calculate EMA, ATR, `middle_line`, `upper_band`, and `lower_band`.\n4. Extract and round the last `upper_band` value.\n\n### Python Program:\n```python\ndef solution():\n    # Define prices and parameters\n    prices = [120, 122, 121, 124, 125, 127, 126, 129, 130, 128, 131, 132, 134, 135, 137, 136, 138, 139, 140, 142, 141, 143, 144, 146, 145]\n    period_ema = 10\n    period_atr = 10\n    multiplier = 1.5\n\n    # Define helper functions\n    def exponential_moving_average(prices, periods):\n        ema = [sum(prices[:periods]) / periods]\n        k = 2 / (periods + 1)\n        for price in prices[periods:]:\n            ema.append((price - ema[-1]) * k + ema[-1])\n        return ema\n\n    def average_true_range(prices, periods):\n        true_ranges = [abs(prices[i] - prices[i - 1]) for i in range(1, len(prices))]\n        atr = [sum(true_ranges[:periods]) / periods]\n        for i in range(periods, len(true_ranges)):\n            atr.append((atr[-1] * (periods - 1) + true_ranges[i]) / periods)\n        return atr\n\n    # Calculate EMA, ATR, and Keltner Channel components\n    ema = exponential_moving_average(prices, period_ema)\n    atr = average_true_range(prices, period_atr)\n\n    # Align lengths for EMA and ATR, use the shortest length\n    if len(ema) > len(atr):\n        ema = ema[-len(atr):]\n    elif len(atr) > len(ema):\n        atr = atr[-len(ema):]\n\n    # Calculate Keltner Channel components\n    middle_line = ema\n    upper_band = [m + (multiplier * a) for m, a in zip(middle_line, atr)]\n    lower_band = [m - (multiplier * a) for m, a in zip(middle_line, atr)]\n\n    # Return the last value of the upper band, rounded to 2 decimal places\n    return round(upper_band[-1], 2)\n```"
        ],
        "retrieval_query": "What is the value of the last upper band in the Keltner Channel, calculated using the given prices, a 10-day EMA period, a 10-day ATR period, and a multiplier of 1.5? Answer to two decimal places.",
        "useful_functions": [
            "def calculate_keltner_channel(prices: list, period_ema: int = 20, period_atr: int = 20, multiplier: float = 2.0) -> dict:\n    \"\"\"\n    Calculate the Keltner Channel for a given list of prices.\n\n    This function computes the Keltner Channel lines, including the middle line (EMA),\n    upper band, and lower band, based on the exponential moving average (EMA)\n    and average true range (ATR) of the provided prices. Keltner Channels are used \n    in technical analysis to determine trend directions and potential trade signals.\n\n    Args:\n        prices (list): A list of asset prices used to calculate the Keltner Channel.\n        period_ema (int): The number of periods for computing the EMA (default is 20).\n        period_atr (int): The number of periods for computing the ATR (default is 20).\n        multiplier (float): The multiplier for the ATR to determine band distance (default is 2.0).\n\n    Returns:\n        keltner_channel (dict): A dictionary containing the middle line, upper band, and lower band\n                               of the Keltner Channel, keys being 'middle_line', 'upper_band', and 'lower_band'.\n\n    Notes:\n        - Applicability: Suitable for analyzing volatility and trend directions in asset prices.\n        - Constraints: The length of `prices` must be greater than `period_ema` and `period_atr`.\n        - Considerations: Ensure inputs are accurate and consistent for meaningful results.\n    \"\"\"\n    def exponential_moving_average(prices, periods):\n        ema = [sum(prices[:periods]) / periods]\n        multiplier = 2 / (periods + 1)\n        for price in prices[periods:]:\n            ema.append((price - ema[-1]) * multiplier + ema[-1])\n        return ema\n\n    def average_true_range(prices, periods):\n        if len(prices) < periods + 1:\n            return []\n        high_lows = [high - low for high, low in zip(prices[1:], prices[:-1])]\n        atr = [sum(high_lows[:periods]) / periods]\n        for i in range(periods, len(high_lows)):\n            atr.append((atr[-1] * (periods - 1) + high_lows[i]) / periods)\n        return atr\n\n    ema = exponential_moving_average(prices, period_ema)\n    atr = average_true_range(prices, period_atr)\n\n    if len(ema) < len(atr):\n        ema = ema[len(ema) - len(atr):]\n    elif len(ema) > len(atr):\n        atr = atr[len(atr) - len(ema):]\n\n    middle_line = ema\n    upper_band = [m + (multiplier * a) for m, a in zip(middle_line, atr)]\n    lower_band = [m - (multiplier * a) for m, a in zip(middle_line, atr)]\n\n    keltner_channel = {\n        'middle_line': middle_line,\n        'upper_band': upper_band,\n        'lower_band': lower_band\n    }\n\n    return keltner_channel"
        ],
        "usage": {
            "completion_tokens": 906,
            "prompt_tokens": 1227,
            "total_tokens": 2133,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    {
        "function_id": "article-1860",
        "article_title": "Technical Indicator",
        "function": "def calculate_rsi(prices: list, period: int) -> list:\n    \"\"\"\n    Calculate the Relative Strength Index (RSI) for a given list of prices.\n\n    The RSI is a momentum oscillator that measures the speed and change of price movements.\n    It oscillates between 0 and 100 and is typically used to identify overbought or oversold \n    conditions in a traded security.\n\n    Args:\n        prices (list): A list of historical prices of a security.\n        period (int): The number of periods to calculate the RSI over. Common values are 14.\n\n    Returns:\n        rsi_values (list): A list of RSI values, corresponding to the input prices.\n\n    Notes:\n        - Applicability: Can be used to evaluate the momentum of a security across various\n          asset classes including stocks, commodities, and forex.\n        - Constraints: Requires at least `period + 1` price data points to start calculating RSI.\n        - Considerations: The RSI might be more reliable in markets that are trending or volatile.\n    \"\"\"\n    if period <= 0:\n        raise ValueError(\"Period must be a positive integer.\")\n    if len(prices) <= period:\n        raise ValueError(\"Prices list must be longer than the period.\")\n\n    gains = []\n    losses = []\n\n    for i in range(1, len(prices)):\n        change = prices[i] - prices[i - 1]\n        if change > 0:\n            gains.append(change)\n            losses.append(0)\n        else:\n            gains.append(0)\n            losses.append(abs(change))\n\n    avg_gain = sum(gains[:period]) / period\n    avg_loss = sum(losses[:period]) / period\n\n    rsi_values = []\n    if avg_loss == 0:\n        rsi_values.append(100)\n    else:\n        rs = avg_gain / avg_loss\n        rsi_values.append(100 - (100 / (1 + rs)))\n\n    for i in range(period, len(prices) - 1):\n        change = prices[i + 1] - prices[i]\n        gain = max(change, 0)\n        loss = max(-change, 0)\n\n        avg_gain = (avg_gain * (period - 1) + gain) / period\n        avg_loss = (avg_loss * (period - 1) + loss) / period\n\n        if avg_loss == 0:\n            rsi_values.append(100)\n        else:\n            rs = avg_gain / avg_loss\n            rsi_values.append(100 - (100 / (1 + rs)))\n\n    return rsi_values",
        "statistics": {
            "number_statistics": {
                "args_numbers": 2,
                "question_numbers": 1,
                "context_numbers": 17,
                "total_numbers": 18
            },
            "operator_statistics": {
                "operators": {
                    "+": 5,
                    "-": 9,
                    "*": 2,
                    "/": 8,
                    "%": 0,
                    "**": 0
                },
                "total_operators": 24
            },
            "code_statistics": {
                "lines": 30,
                "parentheses": 50
            }
        },
        "difficulty": 7.185387015580417,
        "context": "A trader is analyzing the stock prices of a company to determine potential overbought or oversold conditions. The trader has the following closing prices for the stock over the past 15 days: [144, 145, 147, 146, 148, 150, 151, 150, 149, 148, 147, 150, 151, 153, 155]. The trader wants to calculate the Relative Strength Index (RSI) using a 14-day period to make an informed trading decision.",
        "question": "What is the RSI on the 15th day using a 14-day period? Answer as a percentage to two decimal places.",
        "python_solution": "def solution():\n    # List of stock closing prices over the past 15 days\n    prices = [144, 145, 147, 146, 148, 150, 151, 150, 149, 148, 147, 150, 151, 153, 155]\n    period = 14\n    \n    # Calculate gains and losses\n    gains = []\n    losses = []\n    \n    for i in range(1, len(prices)):\n        change = prices[i] - prices[i - 1]\n        if change > 0:\n            gains.append(change)\n            losses.append(0)\n        else:\n            gains.append(0)\n            losses.append(abs(change))\n\n    # Calculate initial average gain and loss\n    avg_gain = sum(gains[:period]) / period\n    avg_loss = sum(losses[:period]) / period\n\n    # Calculate the RSI using the calculation logic\n    if avg_loss == 0:\n        rsi = 100\n    else:\n        rs = avg_gain / avg_loss\n        rsi = 100 - (100 / (1 + rs))\n    \n    return round(rsi, 2)\n\nprint(solution())",
        "ground_truth": 76.19,
        "source": "FinanceReasoning-test-9",
        "question_id": "test-2237",
        "level": "hard",
        "output": [
            "To find the RSI (Relative Strength Index) on the 15th day using a 14-day period, we need to follow these steps:\n\n### Step-by-Step Breakdown:\n\n1. **Constraints and Applicability Check Using EC (Emphasizing Constraints)**:\n   - **Constraint 1**: The closing prices list must have at least 15 elements because we need 14 days to calculate the RSI, and the RSI is determined based on the 14-day observation before the 15th day.\n   - **Constraint 2**: Calculation must respect the 14-day period given in the question.\n   - **Constraint 3**: Provide the RSI result as a percentage to two decimal places.\n\n2. **Input Data**:\n   - Closing prices: `[144, 145, 147, 146, 148, 150, 151, 150, 149, 148, 147, 150, 151, 153, 155]`\n   - Period: 14 days.\n\n3. **RSI Calculation**:\n   - Calculate daily price changes:\n     - Example of change calculation: `145 - 144 = 1` (gain on the 2nd day).\n   - Separate positive changes (gains) and negative changes (losses).\n   - Compute the average gains and losses over the first 14 days.\n   - Calculate the Relative Strength (`RS`):\n     - `RS = (Average Gain) / (Average Loss)`\n   - Compute the RSI using the formula:\n     - `RSI = 100 - (100 / (1 + RS))`.\n\n4. **Output**:\n   - The RSI for the 15th day using the 14-day period.\n   - Format the result as a percentage to two decimal points.\n\nLet's implement the above steps in Python.\n\n```python\ndef solution():\n    # Define variables name and value\n    closing_prices = [144, 145, 147, 146, 148, 150, 151, 150, 149, 148, 147, 150, 151, 153, 155]\n    period = 14\n    \n    # Calculate daily price changes\n    price_changes = [closing_prices[i] - closing_prices[i - 1] for i in range(1, len(closing_prices))]\n    \n    # Calculate initial average gains and losses over the first period\n    gains = [max(change, 0) for change in price_changes[:period]]\n    losses = [abs(min(change, 0)) for change in price_changes[:period]]\n    avg_gain = sum(gains) / period\n    avg_loss = sum(losses) / period\n    \n    # Calculate RSI for the 15th day\n    if avg_loss == 0:\n        # Prevent division by zero; if losses are zero, RSI is 100\n        rsi = 100.0\n    else:\n        rs = avg_gain / avg_loss\n        rsi = 100 - (100 / (1 + rs))\n    \n    # Return the RSI rounded to two decimal places\n    return round(rsi, 2)\n``` \n\nThis program efficiently calculates the RSI for the 15th day while adhering to all constraints and requirements from the question."
        ],
        "retrieval_query": "What is the RSI on the 15th day using a 14-day period? Answer as a percentage to two decimal places.",
        "useful_functions": [
            "def calculate_rsi(prices: list, period: int) -> list:\n    \"\"\"\n    Calculate the Relative Strength Index (RSI) for a given list of prices.\n\n    The RSI is a momentum oscillator that measures the speed and change of price movements.\n    It oscillates between 0 and 100 and is typically used to identify overbought or oversold \n    conditions in a traded security.\n\n    Args:\n        prices (list): A list of historical prices of a security.\n        period (int): The number of periods to calculate the RSI over. Common values are 14.\n\n    Returns:\n        rsi_values (list): A list of RSI values, corresponding to the input prices.\n\n    Notes:\n        - Applicability: Can be used to evaluate the momentum of a security across various\n          asset classes including stocks, commodities, and forex.\n        - Constraints: Requires at least `period + 1` price data points to start calculating RSI.\n        - Considerations: The RSI might be more reliable in markets that are trending or volatile.\n    \"\"\"\n    if period <= 0:\n        raise ValueError(\"Period must be a positive integer.\")\n    if len(prices) <= period:\n        raise ValueError(\"Prices list must be longer than the period.\")\n\n    gains = []\n    losses = []\n\n    for i in range(1, len(prices)):\n        change = prices[i] - prices[i - 1]\n        if change > 0:\n            gains.append(change)\n            losses.append(0)\n        else:\n            gains.append(0)\n            losses.append(abs(change))\n\n    avg_gain = sum(gains[:period]) / period\n    avg_loss = sum(losses[:period]) / period\n\n    rsi_values = []\n    if avg_loss == 0:\n        rsi_values.append(100)\n    else:\n        rs = avg_gain / avg_loss\n        rsi_values.append(100 - (100 / (1 + rs)))\n\n    for i in range(period, len(prices) - 1):\n        change = prices[i + 1] - prices[i]\n        gain = max(change, 0)\n        loss = max(-change, 0)\n\n        avg_gain = (avg_gain * (period - 1) + gain) / period\n        avg_loss = (avg_loss * (period - 1) + loss) / period\n\n        if avg_loss == 0:\n            rsi_values.append(100)\n        else:\n            rs = avg_gain / avg_loss\n            rsi_values.append(100 - (100 / (1 + rs)))\n\n    return rsi_values",
            "def calculate_rsi(price_changes: list, period: int = 14) -> float:\n    \"\"\"\n    Calculate the Relative Strength Index (RSI) for a series of price changes.\n\n    The RSI is a momentum oscillator that measures the speed and change of price\n    movements. It helps identify overbought or oversold conditions in a traded\n    security by comparing the magnitude of recent gains to recent losses.\n\n    Args:\n        price_changes (list): A list of sequential price changes (positive or negative).\n        period (int): The number of time periods to use for the RSI calculation,\n                      typically 14.\n\n    Returns:\n        rsi (float): The calculated RSI value, ranging from 0 to 100.\n\n    Notes:\n        - Applicability: Use this function to identify potential overbought (RSI > 70)\n          or oversold (RSI < 30) conditions.\n        - Constraints: The length of price_changes must be greater than or equal to\n          the specified period to calculate an RSI value.\n        - Considerations: Ensure that the input data is in chronological order.\n          The initial RSI calculations may be less reliable due to insufficient data points.\n    \"\"\"\n    if len(price_changes) < period:\n        raise ValueError(\"price_changes must contain at least 'period' number of data points.\")\n\n    gains = [max(change, 0) for change in price_changes]\n    losses = [abs(min(change, 0)) for change in price_changes]\n\n    avg_gain = sum(gains[:period]) / period\n    avg_loss = sum(losses[:period]) / period\n\n    if avg_loss == 0:\n        return 100.0\n\n    rs = avg_gain / avg_loss\n    rsi = 100 - (100 / (1 + rs))\n    \n    return rsi"
        ],
        "usage": {
            "completion_tokens": 671,
            "prompt_tokens": 1383,
            "total_tokens": 2054,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    }
]